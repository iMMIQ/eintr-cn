This is eintr.info, produced by makeinfo version 7.0.3 from
emacs-lisp-intro.texi.

这是针对非程序员的 ‘Emacs Lisp 编程简介’


   随 Emacs 版本 29.1 发行.

   Copyright © 1990–1995, 1997, 2001–2023 自由软件基金会.

   纸质版本可在 <https://shop.fsf.org/> 获得。由以下机构出版：

     GNU Press,                        https://www.fsf.org/licensing/gnu-press/
     自由软件基金会旗下的一个分部                 电子邮件：sales@fsf.org
     Free Software Foundation, Inc.    电话：+1 (617) 542-5942
     51 Franklin Street, Fifth Floor   传真：+1 (617) 542-2652
     美国马萨诸塞州波士顿，邮编02110-1301


   ISBN 1-882114-43-4

     允许复制、分发和/或修改本文档，遵循 GNU 自由文档许可证 1.3 版或由自
     由软件基金会发布的任何以后版本的条款；本文档没有不变章节，封面文本
     为“GNU 手册”，反面封面文本如 (a) 所示。许可证的副本包含在名为“GNU 自
     由文档许可证”的章节中。

     (a) FSF 的背面封面文本是：“你有自由复制和修改这份 GNU 手册。从 FSF
     购买副本支持其开发 GNU 并推广软件自由。”
INFO-DIR-SECTION Emacs lisp
START-INFO-DIR-ENTRY
* Emacs Lisp Intro: (eintr).    A simple introduction to Emacs Lisp programming.
END-INFO-DIR-ENTRY


File: eintr.info,  Node: Top,  Next: Preface,  Up: (dir)

Emacs Lisp 编程简介
*******************

这是针对非程序员的 ‘Emacs Lisp 编程简介’


   随 Emacs 版本 29.1 发行.

   Copyright © 1990–1995, 1997, 2001–2023 自由软件基金会.

   纸质版本可在 <https://shop.fsf.org/> 获得。由以下机构出版：

     GNU Press,                        https://www.fsf.org/licensing/gnu-press/
     自由软件基金会旗下的一个分部                 电子邮件：sales@fsf.org
     Free Software Foundation, Inc.    电话：+1 (617) 542-5942
     51 Franklin Street, Fifth Floor   传真：+1 (617) 542-2652
     美国马萨诸塞州波士顿，邮编02110-1301


   ISBN 1-882114-43-4

     允许复制、分发和/或修改本文档，遵循 GNU 自由文档许可证 1.3 版或由自
     由软件基金会发布的任何以后版本的条款；本文档没有不变章节，封面文本
     为“GNU 手册”，反面封面文本如 (a) 所示。许可证的副本包含在名为“GNU 自
     由文档许可证”的章节中。

     (a) FSF 的背面封面文本是：“你有自由复制和修改这份 GNU 手册。从 FSF
     购买副本支持其开发 GNU 并推广软件自由。”

   此主菜单首先列出每个章节和索引；然后列出每个章节中的每个节点。

* Menu:

* Preface::                     What to look for.
* List Processing::             What is Lisp?
* Practicing Evaluation::       Running several programs.
* Writing Defuns::              How to write function definitions.
* Buffer Walk Through::         Exploring a few buffer-related functions.
* More Complex::                A few, even more complex functions.
* Narrowing & Widening::        Restricting your and Emacs attention to
                                    a region.
* car cdr & cons::              Fundamental functions in Lisp.
* Cutting & Storing Text::      Removing text and saving it.
* List Implementation::         How lists are implemented in the computer.
* Yanking::                     Pasting stored text.
* Loops & Recursion::           How to repeat a process.
* Regexp Search::               Regular expression searches.
* Counting Words::              A review of repetition and regexps.
* Words in a defun::            Counting words in a ‘defun’.
* Readying a Graph::            A prototype graph printing function.
* Emacs Initialization::        How to write a ‘.emacs’ file.
* Debugging::                   How to run the Emacs Lisp debuggers.
* Conclusion::                  Now you have the basics.
* the-the::                     An appendix: how to find reduplicated words.
* Kill Ring::                   An appendix: how the kill ring works.
* Full Graph::                  How to create a graph with labeled axes.
* Free Software and Free Manuals::
* GNU Free Documentation License::
* Index::
* About the Author::

 — The Detailed Node Listing —

Preface

* Why::                         Why learn Emacs Lisp?
* On Reading this Text::        Read, gain familiarity, pick up habits....
* Who You Are::                 For whom this is written.
* Lisp History::
* Note for Novices::            You can read this as a novice.
* Thank You::

List Processing

* Lisp Lists::                  What are lists?
* Run a Program::               Any list in Lisp is a program ready to run.
* Making Errors::               Generating an error message.
* Names & Definitions::         Names of symbols and function definitions.
* Lisp Interpreter::            What the Lisp interpreter does.
* Evaluation::                  Running a program.
* Variables::                   Returning a value from a variable.
* Arguments::                   Passing information to a function.
* set & setq::                  Setting the value of a variable.
* Summary::                     The major points.
* Error Message Exercises::

Lisp Lists

* Numbers Lists::               List have numbers, other lists, in them.
* Lisp Atoms::                  Elemental entities.
* Whitespace in Lists::         Formatting lists to be readable.
* Typing Lists::                How GNU Emacs helps you type lists.

The Lisp Interpreter

* Complications::               Variables, Special forms, Lists within.
* Byte Compiling::              Specially processing code for speed.

Evaluation

* How the Interpreter Acts::    Returns and Side Effects...
* Evaluating Inner Lists::      Lists within lists...

Variables

* fill-column Example::
* Void Function::               The error message for a symbol
                                  without a function.
* Void Variable::               The error message for a symbol without a value.

Arguments

* Data types::                  Types of data passed to a function.
* Args as Variable or List::    An argument can be the value
                                  of a variable or list.
* Variable Number of Arguments::  Some functions may take a
                                  variable number of arguments.
* Wrong Type of Argument::      Passing an argument of the wrong type
                                  to a function.
* message::                     A useful function for sending messages.

Setting the Value of a Variable

* Using set::                  Setting values.
* Using setq::                 Setting a quoted value.
* Counting::                   Using ‘setq’ to count.

Practicing Evaluation

* How to Evaluate::            Typing editing commands or ‘C-x C-e’
                                 causes evaluation.
* Buffer Names::               Buffers and files are different.
* Getting Buffers::            Getting a buffer itself, not merely its name.
* Switching Buffers::          How to change to another buffer.
* Buffer Size & Locations::    Where point is located and the size of
                               the buffer.
* Evaluation Exercise::

How To Write Function Definitions

* Primitive Functions::
* defun::                        The ‘defun’ macro.
* Install::                      Install a function definition.
* Interactive::                  Making a function interactive.
* Interactive Options::          Different options for ‘interactive’.
* Permanent Installation::       Installing code permanently.
* let::                          Creating and initializing local variables.
* if::                           What if?
* else::                         If–then–else expressions.
* Truth & Falsehood::            What Lisp considers false and true.
* save-excursion::               Keeping track of point and buffer.
* Review::
* defun Exercises::

Install a Function Definition

* Effect of installation::
* Change a defun::              How to change a function definition.

Make a Function Interactive

* Interactive multiply-by-seven::  An overview.
* multiply-by-seven in detail::    The interactive version.

‘let’

* Prevent confusion::
* Parts of let Expression::
* Sample let Expression::
* Uninitialized let Variables::

The ‘if’ Special Form

* if in more detail::
* type-of-animal in detail::    An example of an ‘if’ expression.

Truth and Falsehood in Emacs Lisp

* nil explained::               ‘nil’ has two meanings.

‘save-excursion’

* Point and mark::              A review of various locations.
* Template for save-excursion::

A Few Buffer-Related Functions

* Finding More::                How to find more information.
* simplified-beginning-of-buffer::  Shows ‘goto-char’,
                                ‘point-min’, and ‘push-mark’.
* mark-whole-buffer::           Almost the same as ‘beginning-of-buffer’.
* append-to-buffer::            Uses ‘save-excursion’ and
                                ‘insert-buffer-substring’.
* Buffer Related Review::       Review.
* Buffer Exercises::

The Definition of ‘mark-whole-buffer’

* mark-whole-buffer overview::
* Body of mark-whole-buffer::   Only three lines of code.

The Definition of ‘append-to-buffer’

* append-to-buffer overview::
* append interactive::          A two part interactive expression.
* append-to-buffer body::       Incorporates a ‘let’ expression.
* append save-excursion::       How the ‘save-excursion’ works.

A Few More Complex Functions

* copy-to-buffer::              With ‘set-buffer’, ‘get-buffer-create’.
* insert-buffer::               Read-only, and with ‘or’.
* beginning-of-buffer::         Shows ‘goto-char’,
                                ‘point-min’, and ‘push-mark’.
* Second Buffer Related Review::
* optional Exercise::

The Definition of ‘insert-buffer’

* insert-buffer code::
* insert-buffer interactive::   When you can read, but not write.
* insert-buffer body::          The body has an ‘or’ and a ‘let’.
* if & or::                     Using an ‘if’ instead of an ‘or’.
* Insert or::                   How the ‘or’ expression works.
* Insert let::                  Two ‘save-excursion’ expressions.
* New insert-buffer::

The Interactive Expression in ‘insert-buffer’

* Read-only buffer::            When a buffer cannot be modified.
* b for interactive::           An existing buffer or else its name.

Complete Definition of ‘beginning-of-buffer’

* Optional Arguments::
* beginning-of-buffer opt arg::  Example with optional argument.
* beginning-of-buffer complete::

‘beginning-of-buffer’ with an Argument

* Disentangle beginning-of-buffer::
* Large buffer case::
* Small buffer case::

Narrowing and Widening

* Narrowing advantages::        The advantages of narrowing
* save-restriction::            The ‘save-restriction’ special form.
* what-line::                   The number of the line that point is on.
* narrow Exercise::

‘car’, ‘cdr’, ‘cons’: Fundamental Functions

* Strange Names::               A historical aside: why the strange names?
* car & cdr::                   Functions for extracting part of a list.
* cons::                        Constructing a list.
* nthcdr::                      Calling ‘cdr’ repeatedly.
* nth::
* setcar::                      Changing the first element of a list.
* setcdr::                      Changing the rest of a list.
* cons Exercise::

‘cons’

* Build a list::
* length::                      How to find the length of a list.

Cutting and Storing Text

* Storing Text::                Text is stored in a list.
* zap-to-char::                 Cutting out text up to a character.
* kill-region::                 Cutting text out of a region.
* copy-region-as-kill::         A definition for copying text.
* Digression into C::           Minor note on C programming language macros.
* defvar::                      How to give a variable an initial value.
* cons & search-fwd Review::
* search Exercises::

‘zap-to-char’

* Complete zap-to-char::        The complete implementation.
* zap-to-char interactive::     A three part interactive expression.
* zap-to-char body::            A short overview.
* search-forward::              How to search for a string.
* progn::                       The ‘progn’ special form.
* Summing up zap-to-char::      Using ‘point’ and ‘search-forward’.

‘kill-region’

* Complete kill-region::        The function definition.
* condition-case::              Dealing with a problem.
* Lisp macro::

‘copy-region-as-kill’

* Complete copy-region-as-kill::  The complete function definition.
* copy-region-as-kill body::      The body of ‘copy-region-as-kill’.

The Body of ‘copy-region-as-kill’

* last-command & this-command::
* kill-append function::
* kill-new function::

Initializing a Variable with ‘defvar’

* See variable current value::
* defvar and asterisk::

How Lists are Implemented

* Lists diagrammed::
* Symbols as Chest::            Exploring a powerful metaphor.
* List Exercise::

Yanking Text Back

* Kill Ring Overview::
* kill-ring-yank-pointer::      The kill ring is a list.
* yank nthcdr Exercises::       The ‘kill-ring-yank-pointer’ variable.

Loops and Recursion

* while::                       Causing a stretch of code to repeat.
* dolist dotimes::
* Recursion::                   Causing a function to call itself.
* Looping exercise::

‘while’

* Looping with while::          Repeat so long as test returns true.
* Loop Example::                A ‘while’ loop that uses a list.
* print-elements-of-list::      Uses ‘while’, ‘car’, ‘cdr’.
* Incrementing Loop::           A loop with an incrementing counter.
* Incrementing Loop Details::
* Decrementing Loop::           A loop with a decrementing counter.

Details of an Incrementing Loop

* Incrementing Example::        Counting pebbles in a triangle.
* Inc Example parts::           The parts of the function definition.
* Inc Example altogether::      Putting the function definition together.

Loop with a Decrementing Counter

* Decrementing Example::        More pebbles on the beach.
* Dec Example parts::           The parts of the function definition.
* Dec Example altogether::      Putting the function definition together.

Save your time: ‘dolist’ and ‘dotimes’

* dolist::
* dotimes::

Recursion

* Building Robots::             Same model, different serial number ...
* Recursive Definition Parts::  Walk until you stop ...
* Recursion with list::         Using a list as the test whether to recurse.
* Recursive triangle function::
* Recursion with cond::
* Recursive Patterns::          Often used templates.
* No Deferment::                Don’t store up work ...
* No deferment solution::

Recursion in Place of a Counter

* Recursive Example arg of 1 or 2::
* Recursive Example arg of 3 or 4::

Recursive Patterns

* Every::
* Accumulate::
* Keep::

Regular Expression Searches

* sentence-end::                The regular expression for ‘sentence-end’.
* re-search-forward::           Very similar to ‘search-forward’.
* forward-sentence::            A straightforward example of regexp search.
* forward-paragraph::           A somewhat complex example.
* Regexp Review::
* re-search Exercises::

‘forward-sentence’

* Complete forward-sentence::
* fwd-sentence while loops::    Two ‘while’ loops.
* fwd-sentence re-search::      A regular expression search.

‘forward-paragraph’: a Goldmine of Functions

* forward-paragraph in brief::  Key parts of the function definition.
* fwd-para let::                The ‘let*’ expression.
* fwd-para while::              The forward motion ‘while’ loop.

Counting: Repetition and Regexps

* Why Count Words::
* count-words-example::         Use a regexp, but find a problem.
* recursive-count-words::       Start with case of no words in region.
* Counting Exercise::

The ‘count-words-example’ Function

* Design count-words-example::  The definition using a ‘while’ loop.
* Whitespace Bug::              The Whitespace Bug in ‘count-words-example’.

Counting Words in a ‘defun’

* Divide and Conquer::
* Words and Symbols::           What to count?
* Syntax::                      What constitutes a word or symbol?
* count-words-in-defun::        Very like ‘count-words-example’.
* Several defuns::              Counting several defuns in a file.
* Find a File::                 Do you want to look at a file?
* lengths-list-file::           A list of the lengths of many definitions.
* Several files::               Counting in definitions in different files.
* Several files recursively::   Recursively counting in different files.
* Prepare the data::            Prepare the data for display in a graph.

Count Words in ‘defuns’ in Different Files

* lengths-list-many-files::     Return a list of the lengths of defuns.
* append::                      Attach one list to another.

Prepare the Data for Display in a Graph

* Data for Display in Detail::
* Sorting::                     Sorting lists.
* Files List::                  Making a list of files.
* Counting function definitions::

Readying a Graph

* Columns of a graph::
* graph-body-print::            How to print the body of a graph.
* recursive-graph-body-print::
* Printed Axes::
* Line Graph Exercise::

Your ‘.emacs’ File

* Default Configuration::
* Site-wide Init::              You can write site-wide init files.
* defcustom::                   Emacs will write code for you.
* Beginning init File::         How to write a ‘.emacs’ init file.
* Text and Auto-fill::          Automatically wrap lines.
* Mail Aliases::                Use abbreviations for email addresses.
* Indent Tabs Mode::            Don’t use tabs with TeX
* Key Bindings::                Create some personal key bindings.
* Keymaps::                     More about key binding.
* Loading Files::               Load (i.e., evaluate) files automatically.
* Autoload::                    Make functions available.
* Simple Extension::            Define a function; bind it to a key.
* X11 Colors::                  Colors in X.
* Miscellaneous::
* Mode Line::                   How to customize your mode line.

Debugging

* debug::                       How to use the built-in debugger.
* debug-on-entry::              Start debugging when you call a function.
* debug-on-quit::               Start debugging when you quit with ‘C-g’.
* edebug::                      How to use Edebug, a source level debugger.
* Debugging Exercises::

Handling the Kill Ring

* What the Kill Ring Does::
* current-kill::
* yank::                        Paste a copy of a clipped element.
* yank-pop::                    Insert element pointed to.
* ring file::

The ‘current-kill’ Function

* Code for current-kill::
* Understanding current-kill::

‘current-kill’ in Outline

* Body of current-kill::
* Digression concerning error::  How to mislead humans, but not computers.
* Determining the Element::

A Graph with Labeled Axes

* Labeled Example::
* print-graph Varlist::         ‘let’ expression in ‘print-graph’.
* print-Y-axis::                Print a label for the vertical axis.
* print-X-axis::                Print a horizontal label.
* Print Whole Graph::           The function to print a complete graph.

The ‘print-Y-axis’ Function

* print-Y-axis in Detail::
* Height of label::             What height for the Y axis?
* Compute a Remainder::         How to compute the remainder of a division.
* Y Axis Element::              Construct a line for the Y axis.
* Y-axis-column::               Generate a list of Y axis labels.
* print-Y-axis Penultimate::    A not quite final version.

The ‘print-X-axis’ Function

* Similarities differences::    Much like ‘print-Y-axis’, but not exactly.
* X Axis Tic Marks::            Create tic marks for the horizontal axis.

Printing the Whole Graph

* The final version::           A few changes.
* Test print-graph::            Run a short test.
* Graphing words in defuns::    Executing the final code.
* lambda::                      How to write an anonymous function.
* mapcar::                      Apply a function to elements of a list.
* Another Bug::                 Yet another bug ... most insidious.
* Final printed graph::         The graph itself!



File: eintr.info,  Node: Preface,  Next: List Processing,  Prev: Top,  Up: Top

前言
****

GNU Emacs集成环境的大部分都是用一种叫做Emacs Lisp的编程语言编写的。用这
种编程语言编写的代码是软件，是一组指令，告诉计算机在你给它命令时应该做什
么。Emacs被设计成可以用Emacs Lisp编写新代码，并轻松地将其安装为编辑器的
扩展。

   (GNU Emacs有时被称为“可扩展编辑器”，但它的功能远不止提供编辑功能。更
恰当的称呼是将Emacs视为“可扩展计算环境”。然而，这个短语有点拗口。简单地
将Emacs称为编辑器更容易理解。此外，在Emacs中的一切活动，如查找玛雅日期和
月相、简化多项式、调试代码、管理文件、阅读邮件、撰写书籍，都可以看作是一
种最一般意义上的编辑。)

* Menu:

* Why::                         Why learn Emacs Lisp?
* On Reading this Text::        Read, gain familiarity, pick up habits....
* Who You Are::                 For whom this is written.
* Lisp History::
* Note for Novices::            You can read this as a novice.
* Thank You::


File: eintr.info,  Node: Why,  Next: On Reading this Text,  Up: Preface

为什么要学习 Emacs Lisp？
=========================

尽管Emacs Lisp通常只与Emacs相关，但它是一种完整的计算机编程语言。您可以
像使用其他编程语言一样使用Emacs Lisp。

   也许您想了解编程；也许您想扩展Emacs；或者也许您想成为一名程序员。这个
关于Emacs Lisp的介绍旨在帮助您入门：引导您学习编程的基础知识，更重要的是
，向您展示如何自学以更进一步。


File: eintr.info,  Node: On Reading this Text,  Next: Who You Are,  Prev: Why,  Up: Preface

关于阅读本文
============

在本文中，您将看到一些可以在Emacs中运行的小示例程序。如果您正在使用GNU
Emacs的Info模式阅读本文，您可以按照示例中的说明来运行这些程序（这很容易
做到，当示例程序出现时会有解释）。或者，您可以在运行Emacs的计算机旁边阅
读这本介绍性的书籍。（这是我个人偏好的方式；我喜欢纸质书籍。）如果您旁边
没有正在运行的Emacs，您仍然可以阅读这本书，但在这种情况下，最好将其视为
一部小说或一本尚未探索过的国家的旅行指南：虽然有趣，但不同于亲自实践。

   这个介绍的大部分内容都是关于GNU Emacs中的代码演练和代码导览。这些导览
有两个目的：首先，使您熟悉真实的、可工作的代码（您每天使用的代码）；其次
，使您熟悉Emacs的工作方式。看到一个工作环境是如何实现的是非常有趣的。此
外，我希望您会养成浏览源代码的习惯。您可以从中学习并获得灵感。拥有GNU
Emacs就像拥有一个充满宝藏的巨龙巢穴。

   除了学习作为编辑器的Emacs和作为编程语言的Emacs Lisp，示例和导览还将让
您有机会熟悉作为Lisp编程环境的Emacs。GNU Emacs支持编程，并提供了各种工具
，如‘M-.’（调用‘xref-find-definitions’命令的键）。您还将学习关于缓冲区和
环境中的其他对象的信息。学习这些Emacs的特性就像探索自己家乡的新路线一样
。

   最后，我希望传授一些使用Emacs来学习您不了解的编程方面的技能。您通常可
以使用Emacs来帮助您理解困扰您的事情或做一些新的东西。这种自力更生不仅是
一种乐趣，还是一种优势。


File: eintr.info,  Node: Who You Are,  Next: Lisp History,  Prev: On Reading this Text,  Up: Preface

目标读者
========

本文是为那些不是程序员的人写的初级介绍。如果您是一名程序员，可能对这篇入
门文章感到不满意。原因是您可能已经熟练掌握了阅读参考手册的技巧，并且可能
不喜欢这篇文章的组织方式。

   一位经验丰富的程序员在审阅这篇文章后对我说：

     我更喜欢从参考手册中学习。我在每个段落中深入阅读，然后在段落之间稍
     作休息。

     当我阅读完一个段落时，我假设该主题已经讲解完毕，我知道我需要的一切
     信息（除非下一个段落开始更详细地讨论它）。我期望一个写得很好的，不
     会有太多冗余的参考手册，而且会有出色的指向（一个）我想要的信息的链
     接。

   这个介绍不是针对这样的人写的！

   首先，我尽量将每件事情都至少重复三次：首先是介绍它；其次是在上下文中
展示它；第三是在不同的上下文中展示它，或者进行复习。

   其次，我通常不会把有关某个主题的所有信息都集中在一个地方，更不用说一
个段落了。根据我的思维方式，这会对读者造成过多的负担。相反，我只会尝试在
您需要了解时提供解释。（有时我会包含一些额外信息，以便稍后当额外信息正式
介绍时，您不会觉得突然)。

   当您阅读这篇文章时，您不必一次性掌握所有内容。通常，您只需要对提到的
一些项目有一点了解。我希望我已经结构化了这篇文章并提供了足够的提示，以便
您能够意识到什么是重要的，并专注于它。

   您需要深入研究一些段落；别无他法。但我已经尽量减少这类段落的数量。这
本书旨在作为一个平易近人的小山丘，而不是一个令人望而却步的高峰。

   这本名为 ‘An Introduction to Programming in Emacs Lisp’ 的书有一个配
套文档, *note The GNU Emacs Lisp Reference Manual: (elisp)Top.  参考手册
比这个入门介绍包含更多细节。在参考手册中，有关一个主题的所有信息都集中在
一个地方。如果您是像上面的程序员一样，就应该参考它。当然，在阅读完这本
‘Introduction’后, 您在编写自己的程序时会发现 ‘Reference Manual’ 很有用.


File: eintr.info,  Node: Lisp History,  Next: Note for Novices,  Prev: Who You Are,  Up: Preface

Lisp的历史
==========

Lisp语言在20世纪50年代晚期由麻省理工学院为人工智能研究而开发。Lisp语言的
强大之处使其在其他领域也表现出色，例如编写编辑器命令和集成环境。

   GNU Emacs Lisp在很大程度上受到Maclisp的启发，Maclisp是在20世纪60年代
由麻省理工学院开发的。它也在一定程度上受到Common Lisp的启发，Common
Lisp在20世纪80年代成为了一种标准。然而，Emacs Lisp比Common Lisp简单得多
。（标准的Emacs发行版包含一个可选的扩展文件‘cl-lib.el’，它为Emacs Lisp添
加了许多Common Lisp功能。）


File: eintr.info,  Node: Note for Novices,  Next: Thank You,  Prev: Lisp History,  Up: Preface

新手须知
========

即使您不了解GNU Emacs，您仍然可以从本文中有所收获。但是，我建议您学习
Emacs，即使只是为了学会在计算机屏幕上移动。您可以使用内置教程来自学如何
使用Emacs。要使用它，输入‘C-h t’。（这意味着您同时按下和释放<CTRL>键和
‘h’键，然后按下和释放‘t’键。）

   此外，我经常通过列出用于调用标准Emacs命令的按键，然后在括号中给出命令
的名称，来引用Emacs的标准命令之一，就像这样：‘M-C-\’（‘indent-region’）
。这意味着‘indent-region’命令通常是通过键入‘M-C-\’来调用的。（如果您愿意
，您可以更改用于调用命令的按键；这被称为“rebinding, 重新绑定”。*Note
键位映射: Keymaps.）‘M-C-\’的缩写意味着你需要同时按下<META>键、<CTRL>键
和‘\’键。在许多现代键盘上，<META>键帽上标着<ALT>。像这样的组合被称为组合
键(keychord)。如果你的键盘没有<META>键，单击<ESC>键来代替它。在这种情况
下，‘M-C-\’意味着您按下并释放<ESC>键，然后同时按下<CTRL>键和‘\’键。但通
常‘M-C-\’意味着同时按下标有<ALT>的键和<CTRL>键，同时再按‘\’键。

   除了长按单个组合键外，您还可以在你输入的内容前加上‘C-u’，这被称为“通
用参数”。‘C-u’组合键会将参数传递给后续的命令。因此，要以6空格缩进一段纯
文本的区域，首先标记该区域，然后输入‘C-u 6 M-C-\’。（如果您不指定一个数
字，Emacs将默认数字为4，或者以不同于其他情况的方式运行该命令。）*Note
Numeric Arguments: (emacs)Arguments.

   如果您是在GNU Emacs中使用Info模式阅读这篇文章，您可以通过按下空格键
<SPC>来浏览整个文档。（要了解Info，请输入‘C-h i’，然后选择Info。）

   关于术语的说明：当我单独使用Lisp这个词时，我通常是在泛指各种Lisp方言
，但当我谈到Emacs Lisp时，我指的是特定的GNU Emacs Lisp。


File: eintr.info,  Node: Thank You,  Prev: Note for Novices,  Up: Preface

致谢
====

感谢所有帮助我完成这本书的人。特别感谢Jim Blandy，Noah Friedman，
Jim Kingdon，Roland McGrath，Frank Ritter，Randy Smith，
Richard M. Stallman和Melissa Weisshaus。我还要感谢Philip Johnson和
David Stampe，他们的耐心鼓励对我非常重要。如有遗漏是我的问题。

                                                     Robert J. Chassell
                                                          <bob@gnu.org>


File: eintr.info,  Node: List Processing,  Next: Practicing Evaluation,  Prev: Preface,  Up: Top

1 列表处理
**********

对于未经培训的人来说，Lisp 是一种奇特的编程语言。在 Lisp 代码中，到处都
是括号。甚至有人声称这个名字代表“Lots of Isolated Silly Parentheses”（很
多孤立的愚蠢括号）。但这种说法是不准确的。Lisp 代表 LISt Processing，这
种编程语言通过处理括号中的_列表_（以及列表的列表）来工作。括号标示着列表
的边界。有时候，列表前面会有一个撇号‘'’，称作 Lisp 中的“单引号”。 (1) 列
表是 Lisp 的基础。

* Menu:

* Lisp Lists::                  什么是列表？
* Run a Program::               Lisp中的任何列表都可以直接运行
* Making Errors::               生成错误消息
* Names & Definitions::         符号的名称和函数定义
* Lisp Interpreter::            Lisp解释器的作用
* Evaluation::                  运行程序
* Variables::                   从变量返回值
* Arguments::                   向函数传递信息
* set & setq::                  设置变量的值
* Summary::                     总结
* Error Message Exercises::

   ---------- Footnotes ----------

   (1) A single-quote is an abbreviation for the special form ‘quote’;
you need not think about special forms now.  *Note Complications::.


File: eintr.info,  Node: Lisp Lists,  Next: Run a Program,  Up: List Processing

1.1 Lisp列表
============

在Lisp中，一个列表看起来像这样：‘'(rose violet daisy buttercup)’。这个列
表前面有一个单引号。它也可以写成如下形式，更像你可能熟悉的列表：

     '(rose
       violet
       daisy
       buttercup)

这个列表的元素是四种不同花的名称，它们之间用空格分隔，被括号包围，就像田
野中的花朵被一堵石墙围绕着。

* Menu:

* Numbers Lists::               包含数字和其他列表的列表。
* Lisp Atoms::                  基本实体。
* Whitespace in Lists::         格式化使列表更易阅读。
* Typing Lists::                GNU Emacs如何帮助您输入列表。


File: eintr.info,  Node: Numbers Lists,  Next: Lisp Atoms,  Up: Lisp Lists

列表中的数字与列表
------------------

在 Lisp 中,列表也可以包含数值，就像这个列表：‘(+ 2 2)’。 这个列表包含一
个加号，‘+’，后面跟着两个 ‘2’，它们之间用空格分隔。

   在Lisp中，数据和程序都以相同的方式表示；也就是说，它们都是由单词、数
字或其他列表组成，之间用空格分隔，括在括号中。 (由于程序看起来像数据，一
个程序可以轻松地作为另一个程序的数据；这是Lisp的一个非常强大的特性。) (顺
便说一下，这两个括号中的注释_不是_Lisp列表，因为它们包含了分号 ‘;’ 和句
点 ‘.’ 作为标点符号。)

   这里还有一个列表，这次里面包含了一个列表：

     '(this list has (a list inside of it))

   这个列表的组成部分包括单词 ‘this’, ‘list’, ‘has’, 和列表 ‘(a list
inside of it)’.  内部列表由单词 ‘a’, ‘list’, ‘inside’, ‘of’, ‘it’ 组成。


File: eintr.info,  Node: Lisp Atoms,  Next: Whitespace in Lists,  Prev: Numbers Lists,  Up: Lisp Lists

1.1.1 Lisp原子
--------------

在Lisp中，我们一直称之为单词的东西被称为“原子”。这个术语来自于“原子”一词
的历史含义，即“不可分割”。就Lisp而言，我们在列表中使用的单词不能再分割成
更小的部分，仍然具有与程序的某个部分相同的含义；数字和单字符符号（如
‘+’）也是如此。然而，与古代的原子不同，列表可以被分割成部分。 (*Note
‘car’ ‘cdr’ & ‘cons’ Fundamental Functions: car cdr & cons.)

   在列表中，原子之间由空格分隔。它们可以紧邻括号。

   从技术上讲，Lisp中的列表由括号括起，括号内部包含由空格分隔的原子，或
者括号内部包含其他列表，或者同时包含原子和其他列表。一个列表可以只包含一
个原子，也可以什么都不包含。一个什么都不包含的列表看起来像这样：‘()’，称
为“空列表”。与其他东西不同，空列表既是原子又是列表。

   原子和列表的打印表示被称为“符号表达式”，或更简洁地称为“s-表达式”。单
词“表达式”本身可以指的是打印表示，也可以指的是计算机内部保存的原子或列表
。通常，人们会不加区分地使用“表达式”一词。 (此外，许多文本中，“形式”也被
用作表达式的同义词。)

   顺便提一下，构成我们宇宙的原子最初被认为是不可分割的。但后来发现，原
子并非不可分割。原子可以分裂成两个大致相等的部分，或者可以有部分组成从原
子中分离出来。也就是说，原子在其真正性质被发现之前就被过早地命名了。在
Lisp中，某些类型的原子，例如数组，也可以被分割成部分，但这种分割数组的机
制与分割列表的机制不同。就列表操作而言，列表的原子是不可分割的。

   与汉语词语的含义不同于单个汉字的含义一样,Lisp语言中的原子也不等同于组
成它的字母。例如，熊猫，与"熊" 和 "猫"完全不同。

   自然界中有许多种类的原子，而在Lisp中只有少数几种：例如，“数字”，比如
37、511或1729，以及“符号”，比如‘+’、‘foo’或‘forward-line’。我们在上面的
示例中列出的单词都是符号。在日常的Lisp对话中，“原子”这个术语很少被直接使
用，因为程序员通常会尽量明确他们正在处理哪一类型的原子。Lisp编程主要涉及
列表中符号的处理（有时还涉及数字）。(顺便一提，前文中的括号注释也是一个
合法的Lisp列表，因为它由原子组成，这些原子是符号，被空格分隔并用括号括起
，没有任何非Lisp符号。)

   用双引号括起的文本，即使是句子或段落，也会被视为一个原子。下面是一个
例子：

     '(this list includes "text between quotation marks.")

在Lisp中，所有引号括起的内容，包括标点符号和空格，都会被视为一个单独的原
子。这种类型的原子被称为“字符串”(string)，通常用于让计算机打印出人类可读
的消息。字符串与数字或符号不同，使用方式也有区别。


File: eintr.info,  Node: Whitespace in Lists,  Next: Typing Lists,  Prev: Lisp Atoms,  Up: Lisp Lists

1.1.2 列表中的空格
------------------

在Lisp语言中，表中的空格数量并不重要。从Lisp的角度看，

     '(this list
        looks like this)

与这个表达式完全等价：

     '(this list looks like this)

   这两个例子展示了在Lisp中相同的一个列表，它由这些符号 ‘this’、‘list’、
‘looks’、‘like’ 和 ‘this’ 按顺序组成。

   额外的空格和换行只是为了让人更容易阅读列表。当Lisp读取表达式时，会忽
略额外的空格（但原子之间至少需要一个空格来区分）。

   尽管看起来很奇怪，但我们已经涵盖了Lisp中几乎所有列表的情况！Lisp中的
其他列表都或多或少与这些例子相似，只是列表可能更长更复杂。简而言之，列表
在括号内，字符串在引号内，符号看起来像单词，数字看起来像数字。（对于某些
情况，可能会使用方括号、点号等一些特殊字符；但即使没有它们，我们也已经可
以处理很多情况了。）


File: eintr.info,  Node: Typing Lists,  Prev: Whitespace in Lists,  Up: Lisp Lists

1.1.3 GNU Emacs帮助您输入列表
-----------------------------

在GNU Emacs中，当您在Lisp交互模式或Lisp模式下输入Lisp表达式时，可以使用
一些命令来格式化Lisp表达式，以提高代码的可读性。例如，按下<TAB>键会自动
合理缩进当前行。通常，用于正确缩进区域中的代码的快捷键绑定为‘M-C-\’。代
码缩进可以让您清楚地看出哪些元素属于某个列表—子列表的元素缩进会比包含它
的列表更深。

   此外，当您键入右括号时，Emacs会短暂地将光标跳回到对应的左括号，这样您
可以看到右括号与哪个左括号匹配。这非常有用，因为在Lisp中，您写的每个列表
都必须有对应的右括号和左括号。（有关Emacs模式的更多信息，*Note Major
Modes: (emacs)Major Modes.）


File: eintr.info,  Node: Run a Program,  Next: Making Errors,  Prev: Lisp Lists,  Up: List Processing

1.2 运行程序
============

在Lisp中，任何列表本身都可以作为一个准备执行的程序。如果对列表进行求值（
在Lisp术语中称为“评估”(evaluate, eval)），计算机会执行以下三种操作之一：
直接返回列表本身且不做任何处理；显示错误信息；或者将列表中的第一个符号视
为命令并执行相应操作。 （当然，通常您期望的是最后一种情况！）

   在前面章节的示例中，我在某些列表之前使用的‘'’，称为“单引号”；它的作用
是告诉Lisp直接原样输出这个列表，不做任何处理。但是，如果列表前没有单引号
，那么列表中的第一个元素就具有特殊意义：它是计算机要执行的命令。 （在
Lisp中，这些命令被称为_函数_。）上例中的‘(+ 2 2)’列表没有单引号，因此
Lisp会将‘+’视为指示对后面的数字进行相加运算的命令。

   如果您在GNU Emacs中的Info模式下阅读此文档，可以通过以下步骤来执行
Lisp表达式的计算：将光标置于以下列表的右括号之后，键入‘C-x C-e’：

     (+ 2 2)

您将在回显区域看到数字‘4’(1)。 （您刚刚对该列表进行了评估。回显区域位于
屏幕底部区域，或是输出文本信息。）现在尝试对一个带引号的列表执行相同的操
作：将光标放在下例列表的右括号后，键入‘C-x C-e’：

     '(this is a quoted list)

您将在回显区域看到 ‘(this is a quoted list)’。

   在上述两种情况下，您所做的是向GNU Emacs内部的一个叫做“Lisp解释器”的程
序发送一个命令，即给解释器一个要评估的表达式。Lisp解释器(interpreter)得
名于它解释表达式含义的功能,就像一个人在解释一样。

   您也可以评估一个不是列表的原子，即一个没有被括号包围的原子；同样，
Lisp解释器会将这种人类可读的表达式翻译成计算机语言。但在讨论这个之前（
*note Variables::），我们先来看当出现错误时Lisp解释器会做什么。

   ---------- Footnotes ----------

   (1) Emacs以十进制、八进制和十六进制以及字符的方式显示整数值，但现在让
我们忽略这个便利功能。


File: eintr.info,  Node: Making Errors,  Next: Names & Definitions,  Prev: Run a Program,  Up: List Processing

1.3 生成错误信息
================

部分原因是,如果您不小心出错了,也不用担心，我们现在将向 Lisp 解释器发出一
个命令，让它生成一条错误信息。 这是一项无害的尝试； 事实上，我们经常会尝
试故意生成错误信息。 一旦您理解了相关术语，错误信息就可以提供丰富的信息
帮助。 它们不应该被称为“错误”信息，而更应该被称为“帮助”信息。 它们就像异
国游客遇到的路标； 解读这些信息可能很困难，但一旦理解其含义，它们就能指
明道路。

   错误信息是由GNU Emacs内置的调试器生成的。我们将进入调试器环境。您可以
通过键入 ‘q’ 来退出调试器。

   我们要做的是对一个没有加单引号且第一个元素不是有效命令的列表进行评估
。这个列表和我们之前用过的类似,只是没有加上单引号。将光标定位到该列表的
后面，然后输入 ‘C-x C-e’：

     (this is an unquoted list)

   这将打开一个 ‘*Backtrace*’ 的窗口，您应该在其中看到以下内容：

     ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error: (void-function this)
       (this is an unquoted list)
       eval((this is an unquoted list) nil)
       elisp--eval-last-sexp(nil)
       eval-last-sexp(nil)
       funcall-interactively(eval-last-sexp nil)
       call-interactively(eval-last-sexp nil nil)
       command-execute(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------

此时光标会定位在这个窗口中（可能需要等待几秒才显示出来）。要退出调试器并
关闭调试器窗口，请输入：

     q

请现在按下 ‘q’键，以确保您能退出调试器。然后再次输入 ‘C-x C-e’ 重新进入
调试器。

   根据我们已经了解的知识，我们基本可以解析这个错误信息的含义。

   从下往上查看 ‘*Backtrace*’ 缓冲区的内容；它记录了Emacs执行的步骤。当
您输入 ‘C-x C-e’ 时，向命令 ‘eval-last-sexp’ 发起了交互调用。‘eval’ 是
“evaluate（评估）”的缩写，‘sexp’ 是“symbolic expression（符号表达式）”的
缩写。该命令的含义是“评估最后一个符号表达式”，也就是光标前的那个表达式。

   以上每一行都在告诉我们Lisp解释器接下来评估的内容。最新的操作在顶部。
这个缓冲区被称为 ‘*Backtrace*’ ，因为它允许我们回溯Emacs的执行步骤。

   在 ‘*Backtrace*’ 缓冲区的顶部，您可以看到这样一行：

     Debugger entered--Lisp error: (void-function this)

Lisp 解释器试图对列表的第一个原子 ‘this’ 进行评估。正是这个操作产生了错
误信息 ‘void-function this’。

   这个信息包含了 ‘void-function’ 和 ‘this’ 两个词。

   ‘函数’ (function)这个词之前提到过一次。这是一个非常重要的概念。对我们
而言，可以定义简单理解为一组指令，用于告诉计算机要执行什么操作。

   现在我们可以开始解析这个错误信息‘void-function this’的含义了。这个函
数（也就是，‘this’这个词）没有关联任何一组指令来告诉计算机要执行什么操作
。

   这个比较奇怪的词‘void-function’是为了反映Emacs Lisp的实现方式，也就是
说，当一个符号没有绑定函数定义时，原本要包含执行指令的位置是空的。

   另一方面，由于我们可以成功对2和2进行相加（通过评估 ‘(+ 2 2)’），我们
可以推断符号 ‘+’ 一定有一组与之关联的指令，这些指令会指示计算机将紧随其
后的数字相加。

   在这种情况下，可以避免Emacs进入调试器。我们暂不解释如何实现，但会提及
结果的样子，因为当您在使用某段Emacs代码遇到类似情况时，也可能看到类似的
效果。在这种情况下，您只会看到一行错误信息；它会出现在回显区，看起来像这
样：

     Symbol's function definition is void: this

当你输入任何键，哪怕只是移动一下光标，这个消息就会消失。

   我们知道‘Symbol’这个词的含义。它指代的是列表中的第一个原子，也就是词
‘this’。‘function’一词表示用于告知计算机要执行什么操作的指令。（技术上来
说，这个符号会告知计算机在何处可以找到这些指令，但这个复杂问题我们暂时可
以忽略。）

   所以错误信息可以这样理解：‘Symbol's function definition is void:
this’。这个符号(Symbol)（也就是词‘this’）缺少可供计算机执行的指令。


File: eintr.info,  Node: Names & Definitions,  Next: Lisp Interpreter,  Prev: Making Errors,  Up: List Processing

1.4 符号名称和函数定义
======================

根据目前我们的讨论,我们可以归纳出Lisp的另一关键特性：像 ‘+’ 这样的符号本
身并不是计算机可执行的一组指令。相反，这些符号仅用于暂时定位相关的定义或
指令集。我们看到的只是通过该符号名称才能找到实际指令的方式。人的名字也是
一样的。我可以被称为 ‘Bob’；然而，我不是字母 ‘B’、‘o’、‘b’ 的组合，而是
（或者曾是）一个与特定生命形式长期关联的意识。名字并不是我，但可以用来指
称我。

   在 Lisp 中，一组指令可以被关联到多个名字上。例如，加法运算的计算机指
令可以关联到符号 ‘plus’，也可以关联到符号 ‘+’上（在某些 Lisp 方言中是这
样的）。对于人名，我可以被称为 ‘Robert’，也可以被称为 ‘Bob’，以及其他词
汇。

   但是，一个符号一次只能有一个函数定义与之关联。否则，计算机就会困惑应
该使用哪个定义。如果这种情况发生在人类身上，世界上也只能有一个人被命名为
‘Bob’。然而，符号所代表的函数定义可以很容易地被更改。(*Note
安装函数定义: Install.)

   由于 Emacs Lisp 非常庞大，通常会以能够指明函数属于Emacs的哪个部分的方
式来命名符号。因此，所有涉及 Texinfo 处理的函数名都以 ‘texinfo-’ 开头，
而处理邮件读取的函数则以 ‘rmail-’ 开头。


File: eintr.info,  Node: Lisp Interpreter,  Next: Evaluation,  Prev: Names & Definitions,  Up: List Processing

1.5 Lisp解释器
==============

基于我们所见，现在我们可以开始弄清楚当命令Lisp解释器评估列表时它会做什么
。首先，它会查看列表前是否有引号；如果有，解释器会直接返回这个列表。另一
方面，如果没有引号，解释器会查看列表中的第一个元素，检查它是否有一个函数
定义与之关联。如果有，解释器就会执行该函数定义中的指令。否则，解释器会打
印错误信息。

   这就是Lisp的工作原理。简单明了。当然，还有一些额外的复杂性，我们后面
会提到，但这些是基础。想要编写Lisp程序，您还需要了解如何编写函数定义并将
其关联到函数名上，以及如何在不使自己和计算机产生困惑的情况下实现这一点。

* Menu:

* Complications::               变量、特殊形式、内部列表。
* Byte Compiling::              为加速对代码特殊处理。


File: eintr.info,  Node: Complications,  Next: Byte Compiling,  Up: Lisp Interpreter

复杂情况
--------

现在，我们来看第一个复杂情况。除了列表，Lisp 解释器还可以对没有引号且没
有被括号包围的单个符号进行评估。在这种情况下，Lisp 解释器会试图确定该符
号作为“变量”的值。这种情况我们会在变量部分进行描述。(*Note Variables::.)

   第二个复杂情况是，有一些函数的工作方式与常规函数不同，那些不同寻常的
函数被称为“特殊形式”。它们用于处理特定任务，比如定义函数，而且数量并不多
。在后续章节中，您会了解到一些更重要的特殊形式。

   除特殊形式外，还有“宏”。宏是Lisp中定义的一种构造，不同于函数的地方在
于，它会将一个Lisp表达式转换成另一个要代替原始表达式进行评估的表达式。
(*Note Lisp macro::。)

   就本书而言，您无需过于担心某个东西是特殊形式、宏还是普通函数。例如，
‘if’ 是一个特殊形式（*note if::），而‘when’ 是一个宏（*note Lisp
macro::）。在Emacs的早期版本中，‘defun’ 是一个特殊形式，但现在它是一个宏
（*note defun::），不过它的用法没有改变。

   最后一个复杂情况是：如果Lisp解释器正在处理的函数不是特殊形式，并且它
是列表的一部分，Lisp解释器会检查这个列表是否包含内部列表。如果存在内部列
表，Lisp解释器先确定应该如何处理内部列表，然后再处理外部列表。如果内部列
表中还嵌套了另一个列表，它还会先处理那个列表，以此类推。解释器总是先处理
最内层的列表。它会首先对最内层列表进行评估，得到结果用于外层表达式。

   否则，解释器会从左到右顺序处理表达式，每个表达式依次处理。


File: eintr.info,  Node: Byte Compiling,  Prev: Complications,  Up: Lisp Interpreter

1.5.1 字节编译
--------------

Lisp解释器可以处理两种实体：人类可读的代码，这会是我们的重点；以及经过特
殊处理的代码，称为 “字节编译”的代码，后者不是人类可读的。字节编译的代码
的运行速度比人类可读的代码要快。

   您可以通过运行像 ‘byte-compile-file’ 这样的编译命令，将人类可读的代码
转换为字节编译的代码。字节编译后的代码通常保存在以 ‘.elc’ 为扩展名的文件
中，而不是 ‘.el’。在 ‘emacs/lisp’ 目录下您会看到这两种类型的文件；需要阅
读的是那些 ‘.el’ 扩展名的文件。

   实际上，对于大多数自定义和扩展Emacs的需要，您不一定要进行字节编译；我
在这里也不会详细讨论这个话题。要获取字节编译的完整描述，*Note Byte
Compilation: (elisp)Byte Compilation.


File: eintr.info,  Node: Evaluation,  Next: Variables,  Prev: Lisp Interpreter,  Up: List Processing

1.6 评估
========

当Lisp解释器对表达式进行处理时，这个活动被称为 “评估”。我们说解释器 "评
估表达式"。我之前已经多次使用过这个术语。这个词来源于日常语言中的 "确定
价值或数量"，根据 ‘Webster’s New Collegiate Dictionary’ 的定义。

* Menu:

* How the Interpreter Acts::    返回值和副作用...
* Evaluating Inner Lists::      列表内部的列表...


File: eintr.info,  Node: How the Interpreter Acts,  Next: Evaluating Inner Lists,  Up: Evaluation

Lisp 解释器的行为方式
---------------------

在对表达式评估后，Lisp 解释器很可能会“返回”计算机通过执行函数定义中的指
令得到的值，或者它可能放弃对该函数的处理并生成错误消息。（也可能出现解释
器被抛入另一个函数的执行,或者陷入无限循环的情况,但这些比较少见,我们可以
忽略。）最常见的情况是，解释器返回一个值。

   与此同时，解释器还可能执行其他操作，如移动光标或复制文件；这类被称为
“副作用”。我们人类认为重要的操作，比如打印结果，通常是 Lisp 解释器的副作
用。学习使用副作用相对比较简单。

   综上所述，对符号表达式评估通常会导致 Lisp 解释器返回一个值，并可能产
生副作用；否则就会产生错误信息。


File: eintr.info,  Node: Evaluating Inner Lists,  Prev: How the Interpreter Acts,  Up: Evaluation

1.6.1 评估内部列表
------------------

如果对嵌套在另一个列表中的内部列表进行评估，外部列表在评估时可能会使用内
层列表的评估结果作为信息。这解释了为什么要首先对内部表达式进行评估：它们
的返回值会被外部表达式使用。

   我们可以通过对另一个加法示例进行评估来调查这个过程。将光标置于以下表
达式之后，键入‘C-x C-e’：

     (+ 2 (+ 3 3))

数字8将会出现在回显区域。

   过程是这样的，Lisp解释器首先对内部表达式‘(+ 3 3)’进行评估，返回值是
6；然后它对外部表达式评估，就像表达式写成‘(+ 2 6)’一样，返回值是8。由于
没有更多外层表达式需要评估，解释器将这个值打印在回显区域。

   现在很容易理解‘C-x C-e’这个快捷键所调用命令的名称 ‘eval-last-sexp’。
‘sexp’是“symbolic expression”（符号表达式）的缩写，而‘eval’是
“evaluate”（评估）的缩写。该命令对最后一个符号表达式进行评估。

   作为实验，您可以尝试通过将光标放在表达式后面紧跟的下一行行首，或者放
在表达式内部来评估该表达式。

   下面是表达式的另一份副本：

     (+ 2 (+ 3 3))

如果将光标放在紧随表达式后面的空白行行首，然后键入 ‘C-x C-e’，您仍然会在
回显区域中看到打印的值8。现在试着将光标放在表达式内部。如果将光标放在倒
数第二个括号后（使它看起来位于最后一个括号上方），您会在回显区域看到打印
的值6！这是因为该命令评估了表达式 ‘(+ 3 3)’。

   现在将光标放在一个数字后面。键入 ‘C-x C-e’，您会得到那个数字本身。在
Lisp中，对一个数字评估会直接返回这个数字本身——这是数字与符号的区别。如果
对以像 ‘+’ 这样的符号开头的列表评估，您会得到一个返回值，该返回值是计算
机执行附加在该符号上的函数定义中的指令所得到的结果。如果单独对一个符号评
估，会发生一些不同的事情，我们将在下一节看到。


File: eintr.info,  Node: Variables,  Next: Arguments,  Prev: Evaluation,  Up: List Processing

1.7 变量
========

在 Emacs Lisp 中，一个符号可以附加一个值，就像它可以附加一个函数定义一样
。这两者是不同的。函数定义是计算机将执行的一组指令。值，另一方面，是一些
可以变化的东西，比如一个数字或一个名称（这就是为什么这样的符号被称为变量
的原因）。一个符号的值可以是Lisp中的任何表达式，比如一个符号、数字、列表
或字符串。一个具有值的符号通常被称为“变量”。

   一个符号可以同时有一个函数定义和一个值。或者它可以只有其中之一。这两
者是独立的。这与剑桥这个名称既可以指代马萨诸塞州的城市，又可以附带一些信
息，比如“伟大的编程中心”，有些相似。

   另一种思考这个问题的方式是将一个符号想象成一个抽屉柜。函数定义放在一
个抽屉里，值放在另一个抽屉里，依此类推。在值的抽屉里放置的东西可以更改，
而不影响放置函数定义的抽屉的内容，反之亦然。

* Menu:

* fill-column Example::
* Void Function::               一个没有函数的符号的错误消息。
* Void Variable::               一个没有值的符号的错误消息。


File: eintr.info,  Node: fill-column Example,  Next: Void Function,  Up: Variables

‘fill-column’，一个示例变量
---------------------------

变量 ‘fill-column’ 说明了一个带有值的符号：在每个 GNU Emacs 缓冲区中，该
符号被设置为某个值，通常是 72 或 70，但有时也可能是其他值。要找到此符号
的值，请通过单独评估它来执行。如果您在 GNU Emacs 中的 Info 中阅读此信息
，可以将光标放在符号后面，然后键入 ‘C-x C-e’ 来执行：

     fill-column

在我键入 ‘C-x C-e’ 后，Emacs 在我的回显区打印了数字 72。这是我在编写此内
容时为 ‘fill-column’ 设置的值。在您的 Info 缓冲区中，这个值可能是不同的
。请注意，变量返回的值与执行其指令的函数返回的值的打印方式完全相同。从
Lisp 解释器的角度来看，返回的值就是返回的值。一旦知道值是什么，它来自哪
种表达式就不再重要。

   一个符号可以附有任何值，或者用行话说，我们可以将变量“绑定”到一个值上
：可以是一个数字，比如 72；可以是一个字符串，比如 ‘"如此"’；可以是一个列
表，比如 ‘(云杉 松树 橡树)’；我们甚至可以将变量绑定到一个函数定义上。

   一个符号可以以多种方式绑定到一个值。有关如何执行此操作的信息，请参阅
*Note Setting the Value of a Variable: set & setq.


File: eintr.info,  Node: Void Function,  Next: Void Variable,  Prev: fill-column Example,  Up: Variables

1.7.1 没有函数的符号的错误消息
------------------------------

当我们评估变量 ‘fill-column’ 以获取其值时，我们没有在单词周围加括号。这
是因为我们没有打算将其用作函数名称。

   如果 ‘fill-column’ 是列表的第一个或唯一元素，Lisp 解释器将尝试找到与
之关联的函数定义。但是 ‘fill-column’ 没有函数定义。尝试评估以下内容：

     (fill-column)

将会创建一个 ‘*Backtrace*’ 缓冲区，其中显示：

     ---------- 缓冲区：*Backtrace* ----------
     Debugger entered--Lisp error: (void-function fill-column)
       (fill-column)
       eval((fill-column) nil)
       elisp--eval-last-sexp(nil)
       eval-last-sexp(nil)
       funcall-interactively(eval-last-sexp nil)
       call-interactively(eval-last-sexp nil nil)
       command-execute(eval-last-sexp)
     ---------- 缓冲区：*Backtrace* ----------

（记住，要退出调试器并关闭调试器窗口，请在 ‘*Backtrace*’ 缓冲区中键入
‘q’。）


File: eintr.info,  Node: Void Variable,  Prev: Void Function,  Up: Variables

1.7.2 没有值的符号的错误消息
----------------------------

如果你尝试评估一个没有绑定值的符号，你将收到一个错误消息。你可以通过尝试
我们的2加2的加法来看到这一点。在下面的表达式中，将光标放在第一个数字2之
前的‘+’右边，然后输入‘C-x C-e’：

     (+ 2 2)

在GNU Emacs 22中，你将创建一个名为‘*Backtrace*’的缓冲区，显示如下错误消
息：

     ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error: (void-variable +)
       eval(+)
       elisp--eval-last-sexp(nil)
       eval-last-sexp(nil)
       funcall-interactively(eval-last-sexp nil)
       call-interactively(eval-last-sexp nil nil)
       command-execute(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------

（同样，你可以在‘*Backtrace*’缓冲区中输入‘q’来退出调试器。）

   这个回溯与我们最初看到的第一个错误消息不同，它说的是‘Debugger
entered--Lisp error: (void-function this)’。在这种情况下，该函数没有作为
变量的值；而在其他错误消息中，函数（单词‘this’）没有定义。

   在这个对‘+’的实验中，我们的做法是导致Lisp解释器评估‘+’并寻找变量的值
，而不是函数的定义。我们通过将光标放在符号右边而不是在封闭列表的括号后面
，使Lisp解释器执行了前一个S表达式，这种情况下是单独的‘+’。

   由于‘+’没有绑定到任何值，只有函数定义，错误消息报告该符号作为变量的值
为空。


File: eintr.info,  Node: Arguments,  Next: set & setq,  Prev: Variables,  Up: List Processing

1.8 参数
========

为了了解信息是如何传递给函数的，让我们再次看看我们的老朋友，‘2 + 2’。在
Lisp中，它被写成如下形式：

     (+ 2 2)

   如果你评估这个表达式，数字4将出现在你的回显区。Lisp解释器所做的是将跟
随‘+’的数字相加。

   由‘+’相加的数字被称为函数‘+’的“参数”。这些数字是传递给函数的信息。

   “参数”这个词来自数学中的用法，不是指两个人之间的辩论；而是指提供给函
数的信息，在这种情况下，是提供给‘+’的信息。在Lisp中，函数的参数是跟随函
数的原子或列表。通过评估这些原子或列表的结果值传递给函数。不同的函数需要
不同数量的参数；有些函数根本不需要参数。(1)

* Menu:

* Data types::                  传递给函数的数据类型。
* Args as Variable or List::    参数可以是变量或列表的值。
* Variable Number of Arguments::  一些函数可能接受可变数量的参数。
* Wrong Type of Argument::      将错误类型的参数传递给函数。
* message::                     用于发送消息的有用函数。

   ---------- Footnotes ----------

   (1) 追踪“参数”这个词如何在数学中和日常英语中拥有两个不同的含义是很有
趣的。根据《牛津英语词典》的说法，这个词源于拉丁语，意思是“澄清，证明”；
因此，它通过一条推导线的方式，来表示“作为证据提供的信息”，也就是说，“提
供的信息”，这导致了它在Lisp中的含义。但在另一条推导线上，它的意思变成了
“以一种其他人可以提出反对主张的方式断言”，这解释了这个词作为争论的含义。
(注意这里英语单词同时拥有两个不同的定义。相比之下，在Emacs Lisp中，一个
符号在同一时间不能拥有两个不同的函数定义。)


File: eintr.info,  Node: Data types,  Next: Args as Variable or List,  Up: Arguments

1.8.1 参数的数据类型
--------------------

应传递给函数的数据类型取决于它使用的信息的种类。例如，像‘+’这样的函数的
参数必须是数字，因为‘+’是对数字进行加法运算的。其他函数使用不同类型的数
据作为它们的参数。

   例如，‘concat’函数将两个或多个文本字符串连接或合并成一个字符串。其参
数是字符串。连接两个字符字符串‘abc’和‘def’将产生单个字符串‘abcdef’。通过
评估以下表达式可以看到这一点：

     (concat "abc" "def")

评估这个表达式产生的值是‘"abcdef"’。

   像‘substring’这样的函数使用字符串和数字作为参数。该函数返回字符串的一
部分，即第一个参数的“子字符串”。该函数接受三个参数。其第一个参数是字符字
符串，第二个和第三个参数是指示子字符串的开始（包括）和结束（不包括）的数
字。这些数字表示从字符串开头开始的字符数（包括空格和标点符号）。注意字符
串中的字符是从零开始编号的，而不是从一开始。

   例如，如果你评估以下表达式：

     (substring "The quick brown fox jumped." 16 19)

你将在回显区看到‘"fox"’。这些参数分别是字符串和两个数字。

   请注意，传递给‘substring’的字符串是一个单一的原子，即使它由多个用空格
分隔的单词组成。Lisp将引号之间的所有内容都计为字符串的一部分，包括空格。
你可以将‘substring’函数看作是一种原子粒子解体器，因为它从一个否则不可分
割的原子中提取了一部分。但是，‘substring’只能从参数是字符串的原子中提取
子字符串，而不能从其他类型的原子（如数字或符号）中提取。


File: eintr.info,  Node: Args as Variable or List,  Next: Variable Number of Arguments,  Prev: Data types,  Up: Arguments

1.8.2 参数作为变量或列表的值
----------------------------

参数可以是一个符号，在评估时返回一个值。例如，当单独评估符号
‘fill-column’时，它会返回一个数字。这个数字可以在加法中使用。

   将光标定位到以下表达式后，键入‘C-x C-e’：

     (+ 2 fill-column)

该值将是比仅评估‘fill-column’得到的数字多两个。对我来说，这是74，因为我
的‘fill-column’值是72。

   正如我们刚刚看到的，参数可以是在评估时返回值的符号。此外，参数还可以
是在评估时返回值的列表。例如，在以下表达式中，函数‘concat’的参数是字符串
‘"The "’和‘" red foxes."’，以及列表‘(number-to-string (+ 2
fill-column))’。

     (concat "The " (number-to-string (+ 2 fill-column)) " red foxes.")

如果你评估这个表达式——如果像我的Emacs一样，‘fill-column’评估为72——‘"The
74 red foxes."’将出现在回显区。 (注意，你必须在单词‘The’后面和单词
‘red’前面加上空格，这样它们才会出现在最终的字符串中。函数
‘number-to-string’将加法函数返回的整数转换为字符串。‘number-to-string’也
被称为‘int-to-string’。)


File: eintr.info,  Node: Variable Number of Arguments,  Next: Wrong Type of Argument,  Prev: Args as Variable or List,  Up: Arguments

1.8.3 可变数量的参数
--------------------

一些函数，如‘concat’，‘+’或‘*’，可以接受任意数量的参数。（‘*’是乘法的符
号。）这可以通过以通常的方式评估以下每个表达式来看到。在回显区域中看到的
内容在此文本中以‘⇒’打印出来，你可以将其理解为“求值为”。

   在第一组中，函数没有参数：

     (+)       ⇒ 0

     (*)       ⇒ 1

   在这一组中，函数每个都有一个参数：

     (+ 3)     ⇒ 3

     (* 3)     ⇒ 3

   在这一组中，函数每个都有三个参数：

     (+ 3 4 5) ⇒ 12

     (* 3 4 5) ⇒ 60


File: eintr.info,  Node: Wrong Type of Argument,  Next: message,  Prev: Variable Number of Arguments,  Up: Arguments

1.8.4 使用错误类型的对象作为参数
--------------------------------

当一个函数被传递一个错误类型的参数时，Lisp解释器会产生一个错误消息。例如
，‘+’函数期望其参数的值为数字。作为实验，我们可以传递给它带引号的符号
‘hello’，而不是一个数字。将光标放在以下表达式后，然后输入‘C-x C-e’：

     (+ 2 'hello)

当你这样做时，将生成一个错误消息。发生的情况是，‘+’试图将2添加到
‘'hello’返回的值，但‘'hello’返回的值是符号‘hello’，而不是一个数字。只有
数字可以相加。所以‘+’无法执行其加法运算。

   你将创建并进入一个‘*Backtrace*’缓冲区，其中显示：

     ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error:
              (wrong-type-argument number-or-marker-p hello)
       +(2 hello)
       eval((+ 2 'hello) nil)
       elisp--eval-last-sexp(t)
       eval-last-sexp(nil)
       funcall-interactively(eval-print-last-sexp nil)
       call-interactively(eval-print-last-sexp nil nil)
       command-execute(eval-print-last-sexp)
     ---------- Buffer: *Backtrace* ----------

   和往常一样，错误消息试图提供帮助，并在学会如何阅读后变得有意义。(1)

   错误消息的第一部分很简单，它说‘wrong type argument’。接下来是神秘的行
话词‘number-or-marker-p’。这个词试图告诉你‘+’期望的参数类型。

   符号‘number-or-marker-p’表示Lisp解释器正在尝试确定所呈现的信息（参数
的值）是一个数字还是一个标记（表示缓冲区位置的特殊对象）。它的操作是测试
‘+’是否被赋予要相加的数字。它还测试参数是否是一种称为标记的东西，这是
Emacs Lisp的一个特定特性。（在Emacs中，缓冲区中的位置被记录为标记。当使
用‘C-@’或‘C-<SPC>’命令设置标记时，其位置被保留为标记。标记可以被视为一个
数字—表示该位置距离缓冲区开头的字符数。在Emacs Lisp中，‘+’可以用于将标记
位置的数值作为数字相加。

   ‘number-or-marker-p’中的‘p’体现了Lisp编程早期实践的一种做法。‘p’代表
“谓词”。在早期Lisp研究者使用的行话中，谓词是指一个函数，用于确定某个属性
是否为真或为假。因此，‘p’告诉我们‘number-or-marker-p’是一个函数的名称，
该函数确定所提供的参数是否为数字或标记。其他以‘p’结尾的Lisp符号包括
‘zerop’，一个测试其参数是否为零值的函数，以及‘listp’，一个测试其参数是否
为列表的函数。

   最后，错误消息的最后部分是符号‘hello’。这是传递给‘+’的参数的值。如果
相加操作传递了正确类型的对象，传递的值将是一个数字，如37，而不是像
‘hello’这样的符号。但那样你就不会收到错误消息。

   ---------- Footnotes ----------

   (1) ‘(quote hello)’是‘'hello’缩写的扩展。


File: eintr.info,  Node: message,  Prev: Wrong Type of Argument,  Up: Arguments

1.8.5 ‘message’ 函数
--------------------

类似于‘+’函数，‘message’函数接受可变数量的参数。它用于向用户发送消息，非
常实用，我们将在这里描述它。

   消息将被打印在回显区。例如，通过评估以下列表，您可以在回显区中打印一
条消息：

     (message "This message appears in the echo area!")

   双引号之间的整个字符串是一个单一的参数，并被整体打印出来。（请注意，
在这个例子中，消息本身将在回显区中用双引号括起来；这是因为您看到了
‘message’函数返回的值。在您编写的程序中，‘message’的大多数用法将作为副作
用将文本在回显区中打印出来，而不带引号。*Note ‘multiply-by-seven’ in
detail: multiply-by-seven in detail, 了解其中的一个示例。）

   然而，如果在带引号的字符字符串中有一个‘%s’，‘message’函数不会像这样打
印‘%s’，而是查看跟随字符串的参数。它评估第二个参数，并在字符串中‘%s’的位
置打印该值。

   您可以通过将光标定位在以下表达式之后，然后键入‘C-x C-e’来查看这一点：

     (message "The name of this buffer is: %s." (buffer-name))

在Info中，‘"The name of this buffer is: *info*."’ 将出现在回显区。函数
‘buffer-name’ 返回缓冲区的名称作为字符串，‘message’ 函数将其插入到 ‘%s’
的位置。

   要将值以整数形式打印，可以使用 ‘%d’，与 ‘%s’ 的使用方式相同。例如，要
在回显区中打印一条消息，指出 ‘fill-column’ 的值，请评估以下内容：

     (message "The value of fill-column is %d." fill-column)

在我的系统上，当我评估这个列表时，‘"The value of fill-column is 72."’ 将
出现在我的回显区(1)。

   如果在引用的字符串中有多个 ‘%s’，则在第一个 ‘%s’ 的位置打印跟在引用字
符串后的第一个参数的值，并在第二个 ‘%s’ 的位置打印第二个参数的值，依此类
推。

   例如，如果你评估以下内容，

     (message "There are %d %s in the office!"
              (- fill-column 14) "pink elephants")

你的回显区将显示一条相当奇特的消息。在我的系统上，它会显示，‘"There are
58 pink elephants in the office!"’。

   表达式‘(- fill-column 14)’被评估，生成的数字插入到‘%d’的位置；双引号
中的字符串‘"pink elephants"’被视为单个参数，插入到‘%s’的位置。（也就是说
，双引号之间的字符串评估为它本身，就像一个数字一样。）

   最后，这里有一个稍微复杂的例子，不仅说明了一个数字的计算，而且还展示
了如何在一个表达式中使用另一个表达式来生成替代‘%s’的文本：

     (message "He saw %d %s"
              (- fill-column 32)
              (concat "red "
                      (substring
                       "The quick brown foxes jumped." 16 21)
                      " leaping."))

   在这个例子中，‘message’有三个参数：字符串‘"He saw %d %s"’，表达式‘(-
fill-column 32)’，以及以‘concat’函数开头的表达式。通过评估‘(-
fill-column 32)’生成的值插入到‘%d’的位置；以及通过评估以‘concat’开头的表
达式生成的值插入到‘%s’的位置。

   当你的填充列为70时，评估这个表达式，消息‘"He saw 38 red foxes
leaping."’将出现在你的回显区。

   ---------- Footnotes ----------

   (1) 实际上，你可以使用 ‘%s’ 打印一个数字。它是非具体的。‘%d’ 只打印小
数点左边的数字部分，而不包括任何非数字内容。


File: eintr.info,  Node: set & setq,  Next: Summary,  Prev: Arguments,  Up: List Processing

1.9 设置变量的值
================

有几种方式可以给一个变量赋值。其中一种方式是使用函数‘set’或特殊形式
‘setq’。另一种方式是使用‘let’（*note let::）。（这个过程的行话术语是将变
量“bind”到一个值上。）

   以下章节不仅描述了‘set’和‘setq’的工作方式，还说明了如何传递参数。

* Menu:

* Using set::                  设置值。
* Using setq::                 设置引用值。
* Counting::                      使用‘setq’进行计数。


File: eintr.info,  Node: Using set,  Next: Using setq,  Up: set & setq

1.9.1 使用 ‘set’
----------------

要将符号 ‘flowers’ 的值设置为列表 ‘'(rose violet daisy buttercup)’，请通
过将光标定位在表达式后并键入 ‘C-x C-e’ 来评估以下表达式。

     (set 'flowers '(rose violet daisy buttercup))

列表 ‘(rose violet daisy buttercup)’ 将出现在回显区域。这是由 ‘set’ 函数
_返回_的内容。作为副作用，符号 ‘flowers’ 被绑定到该列表；也就是说，可以
将符号 ‘flowers’ 视为变量，然后将该列表赋给它作为值。（顺便说一下，这个
过程说明了对于Lisp解释器来说，设置值是我们人类感兴趣的主要效果。这是因为
如果Lisp函数没有出错，它必须返回一个值，但只有在设计为具有副作用时才会有
副作用。）

   在评估 ‘set’ 表达式后，可以评估符号 ‘flowers’，它将返回刚刚设置的值。
这是该符号。将光标放在其后，然后键入 ‘C-x C-e’。

     flowers

当你评估 ‘flowers’ 时，列表 ‘(rose violet daisy buttercup)’ 将出现在回显
区域。

   顺便说一下，如果你评估 ‘'flowers’，在带引号的变量前面，你将在回显区域
看到符号本身，即 ‘flowers’。这是带引号的符号，所以你可以试一下：

     'flowers

   还要注意，当你使用 ‘set’ 时，需要引用 ‘set’ 的两个参数，除非你想要它
们被评估。因为我们不想让任何一个参数被评估，所以变量 ‘flowers’ 和列表
‘(rose violet daisy buttercup)’ 都被引用。（当你使用 ‘set’ 而不引用其第
一个参数时，第一个参数在执行任何其他操作之前被评估。如果你这样做而且
‘flowers’ 没有一个已经存在的值，你会得到一个错误消息，指明 ‘Symbol's
value as variable is void’；另一方面，如果在评估后 ‘flowers’ 返回了一个
值，‘set’ 将尝试设置返回的值。有些情况下这是函数正确的行为，但这样的情况
很少见。）


File: eintr.info,  Node: Using setq,  Next: Counting,  Prev: Using set,  Up: set & setq

1.9.2 使用 ‘setq’
-----------------

实际上，几乎总是对‘set’的第一个参数加引号。‘set’和引用的第一个参数的组合
是如此常见，以至于它有自己的名称：特殊形式‘setq’。这个特殊形式与‘set’几
乎相同，只是第一个参数被‘setq’自动引用，因此您不需要自己输入引号。此外，
作为额外的便利，‘setq’允许您在一个表达式中设置多个不同的变量为不同的值。

   为了使用‘setq’将变量‘carnivores’的值设置为列表‘'(lion tiger
leopard)’，可以使用以下表达式：

     (setq carnivores '(lion tiger leopard))

这与使用‘set’完全相同，只是‘setq’自动引用了第一个参数。（‘setq’中的‘q’表
示‘quote’。）

   使用‘set’，表达式如下：

     (set 'carnivores '(lion tiger leopard))

   此外，‘setq’还可以用于为不同的变量分配不同的值。第一个参数绑定到第二
个参数的值，第三个参数绑定到第四个参数的值，依此类推。例如，您可以使用以
下表达式将树的列表分配给符号‘trees’，将食草动物的列表分配给符号
‘herbivores’：

     (setq trees '(pine fir oak maple)
           herbivores '(gazelle antelope zebra))

（表达式同样可以在一行上，但它可能不适合一页；并且人们更容易阅读格式良好
的列表。）

   尽管我一直在使用术语“分配”，但还有一种理解‘set’和‘setq’运作方式的方式
；即‘set’和‘setq’使符号_指向_列表。这种思考方式非常常见，在接下来的章节
中，我们将至少遇到一个其名称中包含“指针”的符号。之所以选择这个名称，是因
为符号有一个值，具体来说是一个列表，与之相关联；或者，换句话说，该符号被
设置为指向该列表。


File: eintr.info,  Node: Counting,  Prev: Using setq,  Up: set & setq

1.9.3 计数
----------

以下是一个示例，展示了如何在计数器中使用‘setq’。您可以使用这种方法来计算
程序的某个部分重复的次数。首先将一个变量设置为零；然后在程序重复自身时每
次将该数字加一。为此，您需要一个用作计数器的变量，以及两个表达式：一个初
始的‘setq’表达式，将计数器变量设置为零；和第二个‘setq’表达式，在每次评估
时递增计数器。

     (setq counter 0)                ; 我们称之为初始化器。

     (setq counter (+ counter 1))    ; 这是递增器。

     counter                         ; 这是计数器。

（在‘;’之后的文本是注释。*Note 修改函数定义: Change a defun.）

   如果您评估这些表达式中的第一个，即初始化器‘(setq counter 0)’，然后评
估第三个表达式‘counter’，数字‘0’将显示在回显区域中。然后，如果您评估第二
个表达式，即递增器‘(setq counter (+ counter 1))’，计数器将获得值1。因此
，如果您再次评估‘counter’，数字‘1’将显示在回显区域中。每次评估第二个表达
式时，计数器的值将递增。

   当您评估递增器‘(setq counter (+ counter 1))’时，Lisp解释器首先评估最
内层的列表；这是加法。为了评估此列表，它必须评估变量‘counter’和数字‘1’。
当它评估变量‘counter’时，它会得到它的当前值。它将这个值和数字‘1’传递给
‘+’，将它们相加。然后，总和作为内部列表的值返回，并传递给‘setq’，将变量
‘counter’设置为这个新值。因此，变量‘counter’的值被更改。


File: eintr.info,  Node: Summary,  Next: Error Message Exercises,  Prev: set & setq,  Up: List Processing

1.10 总结
=========

学习 Lisp 就像攀登一座山，其中的第一部分是最陡峭的。你现在已经攀登过最困
难的部分；随着你继续前进，剩下的部分会变得更容易。

   总的来说，

   • Lisp 程序由表达式组成，这些表达式可以是列表或单个原子。

   • 列表由零个或多个原子或内部列表组成，它们之间由空格分隔，并用括号括
     起来。列表可以为空。

   • 原子可以是多字符符号，比如 ‘forward-paragraph’，也可以是单字符符号
     ，比如 ‘+’，还可以是双引号之间的字符字符串或数字。

   • 数字在求值时等于其自身。

   • 双引号之间的字符串在求值时也等于其自身。

   • 当你对一个符号进行单独求值时，它的值会被返回。

   • 当你对一个列表进行求值时，Lisp 解释器首先查看列表中的第一个符号，然
     后查找与该符号绑定的函数定义。然后执行函数定义中的指令。

   • 单引号 ‘'’ 告诉 Lisp 解释器它应该按照写法返回后面的表达式，而不是像
     没有引号那样对其进行求值。

   • 参数是传递给函数的信息。函数的参数是通过求值列表的其余元素来计算的
     ，其中函数是第一个元素。

   • 函数在求值时总是返回一个值（除非出现错误）；此外，它还可能执行一些
     是副作用的动作。在许多情况下，函数的主要目的是创建副作用。


File: eintr.info,  Node: Error Message Exercises,  Prev: Summary,  Up: List Processing

1.11 练习
=========

一些简单的练习：

   • 通过评估一个适当的不在括号内的符号生成一个错误消息。

   • 通过评估一个适当的在括号之间的符号生成一个错误消息。

   • 创建一个计数器，其增量为两而不是一。

   • 编写一个在评估时在回显区域打印消息的表达式。


File: eintr.info,  Node: Practicing Evaluation,  Next: Writing Defuns,  Prev: List Processing,  Up: Top

2 练习评估
**********

在学习如何在Emacs Lisp中编写函数定义之前，花一点时间评估已经编写的各种表
达式是很有用的。这些表达式将是具有函数作为它们的第一个（通常是唯一的）元
素的列表。由于与缓冲区相关的一些函数既简单又有趣，我们将从这些函数开始。
在本节中，我们将评估其中的一些。在另一节中，我们将研究其他几个与缓冲区相
关的函数的代码，以了解它们是如何编写的。

* Menu:

* How to Evaluate::            键入编辑命令或 ‘C-x C-e’ 会导致评估。
* Buffer Names::               缓冲区和文件是不同的。
* Getting Buffers::               获取缓冲区本身，而不仅仅是它的名称。
* Switching Buffers::               如何切换到另一个缓冲区。
* Buffer Size & Locations::         point 的位置以及缓冲区的大小。
* Evaluation Exercise::


File: eintr.info,  Node: How to Evaluate,  Next: Buffer Names,  Up: Practicing Evaluation

如何进行评估
============

每当你向Emacs Lisp发送一个编辑命令，比如移动光标或滚动屏幕时，你都在评估
一个表达式，其第一个元素是一个函数。这就是Emacs的工作原理。

   当你键入键位时，你会导致Lisp解释器评估一个表达式，这就是你获得结果的
方式。甚至键入纯文本也涉及评估一个Emacs Lisp函数，这种情况下，使用的是
‘self-insert-command’，它简单地插入你键入的字符。通过键入按键而评估的函
数称为“交互”函数或“命令”；如何使函数具有交互性将在编写函数定义的章节中说
明。*Note 使函数具有交互性: Interactive.

   除了键入键盘命令，我们已经看到第二种评估表达式的方法：将光标定位在列
表后面，然后键入‘C-x C-e’。这是本节其余部分将要做的事情。还有其他评估表
达式的方式；当我们遇到它们时会进行描述。

   除了用于练习评估之外，下面几节中显示的函数在其自身方面也是重要的。研
究这些函数清晰地展示了缓冲区和文件之间的区别，如何切换到一个缓冲区以及如
何确定其中的位置。


File: eintr.info,  Node: Buffer Names,  Next: Getting Buffers,  Prev: How to Evaluate,  Up: Practicing Evaluation

2.1 缓冲区名称
==============

两个函数，‘buffer-name’ 和 ‘buffer-file-name’，展示了文件和缓冲区之间的
区别。当你评估下面的表达式 ‘(buffer-name)’ 时，缓冲区的名称会出现在回显
区。当你评估 ‘(buffer-file-name)’ 时，缓冲区所引用的文件的名称会出现在回
显区。通常，由 ‘(buffer-name)’ 返回的名称与它引用的文件的名称相同，而由
‘(buffer-file-name)’ 返回的名称是文件的完整路径名。

   文件和缓冲区是两个不同的实体。文件是永久记录在计算机中的信息（除非你
删除它）。另一方面，缓冲区是 Emacs 内部的信息，在编辑会话结束时（或者当
你杀死缓冲区时）将会消失。通常，缓冲区包含你从文件中复制的信息；我们说缓
冲区正在“访问”该文件。这份副本是你要操作和修改的。对缓冲区的更改不会影响
文件，直到你保存缓冲区。当你保存缓冲区时，缓冲区被复制到文件中，因此被永
久保存。

   如果你正在 GNU Emacs 中的 Info 中阅读本文，你可以通过将光标定位在表达
式后并键入 ‘C-x C-e’ 来评估以下每个表达式。

     (buffer-name)

     (buffer-file-name)

在 Info 中执行 ‘(buffer-name)’ 时，返回的值是 ‘"*info*"’，而执行
‘(buffer-file-name)’ 时返回的值是 ‘nil’。

   另一方面，在我编写这个文档时，执行 ‘(buffer-name)’ 返回的值是
‘"introduction.texinfo"’，而执行 ‘(buffer-file-name)’ 返回的值是
‘"/gnu/work/intro/introduction.texinfo"’。

   前者是缓冲区的名称，而后者是文件的名称。在 Info 中，缓冲区名称是
‘"*info*"’。Info 没有指向任何文件，因此执行 ‘(buffer-file-name)’ 的结果
是 ‘nil’。符号 ‘nil’ 源自拉丁语单词 "nothing"，在这种情况下，它表示该缓
冲区未关联任何文件。（在 Lisp 中，‘nil’ 也用于表示 "false"，并且是空列表
‘()’ 的同义词。）

   在编写文档时，我的缓冲区名称是 ‘"introduction.texinfo"’。它指向的文件
名称是 ‘"/gnu/work/intro/introduction.texinfo"’。

   （在这些表达式中，括号告诉 Lisp 解释器将 ‘buffer-name’ 和
‘buffer-file-name’ 视为函数；没有括号，解释器将尝试将这些符号评估为变量
。*Note Variables::。）

   尽管文件和缓冲区之间有区别，但你经常会发现人们在指代文件时实际上是指
缓冲区，反之亦然。实际上，大多数人会说：“我正在编辑一个文件”，而不是说：
“我正在编辑一个缓冲区，稍后将保存到文件。” 从上下文中几乎总能清楚人们的
意思。然而，在处理计算机程序时，保持区别是重要的，因为计算机没有人类那么
智能。

   顺便说一下，“缓冲区”这个词的意义来源于它作为减缓碰撞力的缓冲物。在早
期计算机中，缓冲区起到了文件与计算机中央处理单元之间相互作用的缓冲作用。
持有文件的磁鼓或磁带和中央处理单元是非常不同的设备，它们以各自的速度、断
断续续地工作。缓冲区使它们能够有效地协同工作。最终，缓冲区从一个中介、一
个临时存放的地方，发展成为工作完成的地方。这种转变有点像一个小港口发展成
为一个大城市：曾经它只是在货物被装上船之前的临时仓库；然后它成为一个独立
的商业和文化中心。

   并非所有的缓冲区都与文件相关。例如，‘*scratch*‘ 缓冲区没有访问任何文
件。同样，‘*Help*‘ 缓冲区也没有与任何文件相关。

   在过去，当你没有 ‘~/.emacs‘ 文件，通过输入 ‘emacs‘ 命令启动 Emacs 会
话时，不指定任何文件，Emacs 会以 ‘*scratch*‘ 缓冲区可见的状态启动。现在
，你会看到一个启动画面。你可以按照启动画面上建议的命令之一，访问一个文件
，或按 ‘q‘ 键退出启动画面并进入 ‘*scratch*‘ 缓冲区。

   如果切换到 ‘*scratch*‘ 缓冲区，输入 ‘(buffer-name)‘，将光标定位到其后
，然后键入 ‘C-x C-e‘ 以评估表达式。将返回并显示 ‘*scratch*‘ 的名称在回显
区。‘*scratch*‘ 就是该缓冲区的名称。当你在 ‘*scratch*‘ 缓冲区中输入
‘(buffer-file-name)‘ 并评估时，回显区将显示 ‘nil‘，就像在 Info 中评估
‘(buffer-file-name)‘ 时一样。

   顺便提一下，如果你在 ‘*scratch*‘ 缓冲区中，想要将表达式返回的值显示在
‘*scratch*‘ 缓冲区本身而不是在回显区，可以键入 ‘C-u C-x C-e‘ 而不是 ‘C-x
C-e‘。这将导致返回的值出现在表达式之后。缓冲区会看起来像这样：

     (buffer-name)"*scratch*"

在 Info 中你不能这样做，因为 Info 是只读的，它不允许你更改缓冲区的内容。
但是在任何你可以编辑的缓冲区中，你都可以这样做；当你编写代码或文档（比如
这本书）时，这个功能非常有用。


File: eintr.info,  Node: Getting Buffers,  Next: Switching Buffers,  Prev: Buffer Names,  Up: Practicing Evaluation

2.2 获取缓冲区
==============

函数‘buffer-name’返回缓冲区的_名称_；要获取缓冲区_本身_，需要使用另一个
函数：‘current-buffer’函数。如果在代码中使用这个函数，你将得到缓冲区本身
。

   名称和名称所指代的对象或实体是不同的。你不是你的名字。你是一个被别人
用名字指称的人。如果你要求与George交谈，而有人递给你一张写有字母‘G’、
‘e’、‘o’、‘r’、‘g’和‘e’的卡片，你可能会感到有趣，但你不会满意。你不想和
名字交谈，而是想和名字所指代的人交谈。缓冲区类似：临时缓冲区的名称是
‘*scratch*’，但名称不是缓冲区。要获取缓冲区本身，需要使用诸如
‘current-buffer’这样的函数。

   然而，有一个小复杂性：如果在一个表达式中评估‘current-buffer’，就像我
们在这里所做的那样，你所看到的是缓冲区名称的打印表示，而不是缓冲区的内容
。Emacs之所以以这种方式工作有两个原因：缓冲区可能有成千上万行长—太长了无
法方便地显示；另一个缓冲区可能具有相同的内容但具有不同的名称，区分它们是
很重要的。

   下面是包含该函数的表达式：

     (current-buffer)

如果你在Emacs中通常的方式下在Info中评估这个表达式，‘#<buffer *info*>’ 将
会出现在回显区。这个特殊的格式表示正在返回的是缓冲区本身，而不仅仅是它的
名称。

   顺便提一下，虽然你可以在程序中键入数字或符号，但不能在缓冲区的打印表
示中这样做：获取缓冲区本身的唯一方式是使用诸如‘current-buffer’的函数。

   一个相关的函数是‘other-buffer’。它返回除了当前所在的缓冲区之外最近选
择的缓冲区，而不是其名称的打印表示。如果你最近在‘*scratch*’缓冲区之间切
换，‘other-buffer’将返回该缓冲区。

   你可以通过评估以下表达式来看到这一点：

     (other-buffer)

你应该在回显区看到‘#<buffer *scratch*>’出现，或者是你最近切换回来的任何
其他缓冲区的名称(1)。

   ---------- Footnotes ----------

   (1) 实际上，默认情况下，如果你刚刚从中切换的缓冲区在另一个窗口中可见
，‘other-buffer’将选择你无法看到的最近的缓冲区；这是我经常忘记的一个细微
之处。


File: eintr.info,  Node: Switching Buffers,  Next: Buffer Size & Locations,  Prev: Getting Buffers,  Up: Practicing Evaluation

2.3 切换缓冲区
==============

实际上，当将‘other-buffer’函数用作需要缓冲区参数的函数的参数时，它实际上
提供了一个缓冲区。通过使用‘other-buffer’和‘switch-to-buffer’来切换到不同
的缓冲区，我们可以看到这一点。

   但首先，让我们简要介绍一下‘switch-to-buffer’函数。当你在Info和
‘*scratch*’缓冲区之间切换以评估‘(buffer-name)’时，你很可能会输入‘C-x b’，
然后在迷你缓冲区中输入‘*scratch*’。(1) 用于切换到所需缓冲区的名称。按下
‘C-x b’这些按键会导致Lisp解释器评估交互函数‘switch-to-buffer’。正如我们
之前所说，这就是Emacs的工作原理：不同的按键调用或运行不同的函数。例如，
‘C-f’调用‘forward-char’，‘M-e’调用‘forward-sentence’等等。

   通过在表达式中编写‘switch-to-buffer’，并给它一个要切换到的缓冲区，我
们可以像‘C-x b’一样切换缓冲区：

     (switch-to-buffer (other-buffer))

符号 ‘switch-to-buffer’ 是列表的第一个元素，因此Lisp解释器将其视为一个函
数并执行与其关联的指令。但在执行之前，解释器会注意到 ‘other-buffer’ 在括
号内，并首先处理该符号。‘other-buffer’ 是此列表的第一个元素（在这种情况
下，也是唯一的元素），因此Lisp解释器调用或运行该函数。它返回另一个缓冲区
。接下来，解释器运行 ‘switch-to-buffer’，将另一个缓冲区作为参数传递给它
，这就是Emacs将要切换到的缓冲区。如果您正在Info中阅读此内容，请立即尝试
。评估此表达式。（要返回，请键入 ‘C-x b <RET>’。）(2)

   在本文档后面的编程示例中，您将更频繁地看到函数 ‘set-buffer’ 而不是
‘switch-to-buffer’。这是因为计算机程序和人类之间存在一个差异：人类有眼睛
，并期望在计算机终端上看到他们正在操作的缓冲区。这是如此明显，几乎不言而
喻。然而，程序没有眼睛。当计算机程序在缓冲区上工作时，该缓冲区不需要在屏
幕上可见。

   ‘switch-to-buffer’ 是为人类设计的，它执行两个不同的操作：它切换
Emacs关注的缓冲区，并将窗口显示的缓冲区切换到新的缓冲区。另一方面，
‘set-buffer’ 只执行一项任务：它将计算机程序的注意力切换到另一个缓冲区。
屏幕上的缓冲区保持不变（当然，通常在命令运行完成之前不会发生任何变化）。

   此外，我们刚刚介绍了另一个行话术语，即词语 “call”。当您评估一个列表，
其中第一个符号是一个函数时，您正在调用该函数。该术语的使用来自于将函数视
为如果您调用它可以为您做一些事情的实体的概念，就像水管工是一个实体，如果
您呼叫他或她，他或她可以修理漏水一样。

   ---------- Footnotes ----------

   (1) 或者更确切地说，为了节省输入，如果默认缓冲区是‘*scratch*’，你可能
只输入‘RET’，或者如果它不同，则只输入部分名称，如‘*sc’，按下‘TAB’键使其
扩展为完整名称，然后输入‘RET’。

   (2) 请记住，此表达式将将您移动到您无法看到的最近的其他缓冲区。如果您
真的想转到最近选择的缓冲区，即使您仍然可以看到它，您需要评估以下更复杂的
表达式：

     (switch-to-buffer (other-buffer (current-buffer) t))

   在这种情况下，‘other-buffer’ 的第一个参数告诉它要跳过的缓冲区（当前的
缓冲区），第二个参数告诉 ‘other-buffer’ 可以切换到可见的缓冲区。在常规用
法中，‘switch-to-buffer’将您带到窗口中不可见的缓冲区，因为您很可能使用
‘C-x o’（‘other-window’）转到另一个可见的缓冲区。


File: eintr.info,  Node: Buffer Size & Locations,  Next: Evaluation Exercise,  Prev: Switching Buffers,  Up: Practicing Evaluation

2.4 缓冲区大小和点的位置
========================

最后，让我们看一些相当简单的函数，‘buffer-size’、‘point’、‘point-min’和
‘point-max’。它们提供有关缓冲区大小和点在其中的位置的信息。

   函数‘buffer-size’告诉您当前缓冲区的大小；也就是说，该函数返回缓冲区中
字符的数量。

     (buffer-size)

您可以通过将光标放置在表达式后，并键入‘C-x C-e’来评估它。

   在Emacs中，光标的当前位置被称为“point”。表达式‘(point)’返回一个数字，
告诉您光标的位置，以字符数表示，从缓冲区开头到point的位置。

   您可以通过以通常的方式评估以下表达式来查看point在该缓冲区的字符计数：

     (point)

在我写这篇文章的时候，point的值是65724。‘point’函数在本书的一些后面的示
例中经常被使用。

   point的值当然取决于它在缓冲区内的位置。如果在这个位置评估point，数字
会更大：

     (point)

对我而言，在这个位置，point的值是66043，这意味着两个表达式之间有319个字
符（包括空格）。 （毫无疑问，由于我首次评估point后进行了编辑，你可能会看
到不同的数字。）

   函数‘point-min’与‘point’有些相似，但它返回当前缓冲区中point的最小允许
值。这个值是1，除非启用了“narrowing”。（Narrowing是一种机制，通过它，您
可以将自己或程序限制在仅对缓冲区的一部分进行操作。*Note 窄化和扩展:
Narrowing & Widening.）同样，函数‘point-max’返回当前缓冲区中point的最大
允许值。


File: eintr.info,  Node: Evaluation Exercise,  Prev: Buffer Size & Locations,  Up: Practicing Evaluation

2.5 练习
========

找到您正在使用的文件，并移动到其中间。 找到其缓冲区名称、文件名称、长度
以及您在文件中的位置。


File: eintr.info,  Node: Writing Defuns,  Next: Buffer Walk Through,  Prev: Practicing Evaluation,  Up: Top

3 如何编写函数定义
******************

当Lisp解释器评估一个列表时，它会查看列表上的第一个符号是否附有一个函数定
义；或者换句话说，该符号是否指向一个函数定义。如果是的话，计算机将执行定
义中的指令。一个具有函数定义的符号被简单地称为函数（尽管严格来说，定义是
函数，符号是它的引用）。

* Menu:

* Primitive Functions::
* defun::                        ‘defun’ 宏。
* Install::                          安装函数定义。
* Interactive::                        使函数具有交互性。
* Interactive Options::                    ‘interactive’ 的不同选项。
* Permanent Installation::                      永久安装代码。
* let::                          创建并初始化局部变量。
* if::                           如果是这样怎么办？
* else::                         If–then–else 表达式。
* Truth & Falsehood::                       Lisp认为的真和假。
* save-excursion::               跟踪点和缓冲区。
* Review::
* defun Exercises::


File: eintr.info,  Node: Primitive Functions,  Next: defun,  Up: Writing Defuns

关于原始函数的一些说明
======================

所有函数都是基于其他函数定义的，除了一些用C编写的“原始”函数。当你编写函
数定义时，你将使用Emacs Lisp编写它们，并将其他函数作为构建块。你将使用的
一些函数本身是用Emacs Lisp编写的（也许是由你编写的），而另一些是用C编写
的原语。这些原始函数的使用方式与用Emacs Lisp编写的函数完全相同，并且其行
为也相同。它们是用C编写的，以便我们可以轻松地在任何具有足够计算能力且能
够运行C的计算机上运行GNU Emacs。

   让我再强调一下：当你在Emacs Lisp中编写代码时，你不区分是使用用C编写的
函数还是使用用Emacs Lisp编写的函数。这种区别是无关紧要的。我提到这个区别
只是因为它是有趣的。实际上，除非你调查，你不会知道一个已经编写好的函数是
用Emacs Lisp还是C编写的。


File: eintr.info,  Node: defun,  Next: Install,  Prev: Primitive Functions,  Up: Writing Defuns

3.1 ‘defun’ 宏
==============

在Lisp中，像 ‘mark-whole-buffer’ 这样的符号附有与其关联的代码，告诉计算
机在调用该函数时应该执行什么操作。这段代码称为 “函数定义”，它是通过评估
以符号 ‘defun’（它是 _define function_ 的缩写）开头的Lisp表达式创建的。

   在后续的章节中，我们将查看Emacs源代码中的函数定义，比如
‘mark-whole-buffer’。在本节中，我们将描述一个简单的函数定义，以便您了解
其外观。这个函数定义使用算术运算，因为这样做可以提供一个简单的例子。有些
人不喜欢使用算术的例子；然而，如果您是这样的人，请不要绝望。在本介绍的其
余部分中，我们将几乎不涉及算术或数学的代码。例子主要涉及以某种方式涉及文
本的内容。

   一个函数定义由跟在 ‘defun’ 之后的最多五个部分组成：

  1. 应该附加函数定义的符号的名称。

  2. 将传递给函数的参数列表。如果不会传递任何参数给函数，这是一个空列表
     ，即 ‘()’。

  3. 描述函数的文档。（从技术上讲是可选的，但强烈推荐。）

  4. 可选地，一个表达式，使函数具有交互性，以便您可以通过键入 ‘M-x’，然
     后输入函数的名称来使用它；或通过输入适当的键或键组。

  5. 告诉计算机要执行的代码：函数定义的 “函数体”。

   有助于将函数定义的五个部分视为一个模板，其中为每个部分都留有槽位：

     (defun FUNCTION-NAME (ARGUMENTS...)
       "OPTIONAL-DOCUMENTATION..."
       (interactive ARGUMENT-PASSING-INFO)     ; 可选
       BODY...)

   以一个将其参数乘以7的函数为例说明。 （此示例不是交互式的。有关此信息
，请参阅*Note 使函数具有交互性: Interactive.）

     (defun multiply-by-seven (number)
       "将NUMBER乘以七。"
       (* 7 number))

   这个定义以括号和符号‘defun’开始，后跟函数的名称。

   函数名称后面是一个包含将传递给函数的参数的列表。 这个列表称为“参数列
表”。 在这个例子中，列表只有一个元素，即符号‘number’。 当使用函数时，该
符号将绑定到作为函数参数的值。

   与选择‘number’作为参数名称不同，我可以选择任何其他名称。 例如，我可以
选择单词‘multiplicand’。 我选择了单词“number”是因为它说明了此槽位所需的
值的类型； 但是我完全可以选择单词“multiplicand”来指示在函数运作中放入此
槽位的值所起的作用。 我可以称其为‘foogle’，但那是一个不好的选择，因为它
不会告诉人们它的含义。 名称的选择由程序员决定，应该选择使函数的含义清晰
的名称。

   确实，你可以为参数列表中的符号选择任何你喜欢的名称，甚至是在其他函数
中使用的符号的名称：在参数列表中使用的名称对于该特定定义是私有的。在该定
义中，该名称指的是与函数定义之外使用的同名实体不同的实体。假设在你的家庭
中你有一个绰号“矮子”；当你的家庭成员提到“矮子”时，他们指的是你。但在你的
家庭之外，比如在电影中，“矮子”这个名字指的是别人。因为参数列表中的名称对
函数定义是私有的，你可以在函数体内改变这样一个符号的值，而不会改变它在函
数外的值。这个效果类似于‘let‘表达式（*Note ‘let’: let.）。

   参数列表后面是描述函数的文档字符串。这是当你键入‘C-h f’和函数的名称时
所看到的内容。顺便说一句，当你编写这样的文档字符串时，应该将第一行写成完
整的句子，因为有些命令（比如‘apropos’）只打印多行文档字符串的第一行。此
外，如果有第二行文档字符串，不应该对其进行缩进，因为在使用‘C-h f’（
‘describe-function’）时，这样看起来很奇怪。文档字符串是可选的，但它非常
有用，几乎应该包含在你编写的每个函数中。

   该示例的第三行是函数定义的主体。 （当然，大多数函数的定义要比这个长。
）在这个函数中，主体是列表‘(* 7 number)’，它表示将NUMBER的值乘以7。（在
Emacs Lisp中，‘*’是乘法的函数，就像‘+’是加法的函数一样。）

   当你使用 ‘multiply-by-seven’ 函数时，参数 ‘number’ 会被评估为你希望使
用的实际数字。下面是展示如何使用 ‘multiply-by-seven’ 的示例；但现在不要
尝试评估它！

     (multiply-by-seven 3)

在函数定义的下一部分中指定的符号 ‘number’ 在实际使用函数时被绑定到值 3。
请注意，尽管在函数定义中 ‘number’ 处于括号中，但传递给
‘multiply-by-seven’ 函数的参数不在括号中。括号写在函数定义中，这样计算机
可以确定参数列表的结束位置和函数定义的其余部分的开始位置。

   如果你评估这个示例，很可能会收到错误消息。（试试看吧！）这是因为我们
已经写了函数定义，但还没有告诉计算机有关定义——我们还没有在Emacs中加载函
数定义。安装函数是告诉Lisp解释器函数定义的过程。安装过程在下一部分中描述
。


File: eintr.info,  Node: Install,  Next: Interactive,  Prev: defun,  Up: Writing Defuns

3.2 安装函数定义
================

如果你正在 Emacs 的 Info 中阅读本文，你可以尝试执行 ‘multiply-by-seven’
函数，首先评估函数定义，然后评估 ‘(multiply-by-seven 3)’。函数定义的副本
如下。将光标放在函数定义的最后一个括号之后，然后键入 ‘C-x C-e’。当你这样
做时，‘multiply-by-seven’ 将显示在回显区域。（这意味着当评估函数定义时，
它返回的值是定义的函数的名称。）与此同时，此操作安装了函数定义。

     (defun multiply-by-seven (number)
       "将 NUMBER 乘以七。"
       (* 7 number))

通过评估这个 ‘defun’，你刚刚在 Emacs 中安装了 ‘multiply-by-seven’。该函
数现在与 Emacs 中的其他编辑函数（如 ‘forward-word’）一样成为 Emacs 的一
部分。（‘multiply-by-seven’ 将一直保持安装状态，直到你退出 Emacs。要在每
次启动 Emacs 时自动重新加载代码，请参阅 *note 永久安装代码: Permanent
Installation.。）

* Menu:

* Effect of installation::
* Change a defun::              如何更改函数定义。


File: eintr.info,  Node: Effect of installation,  Next: Change a defun,  Up: Install

安装的效果
----------

通过评估以下示例，您可以看到安装 ‘multiply-by-seven’ 的效果。将光标放在
下面的表达式之后，然后键入 ‘C-x C-e’。数字 21 将出现在回显区域。

     (multiply-by-seven 3)

   如果您愿意，可以通过键入 ‘C-h f’（‘describe-function’）然后输入函数的
名称 ‘multiply-by-seven’ 来阅读该函数的文档。这样做时，您的屏幕上将出现
一个 ‘*Help*’ 窗口，内容如下：

     multiply-by-seven 是一个 Lisp 函数。

     (multiply-by-seven NUMBER)

     将 NUMBER 乘以七。

（要返回到屏幕上的单个窗口，请键入 ‘C-x 1’。）


File: eintr.info,  Node: Change a defun,  Prev: Effect of installation,  Up: Install

3.2.1 修改函数定义
------------------

如果你想修改 ‘multiply-by-seven’ 中的代码，只需重新编写它。要将新版本安
装到旧版本的位置，重新评估函数定义即可。这就是在Emacs中修改代码的方式，
非常简单。

   举个例子，你可以将 ‘multiply-by-seven’ 函数更改为将数字加到自身七次，
而不是将数字乘以七。它产生相同的答案，但是通过不同的路径。同时，我们将在
代码中添加一条注释；注释是Lisp解释器忽略的文本，但对人类读者可能很有用或
启发。注释是这是第二个版本。

     (defun multiply-by-seven (number)       ; 第二个版本。
       "将 NUMBER 乘以七。"
       (+ number number number number number number number))

   注释以分号 ‘;’ 开头。在Lisp中，分号后面的一行上的所有内容都是注释。行
的结尾是注释的结尾。要将注释延伸到两行或更多行，请在每一行开头加上分号。

   *Note 开始一个 ‘.emacs’ 文件: Beginning init File, 和 *note 注释:
(elisp)Comments, 了解更多关于注释的信息。

   你可以通过以与第一个函数相同的方式评估它来安装 ‘multiply-by-seven’ 函
数的这个版本：将光标放在最后一个括号后，然后输入 ‘C-x C-e’。

   总之，这就是在Emacs Lisp中编写代码的方式：编写函数；安装它；测试它；
然后进行修复或增强，并再次安装它。


File: eintr.info,  Node: Interactive,  Next: Interactive Options,  Prev: Install,  Up: Writing Defuns

3.3 使函数具有交互性
====================

通过在文档后面紧跟以特殊形式 ‘interactive’ 开头的列表，可以使函数具有交
互性。用户可以通过键入 ‘M-x’，然后键入函数名，或者通过键入其绑定的键来调
用交互式函数，例如通过键入 ‘C-n’ 调用 ‘next-line’，或者通过键入 ‘C-x h’
调用 ‘mark-whole-buffer’。

   有趣的是，当你以交互方式调用交互式函数时，返回的值不会自动显示在回显
区。这是因为通常你调用交互式函数是为了其副作用，比如按单词或行前进，而不
是为了返回的值。如果每次键入一个键时都在回显区显示返回的值，会非常分散注
意力。

* Menu:

* Interactive multiply-by-seven::  概述。
* multiply-by-seven in detail::  交互式版本。


File: eintr.info,  Node: Interactive multiply-by-seven,  Next: multiply-by-seven in detail,  Up: Interactive

交互式 ‘multiply-by-seven’，概述
--------------------------------

通过创建 ‘multiply-by-seven’ 的交互式版本，可以演示特殊形式
‘interactive’ 的使用以及在回显区域显示值的一种方式。

   以下是代码：

     (defun multiply-by-seven (number)       ; 交互式版本.
       "将 NUMBER 乘以七。"
       (interactive "p")
       (message "结果是 %d" (* 7 number)))

您可以通过将光标放置在代码后并键入 ‘C-x C-e’ 来安装此代码。函数的名称将
出现在回显区域中。然后，您可以通过键入 ‘C-u’ 和一个数字，然后键入 ‘M-x
multiply-by-seven’ 并按 <RET> 使用此代码。回显区域中将出现短语 ‘结果是
...’，后面跟着乘积。

   更一般地说，可以通过以下两种方式调用这样的函数：

  1. 通过键入包含要传递的数字的前缀参数，然后键入 ‘M-x’ 和函数的名称，如
     ‘C-u 3 M-x forward-sentence’；或者，

  2. 通过键入函数绑定的键或键序列，如 ‘C-u 3 M-e’。

刚才提到的两个示例均以相同的方式工作，将光标向前移动三个句子。 (由于
‘multiply-by-seven’ 未绑定到键，它无法用作绑定键的示例。)

   (*Note 一些按键绑定: Key Bindings, 了解如何将命令绑定到键。)

   通过键入数字键后跟一个数字，例如 ‘M-3 M-e’，或者通过键入 ‘C-u’ 然后是
一个数字，例如 ‘C-u 3 M-e’，将一个 “前缀参数” 传递给交互式函数（如果键入
‘C-u’ 而没有数字，则默认为 4）。


File: eintr.info,  Node: multiply-by-seven in detail,  Prev: Interactive multiply-by-seven,  Up: Interactive

3.3.1 交互式 ‘multiply-by-seven’ 详解
-------------------------------------

让我们看一下特殊形式 ‘interactive’ 的使用，然后再看一下
‘multiply-by-seven’ 的交互版本中的函数 ‘message’。你会记得该函数定义如下
：

     (defun multiply-by-seven (number)       ; 交互版本。
       "将 NUMBER 乘以七。"
       (interactive "p")
       (message "结果是 %d" (* 7 number)))

   在这个函数中，表达式 ‘(interactive "p")’ 是一个包含两个元素的列表。
‘"p"’ 告诉 Emacs 将前缀参数传递给函数，并将其值用作函数的参数。

   参数将是一个数字。这意味着在以下行中，符号‘number’ 将绑定到一个数字：

     (message "结果是 %d" (* 7 number))

例如，如果你的前缀参数是 5，Lisp 解释器将将该行解释为：

     (message "结果是 %d" (* 7 5))

(如果你在 GNU Emacs 中阅读此文，你可以自行评估这个表达式。)首先，解释器
将评估内部列表，即 ‘(* 7 5)’。这将返回一个值为 35。接下来，它将评估外部
列表，将列表的第二个和随后的元素的值传递给函数 ‘message’。

   正如我们所见，‘message’ 是一个专为向用户发送单行消息而设计的 Emacs
Lisp 函数。（*Note The ‘message’ function: message.）总体而言，‘message’
函数会将其第一个参数原样打印在回显区域，但会替换‘%d’ 或 ‘%s’（以及我们未
提及的其他各种 %-sequences）的出现。当它看到控制序列时，该函数会查找第二
个或随后的参数，并在字符串中的控制序列位置打印参数的值。

   在交互式 ‘multiply-by-seven’ 函数中，控制字符串是 ‘%d’，需要一个数字
，而通过评估 ‘(* 7 5)’ 返回的值是数字 35。因此，数字 35 将在 ‘%d’ 的位置
打印，消息为 ‘结果是 35’。

   （请注意，当调用函数 ‘multiply-by-seven’ 时，消息会以无引号形式打印，
但调用 ‘message’ 时，文本将以双引号形式打印。这是因为 ‘message’ 返回的值
是在评估其第一个元素为 ‘message’ 的表达式时出现在回显区域中的内容；但在
嵌入函数中时，‘message’ 以副作用的方式打印文本，没有引号。）


File: eintr.info,  Node: Interactive Options,  Next: Permanent Installation,  Prev: Interactive,  Up: Writing Defuns

3.4 ‘interactive’ 的不同选项
============================

在例子中，‘multiply-by-seven’ 使用 ‘"p"’ 作为‘interactive’ 的参数。这个
参数告诉 Emacs 解释你的输入，无论是 ‘C-u’ 后跟一个数字还是 <META> 后跟一
个数字，都是将该数字作为参数传递给函数。Emacs 预定义了超过二十个字符，可
以用于 ‘interactive’。在几乎所有情况下，这些选项之一将使你能够以交互方式
向函数传递正确的信息。(*Note ‘interactive’ 代码章节: (elisp)Interactive
Codes.)

   考虑函数 ‘zap-to-char’。它的交互表达式为

     (interactive "p\ncZap to char: ")

   ‘interactive’ 的参数的第一部分是 ‘p’，这是你已经熟悉的。这个参数告诉
Emacs 解释一个前缀，作为传递给函数的数字。你可以通过键入 ‘C-u’ 后跟一个
数字或者键入 <META> 后跟一个数字来指定前缀。前缀是指定的字符数。因此，如
果你的前缀是三，指定的字符是‘x’，那么你将删除所有文本，包括第三个 ‘x’。
如果你没有设置前缀，那么你将删除所有文本，包括指定的字符，但不包括之后的
文本。

   ‘c’ 告诉函数要删除的字符的名称。

   更正式地说，具有两个或更多参数的函数可以通过向跟随 ‘interactive’ 的字
符串添加部分来将信息传递给每个参数。当你这样做时，信息将按照它在
‘interactive’ 列表中指定的顺序传递给每个参数。在字符串中，每个部分都由一
个 ‘\n’（换行符）与下一个部分分隔开。例如，你可以在 ‘p’ 后面加上一个
‘\n’ 和一个 ‘cZap to char:’。这将导致 Emacs 传递前缀参数的值（如果有的话
）和字符。

   在这种情况下，函数定义如下，其中 ‘arg’ 和 ‘char’ 是由 ‘interactive’ 绑
定的前缀参数和指定字符：

     (defun NAME-OF-FUNCTION (arg char)
       "DOCUMENTATION..."
       (interactive "p\ncZap to char: ")
       BODY-OF-FUNCTION...)

（在提示符的冒号后加一个空格使其看起来更好。*Note 函数 ‘copy-to-buffer’
的定义: copy-to-buffer, 提供一个例子。）

   当函数不接受参数时，‘interactive’ 不需要任何参数。这样的函数包含简单
的表达式 ‘(interactive)’。‘mark-whole-buffer’ 函数就是这样的一个例子。

   或者，如果特殊的字母代码不适合你的应用程序，你可以将自己的参数作为列
表传递给 ‘interactive’。

   *Note 函数 ‘append-to-buffer’ 的定义: append-to-buffer, 提供一个例子
。*Note 使用 ‘Interactive’: (elisp)Using Interactive, 提供有关这一技术的
更完整解释。


File: eintr.info,  Node: Permanent Installation,  Next: let,  Prev: Interactive Options,  Up: Writing Defuns

3.5 永久安装代码
================

当通过评估来安装函数定义时，它将一直保持安装状态，直到退出 Emacs。下次启
动 Emacs 时，除非重新评估函数定义，否则该函数将不会安装。

   在某个时刻，您可能希望在每次启动新的 Emacs 会话时自动安装代码。有几种
方法可以实现这一点：

   • 如果您的代码只是针对您个人的，您可以将函数定义的代码放入您的
     ‘.emacs’ 初始化文件中。当您启动 Emacs 时，您的 ‘.emacs’ 文件会自动
     评估，并安装其中的所有函数定义。*Note 您的 ‘.emacs’ 文件: Emacs
     Initialization.

   • 或者，您可以将要安装的函数定义放入一个或多个单独的文件中，并使用
     ‘load’ 函数使 Emacs 评估并安装这些文件中的每个函数。*Note 加载文件:
     Loading Files.

   • 第三，如果您有整个站点都会使用的代码，通常将其放入一个名为
     ‘site-init.el’ 的文件中，在构建 Emacs 时加载该文件。这使得代码对使
     用您的计算机的每个人都可用。（请参阅 Emacs 发行版的 ‘INSTALL’ 文件
     。）

   最后，如果您的代码是每个使用 Emacs 的人都可能需要的，您可以将其发布到
计算机网络上，或将副本发送给自由软件基金会。（在执行此操作时，请使用许可
证许可代码及其文档，允许其他人运行、复制、研究、修改和重新分发代码，并保
护您免受他人夺走您的工作的风险。）如果您向自由软件基金会发送代码的副本，
并正确保护自己和其他人，它可能会包含在下一个 Emacs 发布版中。在很大程度
上，这就是 Emacs 在过去几年中发展的方式，通过捐赠。


File: eintr.info,  Node: let,  Next: if,  Prev: Permanent Installation,  Up: Writing Defuns

3.6 ‘let’
=========

‘let’表达式是Lisp中的一种特殊形式，你在大多数函数定义中都需要使用它。

   ‘let’用于以一种方式将符号绑定到值，使得Lisp解释器不会将该变量与不属于
函数的同名变量混淆。

   为了理解为什么需要‘let’特殊形式，考虑以下情况：假设你拥有一所房子，通
常将其称为“房子”，就像在句子中说：“房子需要粉刷。” 如果你正在访问朋友，
而你的主人提到“房子”，他可能是在指的是_他_的房子，而不是你的，也就是说，
是另一座房子。

   如果你的朋友正在指他的房子，而你认为他正在指你的房子，那么可能会产生
一些混乱。在Lisp中，如果在一个函数内部使用的变量与另一个函数内部使用的同
名变量相同，并且两者意图不是引用相同的值，则可能发生类似的情况。‘let’特
殊形式防止了这种混淆。

* Menu:

* Prevent confusion::
* Parts of let Expression::
* Sample let Expression::
* Uninitialized let Variables::


File: eintr.info,  Node: Prevent confusion,  Next: Parts of let Expression,  Up: let

‘let’ 避免混淆
--------------

特殊形式 ‘let’ 可以避免混淆。‘let’ 创建一个“局部变量”的名称，它会遮蔽任
何在 ‘let’ 表达式之外使用相同名称的情况。这就像理解当你的主机提到“房子
”时，他指的是他的房子，而不是你的房子一样。（在参数列表中使用的符号也是
同样的道理。*Note ‘defun’ 宏: defun.）

   由 ‘let’ 表达式创建的局部变量只在 ‘let’ 表达式本身（以及在 ‘let’ 表达
式内调用的表达式中）中保持其值；这些局部变量在 ‘let’ 表达式之外没有影响
。

   另一种理解 ‘let’ 的方式是，它就像一个临时和局部的 ‘setq’。由 ‘let’ 设
置的值在 ‘let’ 结束时会自动撤销。这个设置只影响在 ‘let’ 表达式边界内的表
达式。在计算机科学的术语中，我们会说符号的绑定仅在 ‘let’ 表单中调用的函
数中可见；在 Emacs Lisp 中，默认的作用域是动态的，而不是词法的。 （非默
认的词法绑定在本手册中未讨论。）

   ‘let’ 可以一次创建多个变量。此外，‘let’ 为它创建的每个变量都提供一个
初始值，可以是你指定的值，也可以是 ‘nil’。（在术语中，这是将变量绑定到值
。）在 ‘let’ 创建并绑定了变量之后，它会执行 ‘let’ 主体中的代码，并返回主
体中最后一个表达式的值，作为整个 ‘let’ 表达式的值。（“执行”是一个术语，
指的是评估列表；它源自“实施”一词的使用，意味着“实际生效”（‘Oxford
English Dictionary’）。由于你评估一个表达式来执行一个动作，“执行”已经演
变为“评估”的同义词。）


File: eintr.info,  Node: Parts of let Expression,  Next: Sample let Expression,  Prev: Prevent confusion,  Up: let

3.6.1 ‘let’ 表达式的组成部分
----------------------------

一个 ‘let’ 表达式包含三个部分。第一部分是符号 ‘let’。第二部分是一个列表
，称为“varlist”，其中每个元素要么是一个单独的符号，要么是一个两元素列表
，其中第一个元素是一个符号。‘let’ 表达式的第三部分是 ‘let’ 的主体。主体
通常包含一个或多个列表。

   ‘let’ 表达式的模板如下：

     (let VARLIST BODY...)

varlist 中的符号是由 ‘let’ 特殊形式给予初始值的变量。单独的符号被赋予
‘nil’ 的初始值；而每个作为两元素列表的第一个元素的符号则被绑定到 Lisp 解
释器评估第二个元素时返回的值。

   因此，varlist 可以看起来像这样：‘(thread (needles 3))’。在这种情况下
，在 ‘let’ 表达式中，Emacs 将符号 ‘thread’ 绑定到初始值 ‘nil’，并将符号
‘needles’ 绑定到初始值 3。

   当编写 ‘let’ 表达式时，你要做的是将适当的表达式放入 ‘let’ 表达式模板
的各个部分。

   如果 varlist 由两元素列表组成，这在许多情况下是常见的，那么 ‘let’ 表
达式的模板如下：

     (let ((VARIABLE VALUE)
           (VARIABLE VALUE)
           ...)
       BODY...)


File: eintr.info,  Node: Sample let Expression,  Next: Uninitialized let Variables,  Prev: Parts of let Expression,  Up: let

3.6.2 示例 ‘let’ 表达式
-----------------------

以下表达式创建并为两个变量 ‘zebra’ 和 ‘tiger’ 赋予初始值。‘let’ 表达式的
主体是一个调用 ‘message’ 函数的列表。

     (let ((zebra "条纹")
           (tiger "凶猛"))
       (message "一种动物有 %s，另一种是 %s。"
                zebra tiger))

   在这里，varlist 是 ‘((zebra "条纹") (tiger "凶猛"))’。

   这两个变量是 ‘zebra’ 和 ‘tiger’。每个变量都是两元素列表的第一个元素，
每个值都是其两元素列表的第二个元素。在 varlist 中，Emacs 将变量 ‘zebra’
绑定到值 ‘"条纹"’(1)，并将变量 ‘tiger’ 绑定到值 ‘"凶猛"’。在这个例子中，
两个值都是字符串。这些值同样可以是另一个列表或符号。‘let’ 的主体紧随包含
变量的列表之后。在这个例子中，主体是一个列表，使用 ‘message’ 函数在回显
区域打印一个字符串。

   您可以按照通常的方式评估这个示例，将光标放在最后一个括号后，然后键入
‘C-x C-e’。这样做时，回显区域将显示以下内容：

     "一种动物有条纹，另一种是凶猛。"

   正如我们之前看到的，‘message’ 函数打印其第一个参数，除了 ‘%s’。在这个
例子中，变量 ‘zebra’ 的值将打印在第一个 ‘%s’ 的位置，而变量 ‘tiger’ 的值
将打印在第二个 ‘%s’ 的位置。

   ---------- Footnotes ----------

   (1) 根据Jared Diamond在 ‘枪炮、病菌与钢铁’ 中的说法，“... 斑马在变老
时变得异常危险”，但这里的说法是它们不会像老虎一样变得凶猛。(1997, W. W.
Norton 和 Co., ISBN 0-393-03894-2, 第171页)


File: eintr.info,  Node: Uninitialized let Variables,  Prev: Sample let Expression,  Up: let

3.6.3 ‘let’ 语句中的未初始化变量
--------------------------------

如果在 ‘let’ 语句中不将变量绑定到特定的初始值，它们将自动绑定到初始值为
‘nil’，如下面的表达式所示：

     (let ((birch 3)
           pine
           fir
           (oak 'some))
       (message
        "这里有 %d 个变量，分别具有 %s、%s 和 %s 的值。"
        birch pine fir oak))

这里，变量列表是 ‘((birch 3) pine fir (oak 'some))’。

   如果以通常的方式评估此表达式，将在你的回显区域中看到以下内容：

     "这里有 3 个变量，分别具有 nil、nil 和 some 的值。"

在这个例子中，Emacs将符号 ‘birch’ 绑定到数字3，将符号 ‘pine’ 和 ‘fir’ 绑
定到 ‘nil’，并将符号 ‘oak’ 绑定到值 ‘some’。

   注意，在 ‘let’ 的第一部分中，变量 ‘pine’ 和 ‘fir’ 作为不带括号的原子
独立存在；这是因为它们被绑定到 ‘nil’，即空列表。但是，‘oak’ 被绑定到
‘some’，因此是列表 ‘(oak 'some)’ 的一部分。类似地，‘birch’ 被绑定到数字
3，因此在具有该数字的列表中。 (由于数字在评估时为自身，因此数字不需要引
用。此外，消息中使用 ‘%d’ 而不是 ‘%s’ 打印数字。) 这四个变量作为一个组被
放入列表中，以将它们与 ‘let’ 的主体分开。


File: eintr.info,  Node: if,  Next: else,  Prev: let,  Up: Writing Defuns

3.7 特殊形式 ‘if’
=================

另一种特殊形式是条件语句 ‘if’。该形式用于指导计算机进行决策。您可以编写
不使用 ‘if’ 的函数定义，但它被经常使用且足够重要，因此在这里进行介绍。例
如，在函数 ‘beginning-of-buffer’ 的代码中就使用了它。

   ‘if’ 的基本思想是，_如果_测试为真，_那么_就会评估一个表达式。如果测试
不为真，则不会评估该表达式。例如，您可能会做出这样的决定：“如果天气暖和
而且阳光明媚，那么就去海滩！”

* Menu:

* if in more detail::
* type-of-animal in detail::    一个 ‘if’ 表达式的示例。


File: eintr.info,  Node: if in more detail,  Next: type-of-animal in detail,  Up: if

‘if’详细说明
------------

在Lisp中，‘if’表达式不使用单词“then”；测试和动作是列表的第二个和第三个元
素，其第一个元素是‘if’。尽管如此，‘if’表达式的测试部分通常称为
“if-part”，第二个参数通常称为“then-part”。

   此外，当编写‘if’表达式时，通常将真假测试写在与符号‘if’相同的行上，但
如果测试为真，则执行的操作，即then-part，会写在第二行及后续行。这样可以
使‘if’表达式更易读。

     (if TRUE-OR-FALSE-TEST
         ACTION-TO-CARRY-OUT-IF-TEST-IS-TRUE)

真假测试将是由Lisp解释器评估的表达式。

   以下是一个您可以按照通常方式评估的示例。测试是数字5是否大于数字4。由
于是，将打印消息‘5 is greater than 4!’。

     (if (> 5 4)                             ; if-part
         (message "5 is greater than 4!"))   ; then-part

（函数‘>’测试其第一个参数是否大于其第二个参数，并在其为真时返回true。）

   当然，在实际使用中，‘if’ 表达式中的测试将不会像表达式 ‘(> 5 4)’ 中那
样永远固定。相反，测试中至少一个变量将被绑定到一个预先未知的值。 （如果
值在预先知道，我们就不需要运行测试了！）

   例如，该值可以绑定到函数定义的参数上。在以下函数定义中，动物的特性是
传递给函数的值。如果绑定到 ‘characteristic’ 的值是 ‘"fierce"’，则将打印
消息 ‘It is a tiger!’；否则，将返回 ‘nil’。

     (defun type-of-animal (characteristic)
       "根据 CHARACTERISTIC 在回显区打印消息。
     如果 CHARACTERISTIC 是字符串 \"fierce\"，
     则警告是一只老虎。"
       (if (equal characteristic "fierce")
           (message "It is a tiger!")))

如果您正在 GNU Emacs 中阅读此文档，您可以按照通常的方式评估函数定义以在
Emacs 中安装它，然后可以评估以下两个表达式以查看结果：

     (type-of-animal "fierce")

     (type-of-animal "striped")

当您评估 ‘(type-of-animal "fierce")’ 时，您将在回显区看到打印的以下消息
：‘"It is a tiger!"’；当您评估 ‘(type-of-animal "striped")’ 时，您将在回
显区看到打印的 ‘nil’。


File: eintr.info,  Node: type-of-animal in detail,  Prev: if in more detail,  Up: if

3.7.1 详细介绍 ‘type-of-animal’ 函数
------------------------------------

让我们详细看一下 ‘type-of-animal’ 函数。

   ‘type-of-animal’ 函数的定义是通过填充两个模板而完成的，一个用于整个函
数定义，另一个用于 ‘if’ 表达式。

   每个非交互式函数的模板如下：

     (defun NAME-OF-FUNCTION (ARGUMENT-LIST)
       "DOCUMENTATION..."
       BODY...)

   符合此模板的函数部分如下：

     (defun type-of-animal (characteristic)
       "根据 CHARACTERISTIC 在回显区域打印消息。
     如果 CHARACTERISTIC 是字符串 \"fierce\"，则警告可能是老虎。"
       BODY: THE if EXPRESSION)

   函数的名称是 ‘type-of-animal’；它接受一个参数的值。参数列表后面是多行
文档字符串。在示例中包含文档字符串是一个良好的习惯，建议为每个函数定义都
编写文档字符串。函数定义的主体由 ‘if’ 表达式组成。

   ‘if’ 表达式的模板如下：

     (if TRUE-OR-FALSE-TEST
         ACTION-TO-CARRY-OUT-IF-THE-TEST-RETURNS-TRUE)

   在 ‘type-of-animal’ 函数中，‘if’ 的代码如下：

     (if (equal characteristic "fierce")
         (message "它是一只老虎！"))

   在这里，true-or-false-test 是表达式：

     (equal characteristic "fierce")

   在 Lisp 中，‘equal’ 是一个函数，它确定其第一个参数是否等于第二个参数
。第二个参数是字符串 ‘"fierce"’，第一个参数是符号 ‘characteristic’ 的值
，换句话说，就是传递给该函数的参数。

   在 ‘type-of-animal’ 的第一个示例中，传递了参数 ‘"fierce"’。由于
‘"fierce"’ 等于 ‘"fierce"’，表达式 ‘(equal characteristic "fierce")’ 返
回 true。当发生这种情况时，‘if’ 会评估 ‘if’ 的第二个参数或 true 部分：
‘(message "它是一只老虎！")’。

   另一方面，在 ‘type-of-animal’ 的第二个示例中，传递了参数 ‘"striped"’。
‘"striped"’ 不等于 ‘"fierce"’，因此 true 部分不会被评估，‘if’ 表达式返回
‘nil’。


File: eintr.info,  Node: else,  Next: Truth & Falsehood,  Prev: if,  Up: Writing Defuns

3.8 If–then–else 表达式
=======================

一个 ‘if’ 表达式可能有一个可选的第三个参数，称为 “else-部分”，用于当真假
测试返回 false 时的情况。当这种情况发生时，整个 ‘if’ 表达式的第二个参数
或者 then-部分 _不会_ 被评估，而第三个参数或 else-部分 _会_ 被评估。你可
以将其看作是决策的“如果天气温暖且晴朗，则去海滩，否则读一本书”的多云日备
选方案。

   在Lisp代码中并没有写下单词 "else"；‘if’ 表达式的 else-部分在 then-部
分之后。在书写的Lisp中，else-部分通常写在自己的一行上，并且比 then-部分
的缩进少：

     (if 真假测试
         真时执行的动作
       假时执行的动作)

   例如，下面的 ‘if’ 表达式在通常的情况下，当你对其进行求值时，会打印消
息 ‘4不大于5！’：

     (if (> 4 5)                               ; if-部分
         (message "4 falsely greater than 5!") ; then-部分
       (message "4 is not greater than 5!"))   ; else-部分

请注意，不同缩进级别使得很容易区分 then-部分 和 else-部分。（GNU Emacs 有
几个命令可以自动正确缩进 ‘if’ 表达式。*Note GNU Emacs Helps You Type
Lists: Typing Lists.）

   我们可以通过在 ‘type-of-animal’ 函数中加入一个 else 部分来扩展它，只
需在 ‘if’ 表达式中加入一个额外的部分即可。

   如果你评估以下版本的 ‘type-of-animal’ 函数定义以安装它，然后评估两个
后续表达式，将不同的参数传递给函数，你就能看到这样做的后果。

     (defun type-of-animal (characteristic)  ; 第二个版本。
       "根据 CHARACTERISTIC 在回显区域打印消息。
     如果 CHARACTERISTIC 是字符串 \"fierce\"，
     则警告是一只老虎；否则说它不凶猛。"
       (if (equal characteristic "fierce")
           (message "这是一只老虎！")
         (message "它不凶猛！")))

     (type-of-animal "fierce")

     (type-of-animal "striped")


当你评估 ‘(type-of-animal "fierce")’ 时，你将在回显区域看到以下消息打印
出来：‘"这是一只老虎！"’；但是当你评估 ‘(type-of-animal "striped")’ 时，
你将看到 ‘"它不凶猛！"’。

   （当然，如果 CHARACTERISTIC 是 ‘"ferocious"’，则将打印消息 ‘"它不凶猛
！"’；这可能会产生误导！在编写代码时，你需要考虑到 ‘if’ 可能会测试到这样
的参数，并相应地编写你的程序。）


File: eintr.info,  Node: Truth & Falsehood,  Next: save-excursion,  Prev: else,  Up: Writing Defuns

3.9 Emacs Lisp 中的真值和假值
=============================

在 ‘if’ 表达式中，有一个重要的关于真值测试的方面。到目前为止，我们已经谈
到“true”和“false”作为谓词的值，好像它们是新种类的 Emacs Lisp 对象一样。
实际上，“false”只是我们的老朋友 ‘nil’。任何其他东西——无论什么——都是
“true”。

   对真值进行测试的表达式在解释时会被视为 “真”，如果它的求值结果不是
‘nil’。换句话说，如果返回的值是一个数字，比如 47，一个字符串，比如
‘"hello"’，或者一个符号（除了 ‘nil’ 之外的任何符号），或者一个列表（只要
它不是空的），甚至是一个缓冲区，测试的结果就被认为是真的！

* Menu:

* nil explained::               ‘nil’ 有两个含义。


File: eintr.info,  Node: nil explained,  Up: Truth & Falsehood

‘nil’的解释
-----------

在说明真值测试之前，我们需要解释一下 ‘nil’。

   在Emacs Lisp中，符号 ‘nil’ 有两个含义。首先，它表示空列表。其次，它表
示假，是在真假测试返回假时返回的值。‘nil’可以被写成空列表，‘()’，或者写
作 ‘nil’。就Lisp解释器而言，‘()’ 和 ‘nil’ 是一样的。然而，人们倾向于将
‘nil’ 用于表示假，而将 ‘()’ 用于表示空列表。

   在Emacs Lisp中，任何不是 ‘nil’，即非空列表的值，被认为是真。这意味着
如果一个求值返回了不是空列表的值，一个 ‘if’ 表达式将测试为真。例如，如果
一个数字被放在测试的槽位，它将被求值并返回它自己，因为这是数字在被求值时
所做的。在这个条件语句中，‘if’ 表达式将测试为真。该表达式仅在通过求值表
达式返回 ‘nil’，即空列表时测试为假。

   通过对以下示例中的两个表达式进行求值，您可以看到这一点。

   在第一个示例中，数字4作为 ‘if’ 表达式中的测试被求值并返回自己；因此，
表达式的then部分被求值并返回：在回显区域中显示 ‘true’。在第二个示例中，
‘nil’ 表示假；因此，表达式的else部分被求值并返回：在回显区域中显示
‘false’。

     (if 4
         'true
       'false)

     (if nil
         'true
       'false)

   顺便说一句，如果某个有用的值在返回真的测试时不可用，那么Lisp解释器将
返回符号 ‘t’ 代表真。例如，表达式 ‘(> 5 4)’ 在被求值时返回 ‘t’，您可以通
过通常的方式进行求值查看：

     (> 5 4)

另一方面，如果测试为假，则该函数返回 ‘nil’。

     (> 4 5)


File: eintr.info,  Node: save-excursion,  Next: Review,  Prev: Truth & Falsehood,  Up: Writing Defuns

3.10 ‘save-excursion’
=====================

‘save-excursion’函数是我们将在本章中讨论的最后一个特殊形式。

   在用于编辑的Emacs Lisp程序中，‘save-excursion’函数非常常见。它保存点
（point）的位置，执行函数体，然后如果点的位置发生了变化，则将点还原到其
先前的位置。其主要目的是防止用户因点的意外移动而感到惊讶和困扰。

* Menu:

* Point and mark::              各种位置的回顾。
* Template for save-excursion::


File: eintr.info,  Node: Point and mark,  Next: Template for save-excursion,  Up: save-excursion

光标位置和标记
--------------

然而，在讨论 ‘save-excursion’ 之前，首先回顾一下在 GNU Emacs 中点（
Point）和标记（Mark）的概念可能会很有用。“点” 是光标的当前位置。光标所在
的位置就是点。更准确地说，在光标位于字符之上的终端上，点位于紧接在字符之
前。在 Emacs Lisp 中，点是一个整数。缓冲区中的第一个字符是编号为一，第二
个是编号为二，依此类推。函数 ‘point’ 返回光标的当前位置作为一个数字。每
个缓冲区都有其自己的点值。

   “标记” 是缓冲区中的另一个位置；它的值可以通过诸如 ‘C-<SPC>’（
‘set-mark-command’）的命令设置。如果已经设置了标记，可以使用命令 ‘C-x
C-x’（‘exchange-point-and-mark’）使光标跳到标记位置，并将标记设置为点的
先前位置。此外，如果设置了另一个标记，前一个标记的位置将保存在标记环中。
可以通过键入 ‘C-u C-<SPC>’ 一次或多次将光标跳到保存的标记位置。

   点和标记之间的缓冲区部分称为“区域”。许多命令在区域上起作用，包括
‘center-region’、‘count-words-region’、‘kill-region’ 和 ‘print-region’。

   ‘save-excursion’ 特殊形式保存点的位置，并在该特殊形式的主体内的代码被
Lisp 解释器评估后恢复这个位置。因此，如果点在文本的开头，某些代码将点移
到缓冲区的末尾，‘save-excursion’ 将在函数主体中的表达式被评估后将点放回
到它之前的位置。

   在 Emacs 中，一个函数通常会在其内部工作的过程中移动点，尽管用户不希望
这样。例如，‘count-words-region’ 会移动点。为了防止用户受到既意外又（从
用户的角度）不必要的跳跃的困扰，通常使用 ‘save-excursion’ 来保持点在用户
预期的位置上。使用 ‘save-excursion’ 是良好的编码风格。

   为了确保代码书写规范，‘save-excursion’ 即使在其内部代码发生错误时也会
恢复点的值（或者更准确地说，“在异常退出的情况下”）。这个特性非常有帮助。

   除了记录点的值，‘save-excursion’ 还跟踪当前缓冲区，并在需要时进行恢复
。这意味着你可以编写改变缓冲区的代码，并通过 ‘save-excursion’ 切换回原始
缓冲区。这就是 ‘save-excursion’ 在 ‘append-to-buffer’ 中的使用方式。
(*Note ‘append-to-buffer’ 的定义: append-to-buffer.)


File: eintr.info,  Node: Template for save-excursion,  Prev: Point and mark,  Up: save-excursion

3.10.1 ‘save-excursion’ 表达式的模板
------------------------------------

使用 ‘save-excursion’ 的代码模板很简单：

     (save-excursion
       BODY...)

函数体是一个或多个表达式，它们将按顺序由Lisp解释器求值。如果在函数体中有
多个表达式，则最后一个表达式的值将作为 ‘save-excursion’ 函数的返回值。函
数体中的其他表达式仅用于它们的副作用；而 ‘save-excursion’ 本身仅用于其副
作用（即还原point的位置）。

   更详细地说，‘save-excursion’ 表达式的模板如下：

     (save-excursion
       函数体中的第一个表达式
       函数体中的第二个表达式
       函数体中的第三个表达式
        ...
       函数体中的最后一个表达式)

一个表达式当然可以是一个独立的符号或一个列表。

   在Emacs Lisp代码中，‘save-excursion’ 表达式经常出现在 ‘let’ 表达式的
体内。它的形式如下：

     (let 变量列表
       (save-excursion
         函数体...))


File: eintr.info,  Node: Review,  Next: defun Exercises,  Prev: save-excursion,  Up: Writing Defuns

3.11 复习
=========

在过去的几章中，我们介绍了一个宏和相当多的函数和特殊形式。这里对它们进行
简要描述，以及一些尚未提到的类似函数。

‘eval-last-sexp’
     评估光标前的最后一个符号表达式。除非在调用该函数时使用参数，否则该
     值将打印在回显区域；在这种情况下，输出将打印在当前缓冲区中。通常，
     此命令绑定到 ‘C-x C-e’。

‘defun’
     定义函数。此宏最多有五个部分：名称、传递给函数的参数的模板、文档、
     可选的交互声明和定义的主体。

     例如，在Emacs中，‘dired-unmark-all-marks’ 的函数定义如下。

          (defun dired-unmark-all-marks ()
            "从Dired缓冲区中的所有文件中删除所有标记。"
            (interactive)
            (dired-unmark-all-files ?\r))

‘interactive’
     声明函数可交互使用。此特殊形式后面可能跟着一个包含一个或多个部分的
     字符串，将信息传递给函数的参数，按顺序。这些部分还可以告诉解释器提
     示信息。字符串的各部分由新行，即 ‘\n’ 分隔。

     常见的代码字符包括：

     ‘b’
          现有缓冲区的名称。

     ‘f’
          现有文件的名称。

     ‘p’
          数值前缀参数。（注意，此处的 ‘p’ 是小写。）

     ‘r’
          光标和标记，作为两个数值参数，从最小到最大。这是唯一指定两个连
          续参数而不是一个参数的代码字母。

     *Note 用于 ‘interactive’ 的代码字符: (elisp)Interactive Codes, 以获
     取完整的代码字符列表。

‘let’
     声明一个变量列表，用于在‘let’体内使用，并给它们一个初始值，可以是
     ‘nil’或指定的值；然后评估‘let’体内的其余表达式，并返回最后一个表达
     式的值。在‘let’体内，Lisp解释器看不到与外部绑定的同名变量的值。

     例如，

          (let ((foo (buffer-name))
                (bar (buffer-size)))
            (message
             "当前缓冲区是 %s，包含 %d 个字符。"
             foo bar))

‘save-excursion’
     在评估此特殊形式的体之前，记录point和当前缓冲区的值。在评估完体后，
     恢复point和缓冲区的值。

     例如，

          (message "我们已经在这个缓冲区中 %d 个字符。"
                   (- (point)
                      (save-excursion
                        (goto-char (point-min)) (point))))

‘if’
     评估函数的第一个参数；如果为真，则评估第二个参数；否则，如果存在第
     三个参数，则评估第三个参数。

     ‘if’特殊形式被称为“条件语句”。Emacs Lisp中还有其他条件语句，但
     ‘if’可能是最常用的。

     例如，

          (if (= 22 emacs-major-version)
              (message "这是22版的Emacs")
            (message "这不是22版的Emacs"))

‘<’
‘>’
‘<=’
‘>=’
     ‘<’函数测试其第一个参数是否小于第二个参数。相应的函数‘>’测试第一个
     参数是否大于第二个参数。类似地，‘<=’测试第一个参数是否小于或等于第
     二个参数，而‘>=’测试第一个参数是否大于或等于第二个参数。在所有情况
     下，两个参数必须是数字或标记（标记表示缓冲区中的位置）。

‘=’
     ‘=’函数测试两个参数是否相等，这两个参数都必须是数字或标记。

‘equal’
‘eq’
     测试两个对象是否相同。‘equal’使用“相同”一词的一种含义，而‘eq’使用另
     一种含义：如果两个对象具有相似的结构和内容，例如同一本书的两个副本
     ，则‘equal’返回真。另一方面，‘eq’返回真，如果两个参数实际上是同一个
     对象。

‘string<’
‘string-lessp’
‘string=’
‘string-equal’
     ‘string-lessp’函数测试其第一个参数是否小于第二个参数。同样功能的较
     短名称（‘defalias’）是‘string<’。

     ‘string-lessp’的参数必须是字符串或符号；排序是词法的，因此大小写是
     敏感的。使用符号的打印名称而不是符号本身。

     空字符串，即‘""’，即不包含字符的字符串，小于任何包含字符的字符串。

     ‘string-equal’提供相应的相等测试。它的较短名称是‘string=’。没有与
     >，‘>=’或‘<=’相对应的字符串测试函数。

‘message’
     在回显区域打印消息。第一个参数是一个字符串，可以包含‘%s’，‘%d’或
     ‘%c’，用于打印紧随其后的参数的值。由‘%s’使用的参数必须是字符串或符
     号；由‘%d’使用的参数必须是数字。由‘%c’使用的参数必须是ASCII代码数字
     ；它将被打印为具有该ASCII代码的字符。 （其他各种未提到的%-序列未在
     此提及。）

‘setq’
‘set’
     ‘setq’特殊形式将其第一个参数的值设置为第二个参数的值。第一个参数由
     ‘setq’自动引用。它对后续的参数对执行相同的操作。另一个函数‘set’只接
     受两个参数，并在设置其第一个参数返回的值之前评估两个参数。

‘buffer-name’
     没有参数时，返回缓冲区的名称，作为字符串。

‘buffer-file-name’
     没有参数时，返回缓冲区正在访问的文件的名称。

‘current-buffer’
     返回Emacs处于活动状态的缓冲区；它可能不是屏幕上可见的缓冲区。

‘other-buffer’
     返回最近选择的缓冲区（不包括作为参数传递给‘other-buffer’的缓冲区和
     当前缓冲区）。

‘switch-to-buffer’
     选择Emacs处于活动状态并在当前窗口中显示的缓冲区，以便用户可以查看它
     。通常绑定到‘C-x b’。

‘set-buffer’
     切换Emacs的注意力到将运行程序的缓冲区。不更改窗口显示的内容。

‘buffer-size’
     返回当前缓冲区中字符的数量。

‘point’
     返回光标当前位置的值，作为从缓冲区开头计算的整数字符数。

‘point-min’
     返回当前缓冲区中point的最小允许值。除非限制了缩小，否则为1。

‘point-max’
     返回当前缓冲区中point的最大允许值。除非限制了缩小，否则为缓冲区的末
     尾。


File: eintr.info,  Node: defun Exercises,  Prev: Review,  Up: Writing Defuns

3.12 练习
=========

   • 编写一个非交互式函数，它将其参数（一个数字）的值加倍。将该函数设为
     交互式。

   • 编写一个函数，检查当前的‘fill-column’值是否大于传递给函数的参数，如
     果是，则打印相应的消息。


File: eintr.info,  Node: Buffer Walk Through,  Next: More Complex,  Prev: Writing Defuns,  Up: Top

4 几个与缓冲区相关的函数
************************

在这一章中，我们详细研究了GNU Emacs中使用的几个函数。这被称为“步进演示
”。这些函数被用作Lisp代码的示例，但它们并不是虚构的例子；除了第一个简化
的函数定义之外，这些函数展示了GNU Emacs中实际使用的代码。你可以从这些定
义中学到很多东西。这里描述的函数都与缓冲区有关。稍后，我们将研究其他函数
。

* Menu:

* Finding More::                  如何查找更多信息。
* simplified-beginning-of-buffer::  展示了 ‘goto-char’、
                                  ‘point-min’ 和 ‘push-mark’。
* mark-whole-buffer::             几乎与 ‘beginning-of-buffer’ 相同。
* append-to-buffer::              使用 ‘save-excursion’ 和
                                  ‘insert-buffer-substring’。
* Buffer Related Review::                  回顾。
* Buffer Exercises::


File: eintr.info,  Node: Finding More,  Next: simplified-beginning-of-buffer,  Up: Buffer Walk Through

4.1 查找更多信息
================

在这个步骤中，我将在遇到新函数时逐一描述它，有时详细介绍，有时简要说明。
如果你感兴趣，你可以随时通过输入‘C-h f’，然后输入函数的名称（然后按
<RET>）获取任何Emacs Lisp函数的完整文档。类似地，你可以通过输入‘C-h v’，
然后输入变量的名称（然后按<RET>）获取变量的完整文档。

   此外，‘describe-function’还会告诉你函数定义的位置。

   将光标放在包含函数的文件名上，然后按<RET>键。在这种情况下，<RET>意味
着‘push-button’，而不是“return”或“enter”。Emacs将直接跳转到函数定义处。

   更一般地说，如果你想在原始源文件中查看函数，你可以使用
‘xref-find-definitions’函数跳转到它。‘xref-find-definitions’适用于各种语
言，不仅限于Lisp和C，它还适用于非编程文本。例如，
‘xref-find-definitions’将跳转到本文档的Texinfo源文件的各个节点（前提是你
已经运行‘etags’实用程序记录了Emacs附带手册中的所有节点；*note
(emacs)Create Tags Table::）。

   要使用‘xref-find-definitions’命令，输入‘M-.’（即，按住<META>键的同时
按下句点键，或者按<ESC>键，然后输入句点键），然后在提示符处输入你想要查
看源代码的函数的名称，比如‘mark-whole-buffer’，然后输入<RET>。 （如果命
令没有提示，带一个参数调用它：‘C-u M-.’；*note Interactive Options::。）
Emacs将切换缓冲区并在屏幕上显示函数的源代码(1)。要切换回当前缓冲区，输入
‘M-,’或‘C-x b <RET>’。（在某些键盘上，<META>键标记为<ALT>。）

   顺便说一下，包含Lisp代码的文件通常被称为“库”。这个比喻来源于专业图书
馆的概念，比如法律图书馆或工程图书馆，而不是普通图书馆。每个库或文件都包
含与特定主题或活动相关的函数，比如处理缩写和其他输入快捷方式的
‘abbrev.el’，以及用于帮助的‘help.el’。（有时，多个库提供单个活动的代码，
就像各种‘rmail...’文件提供阅读电子邮件的代码一样。）在‘The GNU Emacs
Manual’中，你会看到类似“‘C-h p’命令允许你按主题关键字搜索标准的Emacs
Lisp库。”的句子。

   ---------- Footnotes ----------

   (1) 如果Emacs不是显示Lisp函数的源代码，而是询问你要访问哪个标签表，请
在其主要模式为Emacs Lisp或Lisp Interaction的缓冲区中调用‘M-.’。


File: eintr.info,  Node: simplified-beginning-of-buffer,  Next: mark-whole-buffer,  Prev: Finding More,  Up: Buffer Walk Through

4.2 一个简化的 ‘beginning-of-buffer’ 定义
=========================================

‘beginning-of-buffer’ 命令是一个很好的起点函数，因为你可能熟悉它，并且它
易于理解。作为交互式命令使用时，‘beginning-of-buffer’ 将光标移动到缓冲区
的开头，同时在先前的位置留下标记。通常绑定到 ‘M-<’。

   在这一节中，我们将讨论该函数的一个简化版本，展示它最常用的形式。这个
简化的函数按原样工作，但不包含复杂选项的代码。在另一节中，我们将描述整个
函数。(*Note ‘beginning-of-buffer’ 的完整定义: beginning-of-buffer.)

   在查看代码之前，让我们考虑函数定义必须包含的内容：必须包括一个使函数
可交互的表达式，以便通过键入 ‘M-x beginning-of-buffer’ 或键入键序（如
‘M-<’）来调用它；必须包括代码以在缓冲区中原始位置留下一个标记；必须包括
将光标移动到缓冲区开头的代码。

   以下是该函数简化版本的完整文本：

     (defun simplified-beginning-of-buffer ()
       "将光标移动到缓冲区开头；在先前位置留下标记。"
       (interactive)
       (push-mark)
       (goto-char (point-min)))

   与所有函数定义一样，此定义在宏 ‘defun’ 之后有五个部分：

  1. 名称：在这个例子中是 ‘simplified-beginning-of-buffer’。

  2. 参数列表：在这个例子中是一个空列表，‘()’。

  3. 文档字符串。

  4. 交互表达式。

  5. 主体。

在此函数定义中，参数列表为空，这意味着此函数不需要任何参数。 （当我们查
看完整函数定义时，我们将看到它可以传递一个可选参数。）

   交互式表达式告诉Emacs该函数旨在以交互方式使用。在这个例子中，
‘interactive’ 没有参数，因为 ‘simplified-beginning-of-buffer’ 不需要参数
。

   函数的主体包括两行：

     (push-mark)
     (goto-char (point-min))

   这些行中的第一行是表达式 ‘(push-mark)’。当Lisp解释器评估此表达式时，
它在光标当前位置设置一个标记，无论光标在哪里。该标记的位置保存在标记环中
。

   接下来的一行是 ‘(goto-char (point-min))’。此表达式将光标跳到缓冲区的
最小点，即缓冲区的开头（如果缩小了，则是缓冲区的可访问部分的开头。*Note
缩小和扩大: Narrowing & Widening.)

   ‘push-mark’ 命令在光标被 ‘(goto-char (point-min))’ 表达式移动到缓冲区
开头之前的位置设置一个标记。因此，如果愿意，可以通过键入 ‘C-x C-x’ 返回
到最初的位置。

   这就是整个函数定义的全部内容！

   当阅读这样的代码并遇到不熟悉的函数时，比如 ‘goto-char’，可以使用
‘describe-function’ 命令了解它的作用。要使用此命令，输入 ‘C-h f’，然后输
入函数的名称并按 <RET>。‘describe-function’ 命令将在 ‘*Help*’ 窗口中打印
函数的文档字符串。例如，‘goto-char’ 的文档如下：

     将点设置为 POSITION，一个数字或标记。
     缓冲区的开头是位置 (point-min)，结束是 (point-max)。

函数的一个参数是所需的位置。

（对于 ‘describe-function’ 的提示将提供光标下或之前的符号，因此您可以通
过将光标直接定位到函数上方或之后，然后键入 ‘C-h f <RET>’ 以节省输入。）

   ‘end-of-buffer’ 函数定义与 ‘beginning-of-buffer’ 定义的方式相同，只是
函数的主体包含 ‘(goto-char (point-max))’ 表达式，而不是 ‘(goto-char
(point-min))’。


File: eintr.info,  Node: mark-whole-buffer,  Next: append-to-buffer,  Prev: simplified-beginning-of-buffer,  Up: Buffer Walk Through

4.3 定义 ‘mark-whole-buffer’
============================

‘mark-whole-buffer’ 函数的理解并不比 ‘simplified-beginning-of-buffer’ 函
数更难。然而，在这种情况下，我们将看一下完整的函数，而不是缩短版本。

   ‘mark-whole-buffer’ 函数并不像 ‘beginning-of-buffer’ 函数那样常用，但
仍然很有用：它通过将点放在开头并在缓冲区末尾放置标记来标记整个缓冲区作为
一个区域。通常绑定到 ‘C-x h’。

* Menu:

* mark-whole-buffer overview::
* Body of mark-whole-buffer::   只有三行代码。


File: eintr.info,  Node: mark-whole-buffer overview,  Next: Body of mark-whole-buffer,  Up: mark-whole-buffer

‘mark-whole-buffer’ 概述
------------------------

在GNU Emacs 22中，完整函数的代码如下：

     (defun mark-whole-buffer ()
       "将点放在缓冲区的开头，将标记放在缓冲区的末尾。
     在Lisp程序中，您可能不应该使用此函数；
     让Lisp函数使用使用或设置标记的任何子例程通常是一个错误。"
       (interactive)
       (push-mark (point))
       (push-mark (point-max) nil t)
       (goto-char (point-min)))

   与所有其他函数一样，‘mark-whole-buffer’ 函数符合函数定义的模板。模板
如下：

     (defun NAME-OF-FUNCTION (ARGUMENT-LIST)
       "DOCUMENTATION..."
       (INTERACTIVE-EXPRESSION...)
       BODY...)

   函数的名称是 ‘mark-whole-buffer’；后面是一个空的参数列表，‘()’ 表示函
数不需要参数。接下来是文档。

   下一行是一个 ‘(interactive)’ 表达式，告诉Emacs该函数将以交互方式使用
。这些细节类似于前一节中描述的 ‘simplified-beginning-of-buffer’ 函数。


File: eintr.info,  Node: Body of mark-whole-buffer,  Prev: mark-whole-buffer overview,  Up: mark-whole-buffer

4.3.1 ‘mark-whole-buffer’ 函数体
--------------------------------

‘mark-whole-buffer’ 函数的主体由三行代码组成：

     (push-mark (point))
     (push-mark (point-max) nil t)
     (goto-char (point-min))

   这些行中的第一行是表达式 ‘(push-mark (point))’。

   这行与 ‘simplified-beginning-of-buffer’ 函数体的第一行 ‘(push-mark)’
完全相同。在这两种情况下，Lisp解释器在光标的当前位置设置一个标记。

   我不知道为什么 ‘mark-whole-buffer’ 中的表达式写为 ‘(push-mark
(point))’，而在 ‘beginning-of-buffer’ 中的表达式写为 ‘(push-mark)’。也许
编写代码的人不知道 ‘push-mark’ 的参数是可选的，如果 ‘push-mark’ 没有传递
参数，该函数默认会在点的位置自动设置标记。或者也许该表达式是为了与下一行
的结构相呼应而写的。无论如何，这行使Emacs确定点的位置并在那里设置一个标
记。

   在GNU Emacs的早期版本中，‘mark-whole-buffer’ 的下一行是 ‘(push-mark
(point-max))’。此表达式在缓冲区中具有最大编号的地方设置一个标记。这将是
缓冲区的末尾（或者，如果缓冲区被缩小，缓冲区的可访问部分的末尾。有关缩小
的更多信息，请参见 *Note Narrowing and Widening: Narrowing & Widening.）
设置了此标记后，前一个标记（在点处设置的标记）不再设置，但Emacs记住了其
位置，就像始终记住所有其他最近的标记一样。这意味着您可以通过键入 ‘C-u
C-<SPC>’ 两次返回到该位置，如果您愿意的话。

   在GNU Emacs 22中，‘(point-max)’ 稍微复杂一些。该行读取

     (push-mark (point-max) nil t)

该表达式几乎与之前相同。它在缓冲区中具有最大编号的位置设置一个标记。然而
，在此版本中，‘push-mark’ 有两个额外的参数。‘push-mark’ 的第二个参数是
‘nil’。这告诉函数在推送标记时应显示一个消息，该消息说“标记已设置”。第三
个参数是 ‘t’。这告诉 ‘push-mark’ 在启用瞬时标记模式时激活标记。瞬时标记
模式突出显示当前活动的区域。通常情况下会关闭它。

   最后，函数的最后一行是 ‘(goto-char (point-min)))’。这与
‘beginning-of-buffer’ 中写得一样。该表达式将光标移动到缓冲区的最小点，即
缓冲区的开头（或者可访问部分的开头）。因此，点被放置在缓冲区的开头，标记
被设置在缓冲区的末尾。整个缓冲区因此成为了一个区域。


File: eintr.info,  Node: append-to-buffer,  Next: Buffer Related Review,  Prev: mark-whole-buffer,  Up: Buffer Walk Through

4.4 ‘append-to-buffer’的定义
============================

‘append-to-buffer’命令比‘mark-whole-buffer’命令更复杂。其功能是将当前缓
冲区中点和标记之间的区域复制到指定的缓冲区。

* Menu:

* append-to-buffer overview::
* append interactive::          由两部分交互式表达式组成。
* append-to-buffer body::       包含‘let’表达式。
* append save-excursion::       ‘save-excursion’的工作原理。


File: eintr.info,  Node: append-to-buffer overview,  Next: append interactive,  Up: append-to-buffer

‘append-to-buffer’的概述
------------------------

‘append-to-buffer’命令使用‘insert-buffer-substring’函数来复制区域。
‘insert-buffer-substring’的名称已经解释了它的功能：它从一个缓冲区中取出
子字符串，然后插入到另一个缓冲区中。

   大部分‘append-to-buffer’涉及设置‘insert-buffer-substring’工作条件：代
码必须指定文本将进入的缓冲区，它来自的窗口以及它要去的窗口，以及将被复制
的区域。

   下面是该函数的可能实现：

     (defun append-to-buffer (buffer start end)
       "将区域的文本附加到指定缓冲区。
     它插入到该缓冲区的点之前。

     在从程序调用时，提供三个参数：
     BUFFER（或缓冲区名称），START和END。
     START和END指定要复制的当前缓冲区的部分。"
       (interactive
        (list (read-buffer "追加到缓冲区：" (other-buffer
                                                 (current-buffer) t))
              (region-beginning) (region-end)))
       (let ((oldbuf (current-buffer)))
         (save-excursion
           (let* ((append-to (get-buffer-create buffer))
                  (windows (get-buffer-window-list append-to t t))
                  point)
             (set-buffer append-to)
             (setq point (point))
             (barf-if-buffer-read-only)
             (insert-buffer-substring oldbuf start end)
             (dolist (window windows)
               (when (= (window-point window) point)
                 (set-window-point window (point))))))))

   通过查看该函数，可以理解它是一系列填充模板。

   最外层模板是函数定义。在这个函数中，它看起来像这样（填充了几个槽）：

     (defun append-to-buffer (buffer start end)
       "文档..."
       (interactive ...)
       主体...)

   函数的第一行包括其名称和三个参数。这些参数是文本将要复制到的
‘buffer’，以及将要复制的当前缓冲区的‘start’和‘end’。

   函数的下一部分是文档，非常清晰而完整。按照惯例，这三个参数以大写字母
写入，以便您轻松注意到它们。更好的是，它们按照参数列表中的顺序进行描述。

   请注意文档区分了缓冲区和其名称。（该函数可以处理任何一种。）


File: eintr.info,  Node: append interactive,  Next: append-to-buffer body,  Prev: append-to-buffer overview,  Up: append-to-buffer

4.4.1 ‘append-to-buffer’ 交互式表达式
-------------------------------------

由于 ‘append-to-buffer’ 函数将被交互使用，该函数必须具有一个
‘interactive’ 表达式。 (有关 ‘interactive’ 的详细信息，请参阅 *note
使函数具有交互性: Interactive.。)

   表达式如下：

     (interactive
      (list (read-buffer
             "追加到缓冲区: "
             (other-buffer (current-buffer) t))
            (region-beginning)
            (region-end)))

该表达式不是一个字母代表部分的表达式，如前所述。相反，它以这些部分开始一
个列表：

   列表的第一部分是一个表达式，用于读取缓冲区的名称并将其作为字符串返回
。那就是 ‘read-buffer’。该函数需要一个提示作为其第一个参数，即 ‘"追加到
缓冲区: "’。其第二个参数告诉命令如果不指定任何值，应提供什么值。

   在这种情况下，第二个参数是一个包含函数 ‘other-buffer’、一个异常和 ‘t’
的表达式，表示为真。

   ‘other-buffer’ 的第一个参数是异常，是另一个函数 ‘current-buffer’。这
不会被返回。第二个参数是真的符号，即 ‘t’。这告诉 ‘other-buffer’ 它可以显
示可见缓冲区（在这种情况下，它将不显示当前缓冲区，这是有道理的）。

   表达式如下：

     (other-buffer (current-buffer) t)

   ‘list’ 表达式的第二个和第三个参数是 ‘(region-beginning)’ 和
‘(region-end)’。这两个函数指定要追加的文本的开头和结尾。

   最初，该命令使用字母 ‘B’ 和 ‘r’。整个 ‘interactive’ 表达式如下：

     (interactive "B追加到缓冲区: \nr")

但是当这样做时，切换到的缓冲区的默认值变为不可见。这是不想要的。

   （提示与第二个参数之间用换行符 ‘\n’ 分隔。它后面跟着一个 ‘r’，告诉
Emacs 将跟随函数参数列表中 ‘buffer’ 符号后面的两个参数（即 ‘start’ 和
‘end’）绑定到点和标记的值。这个参数运行良好。）


File: eintr.info,  Node: append-to-buffer body,  Next: append save-excursion,  Prev: append interactive,  Up: append-to-buffer

4.4.2 ‘append-to-buffer’ 函数体
-------------------------------

‘append-to-buffer’ 函数的体部分以 ‘let’ 开始。

   正如我们之前所见 (*note ‘let’: let.)，‘let’ 表达式的目的是在 ‘let’ 的
体内创建并给予一个或多个变量初始值。这意味着这样的变量不会与 ‘let’ 表达
式外部同名的任何变量混淆。

   通过以下提纲展示了 ‘append-to-buffer’ 函数的模板，其中包含 ‘let’ 表达
式：

     (defun append-to-buffer (buffer start end)
       "DOCUMENTATION..."
       (interactive ...)
       (let ((VARIABLE VALUE))
             BODY...))

   ‘let’ 表达式包含三个元素：

  1. 符号 ‘let’；

  2. 一个 varlist，包含一个两元素列表，即 ‘(VARIABLE VALUE)’；

  3. ‘let’ 表达式的体部分。

   在 ‘append-to-buffer’ 函数中，varlist 的样式如下：

     (oldbuf (current-buffer))

在 ‘let’ 表达式的这部分中，唯一的变量 ‘oldbuf’ 被绑定到
‘(current-buffer)’ 表达式返回的值。这个变量 ‘oldbuf’ 用于跟踪你正在操作
的缓冲区，并从中复制。

   varlist 的元素或元素组被一对括号括起，以便 Lisp 解释器能够区分
varlist 和 ‘let’ 的体部分。因此，varlist 中的两元素列表被一对括号包围。
这一行看起来像这样：

     (let ((oldbuf (current-buffer)))
       ... )

在 ‘oldbuf’ 之前的两个括号可能会让你感到惊讶，如果你没有意识到 ‘oldbuf’
之前的第一个括号标记了 varlist 的边界，而第二个括号标记了两元素列表
‘(oldbuf (current-buffer))’ 的开始。


File: eintr.info,  Node: append save-excursion,  Prev: append-to-buffer body,  Up: append-to-buffer

4.4.3 ‘save-excursion’ 在 ‘append-to-buffer’ 中的应用
-----------------------------------------------------

在 ‘append-to-buffer’ 中的 ‘let’ 表达式的主体由一个 ‘save-excursion’ 表
达式组成。

   ‘save-excursion’ 函数保存 point 的位置，并在 ‘save-excursion’ 主体表
达式执行完成后将其恢复到该位置。此外，‘save-excursion’ 还跟踪原始缓冲区
并将其恢复，这就是在 ‘append-to-buffer’ 中使用 ‘save-excursion’ 的方式。

   顺便提一下，值得注意的是，Lisp 函数通常格式化为多行展开的形式，其中所
有被包裹在多行展开的内容都比第一个符号缩进得更多。在这个函数定义中，
‘let’ 的缩进比 ‘defun’ 大，而 ‘save-excursion’ 的缩进比 ‘let’ 大，就像这
样：

     (defun ...
       ...
       ...
       (let...
         (save-excursion
           ...

这种格式约定使得很容易看到 ‘save-excursion’ 主体中的行是由与
‘save-excursion’ 相关的括号括起来的，就像 ‘save-excursion’ 本身由与
‘let’ 相关的括号括起来一样：

     (let ((oldbuf (current-buffer)))
       (save-excursion
         ...
         (set-buffer ...)
         (insert-buffer-substring oldbuf start end)
         ...))

   使用 ‘save-excursion’ 函数的方式可以看作是填充模板的过程：

     (save-excursion
       主体中的第一个表达式
       主体中的第二个表达式
        ...
       主体中的最后一个表达式)

在这个函数中，‘save-excursion’ 的主体只包含一个表达式，即 ‘let*’ 表达式
。你已经了解了 ‘let’ 函数，而 ‘let*’ 函数则不同。它允许 Emacs 按顺序设置
varlist 中的每个变量，依次设置在 varlist 较早部分设置的变量的值，以便
varlist 较后部分的变量可以使用 varlist 较早部分设置的值。

   观察 ‘append-to-buffer’ 中的 ‘let*’ 表达式：

     (let* ((append-to (get-buffer-create buffer))
            (windows (get-buffer-window-list append-to t t))
            point)
       BODY...)

我们可以看到，‘append-to’ 被绑定到由 ‘(get-buffer-create buffer)’ 返回的
值上。在下一行，‘append-to’ 作为参数传递给了 ‘get-buffer-window-list’；
这在 ‘let’ 表达式中是不可能的。注意，‘point’ 被自动绑定为 ‘nil’，就像在
‘let’ 语句中一样。

   现在让我们专注于 ‘let*’ 表达式的主体中的 ‘set-buffer’ 和
‘insert-buffer-substring’ 函数。

   在旧版本中，‘set-buffer’ 表达式是简单的

     (set-buffer (get-buffer-create buffer))

但现在它是

     (set-buffer append-to)

这是因为 ‘append-to’ 在 ‘let*’ 表达式中先绑定到了 ‘(get-buffer-create
buffer)’ 的值上。

   ‘append-to-buffer’ 函数定义将文本从当前缓冲区插入到一个命名的缓冲区中
。巧合的是，‘insert-buffer-substring’ 恰好相反——它从另一个缓冲区复制文本
到当前缓冲区——这就是为什么 ‘append-to-buffer’ 定义以一个 ‘let’ 开始的原
因，该 ‘let’ 将本地符号 ‘oldbuf’ 绑定到在执行 ‘append-to-buffer’ 命令时
的 ‘current-buffer’ 的值上。

   ‘insert-buffer-substring’ 表达式看起来像这样：

     (insert-buffer-substring oldbuf start end)

‘insert-buffer-substring’ 函数将一个字符串从其第一个参数指定的缓冲区中复
制并插入到当前缓冲区。在这种情况下，‘insert-buffer-substring’ 的参数是由
‘let’ 创建并绑定的变量的值，即 ‘oldbuf’ 的值，这是在给出
‘append-to-buffer’ 命令时的当前缓冲区。

   在 ‘insert-buffer-substring’ 完成其工作后，‘save-excursion’ 将恢复操
作到原始缓冲区，而 ‘append-to-buffer’ 将完成其工作。

   以骨架形式编写，主体的工作看起来像这样：

     (let (将-current-buffer的值绑定到-oldbuf)
       (save-excursion                       ; 跟踪缓冲区。
         更改缓冲区
         从-oldbuf中插入子串到缓冲区)

       完成时切换回原始缓冲区
       完成时使-oldbuf的局部含义消失

   总之，‘append-to-buffer’ 的工作方式如下：它保存了当前缓冲区的值在名为
‘oldbuf’ 的变量中。它获取新的缓冲区（如果需要，创建一个），并将 Emacs 的
注意力切换到它。使用 ‘oldbuf’ 的值，它将来自旧缓冲区的文本区域插入新缓冲
区；然后使用 ‘save-excursion’，它将你带回原始缓冲区。

   通过查看 ‘append-to-buffer’，你已经探索了一个相当复杂的函数。它展示了
如何使用 ‘let’、‘save-excursion’ 以及如何在不同缓冲区之间切换和返回的方
法。许多函数定义都以这种方式使用 ‘let’、‘save-excursion’ 和
‘set-buffer’。


File: eintr.info,  Node: Buffer Related Review,  Next: Buffer Exercises,  Prev: append-to-buffer,  Up: Buffer Walk Through

4.5 复习
========

这里是本章讨论的各种函数的简要总结。

‘describe-function’
‘describe-variable’
     打印函数或变量的文档。通常绑定到 ‘C-h f’ 和 ‘C-h v’。

‘xref-find-definitions’
     查找包含函数或变量源代码的文件，并切换到该文件，将光标定位在该项的
     开头。通常绑定到 ‘M-.’（这是在 <META> 键后面加上句点）。

‘save-excursion’
     保存光标位置，并在评估 ‘save-excursion’ 参数后还原其值。还记住当前
     缓冲区并返回到它。

‘push-mark’
     在某个位置设置标记，并记录标记环上前一个标记的值。标记是缓冲区中的
     一个位置，即使在缓冲区中添加或删除文本，它也会保持相对位置。

‘goto-char’
     将光标设置为由参数的值指定的位置，该参数可以是数字、标记或返回位置
     数字的表达式，例如 ‘(point-min)’。

‘insert-buffer-substring’
     从作为参数传递给函数的缓冲区中复制文本区域，并将该区域插入到当前缓
     冲区中。

‘mark-whole-buffer’
     将整个缓冲区标记为一个区域。通常绑定到 ‘C-x h’。

‘let*’
     声明一个变量列表并为它们赋初始值；然后评估 ‘let*’ 体中的其余表达式
     。变量的值可以用来绑定列表中随后的变量。

‘set-buffer’
     将Emacs的注意力切换到另一个缓冲区，但不更改显示的窗口。在程序而不是
     人类要在不同的缓冲区上工作时使用。

‘get-buffer-create’
‘get-buffer’
     查找命名的缓冲区，如果不存在该名称的缓冲区，则创建一个。如果命名的
     缓冲区不存在，‘get-buffer’ 函数返回 ‘nil’。


File: eintr.info,  Node: Buffer Exercises,  Prev: Buffer Related Review,  Up: Buffer Walk Through

4.6 练习
========

   • 编写自己的 ‘simplified-end-of-buffer’ 函数定义；然后测试它是否有效
     。

   • 使用 ‘if’ 和 ‘get-buffer’ 编写一个函数，该函数打印一条消息，告诉您
     缓冲区是否存在。

   • 使用 ‘xref-find-definitions’ 查找 ‘copy-to-buffer’ 函数的源代码。


File: eintr.info,  Node: More Complex,  Next: Narrowing & Widening,  Prev: Buffer Walk Through,  Up: Top

5 几个更复杂的函数
******************

在这一章中，我们在前几章学到的基础上，深入研究更复杂的函数。
‘copy-to-buffer’ 函数演示了在一个定义中使用两个 ‘save-excursion’ 表达式
，而 ‘insert-buffer’ 函数则演示了在 ‘interactive’ 表达式中使用星号、使用
‘or’，以及名称和名称引用的对象之间的重要区别。

* Menu:

* copy-to-buffer::              使用 ‘set-buffer’、‘get-buffer-create’。
* insert-buffer::               只读，并带有 ‘or’。
* beginning-of-buffer::         展示了 ‘goto-char’、‘point-min’ 和 ‘push-mark’。
* Second Buffer Related Review::
* optional Exercise::


File: eintr.info,  Node: copy-to-buffer,  Next: insert-buffer,  Up: More Complex

5.1 函数 ‘copy-to-buffer’ 的定义
================================

在理解了 ‘append-to-buffer’ 的工作原理后，很容易理解 ‘copy-to-buffer’。
这个函数将文本复制到一个缓冲区，但与其向第二个缓冲区添加文本不同，它替换
了第二个缓冲区中的所有先前文本。

   ‘copy-to-buffer’ 的主体如下，

     ...
     (interactive "BCopy to buffer: \nr")
     (let ((oldbuf (current-buffer)))
       (with-current-buffer (get-buffer-create buffer)
         (barf-if-buffer-read-only)
         (erase-buffer)
         (save-excursion
           (insert-buffer-substring oldbuf start end)))))

   与 ‘append-to-buffer’ 不同，‘copy-to-buffer’ 函数的交互表达式更简单。

   接下来的定义如下

     (with-current-buffer (get-buffer-create buffer) ...

   首先，看最内部的表达式；它首先被评估。该表达式以 ‘get-buffer-create
buffer’ 开头。该函数告诉计算机使用指定为要复制到的缓冲区的名称，或者如果
不存在这样的缓冲区，则创建它。然后，‘with-current-buffer’ 函数使用该缓冲
区临时作为当前缓冲区来评估其主体。

   （这展示了另一种改变计算机注意力但不改变用户注意力的方法。
‘append-to-buffer’ 函数展示了如何使用 ‘save-excursion’ 和 ‘set-buffer’ 来
实现相同的效果。‘with-current-buffer’ 是一种较新、可能更简单的机制。）

   ‘barf-if-buffer-read-only’ 函数在您无法修改缓冲区时发送错误消息，指示
该缓冲区为只读。

   接下来的一行只包含 ‘erase-buffer’ 函数。该函数擦除缓冲区。

   最后，最后两行包含 ‘save-excursion’ 表达式，其主体是
‘insert-buffer-substring’。‘insert-buffer-substring’ 表达式将文本从当前
缓冲区复制到另一个缓冲区（您并没有看到计算机改变其注意力，因此您不知道该
缓冲区现在被称为 ‘oldbuf’）。

   顺便说一下，这就是“替换”的含义。为了替换文本，Emacs 先擦除先前的文本
，然后插入新文本。

   大致上，‘copy-to-buffer’ 的主体如下：

     (let (BIND-oldbuf-TO-VALUE-OF-current-buffer)
         (WITH-THE-BUFFER-YOU-ARE-COPYING-TO
           (BUT-DO-NOT-ERASE-OR-COPY-TO-A-READ-ONLY-BUFFER)
           (erase-buffer)
           (save-excursion
             INSERT-SUBSTRING-FROM-oldbuf-INTO-BUFFER)))


File: eintr.info,  Node: insert-buffer,  Next: beginning-of-buffer,  Prev: copy-to-buffer,  Up: More Complex

5.2 函数 ‘insert-buffer’ 的定义
===============================

‘insert-buffer’ 是另一个与缓冲区相关的函数。该命令将另一个缓冲区的内容
_插入_到当前缓冲区中。它是 ‘append-to-buffer’ 或 ‘copy-to-buffer’ 的反向
操作，因为它们将文本区域从当前缓冲区_复制到_另一个缓冲区。

   以下讨论基于原始代码。该代码在2003年进行了简化，变得更难理解。

   (*Note ‘insert-buffer’ 的新主体: New insert-buffer, 以查看新主体的讨
论。)

   此外，这段代码说明了与可能是“只读”的缓冲区一起使用‘interactive’的用法
，以及对象名称与实际引用的对象之间的重要区别。

* Menu:

* insert-buffer code::
* insert-buffer interactive::   当您能读取但无法写入时。
* insert-buffer body::          主体包含一个 ‘or’ 和一个 ‘let’。
* if & or::                     使用 ‘if’ 而不是 ‘or’。
* Insert or::                   ‘or’ 表达式的工作原理。
* Insert let::                  两个 ‘save-excursion’ 表达式。
* New insert-buffer::


File: eintr.info,  Node: insert-buffer code,  Next: insert-buffer interactive,  Up: insert-buffer

‘insert-buffer’ 的代码
----------------------

以下是早期的代码：

     (defun insert-buffer (buffer)
       "在点之后插入缓冲区的内容。
     在插入的文本之后设置标记。
     BUFFER 可以是缓冲区或缓冲区名称。"
       (interactive "*bInsert buffer: ")
       (or (bufferp buffer)
           (setq buffer (get-buffer buffer)))
       (let (start end newmark)
         (save-excursion
           (save-excursion
             (set-buffer buffer)
             (setq start (point-min) end (point-max)))
           (insert-buffer-substring buffer start end)
           (setq newmark (point)))
         (push-mark newmark)))

   与其他函数定义一样，您可以使用模板查看函数的轮廓：

     (defun insert-buffer (buffer)
       "DOCUMENTATION..."
       (interactive "*bInsert buffer: ")
       BODY...)


File: eintr.info,  Node: insert-buffer interactive,  Next: insert-buffer body,  Prev: insert-buffer code,  Up: insert-buffer

5.2.1 ‘insert-buffer’ 函数中的交互表达式
----------------------------------------

在 ‘insert-buffer’ 中，‘interactive’ 声明的参数有两部分，一个星号 ‘*’ 和
‘bInsert buffer: ’。

* Menu:

* Read-only buffer::            当缓冲区无法修改时。
* b for interactive::             存在的缓冲区或其名称。


File: eintr.info,  Node: Read-only buffer,  Next: b for interactive,  Up: insert-buffer interactive

只读缓冲区
..........

星号用于当前缓冲区为只读缓冲区的情况—无法修改的缓冲区。如果在当前缓冲区
为只读时调用 ‘insert-buffer’，将在回显区打印相应的消息，并且终端可能会发
出哔声或闪烁；您将无法将任何内容插入当前缓冲区。星号后无需加换行符以将其
与下一个参数分隔开。


File: eintr.info,  Node: b for interactive,  Prev: Read-only buffer,  Up: insert-buffer interactive

交互表达式中的 ‘b’
..................

交互表达式中的下一个参数以小写 ‘b’ 开头。 （这与 ‘append-to-buffer’ 的代
码不同，后者使用大写 ‘B’。*Note ‘append-to-buffer’ 的定义:
append-to-buffer.）小写 ‘b’ 表示 Lisp 解释器应该将 ‘insert-buffer’ 的参
数绑定到一个现有缓冲区，否则应该绑定到其名称。Emacs 将提示您输入缓冲区的
名称，并提供默认缓冲区，并启用名称补全。如果缓冲区不存在，您将收到消息
“没有匹配”；终端也可能会哔哔作响。

   新的简化代码生成了 ‘interactive’ 的列表。它使用我们已经熟悉的
‘barf-if-buffer-read-only’ 和 ‘read-buffer’ 函数以及我们尚不熟悉的
‘progn’ 特殊形式（稍后将进行描述）。


File: eintr.info,  Node: insert-buffer body,  Next: if & or,  Prev: insert-buffer interactive,  Up: insert-buffer

5.2.2 ‘insert-buffer’ 函数的主体
--------------------------------

‘insert-buffer’ 函数的主体有两个主要部分：一个 ‘or’ 表达式和一个 ‘let’ 表
达式。 ‘or’ 表达式的目的是确保参数 ‘buffer’ 绑定到一个缓冲区，而不仅仅是
缓冲区的名称。 ‘let’ 表达式的主体包含将另一个缓冲区复制到当前缓冲区的代
码。

   简而言之，这两个表达式适合于 ‘insert-buffer’ 函数，如下所示：

     (defun insert-buffer (buffer)
       "DOCUMENTATION..."
       (interactive "*bInsert buffer: ")
       (or ...
           ...
       (let (VARLIST)
           BODY-OF-let... )

   要理解 ‘or’ 表达式如何确保参数 ‘buffer’ 绑定到一个缓冲区而不是缓冲区
的名称，首先需要了解 ‘or’ 函数。

   在这之前，让我使用 ‘if’ 重新编写此函数的一部分，以便您可以以熟悉的方
式看到所做的事情。


File: eintr.info,  Node: if & or,  Next: Insert or,  Prev: insert-buffer body,  Up: insert-buffer

5.2.3 使用 ‘if’ 替代 ‘or’ 的 ‘insert-buffer’
--------------------------------------------

要完成的任务是确保 ‘buffer’ 的值是一个缓冲区本身，而不是缓冲区的名称。如
果值是名称，则必须获取缓冲区本身。

   你可以想象自己在一个会议上，一个引座员正拿着一张带有你的名字的名单四
处寻找你：引座员与你的名字绑定，而不是与你绑定；但当引座员找到你并搀扶你
的手臂时，引座员就与你绑定了。

   在 Lisp 中，你可以这样描述这种情况：

     (if (not (holding-on-to-guest))
         (find-and-take-arm-of-guest))

   我们想要使用缓冲区做同样的事情——如果我们没有缓冲区本身，我们就希望获
取它。

   使用一个叫做 ‘bufferp’ 的谓词，它告诉我们是否有一个缓冲区（而不是它的
名称），我们可以这样编写代码：

     (if (not (bufferp buffer))              ; if-部分
         (setq buffer (get-buffer buffer)))  ; then-部分

这里，‘if’ 表达式的真假测试是 ‘(not (bufferp buffer))’；然后部分是表达式
‘(setq buffer (get-buffer buffer))’。

   在测试中，函数 ‘bufferp’ 如果其参数是一个缓冲区，则返回 true——但如果
其参数是缓冲区的名称，则返回 false。 （函数名 ‘bufferp’ 的最后一个字符是
字符 ‘p’；正如我们前面看到的，‘p’ 的这种用法是一个约定，表示该函数是一个
谓词，这是一个术语，表示该函数将确定某个属性是真还是假。*Note
使用错误类型的对象作为参数: Wrong Type of Argument.)

   函数 ‘not’ 位于表达式 ‘(bufferp buffer)’ 之前，因此真假测试看起来像这
样：

     (not (bufferp buffer))

‘not’ 是一个函数，如果其参数为 false，则返回 true；如果其参数为 true，则
返回 false。因此，如果 ‘(bufferp buffer)’ 返回 true，则 ‘not’ 表达式返回
false，反之亦然。

   使用这个测试，‘if’ 表达式的工作方式如下：当变量 ‘buffer’ 的值实际上是
一个缓冲区而不是其名称时，真假测试返回 false，‘if’ 表达式不会评估 then-部
分。这是可以的，因为如果它确实是一个缓冲区，我们就不需要对变量 ‘buffer’
做任何操作。

   另一方面，当 ‘buffer’ 的值不是一个缓冲区本身，而是缓冲区的名称时，真
假测试返回 true，并且评估表达式的 then-部分。在这种情况下，then-部分是
‘(setq buffer (get-buffer buffer))’。该表达式使用 ‘get-buffer’ 函数通过
名称返回实际的缓冲区本身。然后，‘setq’ 将变量 ‘buffer’ 设置为缓冲区本身
的值，替换其先前的值（该值是缓冲区的名称）。


File: eintr.info,  Node: Insert or,  Next: Insert let,  Prev: if & or,  Up: insert-buffer

5.2.4 ‘insert-buffer’ 中的 ‘or’ 表达式
--------------------------------------

‘insert-buffer’ 函数中 ‘or’ 表达式的目的是确保参数 ‘buffer’ 绑定到一个缓
冲区，而不仅仅是缓冲区的名称。前一节展示了如何使用 ‘if’ 表达式完成此任务
。然而，‘insert-buffer’ 函数实际上使用了 ‘or’。要理解这一点，有必要了解
‘or’ 的工作原理。

   一个 ‘or’ 函数可以有任意数量的参数。它依次评估每个参数，并返回其参数
中第一个不是 ‘nil’ 的值。此外，这是 ‘or’ 的一个关键特性，即在返回第一个
非 ‘nil’ 值后，它不再评估任何后续参数。

   ‘or’ 表达式如下：

     (or (bufferp buffer)
         (setq buffer (get-buffer buffer)))

‘or’ 的第一个参数是表达式 ‘(bufferp buffer)’。如果缓冲区实际上是一个缓冲
区而不仅仅是缓冲区的名称，则此表达式返回 true（一个非 ‘nil’ 值）。在
‘or’ 表达式中，如果是这种情况，‘or’ 表达式返回这个 true 值，并且不评估下
一个表达式——这对我们来说是可以的，因为如果它确实是一个缓冲区，我们就不希
望对 ‘buffer’ 的值做任何操作。

   另一方面，如果 ‘(bufferp buffer)’ 的值是 ‘nil’，那么如果 ‘buffer’ 的
值是缓冲区的名称，Lisp 解释器将评估 ‘or’ 表达式的下一个元素。这是表达式
‘(setq buffer (get-buffer buffer))’。此表达式返回一个非 ‘nil’ 值，这是它
设置变量 ‘buffer’ 的值——并且这个值是缓冲区本身，而不是缓冲区的名称。

   所有这些的结果是，符号 ‘buffer’ 总是绑定到缓冲区本身而不是缓冲区的名
称。所有这些是必要的，因为后面的一行中的 ‘set-buffer’ 函数只能与缓冲区本
身一起使用，而不能与缓冲区的名称一起使用。

   顺便说一下，使用 ‘or’，引座员的情况可以写成这样：

     (or (holding-on-to-guest) (find-and-take-arm-of-guest))


File: eintr.info,  Node: Insert let,  Next: New insert-buffer,  Prev: Insert or,  Up: insert-buffer

5.2.5 ‘insert-buffer’ 中的 ‘let’ 表达式
---------------------------------------

在确保变量 ‘buffer’ 引用的是缓冲区本身而不仅仅是缓冲区的名称后，
‘insert-buffer’ 函数继续使用 ‘let’ 表达式。这个表达式指定了三个局部变量
‘start’、‘end’ 和 ‘newmark’，并将它们绑定到初始值 ‘nil’。这些变量在
‘let’ 的其余部分中被使用，并在 ‘let’ 结束之前暂时隐藏了任何同名变量的其
他出现。

   ‘let’ 的主体包含两个 ‘save-excursion’ 表达式。首先，我们将详细查看内
部 ‘save-excursion’ 表达式。表达式如下：

     (save-excursion
       (set-buffer buffer)
       (setq start (point-min) end (point-max)))

表达式 ‘(set-buffer buffer)’ 将 Emacs 的注意力从当前缓冲区切换到将要复制
文本的缓冲区。在该缓冲区中，使用命令 ‘point-min’ 和 ‘point-max’ 将变量
‘start’ 和 ‘end’ 设置为缓冲区的开始和结束。请注意，这里演示了 ‘setq’ 如
何能够在同一个表达式中设置两个变量。‘setq’ 的第一个参数设置为其第二个参
数的值，其第三个参数设置为其第四个参数的值。

   在内部 ‘save-excursion’ 的主体被评估之后，‘save-excursion’ 会恢复原始
缓冲区，但是 ‘start’ 和 ‘end’ 仍然设置为将要复制文本的缓冲区的开始和结束
的值。

   外部 ‘save-excursion’ 表达式如下：

     (save-excursion
       (INNER-save-excursion-EXPRESSION
          (GO-TO-NEW-BUFFER-AND-SET-start-AND-end)
       (insert-buffer-substring buffer start end)
       (setq newmark (point)))

‘insert-buffer-substring’ 函数将文本从 ‘buffer’ 中的 ‘start’ 和 ‘end’ 位
置插入到当前缓冲区中。由于第二个缓冲区的整体位于 ‘start’ 和 ‘end’ 之间，
第二个缓冲区的整体被复制到你正在编辑的缓冲区中。接下来，点的值，它将位于
插入文本的末尾，被记录在变量 ‘newmark’ 中。

   在外部 ‘save-excursion’ 的主体被评估之后，点被重新定位到其原始位置。

   然而，方便的是在新插入的文本的末尾放置一个标记，并将点定位在其开头。
‘newmark’ 变量记录了插入文本的末尾。在 ‘let’ 表达式的最后一行中，
‘(push-mark newmark)’ 表达式函数将标记设置为此位置。（标记的先前位置仍然
可访问；它记录在标记环上，你可以使用 ‘C-u C-<SPC>’ 返回到它。）与此同时
，点位于插入文本的开头，这是你调用插入函数之前的位置，该位置由第一个
‘save-excursion’ 保存。

   整个 ‘let’ 表达式如下：

     (let (start end newmark)
       (save-excursion
         (save-excursion
           (set-buffer buffer)
           (setq start (point-min) end (point-max)))
         (insert-buffer-substring buffer start end)
         (setq newmark (point)))
       (push-mark newmark))

   与 ‘append-to-buffer’ 函数一样，‘insert-buffer’ 函数使用了 ‘let’、
‘save-excursion’ 和 ‘set-buffer’。此外，该函数演示了使用 ‘or’ 的一种方式
。所有这些函数都是我们将一遍又一遍找到并使用的构建块。


File: eintr.info,  Node: New insert-buffer,  Prev: Insert let,  Up: insert-buffer

5.2.6 ‘insert-buffer’ 的新主体
------------------------------

GNU Emacs 22 版本中的主体比原始版本更令人困惑。

   它包含两个表达式，

       (push-mark
        (save-excursion
          (insert-buffer-substring (get-buffer buffer))
          (point)))

        nil

除外，这是使初学者困惑的地方，‘push-mark’ 表达式内部执行了非常重要的工作
。

   ‘get-buffer’ 函数返回一个以提供的名称命名的缓冲区。请注意，该函数并
_不_被称为 ‘get-buffer-create’；如果不存在缓冲区，则不会创建一个。由
‘get-buffer’ 返回的缓冲区（已存在的缓冲区）被传递给
‘insert-buffer-substring’，该函数插入整个缓冲区（因为您没有指定其他内容
）。

   ‘push-mark’ 记录插入缓冲区的位置。然后，该函数返回 ‘nil’，即其最后一
条命令的值。换句话说，‘insert-buffer’ 函数仅用于产生副作用，即插入另一个
缓冲区，而不是返回任何值。


File: eintr.info,  Node: beginning-of-buffer,  Next: Second Buffer Related Review,  Prev: insert-buffer,  Up: More Complex

5.3 ‘beginning-of-buffer’ 函数的完整定义
========================================

‘beginning-of-buffer’ 函数的基本结构已经讨论过了。(*Note 一个简化的
‘beginning-of-buffer’ 定义: simplified-beginning-of-buffer.)  本节描述了
定义的复杂部分。

   如前所述，当没有参数调用时，‘beginning-of-buffer’ 将光标移动到缓冲区
的开头（实际上是可访问部分的开头），并将标记留在先前的位置。然而，当以介
于一到十之间的数字调用该命令时，该函数将该数字视为缓冲区长度的十分之一，
Emacs 将光标移动到缓冲区的该部分。因此，您可以使用键命令 ‘M-<’ 调用该函
数，将光标移动到缓冲区的开头，或者使用键命令，例如 ‘C-u 7 M-<’，将光标移
动到缓冲区的70％处。如果使用大于十的数字作为参数，则光标将移动到缓冲区的
末尾。

   ‘beginning-of-buffer’ 函数可以带有或不带有参数调用。使用参数是可选的
。

* Menu:

* Optional Arguments::
* beginning-of-buffer opt arg::  带有可选参数的示例。
* beginning-of-buffer complete::


File: eintr.info,  Node: Optional Arguments,  Next: beginning-of-buffer opt arg,  Up: beginning-of-buffer

5.3.1 可选参数
--------------

除非另有说明，Lisp 期望具有函数定义中参数的函数在调用时将为该参数传递一
个值。如果没有这样做，将出现错误并显示消息 ‘Wrong number of arguments’。

   然而，可选参数是Lisp的一个特性：使用特定的“关键字”告诉Lisp解释器该参
数是可选的。关键字是 ‘&optional’。 （‘&’ 在 ‘optional’ 前面是关键字的一
部分。）在函数定义中，如果一个参数跟在关键字 ‘&optional’ 后面，那么在调
用函数时无需传递值给该参数。

   因此，‘beginning-of-buffer’ 函数的函数定义的第一行看起来像这样：

     (defun beginning-of-buffer (&optional arg)

   概括而言，整个函数看起来像这样：

     (defun beginning-of-buffer (&optional arg)
       "DOCUMENTATION..."
       (interactive "P")
       (or (IS-THE-ARGUMENT-A-CONS-CELL arg)
           (and ARE-BOTH-TRANSIENT-MARK-MODE-AND-MARK-ACTIVE-TRUE)
           (push-mark))
       (let (DETERMINE-SIZE-AND-SET-IT)
       (goto-char
         (IF-THERE-IS-AN-ARGUMENT
             FIGURE-OUT-WHERE-TO-GO
           ELSE-GO-TO
           (point-min))))
        DO-NICETY

   该函数类似于 ‘simplified-beginning-of-buffer’ 函数，只是
‘interactive’ 表达式的参数是 ‘"P"’，并且 ‘goto-char’ 函数后面跟着一个
if-then-else 表达式，用于确定如果有一个不是 cons cell 的参数，光标应该放
在哪里。

   （由于我在很多章节里都没有解释 cons cell，请考虑忽略函数 ‘consp’。
*Note 如何实现列表: List Implementation, 以及 *note Cons Cell and List
Types: (elisp)Cons Cell Type.）

   ‘interactive’ 表达式中的 ‘"P"’ 告诉 Emacs 将前缀参数（如果有的话）以
原始形式传递给函数。前缀参数是通过按 <META> 键后面跟一个数字，或者按
‘C-u’ 然后是一个数字来生成的。（如果不输入数字，‘C-u’ 默认为带有 4 的
cons cell。在 ‘interactive’ 表达式中的小写 ‘"p"’ 会导致函数将前缀参数转
换为数字。）

   ‘if’ 表达式的真值测试看起来复杂，但实际上并不复杂：它检查 ‘arg’ 是否
具有非 ‘nil’ 的值，以及它是否是 cons cell。 （这就是 ‘consp’ 做的事情；
它检查其参数是否为 cons cell。）如果 ‘arg’ 具有非 ‘nil’ 的值（并且不是
cons cell），这个真值测试将返回 true，并且 ‘if’ 表达式的 then-部分将被评
估。另一方面，如果 ‘beginning-of-buffer’ 没有带参数调用，‘arg’ 的值将为
‘nil’，并且 ‘if’ 表达式的 else-部分将被评估。else-部分就是 ‘point-min’，
当这是结果时，整个 ‘goto-char’ 表达式是 ‘(goto-char (point-min))’，这就
是我们在简化形式中看到的 ‘beginning-of-buffer’ 函数。


File: eintr.info,  Node: beginning-of-buffer opt arg,  Next: beginning-of-buffer complete,  Prev: Optional Arguments,  Up: beginning-of-buffer

5.3.2 ‘beginning-of-buffer’ with an Argument
--------------------------------------------

当使用参数调用‘beginning-of-buffer’时，将计算一个表达式来确定传递给
‘goto-char’的值。这个表达式乍一看相当复杂。它包括一个内部的‘if’表达式和
许多算术运算。具体如下：

     (if (> (buffer-size) 10000)
         ;; 避免大缓冲区大小溢出！
                               (* (prefix-numeric-value arg)
                                  (/ size 10))
       (/
        (+ 10
           (*
            size (prefix-numeric-value arg))) 10)))

* Menu:

* Disentangle beginning-of-buffer::
* Large buffer case::
* Small buffer case::


File: eintr.info,  Node: Disentangle beginning-of-buffer,  Next: Large buffer case,  Up: beginning-of-buffer opt arg

Disentangle ‘beginning-of-buffer’
.................................

与其他复杂的表达式一样，‘beginning-of-buffer’中的条件表达式可以通过将其
视为模板的一部分（在这种情况下，是if-then-else表达式的模板）来解开。在骨
架形式中，该表达式如下：

     (if (BUFFER-IS-LARGE
         DIVIDE-BUFFER-SIZE-BY-10-AND-MULTIPLY-BY-ARG
       ELSE-USE-ALTERNATE-CALCULATION

   这个内部的‘if’表达式的真值或假值测试检查缓冲区的大小。这样做的原因是
，旧版本的Emacs使用的数字不超过八百万左右，在随后的计算中，程序员担心如
果缓冲区很大，Emacs可能会尝试使用过大的数字。注释中提到的术语“溢出”意味
着数字过大。更近期的Emacs版本使用更大的数字，但由于人们现在查看的缓冲区
远远大于以往，这段代码没有被更改。

   有两种情况：如果缓冲区很大，如果不大。


File: eintr.info,  Node: Large buffer case,  Next: Small buffer case,  Prev: Disentangle beginning-of-buffer,  Up: beginning-of-buffer opt arg

在大缓冲区中发生了什么
......................

在‘beginning-of-buffer’中，内部的‘if’表达式测试缓冲区的大小是否大于
10,000个字符。为了做到这一点，它使用了‘>’函数和来自let表达式的‘size’计算
。

   在旧版本中，使用了‘buffer-size’函数。不仅调用了该函数多次，而且它给出
的是整个缓冲区的大小，而不是可访问部分的大小。当只处理可访问部分时，计算
会更有意义。关于将注意力集中到可访问部分的更多信息，请参阅《缩小和扩大》
。

   这一行看起来像这样：

     (if (> size 10000)

当缓冲区很大时，‘if’表达式的then部分将被评估。它读起来像这样（格式化以便
阅读）：

     (*
       (prefix-numeric-value arg)
       (/ size 10))

这个表达式是一个乘法，具有‘*’函数的两个参数。

   第一个参数是‘(prefix-numeric-value arg)’。当‘interactive’的参数为
‘"P"’时，传递给函数的参数是一个“原始前缀参数”，而不是一个数字（它是一个
列表中的数字）。为了进行算术运算，需要进行转换，‘prefix-numeric-value’完
成了这个任务。

   第二个参数是‘(/ size 10)’。这个表达式将数值除以十—可访问部分缓冲区大
小的数值。这产生一个数字，告诉我们十分之一缓冲区大小由多少字符组成。在
Lisp中，‘/’用于除法，就像‘*’用于乘法一样。

   在整个乘法表达式中，这个数量被乘以前缀参数的值—乘法看起来像这样：

     (* NUMERIC-VALUE-OF-PREFIX-ARG
        NUMBER-OF-CHARACTERS-IN-ONE-TENTH-OF-THE-ACCESSIBLE-BUFFER)

例如，如果前缀参数是‘7’，那么十分之一的值将乘以7，以给出在缓冲区大小的
70%的位置。

   所有这些的结果是，如果可访问部分的缓冲区很大，那么‘goto-char’表达式将
如下：

     (goto-char (* (prefix-numeric-value arg)
                   (/ size 10)))

   这把光标放在我们想要的位置。


File: eintr.info,  Node: Small buffer case,  Prev: Large buffer case,  Up: beginning-of-buffer opt arg

小缓冲区中的情况
................

如果缓冲区包含的字符少于10,000个，将执行略有不同的计算。你可能认为这是不
必要的，因为第一种计算方法可以完成工作。然而，在小缓冲区中，第一种方法可
能无法将光标精确放置在所需的行上；而第二种方法效果更好。

   以下是代码：

     (/ (+ 10 (* size (prefix-numeric-value arg))) 10))

这是一段代码，你可以通过发现函数嵌套在括号中的方式来理解它的运行。如果每
个表达式都比其封闭表达式缩进得更深，那么代码会更容易阅读：

       (/
        (+ 10
           (*
            size
            (prefix-numeric-value arg)))
        10))

通过查看括号，我们可以看到最内层的操作是‘(prefix-numeric-value arg)’，它
将原始参数转换为数字。在下面的表达式中，这个数字被乘以缓冲区的可访问部分
的大小：

     (* size (prefix-numeric-value arg))

这个乘法会产生一个可能比缓冲区的大小更大的数字——例如，如果参数是7，那么
这个数字会大七倍。然后，这个数字加上10，最终将这个大数字除以10，得到的值
比缓冲区中的百分比位置多一个字符。

   所有这些计算得到的数字被传递给‘goto-char’，并将光标移动到该位置。


File: eintr.info,  Node: beginning-of-buffer complete,  Prev: beginning-of-buffer opt arg,  Up: beginning-of-buffer

5.3.3 完整的‘beginning-of-buffer’
---------------------------------

下面是‘beginning-of-buffer’函数的完整文本：

     (defun beginning-of-buffer (&optional arg)
       "将点移到缓冲区的开头；在先前位置留下标记。
     使用 \\[universal-argument] 前缀时，不在先前位置设置标记。
     使用数值参数 N 时，将点设置为从开头开始的 N/10 处。

     如果缩小了缓冲区，
     此命令使用缓冲区的可访问部分的开头和大小。

     不要在Lisp程序中使用这个命令！
     \(goto-char (point-min))更快
     且不会破坏标记。"
       (interactive "P")
       (or (consp arg)
           (and transient-mark-mode mark-active)
           (push-mark))
       (let ((size (- (point-max) (point-min))))
         (goto-char (if (and arg (not (consp arg)))
                        (+ (point-min)
                           (if (> size 10000)
                               ;; 避免大缓冲区大小的溢出！
                               (* (prefix-numeric-value arg)
                                  (/ size 10))
                             (/ (+ 10 (* size (prefix-numeric-value arg)))
                                10)))
                      (point-min))))
       (if (and arg (not (consp arg))) (forward-line 1)))

除了文档字符串中的一个细节和函数的最后一行之外，前面的讨论展示了这个函数
的工作原理。

   在文档字符串中，有一个表达式的引用：

     \\[universal-argument]

在这个表达式的第一个方括号之前使用了‘\\’。这个‘\\’告诉Lisp解释器替换当前
绑定到‘[...]’的键。在‘universal-argument’的情况下，通常是‘C-u’，但也可能
不同。有关更多信息，*Note 文档字符串提示: (GNU Emacs
Lisp参考手册)Documentation Tips.

   最后，‘beginning-of-buffer’命令的最后一行指示，如果带有参数调用命令：

     (if (and arg (not (consp arg))) (forward-line 1))

如果使用‘C-u’指定命令，但没有数字，也就是说，原始前缀参数只是一个cons单
元，该命令将光标放在第二行的开头。


File: eintr.info,  Node: Second Buffer Related Review,  Next: optional Exercise,  Prev: beginning-of-buffer,  Up: More Complex

5.4 复习
========

这里是对本章涵盖的一些主题的简要总结。

‘or’
     依次评估每个参数，并返回第一个不是 ‘nil’ 的参数的值；如果没有返回一
     个不是 ‘nil’ 的值，则返回 ‘nil’。简言之，返回参数中的第一个真值；如
     果其中任何一个是真值，则返回真值。

‘and’
     依次评估每个参数，并且如果任何一个是 ‘nil’，则返回 ‘nil’；如果没有
     一个是 ‘nil’，则返回最后一个参数的值。简言之，只有当所有参数都为真
     时才返回真值；如果其中任何一个为真，则返回真值。

‘&optional’
     用于指示函数定义中的参数是可选的关键字；这意味着如果需要，可以在不
     提供参数的情况下评估函数。

‘prefix-numeric-value’
     将由 ‘(interactive "P")’ 生成的原始前缀参数转换为数值。

‘forward-line’
     将点移动到下一行的开头，或者如果参数大于一，则向前移动那么多行。如
     果无法移动到应该移动到的位置，‘forward-line’ 将尽量向前移动，并返回
     无法移动的额外行数的计数。

‘erase-buffer’
     删除当前缓冲区的所有内容。

‘bufferp’
     如果其参数是缓冲区，则返回 ‘t’；否则返回 ‘nil’。


File: eintr.info,  Node: optional Exercise,  Prev: Second Buffer Related Review,  Up: More Complex

5.5 ‘optional’ 参数练习
=======================

编写一个交互式函数，该函数带有一个可选参数，用于测试其参数（一个数字）是
否大于或等于 ‘fill-column’ 的值，否则，小于该值，并通过消息告诉您结果。
然而，如果您没有向函数传递参数，则使用默认值56。


File: eintr.info,  Node: Narrowing & Widening,  Next: car cdr & cons,  Prev: More Complex,  Up: Top

6 缩窄与扩大
************

缩窄是Emacs的一个功能，使您能够专注于缓冲区的特定部分，并且在不小心更改
其他部分的情况下工作。通常情况下，缩窄是禁用的，因为它可能使初学者感到困
惑。

* Menu:

* Narrowing advantages::              缩窄的优势
* save-restriction::        ‘save-restriction’ 特殊形式。
* what-line::               光标所在行的行号。
* narrow Exercise::


File: eintr.info,  Node: Narrowing advantages,  Next: save-restriction,  Up: Narrowing & Widening

缩小的优势
==========

通过缩小，缓冲区的其余部分被隐藏起来，就好像它们不存在一样。这是一个优势
，例如，如果你想替换缓冲区的某个部分中的一个单词，而不影响其他部分，你可
以缩小到你想要的部分，替换只在该部分进行，而不影响缓冲区的其余部分。搜索
也仅在缩小的区域内工作，而不在外部，因此如果你正在修复文档的一部分，你可
以通过缩小到你想要的区域来防止意外地找到不需要修复的部分。 （
‘narrow-to-region’的键绑定是‘C-x n n’。）

   然而，缩小会使缓冲区的其余部分变得不可见，这可能会吓到那些不小心调用
缩小并认为已删除文件的一部分的人。此外，‘undo’命令（通常绑定到‘C-x u’）
不会取消缩小（也不应该取消），所以如果人们不知道可以使用‘widen’命令将缓
冲区的其余部分恢复为可见状态，他们可能会变得相当绝望。 （‘widen’的键绑定
是‘C-x n w’。）

   缩小对Lisp解释器和人类一样有用。通常，Emacs Lisp函数被设计为仅在缓冲
区的一部分上工作；或者相反，Emacs Lisp函数需要在已经缩小的整个缓冲区上工
作。例如，‘what-line’函数会在缓冲区存在缩小的情况下移除缩小，并在完成工
作后将缩小恢复到原来的状态。另一方面，‘count-lines’函数使用缩小来限制自
己只在其感兴趣的缓冲区部分中运行，然后恢复到先前的情况。


File: eintr.info,  Node: save-restriction,  Next: what-line,  Prev: Narrowing advantages,  Up: Narrowing & Widening

6.1 特殊形式 ‘save-restriction’
===============================

在Emacs Lisp中，你可以使用特殊形式 ‘save-restriction’ 来追踪当前是否存在
缩小范围的情况。当Lisp解释器遇到 ‘save-restriction’ 时，它会执行
‘save-restriction’ 表达式体中的代码，然后撤销代码引起的任何缩小范围的更
改。例如，如果缓冲区被缩小，而跟在 ‘save-restriction’ 后面的代码消除了缩
小，则 ‘save-restriction’ 将在之后将缓冲区恢复到缩小的区域。在
‘what-line’ 命令中，由 ‘save-restriction’ 命令后立即执行的 ‘widen’ 命令
会撤销缓冲区可能存在的任何缩小。任何原始的缩小在函数完成之前都会被恢复。

   ‘save-restriction’ 表达式的模板很简单：

     (save-restriction
       BODY... )

‘save-restriction’ 的体是一个或多个将由Lisp解释器按顺序评估的表达式。

   最后，需要注意的一点是：当你同时使用 ‘save-excursion’ 和
‘save-restriction’，并且它们紧跟在彼此之后时，应该将 ‘save-excursion’ 放
在最外层。如果你以相反的顺序编写它们，可能无法记录Emacs在调用
‘save-excursion’ 后切换到的缓冲区的缩小。因此，在一起编写时，
‘save-excursion’ 和 ‘save-restriction’ 应该像这样编写：

     (save-excursion
       (save-restriction
         BODY...))

   在其他情况下，当它们没有一起编写时，‘save-excursion’ 和
‘save-restriction’ 特殊形式必须按照适合函数的顺序编写。

   例如，

       (save-restriction
         (widen)
         (save-excursion
         BODY...))


File: eintr.info,  Node: what-line,  Next: narrow Exercise,  Prev: save-restriction,  Up: Narrowing & Widening

6.2 ‘what-line’
===============

‘what-line’命令告诉您光标所在位置的行号。该函数演示了
‘save-restriction’和‘save-excursion’命令的用法。以下是该函数的原始文本：

     (defun what-line ()
       "打印光标所在位置（在缓冲区中）的当前行号。"
       (interactive)
       (save-restriction
         (widen)
         (save-excursion
           (beginning-of-line)
           (message "第%d行"
                    (1+ (count-lines 1 (point)))))))

   （在GNU Emacs的现代版本中，‘what-line’函数已经扩展，不仅告诉您在扩展
缓冲区中的行号，还告诉您在狭窄缓冲区中的行号。现代版本比这里展示的版本更
复杂。如果您感到有冒险精神，可以在弄清楚此版本的工作原理后查看它。您可能
需要使用‘C-h f’（‘describe-function’）。新版本使用条件判断确定缓冲区是否
已经被狭窄。

   此外，‘what-line’的现代版本使用‘line-number-at-pos’，它除了简单的表达
式（例如‘(goto-char (point-min))’）外，还使用‘(forward-line 0)’将光标移
动到当前行的开头，而不是‘beginning-of-line’。）

   这里展示的‘what-line’函数具有文档行并且是交互式的，正如您所期望的那样
。接下来的两行使用了‘save-restriction’和‘widen’函数。

   ‘save-restriction’特殊形式记录当前缓冲区中任何有效的缩小范围（如果有
的话），并在‘save-restriction’的主体代码被评估后恢复该缩小范围。

   ‘save-restriction’特殊形式后跟‘widen’。此函数撤消了在调用
‘what-line’时当前缓冲区可能存在的任何缩小。 （‘save-restriction’记住的是
存在的缩小。）这种扩展使得行计数命令能够从缓冲区的开头计数。否则，它们将
受限于在可访问区域内计数。任何原始缩小都在‘save-restriction’特殊形式完成
函数后立即恢复。

   对‘widen’的调用后跟‘save-excursion’，该函数保存光标（即点）的位置，并
在‘save-excursion’的主体代码使用‘beginning-of-line’函数移动点后恢复它。

   （请注意，‘(widen)’表达式位于‘save-restriction’和‘save-excursion’特殊
形式之间。当您按顺序编写两个‘save- ...’表达式时，将‘save-excursion’写在
最外层。）

   ‘what-line’函数的最后两行是用于计算缓冲区中行数然后在回显区打印该数字
的函数。

     (message "第%d行"
              (1+ (count-lines 1 (point)))))))

   ‘message’函数在Emacs屏幕底部打印一行消息。第一个参数位于引号中，被打
印为一个字符串。但是，它可能包含‘%d’表达式，以打印后续参数。‘%d’将参数打
印为十进制数，因此消息将显示类似于‘第243行’的内容。

   替换‘%d’的位置打印的数字由函数的最后一行计算：

     (1+ (count-lines 1 (point)))

这是从缓冲区的第一个位置（由‘1’指示）到‘(point)’的行数，然后将其加一。 （
‘1+’函数将其参数加一。）我们加一是因为第2行之前只有一行，而
‘count-lines’只计算当前行之前的行。

   在‘count-lines’完成其工作并且消息已经在回显区打印后，
‘save-excursion’将点还原到其原始位置；‘save-restriction’恢复原始的缩小（
如果有的话）。


File: eintr.info,  Node: narrow Exercise,  Prev: what-line,  Up: Narrowing & Widening

6.3 使用 Narrowing 进行练习
===========================

编写一个函数，即使将缓冲区缩小到其后半部分以至于第一行不可访问，也能显示
当前缓冲区的前60个字符。需要使用一系列函数，包括 ‘save-restriction’、
‘widen’、‘goto-char’、‘point-min’、‘message’ 和 ‘buffer-substring’。

   （‘buffer-substring’ 是一个先前未提及的函数，您需要自行查阅；或者您可
能需要使用 ‘buffer-substring-no-properties’ 或 ‘filter-buffer-substring’
...，还有其他函数。文本属性是本文未讨论的另一个功能。*Note 文本属性:
(elisp)文本属性.）

   另外，是否真的需要 ‘goto-char’ 或 ‘point-min’？或者您能否在不使用它们
的情况下编写该函数？


File: eintr.info,  Node: car cdr & cons,  Next: Cutting & Storing Text,  Prev: Narrowing & Widening,  Up: Top

7 ‘car’、‘cdr’ 和 ‘cons’：基本函数
**********************************

在 Lisp 中，‘car’、‘cdr’ 和 ‘cons’ 是基本函数。‘cons’ 函数用于构建列表，
而 ‘car’ 和 ‘cdr’ 函数用于分解列表。

   在 ‘copy-region-as-kill’ 函数的演练中，我们将看到 ‘cons’ 以及两个变体
的 ‘cdr’，即 ‘setcdr’ 和 ‘nthcdr’。(*Note copy-region-as-kill::.)

* Menu:

* Strange Names::               一个历史插曲：为什么是这些奇怪的名字？
* car & cdr::                   用于提取列表的部分的函数。
* cons::                        构建列表。
* nthcdr::                      反复调用 ‘cdr’。
* nth::
* setcar::                      更改列表的第一个元素。
* setcdr::                      更改列表的其余部分。
* cons Exercise::


File: eintr.info,  Node: Strange Names,  Next: car & cdr,  Up: car cdr & cons

Strange Names
=============

‘cons’ 函数的名称并不无道理：它是“construct”一词的缩写。另一方面，‘car’
和 ‘cdr’ 的命名起源有些深奥：‘car’ 是短语“Contents of the Address part
of the Register”的首字母缩写；而 ‘cdr’（发音为“could-er”）是短语
“Contents of the Decrement part of the Register”的首字母缩写。这些短语指
的是原始 Lisp 开发时使用的 IBM 704 计算机。

   IBM 704 在历史上留下了痕迹，但这些名字现在已经成为 Lisp 珍爱的传统。


File: eintr.info,  Node: car & cdr,  Next: cons,  Prev: Strange Names,  Up: car cdr & cons

7.1 ‘car’ 和 ‘cdr’
==================

列表的 CAR（首元素）简单地就是列表中的第一个项。因此，列表 ‘(rose violet
daisy buttercup)’ 的 CAR 就是 ‘rose’。

   如果你在 GNU Emacs 的 Info 中阅读此文档，你可以通过执行以下命令来验证
：

     (car '(rose violet daisy buttercup))

在执行此表达式之后，‘rose’ 将会出现在回显区域。

   ‘car’ 不会从列表中删除第一个项；它只是报告这个项是什么。在术语中，
‘car’ 是“非破坏性”的。这一特性事实上变得很重要。

   列表的 CDR（剩余元素）是列表中剩下的部分，即 ‘cdr’ 函数返回紧随第一个
项之后的列表部分。因此，虽然列表 ‘'(rose violet daisy buttercup)’ 的 CAR
是 ‘rose’，但列表的其余部分，即 ‘cdr’ 函数返回的值，是 ‘(violet daisy
buttercup)’。

   你可以通过以通常的方式执行以下命令来验证这一点：

     (cdr '(rose violet daisy buttercup))

当你执行此命令时，‘(violet daisy buttercup)’ 将会出现在回显区域。

   与 ‘car’ 一样，‘cdr’ 也不会从列表中移除任何元素，它只是返回第二个及后
续元素的报告。

   顺便说一下，在例子中，花卉列表是被引用的。如果没有引用，Lisp 解释器会
尝试通过调用 ‘rose’ 作为函数来评估列表。在这个例子中，我们不想这样做。

   在处理列表时，使用 ‘first’ 和 ‘rest’ 这样的名称可能比 ‘car’ 和 ‘cdr’
更有意义。事实上，一些程序员会将 ‘first’ 和 ‘rest’ 定义为 ‘car’ 和 ‘cdr’
的别名，然后在代码中使用 ‘first’ 和 ‘rest’。

   然而，在Lisp中，列表是使用称为“cons单元”（*note List
Implementation::）的较低级结构构建的，在其中“第一个”或“剩余”这样的概念是
不存在的，而 CAR 和 CDR 是对称的。Lisp 不会隐藏 cons 单元的存在，程序也
会将它们用于除列表之外的其他事物。因此，这些名称有助于提醒程序员，尽管在
列表中它们是不对称使用的，但 ‘car’ 和 ‘cdr’ 实际上是对称的。

   当 ‘car’ 和 ‘cdr’ 应用于由符号组成的列表时（例如，列表 ‘(pine fir oak
maple)’），函数 ‘car’ 返回的列表元素是符号 ‘pine’ 而没有括号。‘pine’ 是
列表中的第一个元素。然而，列表的 CDR 本身是一个列表，即 ‘(fir oak
maple)’，你可以通过以通常的方式执行以下表达式来验证：

     (car '(pine fir oak maple))

     (cdr '(pine fir oak maple))

   另一方面，在列表的列表中，第一个元素本身是一个列表。例如，以下列表包
含三个子列表，一个肉食动物列表，一个食草动物列表和一个海洋哺乳动物列表：

     (car '((lion tiger cheetah)
            (gazelle antelope zebra)
            (whale dolphin seal)))

在这个例子中，列表的第一个元素或 CAR 是肉食动物列表 ‘(lion tiger
cheetah)’，而列表的其余部分是 ‘((gazelle antelope zebra) (whale dolphin
seal))’。

     (cdr '((lion tiger cheetah)
            (gazelle antelope zebra)
            (whale dolphin seal)))

   值得再次强调的是，‘car’ 和 ‘cdr’ 是非破坏性的——也就是说，它们不会修改
或改变应用到它们的列表。这对它们的使用非常重要。

   另外，在第一章中，关于原子的讨论中，我提到在Lisp中，某些类型的原子，
例如数组，可以被分解成部分；但这个机制与拆分列表的机制不同。就Lisp而言，
列表的原子是不可分割的。(*Note Lisp Atoms::.)  ‘car’ 和 ‘cdr’ 函数用于拆
分列表，被认为是Lisp的基本功能。由于它们不能拆分或访问数组的部分，数组被
认为是原子。相反，另一个基本函数 ‘cons’ 可以组合或构造列表，但不能构造数
组。 （数组由数组特定的函数处理。*Note Arrays: (elisp)Arrays.）


File: eintr.info,  Node: cons,  Next: nthcdr,  Prev: car & cdr,  Up: car cdr & cons

7.2 ‘cons’
==========

‘cons’函数用于构建列表；它是‘car’和‘cdr’的反函数。例如，‘cons’可以用来从
三元素列表‘(fir oak maple)’中创建一个四元素列表：

     (cons 'pine '(fir oak maple))

在评估了这个列表之后，你将会看到：

     (pine fir oak maple)

出现在回显区。‘cons’导致创建一个新的列表，其中元素后面是原始列表的元素。

   我们经常说‘cons’将一个新元素放在列表的开头，或者附加或推送元素到列表
中，但这种表达可能会误导，因为‘cons’不会改变现有的列表，而是创建一个新列
表。

   与‘car’和‘cdr’一样，‘cons’是非破坏性的。

* Menu:

* Build a list::
* length::                      如何找到列表的长度。


File: eintr.info,  Node: Build a list,  Next: length,  Up: cons

构建列表
--------

‘cons’必须有一个要附加的列表。(1) 你不能从绝对的空白开始。如果你正在构建
一个列表，你需要至少在开头提供一个空列表。以下是一系列的‘cons’表达式，用
于构建一系列花的列表。如果你在GNU Emacs中的Info中阅读这个，你可以按照通
常的方式评估每个表达式；值将在这个文本中以‘⇒’打印出来，你可以将其解读为
“评估为”。

     (cons 'buttercup ())
          ⇒ (buttercup)

     (cons 'daisy '(buttercup))
          ⇒ (daisy buttercup)

     (cons 'violet '(daisy buttercup))
          ⇒ (violet daisy buttercup)

     (cons 'rose '(violet daisy buttercup))
          ⇒ (rose violet daisy buttercup)

在第一个例子中，空列表显示为‘()’，并构建了一个由‘buttercup’后面跟着空列
表的列表。正如你所见，空列表在构建的列表中没有显示。因为空列表中没有任何
内容，通常来说，空列表是不可见的。

   在第二个例子中，‘(cons 'daisy '(buttercup))’通过将‘daisy’放在
‘buttercup’前面构建了一个新的两元素列表；第三个例子通过将‘violet’放在
‘daisy’和‘buttercup’前面构建了一个三元素列表。

   ---------- Footnotes ----------

   (1) 实际上，你可以将元素‘cons’到原子上以生成一个点对。这里不讨论点对
；参见*note Dotted Pair Notation: (elisp)Dotted Pair Notation.。


File: eintr.info,  Node: length,  Prev: Build a list,  Up: cons

7.2.1 查找列表的长度：‘length’
------------------------------

你可以使用Lisp函数‘length’来查找列表中有多少元素，例如以下示例：

     (length '(buttercup))
          ⇒ 1

     (length '(daisy buttercup))
          ⇒ 2

     (length (cons 'violet '(daisy buttercup)))
          ⇒ 3

在第三个例子中，‘cons’函数用于构建一个包含三个元素的列表，然后将其作为参
数传递给‘length’函数。

   我们还可以使用‘length’来计算空列表中的元素个数：

     (length ())
          ⇒ 0

正如你所期望的那样，空列表中的元素个数为零。

   一个有趣的实验是找出当你尝试找到根本没有列表的长度时会发生什么；也就
是说，如果你尝试调用‘length’而没有给它提供参数，甚至没有空列表：

     (length )

如果你评估这个表达式，你将看到错误消息：

     Lisp error: (wrong-number-of-arguments length 0)

这意味着函数在期望某个其他数量的参数时（在本例中是一个参数），收到了错误
数量的参数，即零。在这种情况下，期望一个参数，而参数是要测量其长度的列表
。（注意，_一个_列表是_一个_参数，即使列表内有多个元素。）

   错误消息中的‘length’是函数的名称。


File: eintr.info,  Node: nthcdr,  Next: nth,  Prev: cons,  Up: car cdr & cons

7.3 ‘nthcdr’
============

函数 ‘nthcdr’ 与函数 ‘cdr’ 相关联。它的作用是重复地取一个列表的 CDR。

   如果对列表 ‘(pine fir oak maple)’ 进行 CDR 操作，将得到列表 ‘(fir oak
maple)’。如果在这个结果上再进行一次 CDR，将得到列表 ‘(oak maple)’。当然
，对原始列表反复 CDR 只会得到原始的 CDR，因为该函数不会改变列表。需要对
CDR 进行评估，然后继续操作。最终，你将得到一个空列表，在这个例子中，它显
示为 ‘nil’ 而非 ‘()’。

   为了复习，以下是一系列重复的 CDR 操作，‘⇒’ 后的文本显示了返回的结果。

     (cdr '(pine fir oak maple))
          ⇒ (fir oak maple)

     (cdr '(fir oak maple))
          ⇒ (oak maple)

     (cdr '(oak maple))
          ⇒ (maple)

     (cdr '(maple))
          ⇒ nil

     (cdr 'nil)
          ⇒ nil

     (cdr ())
          ⇒ nil

   你也可以进行多次 CDR 操作而不打印中间值，像这样：

     (cdr (cdr '(pine fir oak maple)))
          ⇒ (oak maple)

在这个例子中，Lisp 解释器首先评估最内层的列表。最内层的列表被引用，因此
它只是将列表传递给最内层的 ‘cdr’。这个 ‘cdr’ 将由列表的第二个及之后的元
素组成的列表传递给最外层的 ‘cdr’，产生一个由原始列表的第三个及之后的元素
组成的列表。在这个例子中，重复调用 ‘cdr’ 函数并返回一个由原始列表的前两
个元素之外的元素组成的列表。

   函数 ‘nthcdr’ 的作用与重复调用 ‘cdr’ 相同。在下面的例子中，参数 2 被
传递给函数 ‘nthcdr’，连同列表一起传递，返回的值是没有前两个项的列表，这
与在列表上连续调用两次 ‘cdr’ 是一样的：

     (nthcdr 2 '(pine fir oak maple))
          ⇒ (oak maple)

   使用原始的四个元素列表，我们可以看到当传递不同的数值参数给 ‘nthcdr’ 时
会发生什么，包括 0、1 和 5：

     ;; 保留列表不变。
     (nthcdr 0 '(pine fir oak maple))
          ⇒ (pine fir oak maple)

     ;; 返回去掉第一个元素的列表副本。
     (nthcdr 1 '(pine fir oak maple))
          ⇒ (fir oak maple)

     ;; 返回去掉三个元素的列表副本。
     (nthcdr 3 '(pine fir oak maple))
          ⇒ (maple)

     ;; 返回去掉所有四个元素的列表副本。
     (nthcdr 4 '(pine fir oak maple))
          ⇒ nil

     ;; 返回去掉所有元素的列表副本。
     (nthcdr 5 '(pine fir oak maple))
          ⇒ nil


File: eintr.info,  Node: nth,  Next: setcar,  Prev: nthcdr,  Up: car cdr & cons

7.4 ‘nth’
=========

函数 ‘nthcdr’ 重复获取列表的 CDR。函数 ‘nth’ 获取由 ‘nthcdr’ 返回的结果
的 CAR。它返回列表的第 N 个元素。

   因此，如果不是为了速度而在C中定义，‘nth’ 的定义将是：

     (defun nth (n list)
       "返回列表 LIST 的第 N 个元素。
     N 从零开始计数。如果列表没有那么长，则返回 nil。"
       (car (nthcdr n list)))

(最初，‘nth’ 是在Emacs Lisp中在‘subr.el’中定义的，但它的定义在1980年代被
重写为C语言。)

   ‘nth’ 函数返回列表的单个元素。这可能非常方便。

   请注意，元素从零开始编号，而不是从一开始。也就是说，列表的第一个元素
，它的 CAR 是零号元素。这种从零开始计数通常会让习惯于列表中第一个元素为
编号一的人感到困扰。

   例如：

     (nth 0 '("one" "two" "three"))
         ⇒ "one"

     (nth 1 '("one" "two" "three"))
         ⇒ "two"

   值得一提的是，‘nth’、‘nthcdr’ 和 ‘cdr’ 都不会改变原始列表—这些函数是
非破坏性的。这与 ‘setcar’ 和 ‘setcdr’ 函数形成鲜明对比。


File: eintr.info,  Node: setcar,  Next: setcdr,  Prev: nth,  Up: car cdr & cons

7.5 ‘setcar’
============

从它们的名字中，你可能已经猜到了，‘setcar’ 和 ‘setcdr’ 函数用于将列表的
CAR 或 CDR 设置为新值。它们实际上会改变原始列表，与 ‘car’ 和 ‘cdr’ 不同
，它们保持原始列表不变。了解这是如何工作的一种方法是进行实验。我们首先来
看一下 ‘setcar’ 函数。

   首先，我们可以创建一个列表，然后使用 ‘setq’ 特殊形式将变量的值设置为
该列表。因为我们打算使用 ‘setcar’ 来更改列表，所以这个 ‘setq’ 不应该使用
引用形式 ‘'(antelope giraffe lion tiger)’，因为那将产生一个程序的一部分
的列表，如果我们尝试在运行时更改程序的一部分，可能会导致问题。通常来说，
Emacs Lisp 程序的组件在程序运行时应该是常量（或不变的）。因此，我们使用
‘list’ 函数构造一个动物列表，如下所示：

     (setq animals (list 'antelope 'giraffe 'lion 'tiger))

如果你在 GNU Emacs 中的 Info 中阅读这篇文章，你可以通过按 ‘C-x C-e’ 将光
标定位在表达式之后，以通常的方式评估这个表达式。（我在写这篇文章的时候就
是这样做的。这是将解释器内置到计算环境中的优势之一。顺便说一句，当最终括
号之后的行上没有任何内容，比如注释时，光标可以在下一行。因此，如果你的光
标在下一行的第一列，你不需要移动它。事实上，Emacs 允许在最终括号之后有任
意量的空白。）

   当我们评估变量 ‘animals’ 时，我们看到它绑定到列表 ‘(antelope giraffe
lion tiger)’：

     animals
          ⇒ (antelope giraffe lion tiger)

换句话说，变量 ‘animals’ 指向列表 ‘(antelope giraffe lion tiger)’。

   接下来，评估函数 ‘setcar’，同时传递给它两个参数，变量 ‘animals’ 和引
用的符号 ‘hippopotamus’；这是通过编写三个元素的列表 ‘(setcar animals
'hippopotamus)’，然后以通常的方式评估它来完成的：

     (setcar animals 'hippopotamus)

评估完这个表达式后，再次评估变量 ‘animals’。你会看到动物列表已经改变了：

     animals
          ⇒ (hippopotamus giraffe lion tiger)

列表的第一个元素 ‘antelope’ 被 ‘hippopotamus’ 替换。

   所以我们可以看到，‘setcar’ 并没有像 ‘cons’ 那样向列表中添加新元素；它
替换了 ‘antelope’ 为 ‘hippopotamus’；它_改变了_列表。


File: eintr.info,  Node: setcdr,  Next: cons Exercise,  Prev: setcar,  Up: car cdr & cons

7.6 ‘setcdr’
============

‘setcdr’函数类似于‘setcar’函数，不同之处在于该函数替换列表的第二个及其后
的元素，而不是第一个元素。

   (要了解如何更改列表的最后一个元素，请查看*note ‘kill-new’ 函数:
kill-new function.，该函数使用‘nthcdr’和‘setcdr’函数。)

   为了了解它是如何工作的，请通过评估以下表达式将变量的值设置为一组驯养
的动物：

     (setq domesticated-animals (list 'horse 'cow 'sheep 'goat))

如果现在评估该列表，将返回列表‘(horse cow sheep goat)’：

     domesticated-animals
          ⇒ (horse cow sheep goat)

   接下来，通过使用两个参数评估‘setcdr’，第一个参数是具有列表值的变量的
名称，第二个参数是将设置为第一个列表的CDR的列表；

     (setcdr domesticated-animals '(cat dog))

如果评估此表达式，将在回显区域看到列表‘(cat dog)’。这是该函数返回的值。
我们感兴趣的结果是副作用，可以通过评估变量‘domesticated-animals’来查看：

     domesticated-animals
          ⇒ (horse cat dog)

确实，列表从‘(horse cow sheep goat)’更改为‘(horse cat dog)’。列表的CDR从
‘(cow sheep goat)’更改为‘(cat dog)’。


File: eintr.info,  Node: cons Exercise,  Prev: setcdr,  Up: car cdr & cons

7.7 练习
========

通过评估多个表达式使用‘cons’构建一个包含四只鸟的列表。了解当你使用
‘cons’将一个列表连接到自身时会发生什么。将四只鸟的列表的第一个元素替换为
一条鱼。用其他鱼的列表替换该列表的其余部分。


File: eintr.info,  Node: Cutting & Storing Text,  Next: List Implementation,  Prev: car cdr & cons,  Up: Top

8 剪切与存储文本
****************

无论何时在GNU Emacs中使用“kill”命令剪切或剪贴文本，它都会被存储在一个列
表中，您可以使用“yank”命令将其恢复。

   （在Emacs中使用“kill”一词来表示那些特别_不_破坏实体值的过程是一个不幸
的历史偶然。一个更合适的词语应该是“剪切”，因为kill命令的作用是剪切文本并
将其放入存储中，从中可以重新调用。我经常被诱惑着全局替换Emacs源代码中所
有“kill”出现的地方为“clip”，并将所有“killed”的出现地方替换为“clipped”）
。

* Menu:

* Storing Text::                   文本被存储在一个列表中。
* zap-to-char::               剪切文本直到某个字符。
* kill-region::               从区域中剪切文本。
* copy-region-as-kill::       复制文本的定义。
* Digression into C::               C编程语言宏的小注记。
* defvar::                    如何给变量一个初始值。
* cons & search-fwd Review::
* search Exercises::


File: eintr.info,  Node: Storing Text,  Next: zap-to-char,  Up: Cutting & Storing Text

将文本存储在列表中
==================

当文本从缓冲区中剪切出来时，它被存储在一个列表中。连续的文本片段被依次存
储在列表中，因此列表可能看起来像这样：

     ("一段文本" "之前的片段")

函数‘cons’可用于从文本片段（称为“原子”）和现有列表创建一个新列表，如下所
示：

     (cons "另一段"
           '("一段文本" "之前的片段"))

如果您评估此表达式，一个包含三个元素的列表将显示在回显区：

     ("另一段" "一段文本" "之前的片段")

   使用‘car’和‘nthcdr’函数，您可以检索您想要的任何文本片段。例如，在以下
代码中，‘nthcdr 1 ...’返回删除第一个项目的列表；而‘car’返回该剩余部分的
第一个元素—原始列表的第二个元素：

     (car (nthcdr 1 '("另一段"
                      "一段文本"
                      "之前的片段")))
          ⇒ "一段文本"

   实际的Emacs函数当然比这更复杂。剪切和检索文本的代码必须被编写，以便
Emacs可以弄清楚您想要列表中的哪个元素—第一个、第二个、第三个等。此外，当
到达列表的末尾时，Emacs应该给您列表的第一个元素，而不是什么都不给您。

   保存文本片段的列表称为“kill环”。本章首先描述了kill环，以及首先追踪
‘zap-to-char’函数的工作方式。此函数调用一个调用函数，该函数操纵kill环。
因此，在到达山脚之前，我们要先爬过丘陵。

   后续章节描述了从缓冲区剪切的文本如何被检索。*Note 检索文本: Yanking.


File: eintr.info,  Node: zap-to-char,  Next: kill-region,  Prev: Storing Text,  Up: Cutting & Storing Text

8.1 ‘zap-to-char’
=================

让我们看一下交互式函数 ‘zap-to-char’。

* Menu:

* Complete zap-to-char::        完整的实现。
* zap-to-char interactive::     一个三部分的交互式表达式。
* zap-to-char body::            简要概述。
* search-forward::              如何搜索字符串。
* progn::                       特殊形式 ‘progn’。
* Summing up zap-to-char::      使用 ‘point’ 和 ‘search-forward’。


File: eintr.info,  Node: Complete zap-to-char,  Next: zap-to-char interactive,  Up: zap-to-char

完整的 ‘zap-to-char’ 实现
-------------------------

‘zap-to-char’ 函数删除光标位置（即 point）到下一个指定字符（包括该字符）
之间的文本。‘zap-to-char’ 删除的文本被放入 kill ring，可以通过键入
‘C-y’（‘yank’）从 kill ring 中检索。如果给命令传递了一个参数，它将通过指
定数量的出现次数删除文本。因此，如果光标位于本句的开头，字符为 ‘s’，则将
删除 ‘Thus’。如果参数为二，则将删除 ‘Thus, if the curs’，直到 ‘cursor’ 中
的 ‘s’。

   如果未找到指定的字符，‘zap-to-char’ 将显示“Search failed”，告诉您输入
的字符，并且不会删除任何文本。

   为了确定要删除多少文本，‘zap-to-char’ 使用搜索函数。搜索在处理文本的
代码中广泛使用，我们将重点关注搜索以及删除命令。

   下面是版本 22 的函数实现的完整文本：

     (defun zap-to-char (arg char)
       "Kill up to and including ARG'th occurrence of CHAR.
     Case is ignored if `case-fold-search' is non-nil in the current buffer.
     Goes backward if ARG is negative; error if CHAR not found."
       (interactive "p\ncZap to char: ")
       (if (char-table-p translation-table-for-input)
           (setq char (or (aref translation-table-for-input char) char)))
       (kill-region (point) (progn
                              (search-forward (char-to-string char)
                                              nil nil arg)
                              (point))))

   文档非常详细。您需要了解“kill”这个术语的含义。

   ‘zap-to-char’ 版本 22 的文档字符串使用 ASCII grave accent 和撇号引用
一个符号，因此它显示为 `case-fold-search'。这种引用风格受到上世纪 70 年
代显示器的启发，在那里 grave accent 和撇号经常是镜像图像，适合用作引号。
在大多数现代显示器上，这不再成立，当这两个 ASCII 字符出现在文档字符串或
诊断消息格式中时，Emacs 通常将它们转换为 “弯引号”（左右单引号），因此上
面引用的符号显示为 ‘case-fold-search’。源代码字符串也可以直接使用弯引号
。


File: eintr.info,  Node: zap-to-char interactive,  Next: zap-to-char body,  Prev: Complete zap-to-char,  Up: zap-to-char

8.1.1 ‘interactive’ 表达式
--------------------------

‘zap-to-char’ 命令中的交互式表达式如下：

     (interactive "p\ncZap to char: ")

   引号内的部分，‘"p\ncZap to char: "’，指定了两个不同的信息。首先，最简
单的是 ‘p’。这一部分与下一部分由换行符 ‘\n’ 分隔。‘p’ 表示函数的第一个参
数将传递一个 “processed prefix” 的值。前缀参数通过键入 ‘C-u’ 和一个数字
，或者 ‘M-’ 和一个数字传递。如果在不带前缀的情况下交互调用该函数，则将 1
传递给此参数。

   ‘"p\ncZap to char: "’ 的第二部分是 ‘cZap to char: ’。在这一部分中，小
写的 ‘c’ 表示 ‘interactive’ 期望一个提示，并且参数将是一个字符。提示跟在
‘c’ 后面，是字符串 ‘Zap to char: ’（冒号后面有一个空格，使其看起来更好）
。

   所有这些都是为了准备 ‘zap-to-char’ 的参数，以使它们具有正确的类型，并
为用户提供提示。

   在只读缓冲区中，‘zap-to-char’ 函数将文本复制到 kill ring，但不删除它
。回显区显示一条消息，指示缓冲区是只读的。此外，终端可能会发出哔声或闪烁
提醒。


File: eintr.info,  Node: zap-to-char body,  Next: search-forward,  Prev: zap-to-char interactive,  Up: zap-to-char

8.1.2 ‘zap-to-char’函数的主体
-----------------------------

‘zap-to-char’函数的主体包含了用于删除（即移除）文本的代码，该文本位于光
标当前位置到指定字符（包括该字符）的区域。

   代码的第一部分如下：

     (if (char-table-p translation-table-for-input)
         (setq char (or (aref translation-table-for-input char) char)))
     (kill-region (point) (progn
                            (search-forward (char-to-string char) nil nil arg)
                            (point)))

‘char-table-p’是一个前文未见的函数。它用于确定其参数是否为字符表。当是字
符表时，它将传递给‘zap-to-char’的字符设置为其中之一（如果该字符存在），
否则设置为字符本身。（这对于非欧洲语言中的某些字符很重要。‘aref’函数从数
组中提取元素。它是一个特定于数组的函数，本文档不详细描述。*Note Arrays:
(elisp)Arrays.）

‘(point)’是光标的当前位置。

   代码的下一部分是一个使用‘progn’的表达式。‘progn’的主体由对
‘search-forward’和‘point’的调用组成。

   在学习‘progn’之前，了解一下‘search-forward’会更容易理解，因此我们将先
看看‘search-forward’，然后再看‘progn’。


File: eintr.info,  Node: search-forward,  Next: progn,  Prev: zap-to-char body,  Up: zap-to-char

8.1.3 ‘search-forward’函数
--------------------------

‘search-forward’函数用于在‘zap-to-char’中定位要删除的字符。如果搜索成功
，‘search-forward’将光标立即置于目标字符串的最后一个字符之后。（在
‘zap-to-char’中，目标字符串只有一个字符长。‘zap-to-char’使用
‘char-to-string’函数确保计算机将该字符视为字符串。）如果搜索是向后的，
‘search-forward’将光标放在目标的第一个字符之前。此外，‘search-forward’返
回‘t’表示真（移动光标因此是一个副作用）。

   在‘zap-to-char’中，‘search-forward’函数如下：

     (search-forward (char-to-string char) nil nil arg)

   ‘search-forward’函数接受四个参数：

  1. 第一个参数是目标，即要搜索的内容。这必须是一个字符串，例如‘"z"’。

     正好传递给‘zap-to-char’的参数是一个单个字符。由于计算机的构造方式，
     Lisp解释器可能会将单个字符视为与字符串不同。在计算机内部，单个字符
     具有与一个字符的字符串不同的电子格式。（计算机中通常可以用一个字节
     精确地记录一个单个字符；但字符串可能更长，计算机需要为此做好准备。
     ）因此，‘zap-to-char’函数接收的字符必须在计算机内部从一种格式转换为
     另一种格式；否则，‘search-forward’函数将失败。使用
     ‘char-to-string’函数进行此转换。

  2. 第二个参数限制了搜索的范围；它指定为缓冲区中的位置。在这种情况下，
     搜索可以到达缓冲区的末尾，因此未设置边界，第二个参数为‘nil’。

  3. 第三个参数告诉函数如果搜索失败应该做什么——它可以发出错误（并打印一
     条消息），或者返回‘nil’。将‘nil’作为第三个参数会导致函数在搜索失败
     时发出错误。

  4. ‘search-forward’的第四个参数是重复计数——要查找字符串的出现次数。此
     参数是可选的，如果函数在没有重复计数的情况下调用，则此参数将传递值
     1。如果此参数为负数，则搜索将向后进行。

   在模板形式中，‘search-forward’表达式如下：

     (search-forward "TARGET-STRING"
                     LIMIT-OF-SEARCH
                     WHAT-TO-DO-IF-SEARCH-FAILS
                     REPEAT-COUNT)

   接下来我们将看一下‘progn’。


File: eintr.info,  Node: progn,  Next: Summing up zap-to-char,  Prev: search-forward,  Up: zap-to-char

8.1.4 ‘progn’特殊形式
---------------------

‘progn’是一种特殊形式，它导致按顺序评估其每个参数，然后返回最后一个参数
的值。前面的表达式仅为它们执行的副作用而进行评估。它们产生的值被丢弃。

   ‘progn’表达式的模板非常简单：

     (progn
       BODY...)

   在‘zap-to-char‘中，‘progn’表达式必须执行两个操作：将点放置在准确的位
置，并返回点的位置，以便‘kill-region’知道要删除多远。

   ‘progn’的第一个参数是‘search-forward’。当‘search-forward’找到字符串时
，该函数将点立即置于目标字符串的最后一个字符之后。（在本例中，目标字符串
只有一个字符长。）如果搜索是向后的，则‘search-forward’将点置于目标的第一
个字符之前。点的移动是一个副作用。

   ‘progn’的第二个也是最后一个参数是表达式‘(point)’。此表达式返回点的值
，而在这种情况下，它将是由‘search-forward’移动到的位置。（在源代码中，一
行指示函数转到前一个字符（如果它是向前的）的代码在1999年被注释掉了；我不
记得这个功能或错误是否曾经是分布源代码的一部分。）‘point’的值由‘progn’表
达式返回，并作为‘kill-region’的第二个参数传递。


File: eintr.info,  Node: Summing up zap-to-char,  Prev: progn,  Up: zap-to-char

8.1.5 总结‘zap-to-char’
-----------------------

现在我们已经看到了‘search-forward’和‘progn’的工作原理，我们可以看到
‘zap-to-char’函数是如何整体工作的。

   ‘kill-region’的第一个参数是在给定‘zap-to-char’命令时光标的位置——即那
个时刻的点的值。在‘progn’内，搜索函数然后将点移动到刚刚删除的字符之后，
并且‘point’返回此位置的值。‘kill-region’函数将这两个点的值组合在一起，第
一个作为区域的起始，第二个作为区域的结束，然后删除该区域。

   ‘progn’特殊形式是必需的，因为‘kill-region’命令接受两个参数；如果
‘search-forward’和‘point’表达式被顺序写为两个额外的参数，它将失败。
‘progn’表达式是‘kill-region’的单个参数，并返回‘kill-region’所需的唯一值
作为其第二个参数。


File: eintr.info,  Node: kill-region,  Next: copy-region-as-kill,  Prev: zap-to-char,  Up: Cutting & Storing Text

8.2 ‘kill-region’
=================

‘zap-to-char’ 函数使用 ‘kill-region’ 函数。这个函数从一个区域裁剪文本并
将其复制到 kill ring 中，然后可以从中检索该文本。

   该函数的 Emacs 22 版本使用了 ‘condition-case’ 和
‘copy-region-as-kill’，我们将对两者进行解释。‘condition-case’ 是一个重要
的特殊形式。

   实质上，‘kill-region’ 函数调用 ‘condition-case’，它接受三个参数。在这
个函数中，第一个参数什么也不做。第二个参数包含当一切顺利时执行的代码。第
三个参数包含在出现错误时调用的代码。

* Menu:

* Complete kill-region::        函数定义。
* condition-case::              处理问题。
* Lisp macro::


File: eintr.info,  Node: Complete kill-region,  Next: condition-case,  Up: kill-region

完整的 ‘kill-region’ 定义
-------------------------

我们将逐步讲解 ‘condition-case’ 代码。首先，让我们看一下 ‘kill-region’ 的
定义，附带注释：

     (defun kill-region (beg end)
       "Kill (\"cut\") text between point and mark.
     This deletes the text from the buffer and saves it in the kill ring.
     The command \\[yank] can retrieve it from there. ... "

       ;; • 由于顺序很重要，首先传递 point。
       (interactive (list (point) (mark)))
       ;; • 并告诉我们如果无法剪切文本要怎么办。
       ;; 'unless' 是没有 then 部分的 'if'。
       (unless (and beg end)
         (error "The mark is not set now, so there is no region"))

       ;; • 'condition-case' 接受三个参数。
       ;;    如果第一个参数是 nil，就像这里一样，
       ;;    错误信号的信息就不会被存储以供其他函数使用。
       (condition-case nil

           ;; • 'condition-case' 的第二个参数告诉 Lisp 解释器
           ;;    一切正常时要做什么。

           ;;    它以一个 'let' 函数开始，提取字符串并测试它是否存在。
           ;;    如果存在（这是 'when' 检查的内容），它调用一个 'if' 函数，
           ;;    用于确定前一个命令是否是对 'kill-region' 的另一个调用；
           ;;    如果是，则新文本附加到先前的文本；如果不是，则调用
           ;;    另一个函数 'kill-new'。

           ;;    'kill-append' 函数连接新字符串和旧字符串。
           ;;    'kill-new' 函数将文本插入到 kill 环中的新项目中。

           ;;    'when' 是没有 else 部分的 'if'。
           ;;    第二个 'when' 再次检查当前字符串是否存在；
           ;;    此外，它还检查前一个命令是否是对 'kill-region' 的另一个调用。
           ;;    如果其中一个条件为真，则将当前命令设置为 'kill-region'。
           (let ((string (filter-buffer-substring beg end t)))
             (when string                    ; 如果 BEG = END，则 STRING 为 nil
               ;; 将该字符串添加到 kill ring 中，以某种方式。
               (if (eq last-command 'kill-region)
                   ;;    − 'yank-handler' 是传递给 'kill-region' 的可选参数，
                   ;;    告诉 'kill-append' 和 'kill-new' 函数如何处理添加到文本中的属性，
                   ;;    例如 'bold' 或 'italics'。
                   (kill-append string (< end beg) yank-handler)
                 (kill-new string nil yank-handler)))
             (when (or string (eq last-command 'kill-region))
               (setq this-command 'kill-region))
             nil)

         ;;  • 'condition-case' 的第三个参数告诉解释器
         ;;    发生错误时要做什么。
         ;;    第三个参数有一个条件部分和一个体部分。
         ;;    如果满足条件（在这种情况下，如果文本或缓冲区是只读的）
         ;;    那么就执行体部分。
         ((buffer-read-only text-read-only) ;; 条件部分
          ;; ... 体部分
          (copy-region-as-kill beg end)
          ;;    接下来，同样作为体部分的一部分，设置 this-command，
          ;;    这样它将在错误中被设置。
          (setq this-command 'kill-region)
          ;;    最后，在体部分，如果可以在不发出错误的情况下将文本复制到 kill ring 中，则发送消息，否则不发送。
          (if kill-read-only-ok
              (progn (message "Read only text copied to kill ring") nil)
            (barf-if-buffer-read-only)
            ;; 如果缓冲区不是只读的，则文本是只读的。
            (signal 'text-read-only (list (current-buffer)))))))


File: eintr.info,  Node: condition-case,  Next: Lisp macro,  Prev: Complete kill-region,  Up: kill-region

8.2.1 ‘condition-case’
----------------------

正如我们之前所看到的（*note Generate an Error Message: Making Errors.）
，当Emacs Lisp解释器在评估表达式时遇到问题时，它会为您提供帮助；在行话中
，这被称为“发出错误信号”。通常，计算机会停止程序并显示一条消息。

   然而，一些程序执行复杂的操作。它们在发生错误时不应该简单地停止。在
‘kill-region’函数中，最可能的错误是您尝试删除只读且无法删除的文本。因此
，‘kill-region’函数包含处理此情况的代码。这段代码构成了‘kill-region’函数
的主体，位于‘condition-case’特殊形式中。

   ‘condition-case’的模板如下：

     (condition-case
       VAR
       BODYFORM
       ERROR-HANDLER...)

   第二个参数，BODYFORM，很直观。‘condition-case’特殊形式导致Lisp解释器
评估BODYFORM中的代码。如果没有错误发生，特殊形式将返回代码的值并产生副作
用（如果有的话）。

   简而言之，‘condition-case’表达式的BODYFORM部分决定一切正常时应该发生
什么。

   然而，如果发生错误，除了其他动作，生成错误信号的函数还将定义一个或多
个错误条件名。

   错误处理程序是‘condition-case’的第三个参数。错误处理程序有两个部分，
一个是CONDITION-NAME，另一个是BODY。如果错误处理程序的CONDITION-NAME部分
与错误生成的条件名匹配，那么将运行错误处理程序的BODY部分。

   正如您所期望的那样，错误处理程序的CONDITION-NAME部分可以是单个条件名
或条件名列表。

   此外，完整的‘condition-case’表达式可能包含多个错误处理程序。当发生错
误时，将运行第一个适用的处理程序。

   最后，‘condition-case’表达式的第一个参数，VAR参数，有时绑定到包含有关
错误的信息的变量。但是，如果该参数为‘nil’，如在‘kill-region’中的情况，该
信息将被丢弃。

   简而言之，在‘kill-region’函数中，‘condition-case’的代码如下：

     如果没有错误，运行仅此代码
         但是，如果发生错误，运行另一段代码。


File: eintr.info,  Node: Lisp macro,  Prev: condition-case,  Up: kill-region

8.2.2 Lisp macro
----------------

在期望一切顺利的情况下评估的‘condition-case’表达式的一部分具有‘when’。该
代码使用‘when’来确定‘string’变量是否指向存在的文本。

   ‘when’表达式只是程序员的便利。它是一个没有else子句可能性的‘if’。在你
的脑海中，你可以用‘if’替换‘when’并理解发生了什么。这就是Lisp解释器所做的
。

   从技术上讲，‘when’是一个Lisp宏。Lisp宏使您能够定义新的控制结构和其他
语言功能。它告诉解释器如何计算另一个Lisp表达式，该表达式将进而计算值。在
这种情况下，另一个表达式是一个‘if’表达式。

   ‘kill-region’函数定义还有一个‘unless’宏；它是‘when’的反义词。
‘unless’宏是一个没有then子句的‘if’。

   有关Lisp宏的更多信息，请参阅*note Macros: (elisp)Macros.。C编程语言也
提供宏。它们是不同的，但同样有用。

   关于‘when’宏，在‘condition-case’表达式中，当字符串具有内容时，然后执
行另一个条件表达式。这是一个带有then-part和else-part的‘if’。

     (if (eq last-command 'kill-region)
         (kill-append string (< end beg) yank-handler)
       (kill-new string nil yank-handler))

   如果前一个命令是另一个对‘kill-region’的调用，则评估then-part；否则，
评估else-part。

   ‘yank-handler’是传递给‘kill-region’的可选参数，告诉‘kill-append’和
‘kill-new’函数如何处理添加到文本中的属性，例如粗体或斜体。

   ‘last-command’是Emacs附带的一个我们之前没有见过的变量。通常，每当执行
函数时，Emacs都会将‘last-command’的值设置为前一个命令。

   在这个定义片段中，‘if’表达式检查前一个命令是否为‘kill-region’。如果是
，

     (kill-append string (< end beg) yank-handler)

将新剪贴文本的副本连接到刚刚剪贴的文本在kill ring中。


File: eintr.info,  Node: copy-region-as-kill,  Next: Digression into C,  Prev: kill-region,  Up: Cutting & Storing Text

8.3 ‘copy-region-as-kill’
=========================

‘copy-region-as-kill’函数将文本缓冲区中的一段文本复制并（通过
‘kill-append’或‘kill-new’）保存在‘kill-ring’中。

   如果在执行‘kill-region’命令之后立即调用‘copy-region-as-kill’，Emacs将
新复制的文本附加到先前复制的文本上。这意味着如果您粘贴文本，则会得到来自
此次和上一次操作的所有文本。另一方面，如果在‘copy-region-as-kill’之前执
行了其他命令，则该函数将文本复制到kill环中的一个单独条目中。

* Menu:

* Complete copy-region-as-kill::  ‘copy-region-as-kill’函数的完整定义。
* copy-region-as-kill body::      ‘copy-region-as-kill’的主体部分。


File: eintr.info,  Node: Complete copy-region-as-kill,  Next: copy-region-as-kill body,  Up: copy-region-as-kill

‘copy-region-as-kill’函数的完整定义
-----------------------------------

以下是版本22的‘copy-region-as-kill’函数的完整文本：

     (defun copy-region-as-kill (beg end)
       "将区域保存为已杀死，但不要杀死它。
     在瞬时标记模式下，取消激活标记。
     如果`interprogram-cut-function'非空，还为窗口系统剪切和粘贴保存文本。"
       (interactive "r")
       (if (eq last-command 'kill-region)
           (kill-append (filter-buffer-substring beg end) (< end beg))
         (kill-new (filter-buffer-substring beg end)))
       (if transient-mark-mode
           (setq deactivate-mark t))
       nil)

   像往常一样，此函数可以分为其组成部分：

     (defun copy-region-as-kill (ARGUMENT-LIST)
       "DOCUMENTATION..."
       (interactive "r")
       BODY...)

   参数是‘beg’和‘end’，函数以‘"r"’交互，因此两个参数必须引用区域的起始和
结束。如果您从文档开头阅读到这里，理解函数的这些部分几乎变得很常规。

   文档有点令人困惑，除非您记得“kill”一词的意义与通常不同。瞬时标记和
‘interprogram-cut-function’的注释解释了某些副作用。

   一旦设置了标记，缓冲区始终包含一个区域。如果愿意，可以使用瞬时标记模
式临时突出显示区域。 （没有人希望一直突出显示区域，因此瞬时标记模式仅在
适当的时候突出显示。许多人关闭瞬时标记模式，因此区域永远不会被突出显示。
）

   此外，窗口系统允许在不同程序之间复制、剪切和粘贴。例如，在X窗口系统中
，‘interprogram-cut-function’函数是‘x-select-text’，它与窗口系统的Emacs
kill环的等价物一起工作。

   ‘copy-region-as-kill’函数的主体以一个‘if’子句开始。该子句的作用是区分
两种不同的情况：是否立即在先前的‘kill-region’命令之后执行此命令。在第一
种情况下，新区域将附加到先前复制的文本。否则，它将作为一个独立的文本片段
插入到kill环的开头。

   函数的最后两行阻止区域在瞬时标记模式打开时突出显示。


File: eintr.info,  Node: copy-region-as-kill body,  Prev: Complete copy-region-as-kill,  Up: copy-region-as-kill

8.3.1 ‘copy-region-as-kill’的主体
---------------------------------

‘copy-region-as-kill’函数的工作方式与‘kill-region’函数类似。两者都被编写
为使连续两次或更多次的杀死将它们的文本组合成单个条目。如果从kill环粘贴文
本，则会得到一个整体。此外，从当前光标位置向前杀死的杀死将添加到先前复制
的文本的末尾，而将文本向后复制的命令将其添加到先前复制的文本的开头。这样
，文本中的单词保持正确的顺序。

   与‘kill-region’一样，‘copy-region-as-kill’函数利用了‘last-command’变
量，该变量跟踪先前的Emacs命令。

* Menu:

* last-command & this-command::
* kill-append function::
* kill-new function::


File: eintr.info,  Node: last-command & this-command,  Next: kill-append function,  Up: copy-region-as-kill body

‘last-command’和‘this-command’
..............................

通常情况下，每当执行函数时，Emacs将‘this-command’的值设置为正在执行的函
数（在本例中将是‘copy-region-as-kill’）。同时，Emacs将‘last-command’的值
设置为‘this-command’的先前值。

   在‘copy-region-as-kill’函数的主体的第一部分中，一个‘if’表达式确定
‘last-command’的值是否为‘kill-region’。如果是，‘if’表达式的then-part将被
评估；它使用‘kill-append’函数将此次调用函数时复制的文本与kill环的第一个
元素（CAR）中已有的文本连接起来。另一方面，如果‘last-command’的值不是
‘kill-region’，那么‘copy-region-as-kill’函数将使用‘kill-new’函数将一个新
元素附加到kill环中。

   ‘if’表达式如下所示；它使用‘eq’：

       (if (eq last-command 'kill-region)
           ;; then-part
           (kill-append  (filter-buffer-substring beg end) (< end beg))
         ;; else-part
         (kill-new  (filter-buffer-substring beg end)))

   （‘filter-buffer-substring’函数返回缓冲区的过滤子字符串，如果有的话。
可选地——这里没有参数，因此也没有做任何事——该函数可以删除初始文本或返回不
带其属性的文本；此函数是较早的‘buffer-substring’函数的替代，该函数在实现
文本属性之前出现。）

‘eq’函数测试其第一个参数是否与其第二个参数相同的Lisp对象。‘eq’函数类似于
‘equal’函数，因为它用于测试相等性，但不同之处在于它确定两个表示实际上是
计算机内部相同对象，只是具有不同的名称。‘equal’确定两个表达式的结构和内
容是否相同。

   如果先前的命令是‘kill-region’，则Emacs Lisp解释器调用‘kill-append’函
数。


File: eintr.info,  Node: kill-append function,  Next: kill-new function,  Prev: last-command & this-command,  Up: copy-region-as-kill body

‘kill-append’ 函数
..................

‘kill-append’ 函数的定义如下：

     (defun kill-append (string before-p &optional yank-handler)
       "将STRING追加到kill环中最新的kill的末尾。
     如果BEFORE-P非空，则将STRING插入到kill的开头。
     ... "
       (let* ((cur (car kill-ring)))
         (kill-new (if before-p (concat string cur) (concat cur string))
                   (or (= (length cur) 0)
                       (equal yank-handler
                              (get-text-property 0 'yank-handler cur)))
                   yank-handler)))

‘kill-append’ 函数非常直观。它使用了稍后我们将详细讨论的 ‘kill-new’ 函数
。

   （此外，该函数提供了一个可选的参数叫做 ‘yank-handler’；当调用时，此参
数告诉函数如何处理添加到文本的属性，比如粗体或斜体。）

   它使用 ‘let*’ 函数将kill环的第一个元素的值设置为 ‘cur’。（我不知道为
什么函数不使用 ‘let’ 替代；表达式中只设置了一个值。也许这是一个不会产生
问题的bug？）

   考虑到条件语句是 ‘kill-new’ 的两个参数之一。它使用 ‘concat’ 将新文本
连接到kill环的 CAR（第一个元素）。无论是插入还是追加文本，都取决于 ‘if’
表达式的结果：

     (if before-p                            ; if-part
         (concat string cur)                 ; then-part
       (concat cur string))                  ; else-part

如果要删除的区域位于上一次命令中删除的区域之前，那么它应该插入到之前保存
的文本之前；反之，如果删除的文本跟随刚刚删除的文本，它应该追加到先前的文
本之后。 ‘if’ 表达式依赖于谓词 ‘before-p’ 来决定新保存的文本是应该放在先
前保存的文本之前还是之后。

   符号 ‘before-p’ 是 ‘kill-append’ 函数的参数之一的名称。当评估
‘kill-append’ 函数时，它被绑定到通过评估实际参数返回的值。在这种情况下，
这是表达式 ‘(< end beg)’。此表达式不直接确定此命令中删除的文本是在上次命
令中删除的文本之前还是之后；它的作用是确定变量 ‘end’ 的值是否小于变量
‘beg’ 的值。如果是，这意味着用户很可能朝着缓冲区的开头前进。此外，谓词表
达式 ‘(< end beg)’ 的评估结果将为真，文本将在先前文本之前插入。另一方面
，如果变量 ‘end’ 的值大于变量 ‘beg’ 的值，则文本将在先前文本之后追加。

   当新保存的文本将被插入时，字符串与新文本将被连接到旧文本之前：

     (concat string cur)

但如果文本将被追加，它将在旧文本之后连接：

     (concat cur string))

   为了理解这是如何工作的，我们首先需要复习一下 ‘concat’ 函数。‘concat’
函数将两个文本字符串链接或合并在一起。结果是一个字符串。例如：

     (concat "abc" "def")
          ⇒ "abcdef"

     (concat "new "
             (car '("first element" "second element")))
          ⇒ "new first element"

     (concat (car
             '("first element" "second element")) " modified")
          ⇒ "first element modified"

   现在我们可以理解 ‘kill-append’：它修改了kill环的内容。kill环是一个列
表，其中每个元素都是保存的文本。‘kill-append’ 函数使用 ‘kill-new’ 函数，
后者又使用 ‘setcar’ 函数。


File: eintr.info,  Node: kill-new function,  Prev: kill-append function,  Up: copy-region-as-kill body

‘kill-new’ 函数
...............

在版本22中，‘kill-new’ 函数的定义如下：

     (defun kill-new (string &optional replace yank-handler)
       "将STRING设为kill环中的最新kill。
     将`kill-ring-yank-pointer'设为指向它。

     如果`interprogram-cut-function'非nil，则将其应用于STRING。可选的第二个参数REPLACE非nil表示STRING将替换kill环的最前面，而不是被添加到列表中。
     ..."
       (if (> (length string) 0)
           (if yank-handler
               (put-text-property 0 (length string)
                                  'yank-handler yank-handler string))
         (if yank-handler
             (signal 'args-out-of-range
                     (list string "yank-handler specified for empty string"))))
       (if (fboundp 'menu-bar-update-yank-menu)
           (menu-bar-update-yank-menu string (and replace (car kill-ring))))
       (if (and replace kill-ring)
           (setcar kill-ring string)
         (push string kill-ring)
         (if (> (length kill-ring) kill-ring-max)
             (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
       (setq kill-ring-yank-pointer kill-ring)
       (if interprogram-cut-function
           (funcall interprogram-cut-function string (not replace))))

   （注意，此函数不是交互式的。）

   和往常一样，我们可以将这个函数分为几个部分来看。

   函数定义有一个可选的‘yank-handler’参数，当调用时告诉函数如何处理添加
到文本中的属性，比如粗体或斜体。我们将跳过这一点。

   文档的第一行有意义：

     将STRING设为kill环中的最新kill。

让我们暂时跳过文档的其余部分。

同样，让我们跳过初始的‘if’表达式以及涉及‘menu-bar-update-yank-menu’的那
些行代码。我们将在下面解释它们。

   关键的代码在这里：

       (if (and replace kill-ring)
           ;; 然后
           (setcar kill-ring string)
         ;; 否则
         (push string kill-ring)
         (if (> (length kill-ring) kill-ring-max)
             ;; 避免kill环过长
             (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
       (setq kill-ring-yank-pointer kill-ring)
       (if interprogram-cut-function
           (funcall interprogram-cut-function string (not replace))))

   条件测试是 ‘(and replace kill-ring)’。当满足两个条件时，这将为真：
kill环中有内容，并且‘replace’变量为真。

   当‘kill-append’函数将‘replace’设置为真时，且kill环中至少有一项时，将
执行‘setcar’表达式：

     (setcar kill-ring string)

   ‘setcar’函数实际上将‘kill-ring’列表的第一个元素更改为‘string’的值。它
替换第一个元素。

   另一方面，如果kill环为空，或者replace为假，则执行条件的else部分：

     (push string kill-ring)

   ‘push’将其第一个参数推入第二个参数。它类似于较旧的

     (setq kill-ring (cons string kill-ring))

   或者较新的

     (add-to-list kill-ring string)

当为假时，表达式首先通过将要被杀死的字符串作为新元素添加到旧kill环中构造
了新版本的kill环（这就是‘push’的作用）。然后它执行第二个‘if’子句。这第二
个‘if’子句防止kill环变得过长。

   让我们按顺序查看这两个表达式。

   ‘push’ else-part的行将新的kill环的值设置为将要被杀死的字符串添加到旧
kill环中得到的值。

   通过以下示例，我们可以看到它是如何工作的。

   首先，

     (setq example-list '("here is a clause" "another clause"))

通过使用‘C-x C-e’评估此表达式后，您可以评估‘example-list’并查看其返回值
：

     example-list
          ⇒ ("here is a clause" "another clause")

现在，我们可以通过评估以下表达式将一个新元素添加到此列表中：

     (push "a third clause" example-list)

当我们评估‘example-list’时，我们发现其值为：

     example-list
          ⇒ ("a third clause" "here is a clause" "another clause")

因此，通过‘push’添加了第三个子句。

   现在是‘if’子句的第二部分。此表达式防止kill环变得过长。它看起来是这样
的：

     (if (> (length kill-ring) kill-ring-max)
         (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil))

   代码检查kill环的长度是否大于允许的最大长度。这是‘kill-ring-max’（默认
为120）的值。如果kill环的长度太长，则此代码将最后一个元素设置为‘nil’。它
通过使用两个函数‘nthcdr’和‘setcdr’来实现。

   我们之前看过‘setcdr’（*note ‘setcdr’: setcdr.）。它设置列表的CDR，就
像‘setcar’设置列表的CAR一样。但是，在这种情况下，‘setcdr’不会设置整个
kill环的CDR；‘nthcdr’函数用于使其设置kill环的倒数第二个元素的CDR——这意味
着由于倒数第二个元素的CDR是kill环的最后一个元素，它将设置kill环的最后一
个元素。

   ‘nthcdr’函数通过重复获取列表的CDR来工作——它获取CDR的CDR的CDR等等。它
这样做N次并返回结果。(*Note ‘nthcdr’: nthcdr.)

   因此，如果我们有一个应该是三个元素长的四个元素列表，我们可以将倒数第
二个元素的CDR设置为‘nil’，从而缩短列表。（如果将最后一个元素设置为除
‘nil’之外的其他值，您可以这样做，那么您将不会缩短列表。*Note ‘setcdr’:
setcdr.）

   通过依次评估以下三个表达式，您可以看到缩短的效果。首先将‘trees’的值设
置为‘(maple oak pine birch)’，然后将其第二个CDR的CDR设置为‘nil’，然后找
到‘trees’的值：

     (setq trees (list 'maple 'oak 'pine 'birch))
          ⇒ (maple oak pine birch)

     (setcdr (nthcdr 2 trees) nil)
          ⇒ nil

     trees
          ⇒ (maple oak pine)

(‘setcdr’表达式返回的值为‘nil’，因为它将CDR设置为‘nil’。)

   重申一下，在‘kill-new’中，‘nthcdr’函数取kill环的最大允许大小减一的次
数，‘setcdr’函数将其CDR设置为那个元素（这意味着由于倒数第二个元素的CDR是
kill环的最后一个元素，它将设置kill环的最后一个元素）。这样可以防止kill环
变得过长。

   ‘kill-new’函数中倒数第二个表达式是

     (setq kill-ring-yank-pointer kill-ring)

   ‘kill-ring-yank-pointer’是一个全局变量，被设置为‘kill-ring’。

   尽管‘kill-ring-yank-pointer’被称为‘指针’，但它和kill环一样是一个变量
。但是，为了帮助人们理解该变量的用法，选择了这个名称。

   现在，回到函数体中的早期表达式：

       (if (fboundp 'menu-bar-update-yank-menu)
            (menu-bar-update-yank-menu string (and replace (car kill-ring))))

它以一个‘if’表达式开始

   在这种情况下，该表达式首先测试‘menu-bar-update-yank-menu’是否存在作为
函数，并且如果存在，则调用它。‘fboundp’函数返回true，如果它测试的符号具
有非空的函数定义。如果符号的函数定义为空，我们将收到错误消息，就像我们故
意创建错误一样（*note 生成错误消息: Making Errors.）。

然后部分包含一个表达式，其第一个元素是‘and’函数。

   特殊形式 ‘and’ 对其每个参数进行求值，直到其中一个参数返回值为 ‘nil’ 为
止，此时 ‘and’ 表达式返回 ‘nil’；然而，如果没有任何参数返回 ‘nil’，则返
回最后一个参数的求值结果。 （由于这样的值不是 ‘nil’，在Emacs Lisp中被视
为真值。）换句话说，只有当所有参数都为真时，‘and’ 表达式才返回真值。
(*Note Second Buffer Related Review::.)

   该表达式确定了 ‘menu-bar-update-yank-menu’ 的第二个参数是否为真。

   ‘menu-bar-update-yank-menu’ 是使得可以在菜单条的编辑项目的“选择和粘贴
”菜单中使用的函数之一；使用鼠标，您可以查看已保存的各种文本片段，并选择
一个片段进行粘贴。

   ‘kill-new’ 函数中的最后一个表达式将新复制的字符串添加到用于在窗口系统
中运行的不同程序之间复制和粘贴的任何设施中。例如，在X Windowing系统中，
‘x-select-text’ 函数将字符串存储在由X操作的内存中。您可以在另一个程序中
粘贴该字符串，例如Xterm。

   该表达式如下：

       (if interprogram-cut-function
           (funcall interprogram-cut-function string (not replace))))

   如果存在 ‘interprogram-cut-function’，则Emacs执行 ‘funcall’，它又调用
其第一个参数作为函数，并将其余参数传递给它。 （顺便说一下，就我所看到的
，此 ‘if’ 表达式可以被类似于函数第一部分的 ‘and’ 表达式替代。）

   我们不打算进一步讨论窗口系统和其他程序，只是注意到这是一种使GNU
Emacs能够轻松而有效地与其他程序协同工作的机制。

   这段代码用于将文本放入kill环中，可以是与现有元素连接，也可以是作为新
元素。这引导我们进入了从缓冲区中删除文本的代码——yank命令。但在讨论yank命
令之前，最好先了解计算机中列表是如何实现的。这将解释“指针”一词的使用。但
在此之前，我们将离题讨论C。


File: eintr.info,  Node: Digression into C,  Next: defvar,  Prev: copy-region-as-kill,  Up: Cutting & Storing Text

8.4 进入C的插曲
===============

‘copy-region-as-kill’ 函数（参见*note ‘copy-region-as-kill’:
copy-region-as-kill.）使用了 ‘filter-buffer-substring’ 函数，而该函数又
使用了 ‘delete-and-extract-region’ 函数。它会删除区域的内容，而且一旦删
除就无法还原。

   与这里讨论的其他代码不同，‘delete-and-extract-region’ 函数不是用Emacs
Lisp编写的；它是用C编写的，是GNU Emacs系统的原语之一。由于它非常简单，我
将简要离开Lisp并在这里描述它。

   与许多其他Emacs原语一样，‘delete-and-extract-region’ 作为C宏的实例编
写，宏是代码的模板。完整的宏如下：

     DEFUN ("delete-and-extract-region", Fdelete_and_extract_region,
            Sdelete_and_extract_region, 2, 2, 0,
            doc: /* 删除START和END之间的文本并返回它。 */)
       (Lisp_Object start, Lisp_Object end)
     {
       validate_region (&start, &end);
       if (XFIXNUM (start) == XFIXNUM (end))
         return empty_unibyte_string;
       return del_range_1 (XFIXNUM (start), XFIXNUM (end), 1, 1);
     }

   在不深入宏编写过程的细节的情况下，让我指出该宏以单词 ‘DEFUN’ 开头。选
择单词 ‘DEFUN’ 是因为该代码与Lisp中的 ‘defun’ 具有相同的目的。（‘DEFUN’
C宏在‘emacs/src/lisp.h’中定义。）

   单词 ‘DEFUN’ 后面跟着括号内的七个部分：

   • 第一个部分是Lisp中给定的函数名称，‘delete-and-extract-region’。

   • 第二部分是C中的函数名称，‘Fdelete_and_extract_region’。按照惯例，它
     以 ‘F’ 开头。由于C中不使用连字符，而是使用下划线。

   • 第三部分是记录此函数信息以供内部使用的C常量结构的名称。它是C中函数
     的名称，但以 ‘S’ 开头而不是 ‘F’。

   • 第四和第五部分指定函数可以有的参数的最小和最大数量。此函数要求精确
     地有2个参数。

   • 第六部分几乎与在Lisp中编写的函数中的 ‘interactive’ 声明后面的参数相
     似：一个字母，然后是一个提示，也许还有一个数字。与Lisp不同的是，当
     使用零参数调用宏时。然后你写一个 ‘0’（它是一个空字符串），就像这个
     宏一样。

     如果要指定参数，你会将它们放在引号之间。用于 ‘goto-char’ 的C宏包括
     在此位置添加 ‘"NGoto char: "’ 以指示该函数期望一个原始前缀，这种情
     况下是缓冲区中的数值位置，并提供提示。

   • 第七部分是文档字符串，就像Emacs Lisp中的函数的文档字符串一样。这是
     以C注释的形式编写的。（构建Emacs时，程序‘lib-src/make-docfile’提取
     这些注释并用它们制作文档。）

   在C宏中，接下来是形式参数，包括对象类型的说明，然后是宏的主体。对于
‘delete-and-extract-region’，主体包括以下四行：

     validate_region (&start, &end);
     if (XFIXNUM (start) == XFIXNUM (end))
       return empty_unibyte_string;
     return del_range_1 (XFIXNUM (start), XFIXNUM (end), 1, 1);

   ‘validate_region’ 函数检查作为区域开始和结束传递的值是否是正确的类型
并且是否在范围内。如果开始和结束位置相同，则返回一个空字符串。

   ‘del_range_1’ 函数实际上删除文本。这是一个复杂的函数，我们不会深入研
究。它更新缓冲区并执行其他操作。但是，值得注意的是传递给 ‘del_range_1’ 的
两个参数。这些是 ‘XFIXNUM (start)’ 和 ‘XFIXNUM (end)’。

   就C语言而言，‘start’ 和 ‘end’ 是标记要删除的区域的开始和结束的两个不
透明的值。更准确地说，需要更多专业知识才能理解，这两个值的类型是
‘Lisp_Object’，它可能是C指针、C整数或C结构；C代码通常不应关心
‘Lisp_Object’ 的实现方式。

   ‘XFIXNUM’ 是一个C宏，从较长的比特集中提取相关整数；类型比特被丢弃。

   ‘delete-and-extract-region’ 中的命令如下：

     del_range_1 (XFIXNUM (start), XFIXNUM (end), 1, 1);

它删除开始位置 ‘start’ 和结束位置 ‘end’ 之间的区域。

   从编写Lisp的人的角度来看，Emacs非常简单；但是在底层隐藏着大量的复杂性
，以使一切正常工作。


File: eintr.info,  Node: defvar,  Next: cons & search-fwd Review,  Prev: Digression into C,  Up: Cutting & Storing Text

8.5 使用 ‘defvar’ 初始化变量
============================

‘copy-region-as-kill’ 函数是用Emacs Lisp编写的。其中的两个函数，
‘kill-append’ 和 ‘kill-new’，复制缓冲区中的一段区域并将其保存在一个名为
‘kill-ring’ 的变量中。本节描述了如何使用 ‘defvar’ 特殊形式创建和初始化
‘kill-ring’ 变量。

   （再次注意，术语 ‘kill-ring’ 是不准确的。从缓冲区中剪切出来的文本可以
被还原；它不是一个尸体环，而是一个可以复活的文本环。）

   在Emacs Lisp中，诸如 ‘kill-ring’ 这样的变量是通过使用 ‘defvar’ 特殊形
式创建并赋予初始值的。其名称来自于“定义变量”。

   ‘defvar’ 特殊形式类似于 ‘setq’，因为它设置变量的值。但与 ‘setq’ 不同
的有两点：首先，它仅在变量尚未具有值时设置变量的值。如果变量已经有值，
‘defvar’ 就不会覆盖现有值。其次，‘defvar’ 具有文档字符串。

   （有一个相关的宏，‘defcustom’，用于用户自定义的变量。它比 ‘defvar’ 更
强大。 （*Note 使用 ‘defcustom’ 设置变量: defcustom.）

* Menu:

* See variable current value::
* defvar and asterisk::


File: eintr.info,  Node: See variable current value,  Next: defvar and asterisk,  Up: defvar

查看变量的当前值
----------------

您可以使用 ‘describe-variable’ 函数查看任何变量的当前值，通常通过键入
‘C-h v’ 调用。如果在提示时键入 ‘C-h v’ 然后键入 ‘kill-ring’（然后按
<RET>），您将看到当前剪切环中的内容，这可能很多！相反，如果在本次Emacs会
话中除了阅读本文档之外什么都没有做，那么可能什么都没有。此外，您将看到
‘kill-ring’ 的文档：

     文档：
     已删除文本序列的列表。
     由于剪切环应该与窗口系统提供的剪切和粘贴功能良好地交互，因此应使用此变量
     与`interprogram-cut-function'和
     `interprogram-paste-function'良好交互。 函数`kill-new'，
     `kill-append'和`current-kill'应实现此交互；
     您可能希望使用它们而不是直接操作剪切环。

   剪切环的定义如下：

     (defvar kill-ring nil
       "已删除文本序列的列表。
     ...")

在此变量定义中，变量被赋予初始值 ‘nil’，这是有道理的，因为如果您没有保存
任何内容，那么在执行 ‘yank’ 命令时您希望得到空白。文档字符串的写法与
‘defun’ 的文档字符串相同。与 ‘defun’ 的文档字符串一样，文档的第一行应该
是一个完整的句子，因为一些命令（如 ‘apropos’）仅打印文档的第一行。后续行
不应缩进，否则在使用 ‘C-h v’（‘describe-variable’）时会显得奇怪。


File: eintr.info,  Node: defvar and asterisk,  Prev: See variable current value,  Up: defvar

8.5.1 ‘defvar’ 和星号
---------------------

过去，Emacs 在内部变量和用户可能更改的变量上都使用了 ‘defvar’ 特殊形式。
尽管您仍然可以使用 ‘defvar’ 来定义用户可定制的变量，请改用 ‘defcustom’，
因为它提供了进入定制命令的路径。 （*Note 使用 ‘defcustom’ 指定变量:
defcustom.）

   当使用 ‘defvar’ 特殊形式指定变量时，您可以通过在其文档字符串的第一列
键入星号（‘*’）来区分用户可能想更改的变量和其他变量。例如：

     (defvar shell-command-default-error-buffer nil
       "*'shell-command' ...错误输出的缓冲区名称。
     ... ")

您可以（仍然可以）使用 ‘set-variable’ 命令临时更改
‘shell-command-default-error-buffer’ 的值。但是，使用 ‘set-variable’ 设
置的选项仅在编辑会话期间设置。新值在会话之间不会保存。每次Emacs启动时，
它都会读取原始值，除非您在 ‘.emacs’ 文件中更改了该值，要么手动设置它，要
么使用 ‘customize’。 *Note 您的 ‘.emacs’ 文件: Emacs Initialization.

   对我来说，‘set-variable’ 命令的主要用途是建议我可能希望在 ‘.emacs’ 文
件中设置的变量。现在有700多个这样的变量，太多了，记不住。幸运的是，在调
用 ‘M-x set-variable’ 命令后，您可以按 <TAB> 键查看变量的列表。 （*Note
检查和设置变量: (emacs)Examining.）


File: eintr.info,  Node: cons & search-fwd Review,  Next: search Exercises,  Prev: defvar,  Up: Cutting & Storing Text

8.6 Review
==========

这里是一些最近引入的函数的简要概述。

‘car’
‘cdr’
     ‘car’ 返回列表的第一个元素；‘cdr’ 返回列表的第二个及后续元素。

     例如：

          (car '(1 2 3 4 5 6 7))
               ⇒ 1
          (cdr '(1 2 3 4 5 6 7))
               ⇒ (2 3 4 5 6 7)

‘cons’
     ‘cons’通过将其第一个参数添加到其第二个参数前构造一个列表。

     例如：

          (cons 1 '(2 3 4))
               ⇒ (1 2 3 4)

‘funcall’
     ‘funcall’ 将其第一个参数作为函数求值，并将其余参数传递给其第一个参
     数。

‘nthcdr’
     返回在列表上对 CDR 进行 N 次操作的结果。 可以看作是“剩下的剩下”。

     例如：

          (nthcdr 3 '(1 2 3 4 5 6 7))
               ⇒ (4 5 6 7)

‘setcar’
‘setcdr’
     ‘setcar’ 改变列表的第一个元素；‘setcdr’ 改变列表的第二个及后续元素
     。

     例如：

          (setq triple (list 1 2 3))

          (setcar triple '37)

          triple
               ⇒ (37 2 3)

          (setcdr triple '("foo" "bar"))

          triple
               ⇒ (37 "foo" "bar")

‘progn’
     按顺序评估每个参数，然后返回最后一个的值。

     例如：

          (progn 1 2 3 4)
               ⇒ 4

‘save-restriction’
     记录当前缓冲区中生效的任何缩小范围，并在评估参数后恢复该缩小。

‘search-forward’
     搜索字符串，如果找到，移动点。使用正则表达式时，请使用类似的
     ‘re-search-forward’。(*Note 正则表达式搜索: Regexp Search, 了解正则
     表达式模式和搜索的解释。)

     ‘search-forward’ 和 ‘re-search-forward’ 需要四个参数：

       1. 要搜索的字符串或正则表达式。

       2. 可选地，搜索的限制。

       3. 可选地，如果搜索失败，返回 ‘nil’ 或错误消息。

       4. 可选地，重复搜索的次数；如果为负数，则向后搜索。

‘kill-region’
‘delete-and-extract-region’
‘copy-region-as-kill’

     ‘kill-region’ 剪切点和标记之间的文本，并将该文本存储在kill ring中，
     因此您可以通过粘贴将其取回。

     ‘copy-region-as-kill’ 将点和标记之间的文本复制到kill ring中，可以通
     过粘贴获取。该函数不会从缓冲区中删除文本。

   ‘delete-and-extract-region’ 从缓冲区中移除点和标记之间的文本并将其丢
弃。您无法再获取它。 (这不是一个交互式命令。)


File: eintr.info,  Node: search Exercises,  Prev: cons & search-fwd Review,  Up: Cutting & Storing Text

8.7 搜索练习
============

   • 编写一个交互式函数，用于搜索字符串。如果搜索找到字符串，将光标放在
     字符串后面并显示消息：“找到了！”（请勿使用‘search-forward’作为此函
     数的名称；如果这样做，将覆盖Emacs自带的‘search-forward’版本。请使用
     诸如‘test-search’的名称。）

   • 编写一个函数，在回显区域打印剪切环的第三个元素（如果存在）；如果剪
     切环不包含第三个元素，则打印相应的消息。


File: eintr.info,  Node: List Implementation,  Next: Yanking,  Prev: Cutting & Storing Text,  Up: Top

9 如何实现列表
**************

在Lisp中，原子以一种直截了当的方式记录；如果在实践中实现不够直截了当，理
论上仍然是直截了当的。例如，原子 ‘rose’ 被记录为四个连续的字母 ‘r’、
‘o’、‘s’、‘e’。然而，列表的存储方式不同。机制同样简单，但需要一些时间来
适应这个概念。列表使用一系列指针对来维护。在这个系列中，每对中的第一个指
针指向一个原子或另一个列表，而每对中的第二个指针指向下一对，或者指向表示
列表结束的符号 ‘nil’。

   指针本身就是指向所指对象的电子地址。因此，列表被保存为一系列电子地址
。

* Menu:

* Lists diagrammed::
* Symbols as Chest::       探索一个强有力的隐喻。
* List Exercise::


File: eintr.info,  Node: Lists diagrammed,  Next: Symbols as Chest,  Up: List Implementation

列表示意图
==========

例如，列表 ‘(rose violet buttercup)’ 有三个元素，‘rose’、‘violet’ 和
‘buttercup’。在计算机中，‘rose’ 的电子地址记录在称为 “cons cell”（因为它
实际上是函数 ‘cons’ 创建的东西）的计算机内存段中。该 cons cell 还保存了
指向第二个 cons cell 的地址，其 CAR 是原子 ‘violet’；而该地址（指示如何
找到 ‘violet’ 的地址）与保存原子 ‘buttercup’ 的地址一起保存在第三个 cons
cell 的地址中。

   这听起来比实际上更复杂，但在图表中更容易理解：

         ___ ___      ___ ___      ___ ___
        |___|___|--> |___|___|--> |___|___|--> nil
          |            |            |
          |            |            |
           --> rose     --> violet   --> buttercup


在图表中，每个框表示计算机内存中的一个字，通常以内存地址的形式保存一个
Lisp对象。框，即地址，是成对出现的。每个箭头指向地址所指的内容，要么是一
个原子，要么是另一对地址。第一个框是 ‘rose’ 的电子地址，箭头指向 ‘rose’；
第二个框是下一对框的地址，其第一部分是 ‘violet’ 的地址，第二部分是下一对
的地址。最后一个框指向符号 ‘nil’，表示列表的结束。

   当变量使用诸如 ‘setq’ 这样的操作设置为列表时，它将存储在变量中的第一
个框的地址。因此，表达式的求值

     (setq bouquet '(rose violet buttercup))

会创建这样的情况：

     bouquet
          |
          |     ___ ___      ___ ___      ___ ___
           --> |___|___|--> |___|___|--> |___|___|--> nil
                 |            |            |
                 |            |            |
                  --> rose     --> violet   --> buttercup


在此示例中，符号 ‘bouquet’ 持有第一对框的地址。

   相同的列表可以用不同类型的框符号表示，如下所示：

     bouquet
      |
      |    --------------       ---------------       ----------------
      |   | car   | cdr  |     | car    | cdr  |     | car     | cdr  |
       -->| rose  |   o------->| violet |   o------->| butter- |  nil |
          |       |      |     |        |      |     | cup     |      |
           --------------       ---------------       ----------------


   （符号由不仅仅是地址对组成，但符号的结构由地址组成。实际上，符号
‘bouquet’ 由一组地址框组成，其中一个是打印字 ‘bouquet’ 的地址，第二个是
附加到符号的函数定义的地址（如果有的话），第三个是列表 ‘(rose violet
buttercup)’ 的地址的第一对地址框，依此类推。这里我们显示符号的第三个地址
框指向列表的第一对地址框。）

   如果将符号设置为列表的 CDR，列表本身不会改变；符号只是具有列表中更远
地址的地址。 （在行话中，CAR 和 CDR 是“非破坏性的”）因此，对以下表达式的
求值

     (setq flowers (cdr bouquet))

会产生：


     bouquet        flowers
       |              |
       |     ___ ___  |     ___ ___      ___ ___
        --> |   |   |  --> |   |   |    |   |   |
            |___|___|----> |___|___|--> |___|___|--> nil
              |              |            |
              |              |            |
               --> rose       --> violet   --> buttercup



变量 ‘flowers’ 的值是 ‘(violet buttercup)’，也就是说，符号 ‘flowers’ 持
有地址的对应的框，其中第一个框持有 ‘violet’ 的地址，第二个框持有
‘buttercup’ 的地址。

   一对地址框称为 “cons cell” 或 “点对”。有关 cons cell 和点对的更多信息
，请参见 *Note Cons Cell and List Types: (elisp)Cons Cell Type, 以及
*note Dotted Pair Notation: (elisp)Dotted Pair Notation.

   函数 ‘cons’ 将一个新的地址对添加到上面所示的地址系列的前面。例如，对
以下表达式的求值

     (setq bouquet (cons 'lily bouquet))

产生：


     bouquet                       flowers
       |                             |
       |     ___ ___        ___ ___  |     ___ ___       ___ ___
        --> |   |   |      |   |   |  --> |   |   |     |   |   |
            |___|___|----> |___|___|----> |___|___|---->|___|___|--> nil
              |              |              |             |
              |              |              |             |
               --> lily      --> rose       --> violet    --> buttercup



然而，这并不会改变符号 ‘flowers’ 的值，可以通过求值以下表达式来查看：

     (eq (cdr (cdr bouquet)) flowers)

这会返回 ‘t’，表示为真。

   在被重新设置之前，‘flowers’ 仍然具有值 ‘(violet buttercup)’；也就是说
，它持有第一个框的地址，该框的第一个地址是 ‘violet’。

   总而言之，在Lisp中，要获得列表的 CDR，只需获取系列中下一个 cons cell
的地址；要获取列表的 CAR，只需获取列表的第一个元素的地址；要在列表前面添
加新元素，只需在列表的前面添加一个新的 cons cell。就是这样！Lisp的底层结
构非常简单！

   而在一系列 cons 单元中，最后一个地址指向什么呢？它指向空列表，即
‘nil’ 的地址。

   总之，当一个 Lisp 变量被设置为某个值时，它会被赋予指向该变量所引用的
列表的地址。


File: eintr.info,  Node: Symbols as Chest,  Next: List Exercise,  Prev: Lists diagrammed,  Up: List Implementation

9.1 符号作为抽屉式储物柜
========================

在早期的一节中，我建议你将符号想象成一个抽屉式储物柜。一个抽屉放置函数定
义，另一个抽屉放置值，依此类推。放在存放值的抽屉中的内容可以更改，而不影
响放置函数定义的抽屉中的内容，反之亦然。

   实际上，放在每个抽屉中的是值或函数定义的地址。就好像你在阁楼上发现了
一只旧箱子，在其中一个抽屉里找到了一张地图，指引你找到埋藏的宝藏的地方。

   （除了名称、符号定义和变量值之外，符号还有一个用于记录其他信息的“属性
列表”抽屉。这里不讨论属性列表；请参阅*note Property Lists: (elisp，GNU
Emacs Lisp参考手册)Property Lists.。）

   这里是一个幻想的表示：


                 抽屉式储物柜            抽屉的内容

                 __   o0O0o   __
               /                 \
              ---------------------
             |    符号名称的方向    |            [指向地图]
             |                     |             花束
             +---------------------+
             |    符号定义的方向    |
             |                     |             [无]
             +---------------------+
             |    变量值的方向      |            [指向地图]
             |                     |             (玫瑰 紫罗兰 毛茛)
             +---------------------+
             |    属性列表的方向    |             [这里不描述]
             |                     |
             +---------------------+
             |/                   \|




File: eintr.info,  Node: List Exercise,  Prev: Symbols as Chest,  Up: List Implementation

9.2 练习
========

将‘flowers’设置为‘violet’和‘buttercup’。在这个列表上再连接两朵花，并将这
个新列表设置为‘more-flowers’。将‘flowers’的CAR设置为一条鱼。现在，
‘more-flowers’列表包含什么？


File: eintr.info,  Node: Yanking,  Next: Loops & Recursion,  Prev: List Implementation,  Up: Top

10 插入文本
***********

在GNU Emacs中，每当你使用一个kill命令从缓冲区中剪切文本，你都可以使用
yank命令将其还原。从缓冲区中剪切出的文本被放入kill环中，而yank命令则将
kill环的相应内容插入到缓冲区中（不一定是原始缓冲区）。

   一个简单的‘C-y’（‘yank’）命令将kill环中的第一个条目插入到当前缓冲区中
。如果‘C-y’命令后面紧跟着‘M-y’，那么第一个元素将被第二个元素替换。随后的
‘M-y’命令将第二个元素替换为第三个、第四个或第五个元素，依此类推。当达到
kill环中的最后一个元素时，它将被第一个元素替换，然后循环重复。（因此，
kill环被称为“环”而不仅仅是一个“列表”。然而，实际保存文本的数据结构是一个
列表。*Note 处理Kill环: Kill Ring, 了解如何将列表作为环处理的详细信息。
）

* Menu:

* Kill Ring Overview::
* kill-ring-yank-pointer::      Kill环是一个列表。
* yank nthcdr Exercises::           ‘kill-ring-yank-pointer’变量。


File: eintr.info,  Node: Kill Ring Overview,  Next: kill-ring-yank-pointer,  Up: Yanking

10.1 剪切环概述
===============

剪切环是一组文本字符串的列表。它的结构如下所示：

     ("一些文本" "不同的文本片段" "更多文本")

   如果这是我的剪切环的内容，并且我按下 ‘C-y’ 键，那么包含字符串 ‘一些文
本’ 的部分将被插入到我的光标所在位置。

   ‘yank’ 命令还用于通过复制来复制文本。复制的文本并未从缓冲区中删除，而
是将其副本放入剪切环，并通过粘贴将其插入。

   有三个函数用于从剪切环中恢复文本：‘yank’，通常绑定到 ‘C-y’；
‘yank-pop’，通常绑定到 ‘M-y’；以及由这两个函数使用的
‘rotate-yank-pointer’。

   这些函数通过一个称为 ‘kill-ring-yank-pointer’ 的变量引用剪切环。实际
上，‘yank’ 和 ‘yank-pop’ 函数的插入代码为：

     (insert (car kill-ring-yank-pointer))

（好了，不再是这样了。在 GNU Emacs 22 中，该函数已被 ‘insert-for-yank’ 替
代，它会为每个 ‘yank-handler’ 段重复调用 ‘insert-for-yank-1’。转而，
‘insert-for-yank-1’ 根据 ‘yank-excluded-properties’ 从插入的文本中去除文
本属性。否则，它就像 ‘insert’ 一样。我们将继续使用纯粹的 ‘insert’，因为
它更容易理解。）

   要开始理解 ‘yank’ 和 ‘yank-pop’ 如何工作，首先需要查看
‘kill-ring-yank-pointer’ 变量。


File: eintr.info,  Node: kill-ring-yank-pointer,  Next: yank nthcdr Exercises,  Prev: Kill Ring Overview,  Up: Yanking

10.2 变量 ‘kill-ring-yank-pointer’
==================================

‘kill-ring-yank-pointer’ 是一个变量，就像 ‘kill-ring’ 一样是一个变量。它
通过绑定到它所指向的值来指向某个东西，就像任何其他 Lisp 变量一样。

   因此，如果 kill 环的值为：

     ("一些文本" "另一段文本" "更多文本")

而 ‘kill-ring-yank-pointer’ 指向第二个元素，那么
‘kill-ring-yank-pointer’ 的值就是：

     ("另一段文本" "更多文本")

   如前一章节所解释的（*note List Implementation::），计算机并不保留被
‘kill-ring’ 和 ‘kill-ring-yank-pointer’ 指向的文本的两个不同副本。"另一
段文本"和"更多文本"这两个词不会被复制。相反，这两个 Lisp 变量指向相同的
文本片段。以下是一个图示：

     kill-ring     kill-ring-yank-pointer
         |               |
         |      ___ ___  |     ___ ___      ___ ___
          ---> |   |   |  --> |   |   |    |   |   |
               |___|___|----> |___|___|--> |___|___|--> nil
                 |              |            |
                 |              |            |
                 |              |             --> "更多文本"
                 |              |
                 |               --> "另一段文本"
                 |
                  --> "一些文本"



   变量 ‘kill-ring’ 和变量 ‘kill-ring-yank-pointer’ 都是指针。但是 kill
环本身通常被描述成它实际由什么组成。‘kill-ring’ 通常被视为保存最近从
Emacs 缓冲区中剪切的信息的完整数据结构。另一方面，
‘kill-ring-yank-pointer’ 用于指示——即指向——kill 环的哪一部分将被插入。


File: eintr.info,  Node: yank nthcdr Exercises,  Prev: kill-ring-yank-pointer,  Up: Yanking

10.3 使用 ‘yank’ 和 ‘nthcdr’ 的练习
===================================

   • 使用 ‘C-h v’ (‘describe-variable’)，查看你的kill ring的值。向kill
     ring中添加几个项，再次查看其值。使用 ‘M-y’ (‘yank-pop’)，在kill
     ring中循环移动。你的kill ring中有多少项？找到 ‘kill-ring-max’ 的值
     。你的kill ring是满的吗，还是可以保存更多文本块？

   • 使用 ‘nthcdr’ 和 ‘car’，构建一系列表达式，返回列表的第一、第二、第
     三和第四个元素。


File: eintr.info,  Node: Loops & Recursion,  Next: Regexp Search,  Prev: Yanking,  Up: Top

11 循环和递归
*************

Emacs Lisp 有两种主要的方式来使一个表达式或一系列表达式被重复地评估：一
种使用 ‘while’ 循环，另一种使用 “递归”。

   重复可以是非常有价值的。例如，要前进四个句子，你只需要编写一个程序，
该程序将前进一句，然后重复这个过程四次。由于计算机不会感到无聊或疲劳，这
种重复的动作不会像对人类可能有害的过度或错误的重复那样产生不良影响。

   大多数人使用 ‘while’ 循环及其类似物来编写 Emacs Lisp 函数；但你也可以
使用递归，它提供了一种非常强大的思考和解决问题的方式(1)。

* Menu:

* while::                       导致代码段重复执行。
* dolist dotimes::
* Recursion::                   导致函数调用自身。
* Looping exercise::

   ---------- Footnotes ----------

   (1) 你可以编写递归函数，让其在使用心智或计算资源时既节俭又浪费；实际
上，人们发现易于使用——对心智资源节俭的方法——有时会使用相当多的计算资源。
Emacs 设计用于运行在我们现在认为有限的机器上，其默认设置是保守的。你可能
需要增加 ‘max-lisp-eval-depth’ 的值。在我的 ‘.emacs’ 文件中，我将其设置
为默认值的30倍。


File: eintr.info,  Node: while,  Next: dolist dotimes,  Up: Loops & Recursion

11.1 ‘while’
============

特殊形式 ‘while’ 用于测试通过评估其第一个参数返回的值是否为真或假。这类
似于Lisp解释器对 ‘if’ 的处理方式；然而，解释器接下来的操作有所不同。

   在 ‘while’ 表达式中，如果通过评估第一个参数返回的值为假，Lisp解释器将
跳过表达式的其余部分（表达式的 “主体”）并不予以评估。然而，如果该值为真
，则Lisp解释器将评估表达式的主体，然后再次测试 ‘while’ 的第一个参数是真
还是假。如果通过评估第一个参数返回的值再次为真，Lisp解释器将再次评估表达
式的主体。

   ‘while’ 表达式的模板如下：

     (while TRUE-OR-FALSE-TEST
       BODY...)

* Menu:

* Looping with while::          当测试返回 true 时重复执行。
* Loop Example::                  使用列表的 ‘while’ 循环。
* print-elements-of-list::    使用 ‘while’、‘car’、‘cdr’。
* Incrementing Loop::                  带有递增计数器的循环。
* Incrementing Loop Details::
* Decrementing Loop::                  带有递减计数器的循环。


File: eintr.info,  Node: Looping with while,  Next: Loop Example,  Up: while

使用 ‘while’ 循环
-----------------

只要 ‘while’ 表达式的 true-or-false-test 在评估时返回真值，就会重复评估
主体。这个过程称为循环，因为Lisp解释器一遍又一遍地重复相同的操作，就像一
架飞机做环形飞行一样。当评估 true-or-false-test 的结果为假时，Lisp解释器
将不再评估 ‘while’ 的其余部分并退出循环。

   显然，如果通过评估 ‘while’ 的第一个参数返回的值始终为真，那么接下来的
主体将一遍又一遍地被评估……而且永远都是如此。相反，如果返回的值从不为真，
主体中的表达式将永远不会被评估。编写 ‘while’ 循环的技巧在于选择一种机制
，使得 true-or-false-test 仅在您希望后续表达式被评估的次数返回真，然后使
测试返回假。

   通过评估 ‘while’ 的返回值是 true-or-false-test 的值。这样做的一个有趣
的结果是，如果 ‘while’ 循环评估成功且没有错误，它将始终返回 ‘nil’ 或
false，无论它循环了1次还是100次，甚至一次都没有循环。成功评估的 ‘while’
表达式永远不返回真值！这意味着 ‘while’ 总是被评估为其副作用，也就是评估
循环体内表达式的后果。这是有道理的。人们追求的不仅仅是循环的行为，更是循
环体内表达式反复评估时产生的后果。


File: eintr.info,  Node: Loop Example,  Next: print-elements-of-list,  Prev: Looping with while,  Up: while

11.1.1 使用 ‘while’ 循环和列表
------------------------------

控制 ‘while’ 循环的常见方法是测试列表是否包含任何元素。如果包含元素，则
循环将继续；但如果不包含元素，则循环结束。由于这是一种重要的技术，我们将
创建一个简短的示例来说明它。

   测试列表是否包含元素的一种简单方法是评估列表：如果没有元素，它是一个
空列表，将返回空列表 ‘()’，这是 ‘nil’ 或 false 的同义词。另一方面，具有
元素的列表在评估时将返回这些元素。由于Emacs Lisp认为任何非 ‘nil’ 的值都
为真，因此返回元素的列表在 ‘while’ 循环中将测试为真。

   例如，您可以通过评估以下 ‘setq’ 表达式将变量 ‘empty-list’ 设置为
‘nil’：

     (setq empty-list ())

在评估了 ‘setq’ 表达式之后，您可以以通常的方式评估变量 ‘empty-list’，即
将光标放在符号后面，然后键入 ‘C-x C-e’；在您的回显区域中将显示 ‘nil’：

     empty-list

   另一方面，如果将变量设置为具有元素的列表，则在评估变量时将显示该列表
，如通过评估以下两个表达式所示：

     (setq animals '(gazelle giraffe lion tiger))

     animals

   因此，要创建一个 ‘while’ 循环，测试列表 ‘animals’ 中是否有任何项，循
环的第一部分将被编写为：

     (while animals
            ...

当 ‘while’ 测试其第一个参数时，变量 ‘animals’ 被评估。它返回一个列表。只
要列表具有元素，‘while’ 将认为测试的结果为真；但当列表为空时，它将认为测
试的结果为假。

   为防止 ‘while’ 循环无限运行，需要提供某种机制以最终清空列表。一个常用
的技术是在 ‘while’ 表达式的后续形式中之一将列表的值设置为列表的 CDR。每
次评估 ‘cdr’ 函数时，列表都会变得更短，直到最终只剩下空列表。此时，
‘while’ 循环的测试将返回假，‘while’ 的参数将不再被评估。

   例如，将绑定到变量 ‘animals’ 的动物列表可以通过以下表达式设置为原始列
表的 CDR：

     (setq animals (cdr animals))

如果您已经评估了前面的表达式，然后评估此表达式，您将在回显区域中看到
‘(giraffe lion tiger)’。如果再次评估表达式，将显示 ‘(lion tiger)’。如果
再次评估它，‘(tiger)’ 将出现，然后是空列表，由 ‘nil’ 表示。

   使用 ‘cdr’ 反复使真或假测试最终测试为假的 ‘while’ 循环的模板如下：

     (while TEST-WHETHER-LIST-IS-EMPTY
       BODY...
       SET-LIST-TO-CDR-OF-LIST)

   这个测试和使用 ‘cdr’ 的功能可以放在一起，形成一个函数，该函数遍历列表
并在各自的行上打印列表的每个元素。


File: eintr.info,  Node: print-elements-of-list,  Next: Incrementing Loop,  Prev: Loop Example,  Up: while

11.1.2 示例：‘print-elements-of-list’ 函数
------------------------------------------

‘print-elements-of-list’ 函数演示了使用列表的 ‘while’ 循环。

   该函数需要多行输出。如果您正在使用最近版本的 GNU Emacs 阅读此文档，您
可以像往常一样在 Info 中评估以下表达式。

   如果您使用较早版本的 Emacs，则需要将必要的表达式复制到 ‘*scratch*’ 缓
冲区并在那里进行评估。这是因为早期版本的回显区只有一行。

   您可以通过使用 ‘C-<SPC>’（‘set-mark-command’）标记区域的开头，将光标
移动到区域的末尾，然后使用 ‘M-w’（‘kill-ring-save’，它调用
‘copy-region-as-kill’ 并提供视觉反馈）来复制区域。在 ‘*scratch*’ 缓冲区
中，您可以通过键入 ‘C-y’（‘yank’）将表达式还原。

   在将表达式复制到 ‘*scratch*’ 缓冲区后，逐个评估每个表达式。确保通过键
入 ‘C-u C-x C-e’ 评估最后一个表达式 ‘(print-elements-of-list animals)’，
即通过给 ‘eval-last-sexp’ 提供参数。这将导致评估的结果在 ‘*scratch*’ 缓
冲区中打印，而不是在回显区中打印（否则您将在回显区中看到类似于这样的内容
：‘^Jgazelle^J^Jgiraffe^J^Jlion^J^Jtiger^Jnil’，其中每个 ‘^J’ 代表一个换
行符）。

   您可以直接在 Info 缓冲区中评估这些表达式，回显区将增大以显示结果。

     (setq animals '(gazelle giraffe lion tiger))

     (defun print-elements-of-list (list)
       "逐行打印 LIST 的每个元素。"
       (while list
         (print (car list))
         (setq list (cdr list))))

     (print-elements-of-list animals)

当您按顺序评估这三个表达式时，将看到以下结果：

     gazelle

     giraffe

     lion

     tiger
     nil

   列表的每个元素都打印在自己的一行上（这是函数 ‘print’ 的作用），然后打
印函数的返回值。由于函数中的最后一个表达式是 ‘while’ 循环，而且由于
‘while’ 循环总是返回 ‘nil’，因此在列表的最后一个元素后打印了一个 ‘nil’。


File: eintr.info,  Node: Incrementing Loop,  Next: Incrementing Loop Details,  Prev: print-elements-of-list,  Up: while

11.1.3 具有增量计数器的循环
---------------------------

循环如果没有在应该停止的时候停止，就毫无用处。除了使用列表控制循环外，另
一种常见的停止循环的方式是将第一个参数写为一个测试，当正确的重复次数完成
时返回false。这意味着循环必须有一个计数器，即一个表达式，用于计算循环重
复的次数。


File: eintr.info,  Node: Incrementing Loop Details,  Next: Decrementing Loop,  Prev: Incrementing Loop,  Up: while

增量循环的细节
--------------

具有增量计数器的循环的测试可以是诸如 ‘(< count desired-number)’ 的表达式
，如果 ‘count’ 的值小于 ‘desired-number’，则返回 ‘t’ 为true，如果
‘count’ 的值等于或大于 ‘desired-number’，则返回 ‘nil’ 为false。增加计数
的表达式可以是一个简单的 ‘setq’，例如 ‘(setq count (1+ count))’，其中
‘1+’ 是Emacs Lisp中的内置函数，将1添加到其参数。 (表达式 ‘(1+ count)’ 的
结果与 ‘(+ count 1)’ 相同，但对于人类来说更容易阅读。)

   由增量计数器控制的 ‘while’ 循环的模板如下：

     SET-COUNT-TO-INITIAL-VALUE
     (while (< count desired-number)         ; true-or-false-test
       BODY...
       (setq count (1+ count)))              ; incrementer

请注意，您需要设置 ‘count’ 的初始值；通常将其设置为1。

* Menu:

* Incrementing Example::        计算三角形中的鹅卵石。
* Inc Example parts::   函数定义的各个部分。
* Inc Example altogether::   将函数定义组合在一起。


File: eintr.info,  Node: Incrementing Example,  Next: Inc Example parts,  Up: Incrementing Loop Details

具有增量计数器的示例
....................

假设您正在沙滩上玩耍，决定做一个鹅卵石三角形，第一排放一个鹅卵石，第二排
放两个，第三排放三个，依此类推，如下所示：


                    *
                   * *
                  * * *
                 * * * *

(大约2500年前，毕达哥拉斯等人通过考虑这类问题发展了数论的开端。)

   假设您想知道要制作一个有7排的三角形需要多少鹅卵石？

   显然，您需要做的是将从1到7的数字相加。有两种方法可以做到这一点：从最
小的数字开始，即1，按顺序相加列表中的数字1、2、3、4等；或者从最大的数字
开始，按列表向下相加：7、6、5、4等。由于这两种机制都说明了编写 ‘while’ 循
环的常见方法，我们将创建两个示例，一个是递增计数，另一个是递减计数。在这
个第一个示例中，我们将从1开始，然后添加2、3、4等。

   如果您只是在一个短列表中相加一些数字，最简单的方法是一次将所有数字相
加。但是，如果您不知道列表将有多少数字，或者如果您希望为一个非常长的列表
做好准备，那么您需要设计加法，以便您重复一个简单的过程多次，而不是一次执
行更复杂的过程。

   例如，与其一次性将所有鹅卵石相加，不如将第一排的鹅卵石数，即1，加到第
二排的鹅卵石数2中，然后将这两排的总数加到第三排的鹅卵石数3中。然后，将第
四排的鹅卵石数4加到前三排的总数中，依此类推。

   这个过程的关键特征是每个重复的动作都很简单。在这种情况下，在每一步中
，我们只添加两个数字，即排中的鹅卵石数和已找到的总数。这个添加两个数字的
过程一遍又一遍地重复，直到最后一排的鹅卵石被添加到所有前排的总数中。在更
复杂的循环中，重复的动作可能不那么简单，但它将比一次性做所有事情更简单。


File: eintr.info,  Node: Inc Example parts,  Next: Inc Example altogether,  Prev: Incrementing Example,  Up: Incrementing Loop Details

函数定义的各部分
................

前面的分析为我们的函数定义提供了骨架：首先，我们需要一个变量，我们可以称
之为 ‘total’，它将是函数返回的总的鹅卵石数量。这将是函数返回的值。

   其次，我们知道函数将需要一个参数：这个参数将是三角形中的总行数。它可
以被称为 ‘number-of-rows’。

   最后，我们需要一个作为计数器的变量。我们可以称这个变量为 ‘counter’，
但更好的名字是 ‘row-number’。这是因为在这个函数中，计数器的作用是计算行
数，而程序应该尽可能易于理解。

   当Lisp解释器首次开始评估函数中的表达式时，‘total’的值应该设置为零，因
为我们还没有向其中添加任何东西。然后，函数应该将第一行中的鹅卵石数量添加
到总数中，然后将第二行的数量添加到总数中，然后将第三行的数量添加到总数中
，依此类推，直到没有更多的行可以添加。

   ‘total’和‘row-number’都仅在函数内部使用，因此它们可以被声明为局部变量
，并用‘let’给予初始值。显然，‘total’的初始值应为0。‘row-number’的初始值
应为1，因为我们从第一行开始。这意味着‘let’语句将如下所示：

       (let ((total 0)
             (row-number 1))
         BODY...)

   在内部变量被声明并绑定到它们的初始值之后，我们可以开始‘while’循环。作
为测试的表达式应该在‘row-number’小于或等于‘number-of-rows’时返回true。如
果表达式仅在行号小于三角形行数的情况下为true，最后一行将永远不会添加到总
数中；因此行号必须小于或等于行数。

   Lisp提供了‘<=’函数，如果其第一个参数的值小于或等于其第二个参数的值，
则返回true，否则返回false。因此，‘while’将评估为测试的表达式应如下所示：

     (<= row-number number-of-rows)

   鹅卵石的总数量可以通过重复将一行中的鹅卵石数量添加到已找到的总数中来
找到。由于一行中的鹅卵石数量等于行号，因此可以通过将行号添加到总数中来找
到总数。

     (setq total (+ total row-number))

这做的是将‘total’的新值设置为将鹅卵石数量添加到先前总数的和。

   在设置了‘total’的值之后，需要建立下一次循环的条件，如果有的话。这是通
过增加‘row-number’变量的值来完成的，它充当计数器。在增加‘row-number’变量
之后，‘while’循环开头的true-or-false测试会测试其值是否仍然小于或等于
‘number-of-rows’的值，如果是，将新值添加到先前循环的‘total’中。

   内置的Emacs Lisp函数‘1+’将1添加到一个数字，因此可以使用以下表达式递增
‘row-number’变量：

     (setq row-number (1+ row-number))


File: eintr.info,  Node: Inc Example altogether,  Prev: Inc Example parts,  Up: Incrementing Loop Details

Putting the function definition together
........................................

我们已经创建了函数定义的各个部分；现在需要将它们组合起来。

   首先，‘while’ 表达式的内容：

     (while (<= 行号 总行数)   ; 真或假的测试
       (setq 总和 (+ 总和 行号))
       (setq 行号 (1+ 行号)))    ; 增量器

   连同 ‘let’ 表达式的变量列表，这几乎完成了函数定义的主体。但是，还需要
一个微妙的最后要素。

   最后的一步是将变量 ‘总和’ 单独放在 ‘while’ 表达式之后的一行上。否则，
整个函数返回的值将是在 ‘let’ 主体中最后一个表达式的值，而这是由 ‘while’
评估得到的，其值始终为 ‘nil’。

   这一点乍一看可能不明显。它几乎看起来好像增量表达式是整个函数的最后一
个表达式。但是该表达式是 ‘while’ 主体的一部分；它是以符号 ‘while’ 开始的
列表的最后一个元素。此外，整个 ‘while’ 循环是 ‘let’ 主体内的列表。

   概述来说，函数将如下所示：

     (defun 函数名 (参数列表)
       "文档..."
       (let (变量列表)
         (while (真或假的测试)
           WHILE的主体... )
         ... ))                    ; 这里需要最后的表达式。

   评估 ‘let’ 的结果将是由 ‘defun’ 返回的结果，因为 ‘let’ 不嵌套在任何包
含列表中，除了整个 ‘defun’。然而，如果 ‘while’ 是 ‘let’ 表达式的最后一个
元素，函数将始终返回 ‘nil’。这不是我们想要的！相反，我们想要的是变量 ‘总
和’ 的值。通过简单地将该符号作为以 ‘let’ 开始的列表的最后一个元素放置在
列表中，它将在之前的元素被评估之后被评估，这意味着在为总和赋予正确值之后
才被评估。

   通过将以 ‘let’ 开始的列表打印在一行上，可能更容易看到这一点。这种格式
使得显而易见，变量列表 和 ‘while’ 表达式是以 ‘let’ 开始的列表的第二和第
三个元素，而 ‘总和’ 是最后一个元素：

     (let (变量列表) (while (真或假的测试) WHILE的主体... ) 总和)

   将所有内容放在一起，‘triangle’ 函数定义如下：

     (defun triangle (总行数)    ; 带有
                                         ;   增量计数器的版本。
       "将三角形中的鹅卵石数量相加。
     第一行有一个鹅卵石，第二行有两个鹅卵石，
     第三行有三个鹅卵石，依此类推。
     参数为总行数。"
       (let ((总和 0)
             (行号 1))
         (while (<= 行号 总行数)
           (setq 总和 (+ 总和 行号))
           (setq 行号 (1+ 行号)))
         总和))

   安装 ‘triangle’ 后，您可以尝试它。以下是两个示例：

     (triangle 4)

     (triangle 7)

前四个数字的总和是10，前七个数字的总和是28。


File: eintr.info,  Node: Decrementing Loop,  Prev: Incrementing Loop Details,  Up: while

11.1.4 带有递减计数器的循环
---------------------------

另一种常见的编写 ‘while’ 循环的方式是编写测试，使其确定计数器是否大于零
。只要计数器大于零，循环就会重复。但当计数器等于或小于零时，循环停止。为
使此方法有效，计数器必须从大于零开始，然后通过一个可重复评估的形式逐渐减
小。

   测试将是诸如 ‘(> counter 0)’ 的表达式，如果 ‘counter’ 的值大于零，则
返回 ‘t’ 为 true，如果 ‘counter’ 的值等于或小于零，则返回 ‘nil’ 为
false。使数字逐渐减小的表达式可以是一个简单的 ‘setq’，例如 ‘(setq
counter (1- counter))’，其中 ‘1-’ 是 Emacs Lisp 中减去其参数的内置函数。

   递减 ‘while’ 循环的模板如下：

     (while (> counter 0)                    ; 真或假测试
       BODY...
       (setq counter (1- counter)))          ; 递减器

* Menu:

* Decrementing Example::        海滩上更多的小石子。
* Dec Example parts::    函数定义的各个部分。
* Dec Example altogether::    将函数定义组合在一起。


File: eintr.info,  Node: Decrementing Example,  Next: Dec Example parts,  Up: Decrementing Loop

带有递减计数器的示例
....................

为了说明带有递减计数器的循环，我们将重写 ‘triangle’ 函数，使计数器递减到
零。

   这是该函数早期版本的反转。在这种情况下，要找出构成 3 行三角形所需的小
石子数量，将第三行的小石子数量（3）与前一行的数量（2）相加，然后将这两行
的总和添加到它们之前的行，即第一行（1）。

   同样，要找出具有 7 行的三角形中的小石子数量，将第七行的小石子数量（
7）与前一行的数量（6）相加，然后将这两行的总和添加到它们之前的行，即第五
行（5），依此类推。与前一个示例一样，每次添加仅涉及两个数字的相加，已经
添加的行的总和以及正在添加到总和的行的小石子数量。这个加法的过程一遍又一
遍地重复，直到没有更多的小石子可添加。

   我们知道从哪里开始有多少小石子：最后一行中的小石子数量等于行数。如果
三角形有七行，最后一行中的小石子数量为 7。同样，我们知道前一行中有多少小
石子：它比该行中的数量少一个。


File: eintr.info,  Node: Dec Example parts,  Next: Dec Example altogether,  Prev: Decrementing Example,  Up: Decrementing Loop

函数定义的各部分
................

我们从三个变量开始：三角形中的总行数；每行中的小石子数；以及我们想要计算
的小石子的总数。这些变量可以分别命名为 ‘number-of-rows’、
‘number-of-pebbles-in-row’ 和 ‘total’。

   ‘total’ 和 ‘number-of-pebbles-in-row’ 都仅在函数内部使用，并使用
‘let’ 进行声明。显然，‘total’ 的初始值应为零。然而，
‘number-of-pebbles-in-row’ 的初始值应等于三角形中的行数，因为加法将从最
长的行开始。

   这意味着 ‘let’ 表达式的开头将如下所示：

     (let ((total 0)
           (number-of-pebbles-in-row number-of-rows))
       BODY...)

   小石子的总数可以通过重复将每行的小石子数加到已找到的总数中来找到，即
通过反复评估以下表达式：

     (setq total (+ total number-of-pebbles-in-row))

在将 ‘number-of-pebbles-in-row’ 添加到 ‘total’ 后，
‘number-of-pebbles-in-row’ 应减一，因为下次循环重复时将添加前一行到总数
中。

   前一行中的小石子数比当前行中的小石子数少一个，因此可以使用内置的
Emacs Lisp 函数 ‘1-’ 来计算前一行中的小石子数。可以使用以下表达式完成：

     (setq number-of-pebbles-in-row
           (1- number-of-pebbles-in-row))

   最后，我们知道 ‘while’ 循环应在一行中没有小石子时停止重复添加。因此，
‘while’ 循环的测试简单地是：

     (while (> number-of-pebbles-in-row 0)


File: eintr.info,  Node: Dec Example altogether,  Prev: Dec Example parts,  Up: Decrementing Loop

将函数定义组合在一起
....................

我们可以将这些表达式组合在一起以创建一个有效的函数定义。然而，在检查时，
我们发现其中一个局部变量是不必要的！

   函数定义如下：

     ;;; 第一个减法版本。
     (defun triangle (number-of-rows)
       "将三角形中小石子的数量相加。"
       (let ((total 0)
             (number-of-pebbles-in-row number-of-rows))
         (while (> number-of-pebbles-in-row 0)
           (setq total (+ total number-of-pebbles-in-row))
           (setq number-of-pebbles-in-row
                 (1- number-of-pebbles-in-row)))
         total))

   按照写法，这个函数是有效的。

   然而，我们不需要 ‘number-of-pebbles-in-row’。

   当评估 ‘triangle’ 函数时，符号 ‘number-of-rows’ 将绑定到一个数字，给
它一个初始值。该数字可以在函数体内部像局部变量一样更改，而无需担心这样的
更改会影响函数外部的变量值。这是 Lisp 的一个非常有用的特性；这意味着变量
‘number-of-rows’ 可以在函数中任何使用 ‘number-of-pebbles-in-row’ 的地方
使用。

   以下是稍微更清晰地编写的函数的第二个版本：

     (defun triangle (number)                ; 第二个版本。
       "返回 1 到 NUMBER（包括）的数字的总和。"
       (let ((total 0))
         (while (> number 0)
           (setq total (+ total number))
           (setq number (1- number)))
         total))

   简而言之，一个正确编写的 ‘while’ 循环将包含三个部分：

  1. 一个测试，循环重复正确次数后将返回 false。

  2. 一个表达式，其评估在重复评估后将返回所需值。

  3. 一个表达式，用于更改传递给真假测试的值，以便在循环重复正确次数后测
     试返回 false。


File: eintr.info,  Node: dolist dotimes,  Next: Recursion,  Prev: while,  Up: Loops & Recursion

11.2 节省时间：‘dolist’ 和 ‘dotimes’
====================================

除了 ‘while’ 之外，‘dolist’ 和 ‘dotimes’ 都提供了循环的功能。有时候，它
们比等效的 ‘while’ 循环更容易编写。两者都是Lisp宏。(*Note 宏:
(elisp)宏.)

   ‘dolist’ 像一个 ‘while’ 循环，不断地对列表进行 CDR 操作：‘dolist’ 每
次循环都会自动缩短列表—获取列表的 CDR—并将每个缩短版本的列表的 CAR 绑定
到其第一个参数。

   ‘dotimes’ 循环指定的次数：您需要指定次数。

* Menu:

* dolist::
* dotimes::


File: eintr.info,  Node: dolist,  Next: dotimes,  Up: dolist dotimes

‘dolist’ 宏
-----------

例如，假设您想反转一个列表，使得“first” “second” “third” 变成 “third”
“second” “first”。

   实际上，您可以使用 ‘reverse’ 函数，如下所示：

     (setq animals '(gazelle giraffe lion tiger))

     (reverse animals)

以下是使用 ‘while’ 循环反转列表的方法：

     (setq animals '(gazelle giraffe lion tiger))

     (defun reverse-list-with-while (list)
       "使用while循环反转LIST的顺序。"
       (let (value)  ; 确保列表从空开始
         (while list
           (setq value (cons (car list) value))
           (setq list (cdr list)))
         value))

     (reverse-list-with-while animals)

以下是使用 ‘dolist’ 宏的方法：

     (setq animals '(gazelle giraffe lion tiger))

     (defun reverse-list-with-dolist (list)
       "使用dolist宏反转LIST的顺序。"
       (let (value)  ; 确保列表从空开始
         (dolist (element list value)
           (setq value (cons element value)))))

     (reverse-list-with-dolist animals)

在Info中，您可以将光标放在每个表达式的右括号后，然后键入 ‘C-x C-e’; 在每
种情况下，您应该在回显区域看到

     (tiger lion giraffe gazelle)

对于此示例，现有的 ‘reverse’ 函数显然是最好的选择。 ‘while’ 循环就像我们
的第一个示例一样(*note 一个‘while’循环和一个列表: Loop Example.)。
‘while’ 首先检查列表是否有元素；如果有，它通过将列表的第一个元素添加到现
有列表（在循环的第一次迭代中是 ‘nil’）来构造一个新列表。由于第二个元素在
第一个元素的前面添加，第三个元素在第二个元素的前面添加，因此列表被反转。

   在使用 ‘while’ 循环的表达式中， ‘(setq list (cdr list))’ 表达式缩短了
列表，因此 ‘while’ 循环最终停止。此外，它通过在每次循环重复时创建一个新
的更短的列表，为 ‘cons’ 表达式提供了一个新的第一个元素。

   ‘dolist’ 表达式的工作方式与 ‘while’ 表达式非常相似，不同之处在于，
‘dolist’ 宏执行了在编写 ‘while’ 表达式时必须执行的一些工作。

   像 ‘while’ 循环一样，‘dolist’ 循环。不同之处在于，它每次循环都会自动
缩短列表—它会对列表进行 CDR 操作—并且会自动将每个较短版本的列表的 CAR 绑
定到其第一个参数。

   在此示例中，较短版本的列表的 CAR 由符号 ‘element’ 引用，列表本身称为
‘list’，返回的值称为 ‘value’。‘dolist’ 表达式的其余部分是主体。

   ‘dolist’ 表达式将较短版本的列表的 CAR 绑定到 ‘element’，然后评估表达
式的主体；然后重复循环。结果在 ‘value’ 中返回。


File: eintr.info,  Node: dotimes,  Prev: dolist,  Up: dolist dotimes

‘dotimes’ 宏
------------

‘dotimes’ 宏类似于 ‘dolist’，但它循环特定次数。

   ‘dotimes’ 的第一个参数在每次循环时被赋予数字 0、1、2 等等。你需要提供
第二个参数的值，该值表示宏循环的次数。

   例如，下面的代码将数字从 0 到 3（不包括 3）绑定到第一个参数 NUMBER，
然后构建包含这三个数字的列表。（第一个数字是 0，第二个数字是 1，第三个数
字是 2；总共有三个数字，以零为起始。）

     (let (value)      ; 否则 value 是一个未定义变量
       (dotimes (number 3)
         (setq value (cons number value)))
       value)

     ⇒ (2 1 0)

使用 ‘dotimes’ 的方法是对某个表达式 NUMBER 进行操作，重复操作 NUMBER 次
，然后返回结果，可以是列表或原子。

   以下是一个使用 ‘dotimes’ 的 ‘defun’ 示例，用于计算三角形中鹅卵石的总
数。

     (defun triangle-using-dotimes (number-of-rows)
       "使用 `dotimes'，计算三角形中鹅卵石的总数。"
     (let ((total 0))  ; 否则 total 是一个未定义变量
       (dotimes (number number-of-rows)
         (setq total (+ total (1+ number))))
       total))

     (triangle-using-dotimes 4)


File: eintr.info,  Node: Recursion,  Next: Looping exercise,  Prev: dolist dotimes,  Up: Loops & Recursion

11.3 递归
=========

一个递归函数包含代码，告诉Lisp解释器调用一个与自身完全相同但具有略有不同
参数的程序。代码运行完全相同，因为它具有相同的名称。然而，即使程序具有相
同的名称，它也不是相同的实体。它是不同的。在行话中，它是一个不同的“实例
”。

   最终，如果程序被正确编写，稍微不同的参数将与第一个参数足够不同，以至
于最终的实例将停止。

* Menu:

* Building Robots::             相同的模型，不同的序列号...
* Recursive Definition Parts::         走到停下来...
* Recursion with list::         将列表用作判断是否递归的测试。
* Recursive triangle function::
* Recursion with cond::
* Recursive Patterns::               经常使用的模板。
* No Deferment::                  不要存储工作...
* No deferment solution::


File: eintr.info,  Node: Building Robots,  Next: Recursive Definition Parts,  Up: Recursion

11.3.1 构建机器人：扩展隐喻
---------------------------

有时将运行的程序看作是执行任务的机器人是有帮助的。在执行其任务时，递归函
数调用第二个机器人来帮助它。第二个机器人与第一个机器人在每个方面都是相同
的，除了第二个机器人帮助第一个机器人并传递了不同于第一个机器人的参数。

   在递归函数中，第二个机器人可能调用第三个；第三个可能调用第四个，依此
类推。每个都是一个不同的实体；但都是克隆体。

   由于每个机器人都有略有不同的指令——参数将从一个机器人到另一个机器人不
同——最后一个机器人应该知道何时停止。

   让我们扩展一下计算机程序是机器人的隐喻。

   函数定义提供了一个机器人的蓝图。当您安装函数定义时，也就是当您评估
‘defun’宏时，您安装了构建机器人所需的设备。这就好像您在工厂中设置了一个
装配线。具有相同名称的机器人是根据相同的蓝图构建的。因此，它们具有相同的
型号，但不同的序列号。

   我们经常说一个递归函数“调用自身”。我们的意思是递归函数中的指令导致
Lisp解释器运行一个具有相同名称且执行与第一个相同的工作的不同函数，但具有
不同参数。

   参数从一个实例到下一个必须不同；否则，这个过程将永远不会停止。


File: eintr.info,  Node: Recursive Definition Parts,  Next: Recursion with list,  Prev: Building Robots,  Up: Recursion

11.3.2 递归定义的组成部分
-------------------------

一个递归函数通常包含一个条件表达式，该表达式有三个部分：

  1. 一个判断函数是否再次调用的真假测试，这里称为“再次执行测试”。

  2. 函数的名称。当调用此名称时，将创建一个函数的新实例，也可以看作是创
     建一个新的机器人，并告诉它要做什么。

  3. 一个表达式，每次调用函数时都返回不同的值，这里称为“下一步表达式”。
     因此，传递给函数的新实例的参数（或参数）将与传递给上一个实例的参数
     不同。这导致条件表达式，即“再次执行测试”在正确的重复次数后返回
     false。

   递归函数可能比其他类型的函数简单得多。实际上，当人们首次开始使用它们
时，它们经常看起来如此神秘简单，以至于难以理解。就像骑自行车一样，阅读递
归函数定义需要一定的技巧，起初很难，但后来似乎很简单。

   有几种常见的递归模式。一个非常简单的模式如下：

     (defun NAME-OF-RECURSIVE-FUNCTION (ARGUMENT-LIST)
       "DOCUMENTATION..."
       (if DO-AGAIN-TEST
         BODY...
         (NAME-OF-RECURSIVE-FUNCTION
              NEXT-STEP-EXPRESSION)))

   每次评估递归函数时，都会创建它的一个新实例，并告诉它要做什么。参数告
诉实例要做什么。

   参数被绑定到下一步表达式的值。每个实例以不同的下一步表达式的值运行。

   下一步表达式中的值在再次执行测试中使用。

   由下一步表达式返回的值被传递给函数的新实例，该实例评估它（或它的某些
转化）以确定是否继续还是停止。下一步表达式被设计成当函数不再需要重复时再
次执行测试返回false。

   再次执行测试有时被称为“停止条件”，因为它在测试为false时停止重复。


File: eintr.info,  Node: Recursion with list,  Next: Recursive triangle function,  Prev: Recursive Definition Parts,  Up: Recursion

11.3.3 列表递归
---------------

一个用‘while’循环打印数字列表元素的例子可以用递归的方式重写。下面是代码
，包括一个表达式，将变量‘animals’的值设置为一个列表。

   如果你在Emacs的Info中阅读此内容，你可以直接在Info中评估这个表达式。否
则，你必须将示例复制到‘*scratch*’缓冲区，并在那里逐个评估每个表达式。使
用‘C-u C-x C-e’来评估‘(print-elements-recursively animals)’表达式，以便
结果打印在缓冲区中；否则，Lisp解释器将尝试将结果压缩成回显区域的一行。

   此外，在‘print-elements-recursively’函数的最后一个闭合括号之后，在注
释之前将光标放置在此处。否则，Lisp解释器将尝试评估注释。

     (setq animals '(gazelle giraffe lion tiger))

     (defun print-elements-recursively (list)
       "将LIST的每个元素单独打印到一行上。
     使用递归。"
       (when list                            ; do-again-test
             (print (car list))              ; body
             (print-elements-recursively     ; recursive call
              (cdr list))))                  ; next-step-expression

     (print-elements-recursively animals)

   ‘print-elements-recursively’函数首先测试列表中是否有内容；如果有，函
数将打印列表的第一个元素，即列表的CAR。然后，函数调用自身，但将自身作为
参数传递，而不是整个列表，而是列表的第二个及后续元素，即列表的CDR。

   换句话说，如果列表不为空，函数调用另一个与初始代码相似但是不同执行线
程的代码实例，其参数与第一个实例不同。

   再换一种说法，如果列表不为空，第一个机器人组装第二个机器人并告诉它该
做什么；第二个机器人是第一个机器人之外的另一个个体，但是是相同型号。

   当进行第二次评估时，‘when’表达式将被评估，如果为真，则打印作为其参数
接收到的列表的第一个元素（这是原始列表的第二个元素）。然后，函数使用它调
用的列表的CDR调用自身，这是原始列表的CDR的CDR（第二次调用时）。

   请注意，尽管我们说函数“调用自身”，但我们的意思是Lisp解释器将装配并指
导程序的新实例。新实例是第一个的克隆，但是是独立的个体。

   每次函数调用自身时，它都是在原始列表的较短版本上进行的。它创建一个在
较短列表上运行的新实例。

   最终，函数在空列表上调用自身。它创建一个参数为‘nil’的新实例。条件表达
式测试‘list’的值。由于‘list’的值是‘nil’，‘when’表达式测试为假，因此不会
评估then部分。因此，整个函数返回‘nil’。

   当在‘*scratch*’缓冲区中评估表达式‘(print-elements-recursively
animals)’时，你将看到以下结果：

     gazelle

     giraffe

     lion

     tiger
     nil


File: eintr.info,  Node: Recursive triangle function,  Next: Recursion with cond,  Prev: Recursion with list,  Up: Recursion

11.3.4 使用递归替代计数器
-------------------------

在前一节中描述的 ‘triangle’ 函数也可以使用递归方式编写。它的代码如下：

     (defun triangle-recursively (number)
       "返回从1到NUMBER（包括NUMBER）的数字之和，使用递归。"
       (if (= number 1)                    ; 再做一次测试
           1                               ; 然后部分
         (+ number                         ; 否则部分
            (triangle-recursively          ; 递归调用
             (1- number)))))               ; 下一步表达式

     (triangle-recursively 7)

你可以通过评估这个函数来安装它，并通过评估 ‘(triangle-recursively 7)’ 来
尝试它。（记得把光标放在函数定义的最后一个括号之后，注释之前。）这个函数
的值为28。

   为了理解这个函数的工作原理，让我们考虑当函数的参数值为1、2、3或4时发
生的各种情况。

* Menu:

* Recursive Example arg of 1 or 2::
* Recursive Example arg of 3 or 4::


File: eintr.info,  Node: Recursive Example arg of 1 or 2,  Next: Recursive Example arg of 3 or 4,  Up: Recursive triangle function

参数为1或2
..........

首先，如果参数值为1会发生什么？

   在文档字符串之后，函数有一个 ‘if’ 表达式。它测试 ‘number’ 的值是否等
于1；如果是，Emacs 将评估 ‘if’ 表达式的 then-部分，将1作为函数的值返回。
（一个只有一行的三角形中有一个小石子。）

   然而，假设参数值为2。在这种情况下，Emacs 将评估 ‘if’ 表达式的 else-部
分。

   else-部分由一个加法、对 ‘triangle-recursively’ 的递归调用和一个递减操
作组成；它看起来像这样：

     (+ number (triangle-recursively (1- number)))

   当Emacs评估这个表达式时，首先评估最内层的表达式；然后按顺序评估其他部
分。以下是详细的步骤：

步骤1    评估最内层的表达式。

     最内层的表达式是 ‘(1- number)’，因此Emacs将 ‘number’ 的值从2递减到
     1。

步骤2    评估 ‘triangle-recursively’ 函数。

     Lisp解释器创建了 ‘triangle-recursively’ 的一个单独实例。这个函数包
     含在它自己的内部并不重要。Emacs将步骤1的结果作为这个
     ‘triangle-recursively’ 函数实例使用的参数传递。

     在这种情况下，Emacs使用参数1评估 ‘triangle-recursively’。这意味着这
     次评估返回1。

步骤3    评估 ‘number’ 的值。

     变量 ‘number’ 是以 ‘+’ 开头的列表的第二个元素；它的值为2。

步骤4    评估 ‘+’ 表达式。

     ‘+’ 表达式接收两个参数，第一个来自 ‘number’ 的评估（步骤3），第二个
     来自 ‘triangle-recursively’ 的评估（步骤2）。

     加法的结果是2加1的和，返回数字3，这是正确的。一个有两行的三角形中有
     三颗小石子。


File: eintr.info,  Node: Recursive Example arg of 3 or 4,  Prev: Recursive Example arg of 1 or 2,  Up: Recursive triangle function

参数为3或4的情况
................

假设调用 ‘triangle-recursively’ 时参数为3。

步骤 1    评估再次执行测试。

     首先评估 ‘if’ 表达式。这是再次执行测试，并返回false，因此 ‘if’ 表达
     式的else部分将被评估。（请注意，在此示例中，再次执行测试在测试
     false时导致函数调用自身，而不是在测试true时。）

步骤 2    评估else部分的最内层表达式。

     评估else部分的最内层表达式，将3减少到2。这是下一步表达式。

步骤 3    评估 ‘triangle-recursively’ 函数。

     将数字2传递给 ‘triangle-recursively’ 函数。

     我们已经知道当Emacs使用参数2评估 ‘triangle-recursively’ 时会发生什
     么。在经历了前面描述的一系列动作后，它将返回值3。因此，在这里也将发
     生这种情况。

步骤 4    评估加法。

     3将作为参数传递给加法，并将被添加到调用函数的数字中，该数字为3。

函数整体返回的值将为6。

   现在我们知道当 ‘triangle-recursively’ 使用参数3调用时会发生什么，那么
如果使用参数4调用它会发生什么就显而易见了：

     在递归调用中，评估

          (triangle-recursively (1- 4))

     将返回评估的值

          (triangle-recursively 3)

     这是6，此值将通过第三行的加法添加到4中。

函数整体返回的值将为10。

   每次评估 ‘triangle-recursively’ 时，它都会评估它自己的版本—一个具有较
小参数的不同实例，直到参数足够小以使其不再评估自身。

   请注意，这种递归函数的特定设计要求推迟操作。

   在 ‘(triangle-recursively 7)’ 可以计算其答案之前，它必须调用
‘(triangle-recursively 6)’；在 ‘(triangle-recursively 6)’ 可以计算其答案
之前，它必须调用 ‘(triangle-recursively 5)’；依此类推。也就是说，
‘(triangle-recursively 7)’ 进行的计算必须推迟，直到
‘(triangle-recursively 6)’ 进行其计算为止；而 ‘(triangle-recursively 6)’
必须推迟，直到 ‘(triangle-recursively 5)’ 完成为止；依此类推。

   如果将 ‘triangle-recursively’ 的每个实例都视为不同的机器人，第一个机
器人必须等待第二个完成其工作，第二个必须等待第三个完成，依此类推。

   有一种绕过这种等待的方法，我们将在 *note 无推迟的递归: No Deferment.
中讨论。


File: eintr.info,  Node: Recursion with cond,  Next: Recursive Patterns,  Prev: Recursive triangle function,  Up: Recursion

11.3.5 使用 ‘cond’ 进行递归的例子
---------------------------------

先前描述的 ‘triangle-recursively’ 版本是用 ‘if’ 特殊形式编写的。它也可以
使用另一种特殊形式称为 ‘cond’ 来编写。特殊形式 ‘cond’ 的名称是单词
‘conditional’ 的缩写。

   尽管在 Emacs Lisp 源代码中并不像 ‘if’ 那样经常使用 ‘cond’ 特殊形式，
但它被足够频繁地使用，以便解释它是有道理的。

   ‘cond’ 表达式的模板如下：

     (cond
      BODY...)

其中 BODY 是一系列列表。

   更详细地写出来，模板如下：

     (cond
      (FIRST-TRUE-OR-FALSE-TEST FIRST-CONSEQUENT)
      (SECOND-TRUE-OR-FALSE-TEST SECOND-CONSEQUENT)
      (THIRD-TRUE-OR-FALSE-TEST THIRD-CONSEQUENT)
       ...)

   当 Lisp 解释器评估 ‘cond’ 表达式时，它评估第一个元素（即第一个表达式
中的 CAR 或 true-or-false-test）。

   如果 true-or-false-test 返回 ‘nil’，则跳过该表达式的其余部分，即
consequent，并评估下一个表达式的 true-or-false-test。当找到一个表达式，
其 true-or-false-test 返回非 ‘nil’ 的值时，将评估该表达式的 consequent。
consequent 可以是一个或多个表达式。如果 consequent 包含多个表达式，则按
顺序评估这些表达式，并返回最后一个的值。如果表达式没有 consequent，则返
回 true-or-false-test 的值。

   如果没有一个 true-or-false-test 测试为真，‘cond’ 表达式返回 ‘nil’。

   使用 ‘cond’ 编写的 ‘triangle’ 函数如下：

     (defun triangle-using-cond (number)
       (cond ((<= number 0) 0)
             ((= number 1) 1)
             ((> number 1)
              (+ number (triangle-using-cond (1- number))))))

在这个例子中，如果数字小于等于 0，则 ‘cond’ 返回 0；如果数字为 1，则返回
1；如果数字大于 1，则评估 ‘(+ number (triangle-using-cond (1-
number)))’。


File: eintr.info,  Node: Recursive Patterns,  Next: No Deferment,  Prev: Recursion with cond,  Up: Recursion

11.3.6 递归模式
---------------

以下是三种常见的递归模式，每一种都涉及到列表。递归不一定需要涉及列表，但
Lisp是为列表设计的，这展示了其原始功能的一种感觉。

* Menu:

* Every::
* Accumulate::
* Keep::


File: eintr.info,  Node: Every,  Next: Accumulate,  Up: Recursive Patterns

递归模式：_每个元素_
....................

在‘every’递归模式中，对列表的每个元素执行一个操作。

   基本模式如下：

   • 如果列表为空，则返回‘nil’。
   • 否则，对列表的开头（列表的CAR）执行操作
        − 通过对列表的其余部分（CDR）进行函数的递归调用，
        − 并且可以选择地将执行操作的元素与对其余部分进行递归调用的结果使
          用‘cons’结合。

   以下是一个例子：

     (defun square-each (numbers-list)
       "递归地计算NUMBERS LIST中的每个数字的平方。"
       (if (not numbers-list)                ; do-again-test
           nil
         (cons
          (* (car numbers-list) (car numbers-list))
          (square-each (cdr numbers-list))))) ; next-step-expression

     (square-each '(1 2 3))
         ⇒ (1 4 9)

如果‘numbers-list’为空，则不执行任何操作。但如果它包含内容，则构造一个列
表，其中包含第一个数字的平方与递归调用的结果的结合。

   （该示例完全遵循该模式：如果数字列表为空，则返回‘nil’。在实践中，您会
编写条件语句，以便在数字列表不为空时执行操作。）

   ‘print-elements-recursively’函数（*note Recursion with a List:
Recursion with list.）是‘every’模式的另一个示例，不同之处在于，我们不使
用‘cons’将结果组合在一起，而是逐个打印输出的每个元素。

   ‘print-elements-recursively’函数如下：

     (setq animals '(gazelle giraffe lion tiger))

     (defun print-elements-recursively (list)
       "逐行打印LIST中的每个元素。使用递归。"
       (when list                            ; do-again-test
             (print (car list))              ; body
             (print-elements-recursively     ; recursive call
              (cdr list))))                  ; next-step-expression

     (print-elements-recursively animals)

   ‘print-elements-recursively’的模式如下：

   • 当列表为空时，不执行任何操作。
   • 但是当列表至少有一个元素时，
        − 对列表的开头（列表的CAR）执行操作，
        − 并对列表的其余部分（CDR）进行递归调用。


File: eintr.info,  Node: Accumulate,  Next: Keep,  Prev: Every,  Up: Recursive Patterns

递归模式：_累积_
................

另一种递归模式称为‘累积’模式。在‘累积’递归模式中，对列表的每个元素执行一
个操作，并将该操作的结果与对其他元素执行的操作的结果累积在一起。

   这与使用‘cons’的‘每个’模式非常相似，只是不使用‘cons’，而是使用其他某
个组合器。

   该模式如下：

   • 如果列表为空，则返回零或其他常数。
   • 否则，对列表的开头（列表的CAR）进行操作，
        − 将该操作的元素与
        − 通过对列表的其余部分（CDR）进行递归调用的函数进行组合，使用
          ‘+’或其他组合函数。

   以下是一个示例：

     (defun add-elements (numbers-list)
       "将NUMBERS-LIST的元素相加。"
       (if (not numbers-list)
           0
         (+ (car numbers-list) (add-elements (cdr numbers-list)))))

     (add-elements '(1 2 3 4))
         ⇒ 10

   *Note 制作文件列表: Files List, 以获取累积模式的示例。


File: eintr.info,  Node: Keep,  Prev: Accumulate,  Up: Recursive Patterns

递归模式：_保留_
................

第三种递归模式称为‘保留’模式。 在‘保留’递归模式中，测试列表的每个元素；
只有在元素满足条件时，对该元素进行操作并仅保留结果。

   同样，这与‘每个’模式非常相似，只是除非元素满足条件，否则将跳过该元素
。

   该模式有三个部分：

   • 如果列表为空，则返回‘nil’。
   • 否则，如果列表的开头（列表的CAR）通过 一个测试
        − 对该元素进行操作并使用‘cons’与
        − 通过对列表的其余部分（CDR）进行递归调用的函数进行组合。
   • 否则，如果列表的开头（列表的CAR）未通过 测试
        − 跳过该元素，
        − 并以对列表的其余部分（CDR）进行递归调用的方式进行递归调用。

   以下是一个使用‘cond’的示例：

     (defun keep-three-letter-words (word-list)
       "保留WORD-LIST中的三个字母的单词。"
       (cond
        ;; 第一个再次测试：停止条件
        ((not word-list) nil)

        ;; 第二个再次测试：何时操作
        ((eq 3 (length (symbol-name (car word-list))))
         ;; 将已操作的元素与对较短列表进行递归调用的结果组合
         (cons (car word-list) (keep-three-letter-words (cdr word-list))))

        ;; 第三个再次测试：何时跳过元素；
        ;;   以下一步表达式对较短列表进行递归调用
        (t (keep-three-letter-words (cdr word-list)))))

     (keep-three-letter-words '(one two three four five six))
         ⇒ (one two six)

   毫无疑问，您无需使用‘nil’作为停止测试的条件；当然，您可以组合这些模式
。


File: eintr.info,  Node: No Deferment,  Next: No deferment solution,  Prev: Recursive Patterns,  Up: Recursion

11.3.7 无推迟的递归
-------------------

让我们再次考虑一下‘triangle-recursively’函数的运行情况。我们会发现中间计
算被推迟，直到所有计算都可以完成。

   以下是函数定义：

     (defun triangle-recursively (number)
       "返回从1加到NUMBER（包括）的数字的和。
     使用递归。"
       (if (= number 1)                    ; do-again-test
           1                               ; then-part
         (+ number                         ; else-part
            (triangle-recursively          ; recursive call
             (1- number)))))               ; next-step-expression

   当我们使用参数7调用此函数时会发生什么？

   第一次调用‘triangle-recursively’函数会将数字7与第二个
‘triangle-recursively’实例的返回值相加，该实例已被传递了一个 参数为6。也
就是说，第一次计算是：

     (+ 7 (triangle-recursively 6))

第一次调用‘triangle-recursively’—你可以把它想象成一个小机器人—无法完成它
的工作。它必须将‘(triangle-recursively 6)’的计算委托给程序的第二个实例，
即第二个机器人。这第二个个体与第一个完全不同；它是，按行话来说，一个“不
同的实例”。“换句话说，它是一个不同的机器人。它与第一个相同；它递归地计算
三角形数；但它有一个不同的序列号。

   那么‘(triangle-recursively 6)’返回什么呢？它返回数字6加上评估带有参数
5的 ‘triangle-recursively’的返回值。使用机器人的隐喻，它要求另一个机器人
帮助它。

   现在总数是：

     (+ 7 6 (triangle-recursively 5))

   接下来会发生什么？

     (+ 7 6 5 (triangle-recursively 4))

   每次调用‘triangle-recursively’，除了最后一次外，它都会创建程序的另一
个实例—另一个机器人—并要求它进行计算。

   最终，完整的加法被设置并执行：

     (+ 7 6 5 4 3 2 1)

   这个函数的设计推迟了第一步的计算，直到第二步可以完成，然后推迟到第三
步可以完成，依此类推。每个推迟都意味着计算机必须记住正在等待什么。在这个
例子中，当步骤很少时，这不是问题。但当步骤更多时，这可能会成为问题。


File: eintr.info,  Node: No deferment solution,  Prev: No Deferment,  Up: Recursion

11.3.8 无推迟解决方案
---------------------

解决推迟操作的问题的方法是以不推迟操作的方式编写代码(1)。这需要编写一个
不同的模式，通常涉及编写两个函数定义，一个初始化函数和一个辅助函数。

   初始化函数设置任务；辅助函数执行工作。

   以下是两个求和的函数定义。它们非常简单，我发现它们很难理解。

     (defun triangle-initialization (number)
       "返回从1加到NUMBER（包括）的数字的和。
     这是使用递归的两个函数对的初始化组件。"
       (triangle-recursive-helper 0 0 number))

     (defun triangle-recursive-helper (sum counter number)
       "使用COUNTER返回SUM，通过NUMBER（包括）。
     这是使用递归的两个函数对的辅助组件。"
       (if (> counter number)
           sum
         (triangle-recursive-helper (+ sum counter)  ; sum
                                    (1+ counter)     ; counter
                                    number)))        ; number

   通过评估这两个函数定义来安装它们，然后使用2行调用
‘triangle-initialization’：

     (triangle-initialization 2)
         ⇒ 3

   初始化函数使用三个参数调用辅助函数的第一个实例：零，零，以及三角形中
的行数。

   传递给辅助函数的前两个参数是初始化值。这些值在
‘triangle-recursive-helper’调用新实例时会更改。(2)

   让我们看看当我们有一个只有一行的三角形时会发生什么。（这个三角形将有
一个小石子！）

   ‘triangle-initialization’将使用参数‘0 0 1’调用它的辅助函数。该函数将
运行条件测试，即‘(> counter number)’：

     (> 0 1)

并发现结果为假，因此它将调用‘if’子句的else部分：

         (triangle-recursive-helper
          (+ sum counter)  ; sum加counter ⇒ sum
          (1+ counter)     ; 增加counter ⇒ counter
          number)          ; number保持不变

这将首先计算：

     (triangle-recursive-helper (+ 0 0)  ; sum
                                (1+ 0)   ; counter
                                1)       ; number
即：

     (triangle-recursive-helper 0 1 1)

   再次，‘(> counter number)’将为假，因此Lisp解释器将评估
‘triangle-recursive-helper’，创建一个新实例并传递新参数。

   这个新实例将是：

         (triangle-recursive-helper
          (+ sum counter)  ; sum加counter ⇒ sum
          (1+ counter)     ; 增加counter ⇒ counter
          number)          ; number保持不变

即：

     (triangle-recursive-helper 1 2 1)

   在这种情况下，‘(> counter number)’测试将为真！因此，该实例将返回
‘sum’的值，该值将是1，符合预期。

   现在，让我们将‘triangle-initialization’的参数设置为2，以查看具有两行
的三角形中有多少个小石子。

   该函数调用‘(triangle-recursive-helper 0 0 2)’。

   分阶段，被调用的实例将是：

                               sum counter number
     (triangle-recursive-helper 0    1       2)

     (triangle-recursive-helper 1    2       2)

     (triangle-recursive-helper 3    3       2)

   当调用最后一个实例时，‘(> counter number)’测试将为真，因此该实例将返
回‘sum’的值，该值将是3。

   这种模式在编写可能使用计算机中的许多资源的函数时很有帮助。

   ---------- Footnotes ----------

   (1) 术语“尾递归”用来描述这种使用常量空间的过程。

   (2) 术语有点混乱：‘triangle-recursive-helper’在递归的过程中使用迭代的
方式，因为计算机只需记录三个值‘sum’、‘counter’和‘number’；而该过程在递归
的过程中使用递归的方式，因为函数调用了自身。另一方面，
‘triangle-recursively’使用的过程和过程都被称为递归。在这两种情况下，“递
归”这个词在两个上下文中有不同的含义。


File: eintr.info,  Node: Looping exercise,  Prev: Recursion,  Up: Loops & Recursion

11.4 循环练习
=============

   • 编写一个类似于 ‘triangle’ 的函数，其中每一行的值是该行号的平方。使
     用 ‘while’ 循环。

   • 编写一个类似于 ‘triangle’ 的函数，但是它将值相乘而不是相加。

   • 递归地重写这两个函数。使用 ‘cond’ 重写这些函数。

   • 为 Texinfo 模式编写一个函数，在段落开头为每个段落中的 ‘@dfn’ 创建一
     个索引条目。 （在 Texinfo 文件中，‘@dfn’ 标记一个定义。本书是用
     Texinfo 编写的。）

     你将需要用到前两章中的许多函数，*note 剪切与存储文本: Cutting &
     Storing Text. 和 *note Yanking Text Back: Yanking. 中有它们的描述。
     如果使用 ‘forward-paragraph’ 将索引条目放在段落开头，您将需要使用
     ‘C-h f’（‘describe-function’）查找如何使命令向后执行。

     更多信息，请参见 *note Indicating Definitions:
     (texinfo)Indicating.。


File: eintr.info,  Node: Regexp Search,  Next: Counting Words,  Prev: Loops & Recursion,  Up: Top

12 正则表达式搜索
*****************

正则表达式搜索在GNU Emacs中被广泛使用。两个函数，‘forward-sentence’和
‘forward-paragraph’，很好地说明了这些搜索的用法。它们使用正则表达式来确
定点应该移动到哪里。短语“正则表达式”通常写作“regexp”。

   正则表达式搜索在*note Regular Expression Search: (emacs)Regexp
Search.中有详细描述，以及在*note (elisp)Regular Expressions::中也有描述
。在撰写本章时，我假定您至少对它们有一些了解。需要记住的主要观点是正则表
达式允许您搜索模式以及字符字面上的字符串。例如，‘forward-sentence’函数中
的代码搜索可能标记句子结束的字符模式，并将点移动到该位置。

   在查看‘forward-sentence’函数的代码之前，值得考虑一下标记句子结束的模
式是什么。该模式将在下一节中讨论；随后是正则表达式搜索函数
‘re-search-forward’的描述。‘forward-sentence’函数在其后的部分中描述。最
后，本章的最后一节描述了‘forward-paragraph’函数。‘forward-paragraph’是一
个复杂的函数，引入了一些新功能。

* Menu:

* sentence-end::                ‘sentence-end’的正则表达式。
* re-search-forward::           与‘search-forward’非常相似。
* forward-sentence::            正则表达式搜索的简单示例。
* forward-paragraph::           一个相对复杂的示例。
* Regexp Review::
* re-search Exercises::


File: eintr.info,  Node: sentence-end,  Next: re-search-forward,  Up: Regexp Search

12.1 关于 ‘sentence-end’ 的正则表达式
=====================================

符号 ‘sentence-end’ 被绑定到标记句子结束的模式。这个正则表达式应该是什么
呢？

   显然，句子可以以句点、问号或感叹号结束。实际上，在英语中，只有以这三
个字符之一结尾的从句才应被视为句子的结束。这意味着模式应包括字符集：

     [.?!]

   然而，我们不希望 ‘forward-sentence’ 只是简单地跳到句点、问号或感叹号
，因为这样的字符可能在句子中间使用。例如，句点在缩写后使用。因此，需要其
他信息。

   按照约定，你在每个句子后面键入两个空格，但在句子中间的句点、问号或感
叹号后只键入一个空格。因此，句点、问号或感叹号后跟两个空格是句子结束的良
好指示器。然而，在文件中，这两个空格可能被制表符或行尾替代。这意味着正则
表达式应包括这三个项作为备选项。

   这组备选项将如下所示：

     \\($\\| \\|  \\)
            ^   ^^
           TAB  SPC

这里，‘$’ 表示行尾，我标出了制表符和两个空格在表达式中的位置。两者都是通
过将实际字符放入表达式中插入的。

   在括号和竖线前需要两个反斜杠，‘\\’：第一个反斜杠引用 Emacs 中的后续反
斜杠；第二个指示后面的字符（括号或竖线）是特殊的。

   另外，句子后面可能跟着一个或多个回车，就像这样：

     [
     ]*

与制表符和空格一样，通过将其直接插入正则表达式，回车就会插入其中。星号表
示 <RET> 重复零次或多次。

   但句子结尾不仅仅包括句点、问号或感叹号后跟适当的空格：可能有一个闭合
引号或某种括号在空格之前。事实上，可能有一个以上这样的引号或括号在空格之
前。这需要一个如下所示的表达式：

     []\"')}]*

   在这个表达式中，第一个 ‘]’ 是表达式中的第一个字符；第二个字符是 ‘"’，
它前面有一个 ‘\’，告诉 Emacs ‘"’ 不是特殊字符。最后三个字符是 ‘'’, ‘)’ 和
‘}’。

   所有这些都暗示了匹配句子结尾的正则表达式模式，确实，如果我们评估
‘sentence-end’，我们会发现它返回以下值：

     sentence-end
          ⇒ "[.?!][]\"')}]*\\($\\|     \\|  \\)[
     ]*"

（好吧，在 GNU Emacs 22 中不是这样；这是因为为了使过程更简单并处理更多的
字形和语言而做的努力。当 ‘sentence-end’ 的值为 ‘nil’ 时，使用函数
‘sentence-end’ 定义的值。 （这是 Emacs Lisp 中值和函数之间差异的使用示例
。）该函数返回由变量 ‘sentence-end-base’、‘sentence-end-double-space’、
‘sentence-end-without-period’ 和 ‘sentence-end-without-space’ 构造的值。
关键变量是 ‘sentence-end-base’；它的全局值类似于上述描述的值，但还包含两
个额外的引号。这些引号的弯曲程度不同。当 ‘sentence-end-without-period’ 变
量为真时，告诉 Emacs 句子可以在没有句点的情况下结束，例如泰语文本。）


File: eintr.info,  Node: re-search-forward,  Next: forward-sentence,  Prev: sentence-end,  Up: Regexp Search

12.2 ‘re-search-forward’ 函数
=============================

‘re-search-forward’ 函数与 ‘search-forward’ 函数非常相似。(*Note
‘search-forward’ 函数: search-forward.)

   ‘re-search-forward’ 用于搜索正则表达式。如果搜索成功，它将把光标立即
放在目标的最后一个字符之后。如果是反向搜索，它将把光标放在目标的第一个字
符之前。您可以告诉 ‘re-search-forward’ 在搜索成功时返回 ‘t’。 (移动光标
因此是一个副作用。)

   与 ‘search-forward’ 一样，‘re-search-forward’ 函数接受四个参数：

  1. 第一个参数是要搜索的正则表达式。正则表达式将是双引号之间的字符串。

  2. 可选的第二个参数限制函数搜索的范围；它是一个界限，指定为缓冲区中的
     位置。

  3. 可选的第三个参数指定函数对失败的响应方式：当搜索失败时，第三个参数
     为 ‘nil’ 会导致函数发出错误信号（并打印一条消息）；任何其他值会导致
     在搜索失败时返回 ‘nil’，在搜索成功时返回 ‘t’。

  4. 可选的第四个参数是重复计数。负重复计数会导致 ‘re-search-forward’ 进
     行向后搜索。

   ‘re-search-forward’ 的模板如下：

     (re-search-forward "正则表达式"
                     搜索限制
                     失败时的操作
                     重复计数)

   第二、第三和第四个参数是可选的。但是，如果您想向最后两个参数之一或两
者都传递一个值，您还必须向所有前面的参数传递一个值。否则，Lisp 解释器将
混淆您正在传递值的参数。

   在 ‘forward-sentence’ 函数中，正则表达式将是变量 ‘sentence-end’ 的值
。简单形式如下：

     "[.?!][]\"')}]*\\($\\|  \\|  \\)[
     ]*"

搜索的限制将是段落的末尾（因为句子不能超过段落）。如果搜索失败，函数将返
回 ‘nil’；而重复计数将由 ‘forward-sentence’ 函数的参数提供。


File: eintr.info,  Node: forward-sentence,  Next: forward-paragraph,  Prev: re-search-forward,  Up: Regexp Search

12.3 ‘forward-sentence’
=======================

将光标向前移动到下一个句子末尾的命令是如何在Emacs Lisp中使用正则表达式搜
索的一个直观例子。实际上，该函数看起来比实际复杂得多；这是因为该函数旨在
向前和向后移动；而且，可选地，可以跨越多个句子。该函数通常绑定到键命令
‘M-e’。

* Menu:

* Complete forward-sentence::
* fwd-sentence while loops::    两个 ‘while’ 循环。
* fwd-sentence re-search::      正则表达式搜索。


File: eintr.info,  Node: Complete forward-sentence,  Next: fwd-sentence while loops,  Up: forward-sentence

完整的 ‘forward-sentence’ 函数定义
----------------------------------

以下是‘forward-sentence’的代码：

     (defun forward-sentence (&optional arg)
       "向前移动到下一个句子末尾。带有参数时重复。带有负数参数时，反复向后移动到句子开头。

     变量 `sentence-end' 是一个正则表达式，用于匹配句子的末尾。此外，每个段落边界也会终止句子。"
       (interactive "p")
       (or arg (setq arg 1))
       (let ((opoint (point))
             (sentence-end (sentence-end)))
         (while (< arg 0)
           (let ((pos (point))
                 (par-beg (save-excursion (start-of-paragraph-text) (point))))
            (if (and (re-search-backward sentence-end par-beg t)
                     (or (< (match-end 0) pos)
                         (re-search-backward sentence-end par-beg t)))
                (goto-char (match-end 0))
              (goto-char par-beg)))
           (setq arg (1+ arg)))
         (while (> arg 0)
           (let ((par-end (save-excursion (end-of-paragraph-text) (point))))
            (if (re-search-forward sentence-end par-end t)
                (skip-chars-backward " \t\n")
              (goto-char par-end)))
           (setq arg (1- arg)))
         (constrain-to-field nil opoint t)))

   这个函数乍一看似乎很长，最好先看它的骨架，然后再看它的实现。看骨架的
方法是查看从最左列开始的表达式：

     (defun forward-sentence (&optional arg)
       "DOCUMENTATION..."
       (interactive "p")
       (or arg (setq arg 1))
       (let ((opoint (point)) (sentence-end (sentence-end)))
         (while (< arg 0)
           (let ((pos (point))
                 (par-beg (save-excursion (start-of-paragraph-text) (point))))
            向后移动时 WHILE 循环的其余部分的主体
         (while (> arg 0)
           (let ((par-end (save-excursion (end-of-paragraph-text) (point))))
            向前移动时 WHILE 循环的其余部分的主体
         处理表单和等价物的表达式

   这看起来简单得多！函数定义由文档、一个‘interactive’表达式、一个‘or’表
达式、一个‘let’表达式和‘while’循环组成。

   让我们逐个查看这些部分。

   我们注意到文档写得很详细且易懂。

   函数有一个‘interactive "p"’声明。这意味着处理过的前缀参数（如果有）将
作为函数的参数传递。 （这将是一个数字。）如果函数未以参数形式调用（它是
可选的），则参数‘arg’将绑定为1。

   当以非交互方式调用‘forward-sentence’且没有参数时，‘arg’绑定为‘nil’。
‘or’表达式处理这一点。它的作用是仅在‘arg’绑定到一个值时保持‘arg’的值不变
；或者在‘arg’绑定到‘nil’时将‘arg’的值设置为1。

   接下来是一个‘let’。它指定了两个局部变量‘opoint’和‘sentence-end’的值。
从搜索之前的点的局部值用于‘constrain-to-field’函数，该函数处理表单和等价
物。‘sentence-end’变量由‘sentence-end’函数设置。


File: eintr.info,  Node: fwd-sentence while loops,  Next: fwd-sentence re-search,  Prev: Complete forward-sentence,  Up: forward-sentence

The ‘while’ loops
-----------------

接下来是两个‘while’循环。第一个‘while’具有一个真假测试，如果
‘forward-sentence’的前缀参数是负数，则测试为真。这是用于向后移动的情况。
该循环的主体类似于第二个‘while’子句的主体，但不完全相同。我们将跳过这个
‘while’循环，专注于第二个‘while’循环。

   第二个‘while’循环是用于向前移动点的。它的框架如下：

     (while (> arg 0)            ; 真假测试
       (let VARLIST
         (if (真假测试)
             THEN-PART
           ELSE-PART
       (setq arg (1- arg))))     ; while 循环递减器

   该‘while’循环是递减型的。(*Note A Loop with a Decrementing Counter:
Decrementing Loop.)  它有一个真假测试，只要计数器（在这种情况下是变量
‘arg’）大于零，测试就为真；并且有一个递减器，每次循环重复时从计数器的值
中减去1。

   如果没有给‘forward-sentence’提供前缀参数，这是该命令最常用的方式，那
么这个‘while’循环将运行一次，因为‘arg’的值将为1。

   ‘while’循环的主体包含一个‘let’表达式，该表达式创建和绑定一个局部变量
，并且其主体是一个‘if’表达式。

   ‘while’循环的主体如下：

     (let ((par-end
            (save-excursion (end-of-paragraph-text) (point))))
       (if (re-search-forward sentence-end par-end t)
           (skip-chars-backward " \t\n")
         (goto-char par-end)))

   ‘let’表达式创建并绑定局部变量‘par-end’。正如我们将看到的，此局部变量
旨在为正则表达式搜索提供一个边界或限制。如果搜索未能在段落中找到适当的句
子结束，它将在达到段落末尾时停止。

   但首先，让我们查看‘par-end’如何绑定到段落末尾的值。发生的是‘let’将
‘par-end’的值设置为Lisp解释器评估表达式时返回的值

     (save-excursion (end-of-paragraph-text) (point))

在此表达式中，‘(end-of-paragraph-text)’将point移动到段落末尾，
‘(point)’返回point的值，然后‘save-excursion’将point恢复到其原始位置。因
此，‘let’将‘par-end’绑定到由‘save-excursion’表达式返回的值，即段落末尾的
位置。 (‘end-of-paragraph-text’函数使用‘forward-paragraph’，我们将很快讨
论。)

   接下来，Emacs评估‘let’的主体，这是一个‘if’表达式，如下所示：

     (if (re-search-forward sentence-end par-end t) ; if部分
         (skip-chars-backward " \t\n")              ; then部分
       (goto-char par-end)))                        ; else部分

   ‘if’测试其第一个参数是否为真，如果是，则评估其then部分；否则，Emacs
Lisp解释器将评估else部分。‘if’表达式的真假测试是正则表达式搜索。

   可能看起来奇怪的是，在这里埋藏看起来像是‘forward-sentence’函数的实际
工作，但这是Lisp中执行此类操作的常见方式。


File: eintr.info,  Node: fwd-sentence re-search,  Prev: fwd-sentence while loops,  Up: forward-sentence

正则表达式搜索
--------------

函数 ‘re-search-forward’ 用于搜索句子的结尾，即由 ‘sentence-end’ 正则表
达式定义的模式。如果找到模式——也就是找到了句子的结尾——那么
‘re-search-forward’ 函数会执行两个操作：

  1. ‘re-search-forward’ 函数执行一个副作用，即将点移动到找到的出现的结
     尾。

  2. ‘re-search-forward’ 函数返回 true 的值。这是由 ‘if’ 接收的值，并表
     示搜索成功。

副作用，即点的移动，在 ‘if’ 函数接收到搜索成功的返回值之前完成。

   当 ‘if’ 函数从成功调用 ‘re-search-forward’ 接收到 true 的值时，‘if’ 会
评估 then 部分，即表达式 ‘(skip-chars-backward " \t\n")’。这个表达式向后
移动任何空格、制表符或回车，直到找到一个打印字符，然后将点留在字符之后。
由于点已经被移动到标记句子结尾的模式的末尾，这个操作将点留在句子的结束字
符后，通常是一个句点。

   另一方面，如果 ‘re-search-forward’ 函数未能找到标记句子结束的模式，则
该函数返回 false。然后 false 导致 ‘if’ 评估其第三个参数，即 ‘(goto-char
par-end)’：将点移动到段落的末尾。

   （如果文本处于表单或等效状态，且点可能无法完全移动，则会调用
‘constrain-to-field’ 函数。）

   正则表达式搜索非常有用，而由 ‘re-search-forward’ 展示的模式，其中搜索
是 ‘if’ 表达式的测试，非常方便。你会经常看到或编写包含这个模式的代码。


File: eintr.info,  Node: forward-paragraph,  Next: Regexp Review,  Prev: forward-sentence,  Up: Regexp Search

12.4 ‘forward-paragraph’：一个丰富的功能集合
============================================

‘forward-paragraph’ 函数将点（point）向前移动到段落末尾。通常绑定到
‘M-}’，并且使用一些重要的函数，包括‘let*’、‘match-beginning’ 和
‘looking-at’。

   ‘forward-paragraph’ 的函数定义比 ‘forward-sentence’ 的函数定义长得多
，因为它处理一个段落，其中每一行可能以填充前缀开始。

   填充前缀由一串在每一行开头重复的字符组成。例如，在 Lisp 代码中，通常
使用 ‘;;; ’ 开始段落长注释的每一行。在文本模式中，四个空格组成了另一种常
见的填充前缀，创建一个缩进的段落。（有关填充前缀的更多信息，请参阅 *Note
(emacs)Fill Prefix::。）

   存在填充前缀意味着除了能够找到以最左列开始的段落的末尾之外，
‘forward-paragraph’ 函数还必须能够找到在缓冲区中所有或许多行都以填充前缀
开头的段落的末尾。

   此外，有时忽略存在的填充前缀是切实可行的，特别是在空白行分隔段落时。
这是一个额外的复杂性。

* Menu:

* forward-paragraph in brief::  函数定义的关键部分。
* fwd-para let::                ‘let*’ 表达式。
* fwd-para while::              前进运动的 ‘while’ 循环。


File: eintr.info,  Node: forward-paragraph in brief,  Next: fwd-para let,  Up: forward-paragraph

Shortened ‘forward-paragraph’ function definition
-------------------------------------------------

与其打印整个 ‘forward-paragraph’ 函数，我们只打印其中的部分。如果毫无准
备地阅读，这个函数可能令人生畏！

   简而言之，该函数的轮廓如下：

     (defun forward-paragraph (&optional arg)
       "文档..."
       (interactive "p")
       (or arg (setq arg 1))
       (let*
           变量列表
         (while (and (< arg 0) (not (bobp)))     ; 向后移动的代码
           ...
         (while (and (> arg 0) (not (eobp)))     ; 向前移动的代码
           ...

   函数的前部分很常规：函数的参数列表包含一个可选参数。文档随后。

   在 ‘interactive’ 声明中的小写 ‘p’ 表示处理后的前缀参数（如果有）将传
递给函数。这将是一个数字，是光标将移动的段落数的重复计数。下一行的 ‘or’
表达式处理了未向函数传递参数的常见情况，即如果函数是从其他代码中调用而不
是交互式调用时发生的情况。此情况在之前已经描述过。(*Note The
‘forward-sentence’ function: forward-sentence.)  现在我们到达了这个函数
的熟悉部分的末尾。


File: eintr.info,  Node: fwd-para let,  Next: fwd-para while,  Prev: forward-paragraph in brief,  Up: forward-paragraph

The ‘let*’ expression
---------------------

‘forward-paragraph’ 函数的下一行开始了一个 ‘let*’ 表达式 (*note ‘let*’
introduced: let* introduced.)，在其中 Emacs 绑定了七个变量：‘opoint’、
‘fill-prefix-regexp’、‘parstart’、‘parsep’、‘sp-parstart’、‘start’ 和
‘found-start’。

   变量 ‘parsep’ 出现两次，首先是为了去除 ‘^’ 的实例，其次是为了处理填充
前缀。

   变量 ‘opoint’ 只是 ‘point’ 的值。正如你可以猜到的，它在一个
‘constrain-to-field’ 表达式中使用，就像在 ‘forward-sentence’ 中一样。

   变量 ‘fill-prefix-regexp’ 被设置为通过评估以下列表返回的值：

     (and fill-prefix
          (not (equal fill-prefix ""))
          (not paragraph-ignore-fill-prefix)
          (regexp-quote fill-prefix))

这是一个表达式，其第一个元素是 ‘and’ 特殊形式。

   正如我们之前学到的(*note ‘kill-new’ 函数: kill-new function.)，‘and’
特殊形式评估其每个参数，直到其中一个参数返回 ‘nil’ 的值，此时 ‘and’ 表达
式返回 ‘nil’；然而，如果没有任何参数返回 ‘nil’ 的值，则评估最后一个参数
产生的值将被返回。 (由于这样的值不是 ‘nil’，在 Lisp 中被视为真值。) 换句
话说，只有当 ‘and’ 表达式的所有参数都为真时，它才返回真值。

   在这种情况下，只有当以下四个表达式在评估时产生真值（即非 ‘nil’ 值）时
，变量 ‘fill-prefix-regexp’ 才绑定到非 ‘nil’ 值；否则，
‘fill-prefix-regexp’ 被绑定到 ‘nil’。

‘fill-prefix’
     评估此变量时，返回填充前缀的值（如果有的话）。如果没有填充前缀，则
     此变量返回 ‘nil’。

‘(not (equal fill-prefix ""))’
     此表达式检查现有填充前缀是否为空字符串，即不包含任何字符的字符串。
     空字符串不是有用的填充前缀。

‘(not paragraph-ignore-fill-prefix)’
     如果变量 ‘paragraph-ignore-fill-prefix’ 被设置为真值，如 ‘t’，则此
     表达式返回 ‘nil’。

‘(regexp-quote fill-prefix)’
     这是 ‘and’ 特殊形式的最后一个参数。如果 ‘and’ 的所有参数都为真，则
     通过评估此表达式产生的值将被 ‘and’ 表达式返回，并绑定到变量
     ‘fill-prefix-regexp’，

成功评估此 ‘and’ 表达式的结果是，‘fill-prefix-regexp’ 将绑定到由
‘regexp-quote’ 函数修改的 ‘fill-prefix’ 的值。 ‘regexp-quote’ 做的是读取
一个字符串并返回一个正则表达式，该正则表达式将精确匹配该字符串且不匹配其
他任何内容。这意味着如果存在填充前缀，‘fill-prefix-regexp’ 将被设置为一
个精确匹配填充前缀的值。否则，该变量将被设置为 ‘nil’。

   ‘let*’ 表达式中的下两个局部变量旨在从 ‘parstart’ 和 ‘parsep’ 中删除
‘^’ 的实例。接下来的表达式再次设置 ‘parsep’。这是为了处理填充前缀。

   这是定义调用 ‘let*’ 而不是 ‘let’ 的设置。 ‘if’ 表达式的真假测试取决于
变量 ‘fill-prefix-regexp’ 是否评估为 ‘nil’ 或其他值。

   如果 ‘fill-prefix-regexp’ 没有值，Emacs 评估 ‘if’ 表达式的 else-部分
，并将 ‘parsep’ 绑定到其局部值。 (‘parsep’ 是一个匹配段落之间分隔符的正
则表达式。)

   但是，如果 ‘fill-prefix-regexp’ 有值，Emacs 将评估 ‘if’ 表达式的
then-部分，并将 ‘parsep’ 绑定到一个正则表达式，该正则表达式包含
‘fill-prefix-regexp’ 作为模式的一部分。

   具体而言，‘parsep’ 被设置为段落分隔正则表达式的原始值，后面跟着一个可
选的空白到行尾的替代表达式，由 ‘"[ \t]*$"’ 定义。) ‘\\|’ 定义了正则表达
式的这一部分作为 ‘parsep’ 的替代项。

   根据代码中的注释，接下来的局部变量，‘sp-parstart’，用于搜索，然后最后
两个，‘start’ 和 ‘found-start’，被设置为 ‘nil’。

   现在我们进入了 ‘let*’ 的主体。 ‘let*’ 的主体的第一部分处理函数被给予
负参数且因此向后移动的情况。我们将跳过这一部分。


File: eintr.info,  Node: fwd-para while,  Prev: fwd-para let,  Up: forward-paragraph

前进动作 ‘while’ 循环
---------------------

‘let*’ 的第二部分处理前进动作。它是一个 ‘while’ 循环，只要 ‘arg’ 的值大
于零就重复执行。在函数的最常见用法中，参数的值为 1，因此 ‘while’ 循环的
主体只被评估一次，光标向前移动一个段落。

   这部分处理三种情况：当光标在段落之间时，当存在填充前缀时，当不存在填
充前缀时。

   ‘while’ 循环如下：

     ;; 向前移动且不在缓冲区末尾
     (while (and (> arg 0) (not (eobp)))

       ;; 在段落之间
       ;; 向前移动过分隔行…
       (while (and (not (eobp))
                   (progn (move-to-left-margin) (not (eobp)))
                   (looking-at parsep))
         (forward-line 1))
       ;;  这减少了循环计数
       (unless (eobp) (setq arg (1- arg)))
       ;; …再多移动一行。
       (forward-line 1)

       (if fill-prefix-regexp
           ;; 存在填充前缀；它覆盖了 parstart；
           ;; 我们逐行向前移动
           (while (and (not (eobp))
                       (progn (move-to-left-margin) (not (eobp)))
                       (not (looking-at parsep))
                       (looking-at fill-prefix-regexp))
             (forward-line 1))

         ;; 不存在填充前缀；
         ;; 我们逐字符向前移动
         (while (and (re-search-forward sp-parstart nil 1)
                     (progn (setq start (match-beginning 0))
                            (goto-char start)
                            (not (eobp)))
                     (progn (move-to-left-margin)
                            (not (looking-at parsep)))
                     (or (not (looking-at parstart))
                         (and use-hard-newlines
                              (not (get-text-property (1- start) 'hard)))))
           (forward-char 1))

         ;; 如果没有填充前缀且不在末尾，
         ;;     则转到在正则表达式搜索 sp-parstart 中找到的内容
         (if (< (point) (point-max))
             (goto-char start))))

   我们可以看到这是一个递减计数器的 ‘while’ 循环，使用表达式 ‘(setq arg
(1- arg))’ 作为递减器。该表达式并不远离 ‘while’，但被隐藏在另一个 Lisp 宏
中，即 ‘unless’ 宏。除非我们在缓冲区末尾——这是 ‘eobp’ 函数确定的；它是
‘End Of Buffer P’ 的缩写——否则我们会将 ‘arg’ 的值减小一。

   （如果我们在缓冲区末尾，我们无法再向前移动，由于测试是与 ‘(not
(eobp))’ 的 ‘and’，下一个循环的表达式将测试为假，因为 ‘not’ 函数的作用与
您期望的完全相同；它是 ‘null’ 的另一个名称，当其参数为假时返回真。）

   有趣的是，循环计数器在我们离开段落之间之前并未递减，除非我们到达缓冲
区的末尾或停止看到段落分隔符的本地值。

   这第二个 ‘while’ 也有一个 ‘(move-to-left-margin)’ 表达式。该函数是不
言自明的。它在一个 ‘progn’ 表达式中，并且不是其主体的最后一个元素，因此
它仅被调用以产生其移动到当前行左边缘的副作用。

   ‘looking-at’ 函数同样不言自明；如果点之后的文本与其参数给定的正则表达
式匹配，则返回真。

   在理解的过程中，循环体的其余部分起初看起来可能有些困难，但随着理解，
它会变得合理。

   首先考虑如果存在填充前缀时会发生什么：

       (if fill-prefix-regexp
           ;; 存在填充前缀；它覆盖了 parstart；
           ;; 我们逐行向前移动
           (while (and (not (eobp))
                       (progn (move-to-left-margin) (not (eobp)))
                       (not (looking-at parsep))
                       (looking-at fill-prefix-regexp))
             (forward-line 1))

这个表达式会使点逐行向前移动，只要四个条件都为真：

  1. 点不在缓冲区末尾。

  2. 我们可以移动到文本的左边缘且不在缓冲区末尾。

  3. 点之后的文本不分隔段落。

  4. 点之后的模式是填充前缀正则表达式。

   最后一个条件可能令人困惑，直到您记住点在 ‘forward-paragraph’ 函数中早
期被移动到行的开头。这意味着如果文本有填充前缀，‘looking-at’ 函数将会看
到它。

   考虑当没有填充前缀时会发生什么。

         (while (and (re-search-forward sp-parstart nil 1)
                     (progn (setq start (match-beginning 0))
                            (goto-char start)
                            (not (eobp)))
                     (progn (move-to-left-margin)
                            (not (looking-at parsep)))
                     (or (not (looking-at parstart))
                         (and use-hard-newlines
                              (not (get-text-property (1- start) 'hard)))))
           (forward-char 1))

这个 ‘while’ 循环让我们向前搜索 ‘sp-parstart’，它是可能的空白字符与段落
或段落分隔符的本地值的组合。 （后两者都在以 ‘\(?:’ 开头的表达式中，以便
它们不被 ‘match-beginning’ 函数引用。）

   这两个表达式，

     (setq start (match-beginning 0))
     (goto-char start)

意味着转到由正则表达式搜索匹配的文本的开头。

   ‘(match-beginning 0)’ 表达式是新的。它返回一个指定由最近的搜索匹配的
文本的开头位置的数字。

   当给定参数 0 时，‘match-beginning’ 返回最近搜索匹配的文本的开头位置。
在这种情况下，最近的搜索寻找 ‘sp-parstart’。‘(match-beginning 0)’ 表达式
返回该模式的开头位置，而不是该模式的结束位置。

   （顺便说一下，当作为参数传递一个正数时，‘match-beginning’ 函数返回最
后一次搜索中括号表达式的位置，除非该括号表达式以 ‘\(?:’ 开头。我不知道为
什么这里出现 ‘\(?:’，因为参数是 0。）

   当没有填充前缀时的最后一个表达式是

     (if (< (point) (point-max))
         (goto-char start))))

这表示如果没有填充前缀且不在末尾，点应该移动到由正则表达式搜索
‘sp-parstart’ 找到的内容的开头。

   ‘forward-paragraph’ 函数的完整定义不仅包括前进的代码，还包括后退的代
码。

   如果您在 GNU Emacs 中阅读此内容并想查看整个函数，请键入 ‘C-h f’（
‘describe-function’）和函数的名称。这会给您函数文档和包含函数源代码的库
的名称。将点放在库的名称上，然后按 <RET> 键；您将直接转到源代码。（确保
安装了源代码！没有源代码，您就像闭着眼睛开车的人一样！）


File: eintr.info,  Node: Regexp Review,  Next: re-search Exercises,  Prev: forward-paragraph,  Up: Regexp Search

12.5 复习
=========

以下是一些最近引入的函数的简要概述。

‘while’
     重复评估表达式体的主体，只要体的第一个元素测试为真。然后返回‘nil’。
     （仅为了其副作用而评估表达式。）

     例如：

          (let ((foo 2))
            (while (> foo 0)
              (insert (format "foo is %d.\n" foo))
              (setq foo (1- foo))))

               ⇒      foo is 2.
                       foo is 1.
                       nil

     （‘insert’函数在光标处插入其参数；‘format’函数根据其参数的方式返回
     一个字符串，就像‘message’格式化其参数一样；‘\n’产生一个新行。）

‘re-search-forward’
     搜索模式，如果找到模式，则将光标移动到其后。

     与‘search-forward’相似，接受四个参数：

       1. 一个正则表达式，指定要搜索的模式。（记得在这个参数周围加上引号
          ！）

       2. 可选的搜索限制。

       3. 可选的，如果搜索失败，返回‘nil’或错误消息。

       4. 可选的，重复搜索的次数；如果为负数，则进行反向搜索。

‘let*’
     在本地将一些变量绑定到特定值，然后评估其余参数，返回最后一个的值。
     在绑定本地变量时，使用先前绑定的变量的本地值（如果有）。

     例如：

          (let* ((foo 7)
                 (bar (* 3 foo)))
            (message "`bar' is %d." bar))
               ⇒ ‘bar’ is 21.

‘match-beginning’
     返回由上一次正则表达式搜索找到的文本的起始位置。

‘looking-at’
     如果光标后的文本与参数匹配（应为正则表达式），则返回‘t’为真。

‘eobp’
     如果光标位于缓冲区的可访问部分的末尾，则返回‘t’为真。如果缓冲区没有
     缩小，则可访问部分的末尾是缓冲区的末尾；如果缓冲区已经缩小，则可访
     问部分的末尾是缩小部分的末尾。


File: eintr.info,  Node: re-search Exercises,  Prev: Regexp Review,  Up: Regexp Search

12.6 使用‘re-search-forward’的练习
==================================

   • 编写一个函数来搜索与正则表达式匹配的两个或更多空白行。

   • 编写一个函数来搜索重复的单词，例如“the the”。有关如何编写匹配由两个
     相同部分组成的字符串的正则表达式（regexp）的信息，请参阅*Note
     Syntax of Regular Expressions: (emacs)Regexps.  您可以设计几个正则
     表达式；有些比其他的好。我使用的函数在附录中有描述，以及几个正则表
     达式。*Note ‘the-the’ Duplicated Words Function: the-the.


File: eintr.info,  Node: Counting Words,  Next: Words in a defun,  Prev: Regexp Search,  Up: Top

13 通过重复和正则表达式进行统计
*******************************

重复和正则表达式搜索是在编写Emacs Lisp代码时经常使用的强大工具。本章通过
使用 ‘while’ 循环和递归构建单词计数命令来说明正则表达式搜索的使用。

* Menu:

* Why Count Words::
* count-words-example::          使用正则表达式，但遇到问题。
* recursive-count-words::       从区域中没有单词的情况开始。
* Counting Exercise::


File: eintr.info,  Node: Why Count Words,  Next: count-words-example,  Up: Counting Words

统计单词
========

标准的Emacs发行版包含用于计算区域内行数和单词数的函数。

   某些类型的写作要求你统计单词数。因此，如果你写一篇文章，你可能被限制
在800个单词；如果你写一本小说，你可能自律地每天写1000个单词。这似乎有些
奇怪，但很长一段时间，Emacs缺乏一个统计单词数的命令。也许人们主要使用
Emacs编写代码或一些不需要统计单词数的文档；或者他们局限于使用操作系统的
单词计数命令 ‘wc’。另外，人们可能按照出版商的习惯，通过将文档中的字符数
除以五来计算单词数。

   有许多实现统计单词数的方法。以下是一些例子，您可能希望与标准Emacs命令
‘count-words-region’ 进行比较。


File: eintr.info,  Node: count-words-example,  Next: recursive-count-words,  Prev: Why Count Words,  Up: Counting Words

13.1 函数 ‘count-words-example’
===============================

一个单词计数命令可以在行、段落、区域或缓冲区中计算单词数。这个命令应该覆
盖什么范围？你可以设计命令来计算整个缓冲区中的单词数。然而，Emacs 传统鼓
励灵活性——你可能只想计算一个部分中的单词，而不是整个缓冲区。因此，更有意
义的是设计命令来计算区域中的单词数。一旦你有一个计算区域中单词数的命令，
如果愿意，可以通过使用‘C-x h’（‘mark-whole-buffer’）标记整个缓冲区来计算
单词数。

   显然，计算单词是一个重复的动作：从区域的开头开始，计算第一个单词，然
后是第二个单词，依此类推，直到达到区域的末尾。这意味着单词计数理想情况下
适合使用递归或‘while’循环。

* Menu:

* Design count-words-example::  使用‘while’循环进行定义。
* Whitespace Bug::  ‘count-words-example’中的空白符号错误。


File: eintr.info,  Node: Design count-words-example,  Next: Whitespace Bug,  Up: count-words-example

设计 ‘count-words-example’
--------------------------

首先，我们将使用‘while’循环实现单词计数命令，然后再使用递归。当然，该命
令将是交互式的。

   交互式函数定义的模板如下：

     (defun NAME-OF-FUNCTION (ARGUMENT-LIST)
       "DOCUMENTATION..."
       (INTERACTIVE-EXPRESSION...)
       BODY...)

   我们需要填写这些位置。

   函数的名称应该是不言自明且容易记忆的。‘count-words-region’是显而易见
的选择。由于该名称已用于标准的Emacs命令以计算单词数，我们将为我们的实现
命名为‘count-words-example’。

   该函数计算区域中的单词数。这意味着参数列表必须包含绑定到区域的两个位
置的符号，即起始和结束。这两个位置可以分别称为‘beginning’和‘end’。文档的
第一行应该是一个简单的句子，因为这是由‘apropos’等命令打印的所有文档。交
互表达式将采用形式‘(interactive "r")’，因为这将导致Emacs将区域的起始和结
束传递给函数的参数列表。所有这些都是例行公事。

   函数的主体需要编写三个任务：首先，设置‘while’循环可以计算单词的条件；
其次，运行‘while’循环；最后，向用户发送消息。

   当用户调用‘count-words-example’时，点可能位于区域的开头或末尾。然而，
计数过程必须从区域的开头开始。这意味着如果点尚未在那里，我们将希望将点放
在那里。执行‘(goto-char beginning)’可以确保这一点。当函数完成其工作时，
当然我们希望将点返回到其预期的位置。因此，主体必须包含在
‘save-excursion’表达式中。

   函数主体的核心部分包含一个‘while’循环，其中一个表达式按单词向前跳转点
，另一个表达式计算这些跳转。‘while’循环的真假测试应该在点应该向前跳转时
返回true，在点在区域末尾时返回false。

   我们可以使用‘(forward-word 1)’作为将点逐个单词向前移动的表达式，但如
果使用正则表达式搜索，可以更容易地看到Emacs将其识别为“单词”的内容。

   一个正则表达式搜索找到其正在搜索的模式后，将点留在匹配的最后一个字符
之后。这意味着一系列成功的单词搜索将点逐个单词向前移动。

   实际上，我们希望正则表达式搜索跳过单词之间的空白符和标点符号，以及单
词本身。一个拒绝跳过单词之间空白符的正则表达式搜索永远不会跳过一个以上的
单词！这意味着正则表达式应包括单词之后（如果有的话）的空白符和标点符号，
以及单词本身。 （一个单词可能结束于缓冲区，而没有任何后续空白符或标点符
号，因此该正则表达式的这一部分必须是可选的。）

   因此，我们希望正则表达式的模式是定义一个或多个单词成分字符，后面跟着
可选的一个或多个不是单词成分字符的字符。这个正则表达式的模式如下：

     \w+\W*

缓冲区的语法表决定了哪些字符是单词成分字符，哪些不是。有关语法的更多信息
，请参见*note Syntax Tables: (elisp)Syntax Tables.。

   搜索表达式看起来像这样：

     (re-search-forward "\\w+\\W*")

（请注意，斜杠前面有‘w’和‘W’。单个斜杠对Emacs Lisp解释器有特殊含义。它表
示以下字符的解释方式与通常不同。例如，两个字符‘\n’代表‘newline’，而不是
反斜杠后跟‘n’。两个连续的斜杠表示一个普通的、非特殊的反斜杠，因此Emacs
Lisp解释器最终会看到一个后面跟着一个字母的单个反斜杠。因此，它发现这个字
母是特殊的。）

   我们需要一个计数器来计算有多少个单词；这个变量必须首先设置为0，然后在
Emacs循环‘while’中的每一次都递增。递增表达式很简单：

     (setq count (1+ count))

   最后，我们想告诉用户区域中有多少个单词。‘message’函数适用于向用户呈现
这种类型的信息。消息必须以这样的方式构造，以便不管区域中有多少个单词，它
都能正确阅读：我们不想说“区域中有1个单词”。单数和复数之间的冲突是不合语
法的。我们可以通过使用条件表达式来解决此问题，该表达式根据区域中的单词数
评估不同的消息。有三种可能性：区域中没有单词，区域中有一个单词，以及区域
中有多个单词。这意味着‘cond’特殊形式是适当的。

   所有这些导致以下函数定义：

     ;;; 第一个版本；存在错误！
     (defun count-words-example (beginning end)
       "打印区域中的单词数。
     单词被定义为至少一个单词成分字符，后跟至少一个不是单词成分字符的字符。
     缓冲区的语法表决定了这些字符是什么。"
       (interactive "r")
       (message "正在计算区域中的单词数... ")

     ;;; 1. 设置适当的条件。
       (save-excursion
         (goto-char beginning)
         (let ((count 0))

     ;;; 2. 运行 while 循环。
           (while (< (point) end)
             (re-search-forward "\\w+\\W*")
             (setq count (1+ count)))

     ;;; 3. 向用户发送消息。
           (cond ((zerop count)
                  (message
                   "区域中没有单词。"))
                 ((= 1 count)
                  (message
                   "区域中有1个单词。"))
                 (t
                  (message
                   "区域中有%d个单词。" count))))))

按照目前的编写方式，该函数能够工作，但在某些情况下不完全正确。


File: eintr.info,  Node: Whitespace Bug,  Prev: Design count-words-example,  Up: count-words-example

13.1.1 ‘count-words-example’ 中的空白字符错误
---------------------------------------------

在前面的章节中描述的 ‘count-words-example’ 命令有两个错误，或者更确切地
说，有一个带有两个表现形式的错误。首先，如果你标记一个仅包含中间某些文本
的空白区域，‘count-words-example’ 命令会告诉你该区域包含一个单词！其次，
如果你标记一个仅包含位于缓冲区末尾或缩小缓冲区的可访问部分的空白字符的区
域，该命令会显示一个错误消息，看起来像这样：

     搜索失败："\\w+\\W*"

   如果你是在GNU Emacs的Info中阅读本文，你可以自行测试这些错误。

   首先，按照通常的方式评估该函数以安装它。 这是定义的一个副本。将光标放
在括号结束后，然后键入 ‘C-x C-e’ 以安装它。

     ;; 第一个版本; 存在错误!
     (defun count-words-example (beginning end)
       "打印区域内的单词数。
     单词定义为至少一个单词构成字符，后面跟着至少一个不是单词构成字符的字符。缓冲区的语法表确定这些字符。"
       (interactive "r")
       (message "正在计算区域内的单词数 ... ")

     ;;; 1. 设置适当的条件。
       (save-excursion
         (goto-char beginning)
         (let ((count 0))

     ;;; 2. 运行 while 循环。
           (while (< (point) end)
             (re-search-forward "\\w+\\W*")
             (setq count (1+ count)))

     ;;; 3. 向用户发送消息。
           (cond ((zerop count)
                  (message "该区域不包含任何单词。"))
                 ((= 1 count) (message "该区域包含1个单词。"))
                 (t (message "该区域包含%d个单词。" count))))))

   如果愿意，也可以通过评估以下绑定来安装此键绑定：

     (global-set-key "\C-c=" 'count-words-example)

   进行第一个测试，将标记和点设置到以下行的开始和结束，然后键入 ‘C-c =’（
或如果未绑定 ‘C-c =’，则为 ‘M-x count-words-example’）：

         一个  两个  三

Emacs 将告诉你，该区域有三个单词，这是正确的。

   重复测试，但将标记放在该行的开头，并将点放在单词 ‘一个’ 之前。再次输
入命令 ‘C-c =’（或 ‘M-x count-words-example’）。Emacs 应该告诉你该区域没
有单词，因为它仅由该行开头的空白字符组成。但是，Emacs却告诉你该区域有一
个单词！

   对于第三个测试，将示例行复制到 ‘*scratch*’ 缓冲区的末尾，然后在该行的
末尾输入多个空格。将标记放在单词 ‘三’ 之后，将点放在行末。 （行末将是缓
冲区的末尾。）像之前一样，输入 ‘C-c =’（或 ‘M-x count-words-example’）。
再次，Emacs 应该告诉你该区域没有单词，因为它仅由该行末尾的空白字符组成。
但是，相反，Emacs 显示一个错误消息，其中显示 ‘Search failed’。

   这两个错误源于同一个问题。

   考虑错误的第一个表现形式，在该表现形式中，该命令告诉你该行开头的空白
字符包含一个单词。发生的情况是：‘M-x count-words-example’ 命令将点移动到
区域的开头。‘while’ 测试点的值是否小于 ‘end’ 的值，它是的。因此，正则表
达式搜索寻找并找到第一个单词。它将点放在单词之后。 ‘count’ 设置为一。
‘while’ 循环重复; 但是这次点的值大于 ‘end’ 的值，循环退出；函数显示一条
消息，其中包含区域中的单词数为一。简而言之，尽管标记区域外的单词，但正则
表达式搜索却寻找并找到了该单词。

   在错误的第二个表现形式中，该区域是位于缓冲区末尾的空白字符。Emacs 显
示 ‘Search failed’。发生的情况是，在 ‘while’ 循环中的真假测试中，测试为
真，因此执行搜索表达式。但由于缓冲区中没有更多的单词，搜索失败。

   在错误的两个表现形式中，搜索都会扩展或尝试扩展到区域之外。

   解决方案是限制搜索到该区域，这是一个相当简单的操作，但正如你可能期望
的那样，它并不像你想象的那么简单。

   正如我们所见，‘re-search-forward’ 函数将搜索模式作为其第一个参数。但
除了这第一个，强制性的参数外，它还接受三个可选参数。可选的第二个参数限制
了搜索。可选的第三个参数，如果是 ‘t’，则使函数在搜索失败时返回 ‘nil’ 而
不是引发错误。可选的第四个参数是重复计数。（在Emacs中，可以通过键入 ‘C-h
f’，函数的名称，然后 <RET> 来查看函数的文档。）

   在 ‘count-words-example’ 的定义中，区域末尾的值由传递给函数的变量
‘end’ 持有。因此，我们可以将 ‘end’ 添加为正则表达式搜索表达式的参数：

     (re-search-forward "\\w+\\W*" end)

   然而，如果你只对 ‘count-words-example’ 定义进行这个更改，然后在一段空
白区域上测试新版本的定义，你将收到一条错误消息，其中显示 ‘Search
failed’。

   发生的情况是：搜索限制为该区域，因为在该区域中没有单词构成字符，所以
搜索失败，正如你所期望的那样。由于失败，我们收到了一条错误消息。但在这种
情况下，我们不希望收到错误消息；我们希望收到消息“该区域不包含任何单词”。

   解决此问题的方法是向 ‘re-search-forward’ 提供第三个参数 ‘t’，这将导致
函数在搜索失败时返回 ‘nil’ 而不是引发错误。

   然而，如果你进行此更改并尝试运行它，你将看到消息“计算区域内的单词数
...”，等等，你将继续看到该消息...，直到你键入 ‘C-g’（‘keyboard-quit’）。

   发生的情况是：搜索限制为该区域，与之前一样失败，因为该区域中没有单词
构成字符，正如预期的那样。因此，‘re-search-forward’ 表达式返回 ‘nil’。它
仅仅返回 ‘nil’。特别地，如果找到了搜索目标，它不会移动点，这是它的副作用
之一。在 ‘re-search-forward’ 表达式返回 ‘nil’ 后，‘while’ 循环中的下一个
表达式将被评估。该表达式递增计数。然后循环重复。由于 ‘re-search-forward’
表达式没有移动点，所以 ‘while’ 循环的真假测试测试为真，因为点的值仍然小
于 ‘end’ 的值。...循环重复...

   ‘count-words-example’ 定义需要进行另一个修改，以使 ‘while’ 循环的真假
测试在搜索失败时测试为假。换句话说，在增加单词计数变量之前，必须同时满足
两个条件：点必须仍然在区域内，并且搜索表达式必须找到一个要计数的单词。

   由于第一个条件和第二个条件必须一起为真，所以这两个表达式，区域测试和
搜索表达式，可以用 ‘and’ 特殊形式连接，并嵌入到 ‘while’ 循环中作为真假测
试，如下所示：

     (and (< (point) end) (re-search-forward "\\w+\\W*" end t))

（关于 ‘and’ 的信息，请参见 *note The ‘kill-new’ function: kill-new
function.。）

   ‘re-search-forward’ 表达式在搜索成功时返回 ‘t’，并作为副作用移动点。
因此，随着找到单词，点通过区域移动。当搜索表达式未能找到另一个单词，或当
点达到区域的末尾时，真假测试失败，‘while’ 循环退出，
‘count-words-example’ 函数显示其消息之一。

   在加入这些最终更改后，‘count-words-example’ 就没有错误了（或者至少，
我没有找到错误！）。以下是它的最终版本：

     ;;; 最终版本： while
     (defun count-words-example (beginning end)
       "打印区域内的单词数。"
       (interactive "r")
       (message "计算区域内的单词数 ... ")

     ;;; 1. 设置适当的条件。
       (save-excursion
         (let ((count 0))
           (goto-char beginning)

     ;;; 2. 运行 while 循环。
           (while (and (< (point) end)
                       (re-search-forward "\\w+\\W*" end t))
             (setq count (1+ count)))

     ;;; 3. 向用户发送消息。
           (cond ((zerop count)
                  (message
                   "该区域不包含任何单词。"))
                 ((= 1 count)
                  (message
                   "该区域包含一个单词。"))
                 (t
                  (message
                   "该区域包含 %d 个单词。" count))))))


File: eintr.info,  Node: recursive-count-words,  Next: Counting Exercise,  Prev: count-words-example,  Up: Counting Words

13.2 递归计算单词数
===================

你可以编写递归方式和使用 ‘while’ 循环的函数来计算单词数。让我们看看如何
实现。

   首先，我们需要认识到 ‘count-words-example’ 函数有三个任务：它设置适当
的条件来进行计数；它计算区域内的单词数；并向用户发送一条消息，告诉有多少
个单词。

   如果我们写一个单一的递归函数来执行所有这些任务，我们将为每个递归调用
都收到一条消息。如果区域包含13个单词，我们将接收到十三条消息，依次排列。
我们不想要这样！相反，我们必须编写两个函数来完成工作，其中一个（递归函数
）将在另一个内部使用。一个函数将设置条件并显示消息；另一个将返回单词数。

   让我们从引起消息显示的函数开始。我们可以继续称之为
‘count-words-example’。

   这是用户将调用的函数。它将是交互式的。实际上，它将类似于我们先前版本
的这个函数，只是它将调用 ‘recursive-count-words’ 来确定区域中有多少个单
词。

   我们可以基于先前的版本轻松构造这个函数的模板：

     ;; 递归版本；使用正则表达式搜索
     (defun count-words-example (beginning end)
       "DOCUMENTATION..."
       (INTERACTIVE-EXPRESSION...)

     ;;; 1. 设置适当的条件。
       (EXPLANATORY MESSAGE)
       (SET-UP FUNCTIONS...

     ;;; 2. 计算单词数。
         RECURSIVE CALL

     ;;; 3. 向用户发送消息。
         MESSAGE PROVIDING WORD COUNT))

   定义看起来很简单，只是要注意递归调用返回的计数如何传递给显示单词计数
的消息。经过一点思考，我们可以利用 ‘let’ 表达式来实现：我们可以在 ‘let’
表达式的 varlist 中将一个变量绑定到区域内的单词数，由递归调用返回；然后
‘cond’ 表达式可以使用绑定来向用户显示该值。

   通常，人们将 ‘let’ 表达式内的绑定视为函数的主要工作的某种次要部分。但
在这种情况下，您可能认为函数的主要工作，即计算单词数，是在 ‘let’ 表达式
内完成的。

   使用 ‘let’，函数定义如下：

     (defun count-words-example (beginning end)
       "打印区域内的单词数。"
       (interactive "r")

     ;;; 1. 设置适当的条件。
       (message "正在计算区域内的单词数... ")
       (save-excursion
         (goto-char beginning)

     ;;; 2. 计算单词数。
         (let ((count (recursive-count-words end)))

     ;;; 3. 向用户发送消息。
           (cond ((zerop count)
                  (message
                   "该区域没有任何单词。"))
                 ((= 1 count)
                  (message
                   "该区域有1个单词。"))
                 (t
                  (message
                   "该区域有 %d 个单词。" count))))))

   接下来，我们需要编写递归计数函数。

   递归函数至少有三个部分：再次执行测试，下一步表达式和递归调用。

   再次执行测试确定函数是否将再次调用。由于我们在区域中计算单词数并可以
使用一个每个单词都向前移动指针的函数，再次执行测试可以检查点是否仍然在区
域内。再次执行测试应该找到点的值，并确定点是在区域结束的值之前，与之相等
还是之后。我们可以使用 ‘point’ 函数来定位点。显然，必须将区域结束的值作
为参数传递给递归计数函数。

   此外，再次执行测试还应该测试搜索是否找到了单词。如果没有找到，函数不
应再次调用自身。

   下一步表达式更改一个值，以便当递归函数应该停止调用自身时，它停止。更
准确地说，下一步表达式更改一个值，以便在正确的时间，再次执行测试停止递归
函数再次调用自身。在这种情况下，下一步表达式可以是将点按单词向前移动的表
达式。

   递归函数的第三部分是递归调用。

   还需要一个执行函数工作的部分，一个执行计数的重要部分！

   但是，我们已经有了递归计数函数的大纲：

     (defun recursive-count-words (region-end)
       "DOCUMENTATION..."
        DO-AGAIN-TEST
        NEXT-STEP-EXPRESSION
        RECURSIVE CALL)

   现在我们需要填充这些槽。让我们从最简单的情况开始：如果点在区域结束的
位置或之后，那么区域中不能有任何单词，因此函数应返回零。同样，如果搜索失
败，就没有单词可计数，因此函数应返回零。

   另一方面，如果点在区域内且搜索成功，则函数应再次调用自身。

   因此，再次执行测试应如下所示：

     (and (< (point) region-end)
          (re-search-forward "\\w+\\W*" region-end t))

   请注意，搜索表达式是再次执行测试的一部分——如果其搜索成功，则函数返回
‘t’，如果失败，则返回 ‘nil’。(*Note ‘count-words-example’
中的空白字符错误: Whitespace Bug, 了解 ‘re-search-forward’ 的工作原理的
解释。)

   再次执行测试是 ‘if’ 子句的真值测试。显然，如果再次执行测试成功，则
‘if’ 子句的 then-部分应该再次调用函数；但如果失败，则 else-部分应该返回
零，因为要么点在区域外，要么搜索失败，因为找不到单词。

   但在考虑递归调用之前，我们需要考虑下一步表达式。这是什么？有趣的是，
它就是do-again-test的搜索部分。

   除了为do-again-test返回‘t’或‘nil’外，‘re-search-forward’在成功搜索时
会作为副作用移动点。这是改变点值的操作，使得递归函数停止调用自身，当点通
过区域完成移动。因此，‘re-search-forward’表达式就是
next-step-expression。

   概述来看，‘recursive-count-words’函数的主体如下：

     (if DO-AGAIN-TEST-AND-NEXT-STEP-COMBINED
         ;; then
         RECURSIVE-CALL-RETURNING-COUNT
       ;; else
       RETURN-ZERO)

   如何融入计数机制？

   如果你不习惯编写递归函数，这样的问题可能会让人头疼。但应该以系统的方
式来解决。

   我们知道计数机制应该以某种方式与递归调用关联起来。确实，由于
next-step-expression通过一个单词将点向前移动，并且由于每个单词都会进行递
归调用，计数机制必须是一个表达式，该表达式将一个添加到由
‘recursive-count-words’调用返回的值。

   考虑几种情况：

   • 如果区域中有两个单词，则函数应该返回一个值，该值是在计算第一个单词
     时添加到该值的值，再加上计算区域中剩余单词时返回的数字，这在这种情
     况下为一。

   • 如果区域中只有一个单词，则函数应该返回一个值，该值是在计算该单词时
     添加到该值的值，再加上计算区域中剩余单词时返回的数字，这在这种情况
     下为零。

   • 如果区域中没有单词，则函数应该返回零。

   从草图中我们可以看到，‘if’的else部分对于没有单词的情况返回零。这意味
着‘if’的then部分必须返回一个值，该值是通过递归调用的返回值添加一的结果。

   表达式将如下所示，其中‘1+’是一个将一个添加到其参数的函数。

     (1+ (recursive-count-words region-end))

   整个‘recursive-count-words’函数将如下所示：

     (defun recursive-count-words (region-end)
       "DOCUMENTATION..."

     ;;; 1. do-again-test
       (if (and (< (point) region-end)
                (re-search-forward "\\w+\\W*" region-end t))

     ;;; 2. then-part: the recursive call
           (1+ (recursive-count-words region-end))

     ;;; 3. else-part
         0))

   让我们看看这是如何工作的：

   如果区域中没有单词，则‘if’表达式的else部分被求值，因此函数返回零。

   如果区域中有一个单词，则点的值小于‘region-end’的值，并且搜索成功。在
这种情况下，‘if’表达式的true-or-false-test为true，将求值‘if’表达式的
then部分。计数表达式将被求值。该表达式返回一个值（这将是整个函数返回的值
），即加一到递归调用返回的值。

   同时，next-step-expression导致点跳过区域中的第一个（在这种情况下是唯
一的）单词。这意味着当‘(recursive-count-words region-end)’第二次求值时，
由于递归调用的结果，点的值将等于或大于region end的值。因此，这次，
‘recursive-count-words’将返回零。零将添加到一，原始的
‘recursive-count-words’的求值将返回一加零，即一，这是正确的数量。

   显然，如果区域中有两个单词，则第一次调用‘recursive-count-words’将返回
一个添加到调用‘recursive-count-words’的区域剩余单词的值，即它添加到一，
产生两个，这是正确的数量。

   同样地，如果区域中有三个单词，则第一次调用‘recursive-count-words’将返
回一个添加到调用‘recursive-count-words’的区域剩余两个单词的值，依此类推
。

具有完整文档的两个函数如下：

递归函数：

     (defun recursive-count-words (region-end)
       "在点和REGION-END之间的单词数。"

     ;;; 1. do-again-test
       (if (and (< (point) region-end)
                (re-search-forward "\\w+\\W*" region-end t))

     ;;; 2. then-part: the recursive call
           (1+ (recursive-count-words region-end))

     ;;; 3. else-part
         0))

包装器：

     ;;; 递归版本
     (defun count-words-example (beginning end)
       "打印区域中的单词数。"

     单词被定义为至少一个单词构成字符，后面跟着至少一个不是单词构成字符的字符。缓冲区的语法表决定了这些字符是哪些。"
       (interactive "r")
       (message "正在计算区域中的单词数...")
       (save-excursion
         (goto-char beginning)
         (let ((count (recursive-count-words end)))
           (cond ((zerop count)
                  (message
                   "该区域没有任何单词。"))
                 ((= 1 count)
                  (message "该区域有1个单词。"))
                 (t
                  (message
                   "该区域有%d个单词。" count))))))


File: eintr.info,  Node: Counting Exercise,  Prev: recursive-count-words,  Up: Counting Words

13.3 练习：计算标点符号
=======================

使用 ‘while’ 循环，编写一个函数来计算区域内标点符号的数量—句号、逗号、分
号、冒号、感叹号和问号。然后使用递归方式完成相同的任务。


File: eintr.info,  Node: Words in a defun,  Next: Readying a Graph,  Prev: Counting Words,  Up: Top

14 在 ‘defun’ 中计算单词数
**************************

我们下一个项目是计算函数定义中的单词数。显然，这可以通过一些
‘count-words-example’ 的变体来完成。参见 *Note 通过重复和正则表达式计数:
Counting Words.  如果我们只想计算一个定义中的单词数，那么可以使用
‘C-M-h’ (‘mark-defun’) 命令标记定义，然后调用 ‘count-words-example’。

   然而，我更有雄心壮志：我想要计算 Emacs 源代码中每个定义中的单词和符号
的数量，然后打印一个图表，显示每个长度的函数有多少个：包含 40 到 49 个单
词或符号的有多少个函数，包含 50 到 59 个单词或符号的有多少个，依此类推。
我常常好奇一个典型函数有多长，这将给出答案。

* Menu:

* Divide and Conquer::
* Words and Symbols::           应该计数什么？
* Syntax::                  什么构成一个单词或符号？
* count-words-in-defun:: 与 ‘count-words-example’ 非常相似。
* Several defuns::           计算文件中的多个定义。
* Find a File::              想要查看一个文件吗？
* lengths-list-file::     许多定义长度的列表。
* Several files::              在不同文件中计数定义。
* Several files recursively::      递归在不同文件中计数。
* Prepare the data::              为在图表中显示准备数据。


File: eintr.info,  Node: Divide and Conquer,  Next: Words and Symbols,  Up: Words in a defun

分而治之
========

用一句话描述，直方图项目是艰巨的；但是，将其分解为许多小步骤，我们可以一
次解决一个，项目就变得不那么可怕了。让我们考虑这些步骤应该是什么：

   • 首先，编写一个函数来计算一个定义中的单词数。这包括处理符号以及单词
     的问题。

   • 其次，编写一个函数来列出文件中每个函数中的单词数。这个函数可以使用
     ‘count-words-in-defun’ 函数。

   • 第三，编写一个函数来列出每个文件中每个函数中的单词数。这涉及到自动
     找到不同文件，切换到它们，并计算其中定义的单词数。

   • 第四，编写一个函数将我们在第三步中创建的数字列表转换为适合打印为图
     表的形式。

   • 第五，编写一个函数将结果打印为图表。

   这是一个相当庞大的项目！但是，如果我们慢慢来，它并不难。


File: eintr.info,  Node: Words and Symbols,  Next: Syntax,  Prev: Divide and Conquer,  Up: Words in a defun

14.1 如何计数？
===============

当我们首次考虑如何计算函数定义中的单词时，第一个问题是（或者应该是）我们
要计数什么？当我们谈到与 Lisp 函数定义相关的“单词”时，实际上在很大程度上
我们是在谈论符号。例如，下面的 ‘multiply-by-seven’ 函数包含五个符号：
‘defun’、‘multiply-by-seven’、‘number’、‘*’ 和 ‘7’。此外，在文档字符串中
，它包含四个单词：‘Multiply’、‘NUMBER’、‘by’ 和 ‘seven’。符号 ‘number’ 被
重复使用，因此定义包含总共十个单词和符号。

     (defun multiply-by-seven (number)
       "Multiply NUMBER by seven."
       (* 7 number))

然而，如果我们使用 ‘C-M-h’（‘mark-defun’）标记 ‘multiply-by-seven’ 定义
，然后调用 ‘count-words-example’，我们会发现 ‘count-words-example’ 声称
该定义有十一个单词，而不是十个！有些地方出错了！

   问题有两个方面：‘count-words-example’ 不将 ‘*’ 视为一个单词，而将单个
符号 ‘multiply-by-seven’ 视为包含三个单词。连字符被视为单词间的空格而不
是单词内的连接符：‘multiply-by-seven’ 被计算为如果它被写成 ‘multiply by
seven’。

   混淆的原因在于 ‘count-words-example’ 定义中的正则表达式搜索，该搜索按
单词向前移动点。在 ‘count-words-example’ 的典型版本中，正则表达式为：

     "\\w+\\W*"

该正则表达式是一个模式，定义了一个或多个单词构成字符，后面可能跟着一个或
多个不是单词构成字符的字符。关于“单词构成字符”是什么，这就引出了语法问题
，值得单独讨论一节。


File: eintr.info,  Node: Syntax,  Next: count-words-in-defun,  Prev: Words and Symbols,  Up: Words in a defun

14.2 何为单词或符号的组成部分？
===============================

Emacs将不同的字符视为属于不同的“语法类别”。例如，正则表达式‘\\w+’是一个
模式，指定一个或多个_单词组成_字符。单词组成字符属于一个语法类别。其他语
法类别包括标点字符类，如句点和逗号，以及空白字符类，如空格和制表符。（更
多信息，请参阅*note Syntax Tables: (elisp)Syntax Tables.。）

   语法表指定哪些字符属于哪些类别。通常，连字符不被指定为单词组成字符。
相反，它被指定为符号名称中的字符类，但不是单词。这意味着
‘count-words-example’函数以与单词间空格相同的方式处理它，这就是为什么
‘count-words-example’将‘multiply-by-seven’计为三个单词的原因。

   有两种方法可以使Emacs将‘multiply-by-seven’计为一个符号：修改语法表或
修改正则表达式。

   我们可以通过修改Emacs为每种模式保留的语法表来重新定义连字符为单词组成
字符。这个动作将满足我们的目的，除了连字符仅仅是符号中最常见的不是单词组
成字符的字符；还有其他字符。

   或者，我们可以重新定义‘count-words-example’定义中使用的正则表达式，以
包括符号。这个过程具有清晰的优点，但任务有点棘手。

   第一部分相当简单：模式必须匹配至少一个是单词或符号组成字符的字符。因
此：

     "\\(\\w\\|\\s_\\)+"

‘\\(’是包含‘\\w’和‘\\s_’作为选择项的分组结构的第一部分，由‘\\|’分隔。
‘\\w’匹配任何单词组成字符，而‘\\s_’匹配任何是符号名称但不是单词组成字符
的字符。组后面的‘+’表示单词或符号组成字符必须至少匹配一次。

   然而，正则表达式的第二部分设计更难。我们希望第一部分后面可以选择跟随
零个或多个不是单词或符号组成字符的字符。起初，我认为可以用以下方式定义这
个：

     "\\(\\W\\|\\S_\\)*"

大写的‘W’和‘S’匹配_不是_单词或符号组成字符的字符。不幸的是，这个表达式匹
配任何不是单词组成字符或符号组成字符的字符。这匹配任何字符！

   我然后注意到我的测试区域中的每个单词或符号后面都跟着空白（空格、制表
符或换行符）。所以我尝试在匹配一个或多个单词或符号组成字符的模式之后放置
一个匹配一个或多个空格的模式。这也失败了。单词和符号通常由空白分隔，但在
实际代码中，括号可能跟随符号，标点可能跟随单词。因此最后，我设计了一个模
式，其中单词或符号组成字符后面可以选择跟随不是空白字符的字符，然后可以选
择跟随空白字符。

   以下是完整的正则表达式：

     "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"


File: eintr.info,  Node: count-words-in-defun,  Next: Several defuns,  Prev: Syntax,  Up: Words in a defun

14.3 ‘count-words-in-defun’ 函数
================================

我们已经看到有几种编写 ‘count-words-region’ 函数的方法。为了编写
‘count-words-in-defun’，我们只需调整其中一种版本即可。

   使用 ‘while’ 循环的版本很容易理解，因此我将对其进行调整。由于
‘count-words-in-defun’ 将成为一个更复杂的程序的一部分，它不需要是交互式
的，也不需要显示消息，只需返回计数即可。这些考虑稍微简化了定义。

   另一方面，‘count-words-in-defun’ 将在包含函数定义的缓冲区中使用。因此
，合理的要求是，该函数确定在调用时点是否位于函数定义内，并且如果是，则返
回该定义的计数。这增加了定义的复杂性，但省去了需要将参数传递给函数的需要
。

   这些考虑引导我们准备以下模板：

     (defun count-words-in-defun ()
       "DOCUMENTATION..."
       (SET UP...
          (WHILE LOOP...)
        RETURN COUNT)

像往常一样，我们的任务是填写这些槽。

   首先，设置。

   我们假设该函数将在包含函数定义的缓冲区中调用。点要么在函数定义内，要
么不在。为了使 ‘count-words-in-defun’ 起作用，点必须移动到定义的开头，一
个计数器必须从零开始，而计数循环必须在点达到定义的末尾时停止。

   ‘beginning-of-defun’ 函数向后搜索开头为 ‘(’（例如在行首）的分隔符，并
将点移动到该位置，否则移到搜索的限制位置。在实践中，这意味着
‘beginning-of-defun’ 将点移到封闭或前置函数定义的开头，或者移到缓冲区的
开头。我们可以使用 ‘beginning-of-defun’ 将点放置在我们想要开始的位置。

   ‘while’ 循环需要一个计数器来跟踪要计数的单词或符号。可以使用 ‘let’ 表
达式创建一个用于此目的的局部变量，并将其绑定到零的初始值。

   ‘end-of-defun’ 函数与 ‘beginning-of-defun’ 类似，除了它将点移动到定义
的末尾。‘end-of-defun’ 可以作为确定定义末尾位置的表达式的一部分使用。

   ‘count-words-in-defun’ 的设置迅速形成：首先将点移动到定义的开头，然后
创建一个本地变量以保存计数，最后记录定义的末尾位置，以便 ‘while’ 循环知
道何时停止循环。

   代码如下：

     (beginning-of-defun)
     (let ((count 0)
           (end (save-excursion (end-of-defun) (point))))

代码很简单。唯一的小复杂性可能涉及到 ‘end’：它被绑定到通过
‘save-excursion’ 表达式返回的点的位置，该表达式在 ‘end-of-defun’ 暂时将
其移动到定义的末尾后返回其值。

   ‘count-words-in-defun’ 的第二部分，在设置之后，是 ‘while’ 循环。

   该循环必须包含一个表达式，该表达式按单词和符号前进并且另一个表达式用
于计数跳跃。‘while’ 循环的真假测试应该在点应该前进时为真，而在点位于定义
末尾时为假。我们已经重新定义了这个正则表达式，所以循环很简单：

     (while (and (< (point) end)
                 (re-search-forward
                  "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*" end t))
       (setq count (1+ count)))

   该函数定义的第三部分返回单词和符号的计数。这一部分是 ‘let’ 表达式体内
的最后一个表达式，可以非常简单地是局部变量 ‘count’，在评估时返回计数。

   将这些部分组合起来，‘count-words-in-defun’ 的定义如下：

     (defun count-words-in-defun ()
       "返回 defun 中的单词和符号数。"
       (beginning-of-defun)
       (let ((count 0)
             (end (save-excursion (end-of-defun) (point))))
         (while
             (and (< (point) end)
                  (re-search-forward
                   "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"
                   end t))
           (setq count (1+ count)))
         count))

   如何测试这个函数？虽然函数不是交互式的，但很容易在其周围添加包装器使
其变为交互式；我们可以使用几乎与递归版本的 ‘count-words-example’ 相同的
代码：

     ;;; 交互版本。
     (defun count-words-defun ()
       "函数定义中的单词和符号数。"
       (interactive)
       (message
        "正在计算函数定义中的单词和符号数... ")
       (let ((count (count-words-in-defun)))
         (cond
          ((zerop count)
           (message
            "该定义没有任何单词或符号。"))
          ((= 1 count)
           (message
            "该定义有 1 个单词或符号。"))
          (t
           (message
            "该定义有 %d 个单词或符号。" count)))))

让我们重新使用 ‘C-c =’ 作为一个方便的键绑定：

     (global-set-key "\C-c=" 'count-words-defun)

   现在我们可以尝试 ‘count-words-defun’：安装 ‘count-words-in-defun’ 和
‘count-words-defun’，并设置键绑定。然后将以下内容复制到 Emacs Lisp 缓冲
区（例如，‘*scratch*’），将光标放在定义内，并使用 ‘C-c =’ 命令。

     (defun multiply-by-seven (number)
       "将 NUMBER 乘以七。"
       (* 7 number))
          ⇒ 10

成功！该定义有 10 个单词和符号。

   下一个问题是计算单个文件中多个定义中的单词和符号数。


File: eintr.info,  Node: Several defuns,  Next: Find a File,  Prev: count-words-in-defun,  Up: Words in a defun

14.4 统计文件中的多个 ‘defun’
=============================

一个文件，比如 ‘simple.el’，可能包含一百个或更多的函数定义。我们的长期目
标是收集许多文件的统计信息，但作为第一步，我们的即时目标是在一个文件中收
集统计信息。

   信息将是一系列数字，每个数字代表一个函数定义的长度。我们可以将这些数
字存储在一个列表中。

   我们知道我们将要将关于一个文件的信息与许多其他文件的信息结合起来；这
意味着在一个文件中计算定义长度的函数只需要返回长度列表，而不需要也不应该
显示任何消息。

   字数统计命令包含一个表达式，用于逐个单词向前跳转，以及另一个表达式，
用于计算跳转的次数。用于返回定义长度的函数可以被设计成以相同的方式工作，
其中一个表达式用于逐个定义向前跳转，另一个表达式用于构造长度列表。

   问题的陈述使编写函数定义变得非常基础。显然，我们将从文件的开头开始计
数，因此第一个命令将是 ‘(goto-char (point-min))’。接下来，我们启动
‘while’ 循环；循环的真假测试可以是对下一个函数定义进行正则表达式搜索—只
要搜索成功，点就向前移动，然后评估循环体。循环体需要一个表达式，用于构造
长度列表。列表构造命令 ‘cons’ 可以用来创建列表。就是这样简单。

   以下是这段代码片段的样子：

     (goto-char (point-min))
     (while (re-search-forward "^(defun" nil t)
       (setq lengths-list
             (cons (count-words-in-defun) lengths-list)))

   我们遗漏的是找到包含函数定义的文件的机制。

   在以前的例子中，我们要么使用当前文件，Info 文件，要么在其他缓冲区之间
切换，比如 ‘*scratch*’ 缓冲区。

   找到文件是我们尚未讨论的一个新过程。


File: eintr.info,  Node: Find a File,  Next: lengths-list-file,  Prev: Several defuns,  Up: Words in a defun

14.5 查找文件
=============

在Emacs中查找文件，您可以使用‘C-x C-f’（‘find-file’）命令。这个命令几乎
完全符合长度问题，但还需要稍作调整。

   让我们看一下‘find-file’的源代码：

     (defun find-file (filename)
       "编辑文件 FILENAME。
     切换到访问文件 FILENAME 的缓冲区，如果不存在则创建一个。"
       (interactive "FFind file: ")
       (switch-to-buffer (find-file-noselect filename)))

（‘find-file’函数定义的最新版本允许您指定可选的通配符以访问多个文件；这
使得定义更加复杂，我们在这里不讨论，因为这与问题无关。您可以使用‘M-.’（
‘xref-find-definitions’）或‘C-h f’（‘describe-function’）查看其源代码。
）

   我展示的定义具有简短但完整的文档和交互规范，在您以交互方式使用命令时
会提示您输入文件名。定义的主体包含两个函数，‘find-file-noselect’ 和
‘switch-to-buffer’。

   根据‘C-h f’（‘describe-function’命令）显示的文档，
‘find-file-noselect’函数将指定的文件读入缓冲区并返回该缓冲区。（其最新版
本还包括一个可选的WILDCARDS参数，以及另一个以文本方式读取文件和另一个以
抑制警告消息的参数。这些可选参数与问题无关。）

   然而，‘find-file-noselect’函数不会选择放置文件的缓冲区。Emacs不会切换
其注意力（或者如果您正在使用‘find-file-noselect’，那么是您的注意力）到选
定的缓冲区。这就是‘switch-to-buffer’的作用：它切换Emacs关注的缓冲区；并
且将窗口中显示的缓冲区切换到新的缓冲区。我们已经在其他地方讨论了缓冲区切
换。 （*Note Switching Buffers::。）

   在这个直方图项目中，我们不需要在屏幕上显示每个文件，因为程序确定其中
每个定义的长度。我们可以使用‘set-buffer’而不是‘switch-to-buffer’，后者会
将屏幕上的缓冲区重新显示。因此，我们不必调用‘find-file’来执行这项任务，
而是必须编写我们自己的表达式。

   任务很简单：使用‘find-file-noselect’和‘set-buffer’。


File: eintr.info,  Node: lengths-list-file,  Next: Several files,  Prev: Find a File,  Up: Words in a defun

14.6 ‘lengths-list-file’ 详解
=============================

‘lengths-list-file’ 函数的核心是一个包含 ‘while’ 循环的结构，其中包含一
个函数来逐个 defun 地将 point 前进，以及一个函数来计算每个 defun 中的单
词和符号数。这个核心必须被包裹在执行各种其他任务的函数中，包括查找文件并
确保 point 位于文件的开头。该函数定义如下：

     (defun lengths-list-file (filename)
       "返回 FILE 中定义长度的列表。
     返回的列表是数字的列表。
     每个数字是一个函数定义中的单词或符号的数量。"
       (message "正在处理 `%s' ... " filename)
       (save-excursion
         (let ((buffer (find-file-noselect filename))
               (lengths-list))
           (set-buffer buffer)
           (setq buffer-read-only t)
           (widen)
           (goto-char (point-min))
           (while (re-search-forward "^(defun" nil t)
             (setq lengths-list
                   (cons (count-words-in-defun) lengths-list)))
           (kill-buffer buffer)
           lengths-list)))

该函数接受一个参数，即它将操作的文件的名称。它有四行文档，但没有交互规范
。由于人们担心如果他们看不到任何操作就会认为计算机出了问题，函数体的第一
行是一个消息。

   接下来的一行包含一个 ‘save-excursion’，在函数完成时将 Emacs 的注意力
返回到当前缓冲区。这对于嵌套在假设 point 被恢复到原始缓冲区的另一个函数
中的情况是有用的。

   在 ‘let’ 表达式的变量列表中，Emacs 找到文件并将局部变量 ‘buffer’ 绑定
到包含文件的缓冲区。同时，Emacs 创建了 ‘lengths-list’ 作为局部变量。

   接下来，Emacs 将注意力切换到缓冲区。

   在接下来的一行中，Emacs 将缓冲区设置为只读。理想情况下，这一行是不必
要的。在计算函数定义中的单词和符号数的函数中，缓冲区不应该发生更改。此外
，即使更改了缓冲区，它也不会被保存。这一行完全是对极度谨慎的后果。对谨慎
的原因是，这个函数及其调用的函数处理 Emacs 的源代码，并且如果它们被意外
修改，则会很不方便。不用说，在一个实验出现问题并开始修改我的 Emacs 源文
件之前，我并没有意识到需要这一行 ...

   接下来是调用扩展缓冲区的函数，如果它被缩小了的话。通常情况下，这个函
数是不需要的 - Emacs 如果还没有存在缓冲区，就会创建一个新的；但是如果已
经存在了一个访问文件的缓冲区，Emacs 就返回那个缓冲区。在这种情况下，缓冲
区可能被缩小，必须被扩展。如果我们想要完全用户友好，我们会安排保存约束和
point 的位置，但我们不会这样做。

   ‘(goto-char (point-min))’ 表达式将 point 移动到缓冲区的开头。

   然后是一个 ‘while’ 循环，在循环中执行函数的工作。在循环中，Emacs 确定
每个定义的长度并构造包含该信息的长度列表。

   在处理完缓冲区后，Emacs 将其关闭。这是为了在 Emacs 中保存空间。我使用
的 GNU Emacs 19 版本包含了 300 多个感兴趣的源文件；GNU Emacs 22 包含了一
千多个源文件。另一个函数将应用 ‘lengths-list-file’ 到每个文件。

   最后，在 ‘let’ 表达式中的最后一个表达式是 ‘lengths-list’ 变量；其值作
为整个函数的值返回。

   你可以通过通常的方式安装这个函数并尝试它。然后，将光标放在以下表达式
之后，键入 ‘C-x C-e’ (‘eval-last-sexp’).

     (lengths-list-file
      "/usr/local/share/emacs/22.1/lisp/emacs-lisp/debug.el")

你可能需要更改文件的路径名；这里的路径是适用于 GNU Emacs 版本 22.1 的。
要更改表达式，将其复制到 ‘*scratch*’ 缓冲区并进行编辑。

此外，为了看到列表的完整长度，而不是截断版本，你可能需要评估以下内容：

     (custom-set-variables '(eval-expression-print-length nil))

(*Note 使用 ‘defcustom’ 指定变量: defcustom.  然后评估
‘lengths-list-file’ 表达式。)

   ‘debug.el’ 的长度列表在 GNU Emacs 22 中不到一秒钟就产生了，看起来像这
样：

     (83 113 105 144 289 22 30 97 48 89 25 52 52 88 28 29 77 49 43 290 232 587)

   (在我的旧机器上，版本 19 的 ‘debug.el’ 长度列表花费了七秒钟并且看起来
像这样：

     (75 41 80 62 20 45 44 68 45 12 34 235)

新版本的 ‘debug.el’ 包含比早期版本更多的 defuns；而我的新机器比旧机器要
快得多。) 请注意，文件中的最后一个定义的长度在列表中是最先的。


File: eintr.info,  Node: Several files,  Next: Several files recursively,  Prev: lengths-list-file,  Up: Words in a defun

14.7 统计不同文件中 ‘defuns’ 的词数
===================================

在前一节中，我们创建了一个函数，该函数返回文件中每个定义的长度的列表。现
在，我们想要定义一个函数，返回一个包含多个文件中定义长度的主列表。

   处理文件列表中的每个文件是一个重复的操作，因此我们可以使用 ‘while’ 循
环或递归。

* Menu:

* lengths-list-many-files::     返回 ‘defuns’ 长度的列表。
* append::                      将一个列表附加到另一个列表。


File: eintr.info,  Node: lengths-list-many-files,  Next: append,  Up: Several files

确定 ‘defuns’ 的长度
--------------------

使用 ‘while’ 循环的设计是常规的。传递给函数的参数是一个文件列表。正如我
们之前看到的 (*note Loop Example::)，可以编写一个 ‘while’ 循环，使得在列
表包含元素的情况下计算循环体，但在列表为空时退出循环。为了使此设计工作，
循环体必须包含一个表达式，该表达式在每次计算循环体时缩短列表，以便最终列
表为空。通常的技术是在每次计算循环体时将列表的值设置为列表的 CDR 的值。

   模板如下：

     (while 测试列表是否为空
       循环体...
       设置列表为列表的CDR)

   此外，我们要记住，‘while’ 循环返回 ‘nil’（真假测试的计算结果），而不
是循环体内任何评估的结果。（循环体内的评估是为了它们的副作用。）然而，设
置长度列表的表达式是循环体的一部分，这是我们希望整个函数返回的值。为了实
现这一点，我们将 ‘while’ 循环封装在一个 ‘let’ 表达式内，并安排 ‘let’ 表
达式的最后一个元素包含长度列表的值。(*Note 带有增量计数器的循环示例:
Incrementing Example.)

   这些考虑直接引导我们到函数本身：

     ;;; 使用 ‘while’ 循环。
     (defun lengths-list-many-files (list-of-files)
       "返回 LIST-OF-FILES 中 defuns 的长度列表。"
       (let (lengths-list)

     ;;; 真假测试
         (while list-of-files
           (setq lengths-list
                 (append
                  lengths-list

     ;;; 生成长度列表。
                  (lengths-list-file
                   (expand-file-name (car list-of-files)))))

     ;;; 使文件列表变短。
           (setq list-of-files (cdr list-of-files)))

     ;;; 返回长度列表的最终值。
         lengths-list))

   ‘expand-file-name’ 是一个内置函数，将文件名转换为绝对路径形式。该函数
使用调用函数所在目录的名称。

   因此，如果在 Emacs 访问
‘/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/’ 目录时，对 ‘debug.el’ 调
用 ‘expand-file-name’，

     debug.el

变成了

     /usr/local/share/emacs/22.1.1/lisp/emacs-lisp/debug.el

   该函数定义的另一个新元素是尚未学习的 ‘append’ 函数，它值得有一个专门
的小节。


File: eintr.info,  Node: append,  Prev: lengths-list-many-files,  Up: Several files

14.7.1 ‘append’ 函数
--------------------

‘append’ 函数将一个列表附加到另一个列表。因此，

     (append '(1 2 3 4) '(5 6 7 8))

产生了列表

     (1 2 3 4 5 6 7 8)

   这正是我们希望将 ‘lengths-list-file’ 生成的两个长度列表附加到一起的方
式。与 ‘cons’ 的结果形成对比，

     (cons '(1 2 3 4) '(5 6 7 8))

它构造一个新列表，其中 ‘cons’ 的第一个参数成为新列表的第一个元素：

     ((1 2 3 4) 5 6 7 8)


File: eintr.info,  Node: Several files recursively,  Next: Prepare the data,  Prev: Several files,  Up: Words in a defun

14.8 递归计算不同文件中的单词数
===============================

除了使用 ‘while’ 循环外，你还可以通过递归来处理文件列表中的每个文件。一
个递归版本的 ‘lengths-list-many-files’ 很短而简单。

   递归函数具有通常的部分：再次执行测试、下一步表达式和递归调用。再次执
行测试确定函数是否应该再次调用自身，如果 ‘list-of-files’ 包含任何剩余元
素，它将调用自身；下一步表达式将 ‘list-of-files’ 重置为其自身的 CDR，所
以最终列表将为空；递归调用在较短的列表上调用自身。整个函数比这个描述还要
短！

     (defun recursive-lengths-list-many-files (list-of-files)
       "返回 LIST-OF-FILES 中每个 defun 的长度列表。"
       (if list-of-files                     ; 再次执行测试
           (append
            (lengths-list-file
             (expand-file-name (car list-of-files)))
            (recursive-lengths-list-many-files
             (cdr list-of-files)))))

简而言之，该函数返回第一个 ‘list-of-files’ 的长度列表，附加到对其余
‘list-of-files’ 调用自身的结果上。

   这里是对 ‘recursive-lengths-list-many-files’ 的测试，以及在每个文件上
分别运行 ‘lengths-list-file’ 的结果。

   如果需要，安装 ‘recursive-lengths-list-many-files’ 和
‘lengths-list-file’，然后评估以下表达式。您可能需要更改文件的路径；这些
路径在此 Info 文件和 Emacs 源代码位于其习惯位置时有效。要更改表达式，将
其复制到 ‘*scratch*’ 缓冲区，编辑它们，然后评估它们。

   结果在 ‘⇒’ 之后显示。（这些结果是针对 Emacs 版本 22.1.1 的文件；来自
其他版本的 Emacs 的文件可能会产生不同的结果。）

     (cd "/usr/local/share/emacs/22.1.1/")

     (lengths-list-file "./lisp/macros.el")
          ⇒ (283 263 480 90)

     (lengths-list-file "./lisp/mail/mailalias.el")
          ⇒ (38 32 29 95 178 180 321 218 324)

     (lengths-list-file "./lisp/hex-util.el")
          ⇒ (82 71)

       (recursive-lengths-list-many-files
        '("./lisp/macros.el"
          "./lisp/mail/mailalias.el"
          "./lisp/hex-util.el"))
            ⇒ (283 263 480 90 38 32 29 95 178 180 321 218 324 82 71)

   ‘recursive-lengths-list-many-files’ 函数产生了我们想要的输出。

   下一步是准备列表中的数据以在图表中显示。


File: eintr.info,  Node: Prepare the data,  Prev: Several files recursively,  Up: Words in a defun

14.9 为在图表中显示准备数据
===========================

函数 ‘recursive-lengths-list-many-files’ 返回一个数字列表。每个数字记录
一个函数定义的长度。我们现在需要将这些数据转换为适合生成图表的数字列表。
新列表将显示有多少个函数定义包含少于10个单词和符号，有多少个包含10到19个
单词和符号，有多少个包含20到29个单词和符号，以此类推。

   简而言之，我们需要遍历由 ‘recursive-lengths-list-many-files’ 函数生成
的长度列表，并统计每个长度范围内的 defuns 的数量，并生成一个包含这些数字
的列表。

* Menu:

* Data for Display in Detail::
* Sorting::                     列表排序。
* Files List::                  制作文件列表。
* Counting function definitions::


File: eintr.info,  Node: Data for Display in Detail,  Next: Sorting,  Up: Prepare the data

详细显示的数据
--------------

基于我们之前所做的工作，我们可以预见编写一个函数不会太难，该函数 CDRs 下
长度列表，查看每个元素，确定它属于哪个长度范围，并增加该范围的计数器。

   然而，在开始编写这样一个函数之前，我们应该考虑先对长度列表进行排序的
优势，以便数字按从小到大的顺序排列。首先，排序将使在每个范围内计数数字变
得更容易，因为两个相邻的数字要么在相同的长度范围内，要么在相邻的范围内。
其次，通过检查已排序的列表，我们可以发现最高和最低的数字，从而确定我们将
需要的最大和最小长度范围。


File: eintr.info,  Node: Sorting,  Next: Files List,  Prev: Data for Display in Detail,  Up: Prepare the data

14.9.1 列表排序
---------------

Emacs 包含一个用于排序列表的函数，称为（你可能猜到的）‘sort’。‘sort’ 函
数接受两个参数，要排序的列表和一个断言，该断言确定两个列表元素中的第一个
是否小于第二个。

   正如我们之前所见（*note 使用错误类型的对象作为参数: Wrong Type of
Argument.），断言是确定某个属性是真还是假的函数。‘sort’ 函数将根据断言使
用的任何属性重新排序列表；这意味着 ‘sort’ 可以根据非数值标准对非数值列表
进行排序—例如，它可以对列表进行字母排序。

   在对数值列表进行排序时，使用函数 ‘<’。例如，

     (sort '(4 8 21 17 33 7 21 7) '<)

产生以下结果：

     (4 7 7 8 17 21 21 33)

（请注意，在此示例中，两个参数都引用了，以便在传递给 ‘sort’ 之前不对符号
进行求值。）

   对由 ‘recursive-lengths-list-many-files’ 函数返回的列表进行排序很简单
；它使用 ‘<’ 函数：

     (sort
      (recursive-lengths-list-many-files
       '("./lisp/macros.el"
         "./lisp/mailalias.el"
         "./lisp/hex-util.el"))
      '<)

产生以下结果：

     (29 32 38 71 82 90 95 178 180 218 263 283 321 324 480)

（请注意，在此示例中，‘sort’ 的第一个参数未引用，因为必须评估表达式以产
生传递给 ‘sort’ 的列表。）


File: eintr.info,  Node: Files List,  Next: Counting function definitions,  Prev: Sorting,  Up: Prepare the data

14.9.2 创建文件列表
-------------------

函数 ‘recursive-lengths-list-many-files’ 需要一个文件列表作为其参数。在
我们的测试示例中，我们手工构建了这样一个列表；但是 Emacs Lisp 源代码目录
太大，我们无法手动创建。相反，我们将编写一个函数来为我们完成这个任务。在
这个函数中，我们将同时使用 ‘while’ 循环和递归调用。

   在旧版本的 GNU Emacs 中，我们无需编写这样的函数，因为它们将所有的
‘.el’ 文件放在一个目录中。相反，我们可以使用 ‘directory-files’ 函数，该
函数列出了匹配指定模式的文件的名称，该模式在单个目录中。

   然而，最近的 Emacs 版本将 Emacs Lisp 文件放在顶层 ‘lisp’ 目录的子目录
中。这种重新排列方便了导航。例如，所有与邮件相关的文件都在名为 ‘mail’ 的
‘lisp’ 子目录中。但与此同时，这种排列方式迫使我们创建一个能够进入子目录
的文件列表函数。

   我们可以使用熟悉的函数，如 ‘car’、‘nthcdr’ 和 ‘substring’，以及一个名
为 ‘directory-files-and-attributes’ 的现有函数来创建这个函数。这个后者不
仅列出目录中所有文件的名称，包括子目录的名称，还列出它们的属性。

   重新表述我们的目标：创建一个函数，使我们能够将文件名作为一个列表传递
给 ‘recursive-lengths-list-many-files’，该列表看起来像这样（但元素更多）
：

     ("./lisp/macros.el"
      "./lisp/mail/rmail.el"
      "./lisp/hex-util.el")

   ‘directory-files-and-attributes’ 函数返回一个列表的列表。主列表中的每
个列表都包含13个元素。列表的第一个元素是包含文件的名称的字符串，在
GNU/Linux 中，它可能是一个 “目录文件”，也就是说，具有目录的特殊属性的文
件。列表的第二个元素是目录的 ‘t’，符号链接的字符串（字符串是链接到的名称
），或 ‘nil’。

   例如，‘lisp/’ 目录中的第一个 ‘.el’ 文件是 ‘abbrev.el’。它的名称是
‘/usr/local/share/emacs/22.1.1/lisp/abbrev.el’，它既不是目录也不是符号链
接。

   以下是 ‘directory-files-and-attributes’ 如何列出该文件及其属性的方式
：

     ("abbrev.el"
     nil
     1
     1000
     100
     (20615 27034 579989 697000)
     (17905 55681 0 0)
     (20615 26327 734791 805000)(1)
     13188
     "-rw-r--r--"
     t
     2971624
     773)

   另一方面，‘mail/’ 是 ‘lisp/’ 目录中的一个子目录。其列表的开头看起来像
这样：

     ("mail"
     t
     ...
     )

   （要了解不同属性，请查看 ‘file-attributes’ 的文档。请注意，
‘file-attributes’ 函数不会列出文件名，因此它的第一个元素是
‘directory-files-and-attributes’ 的第二个元素。）

   我们希望我们的新函数 ‘files-in-below-directory’ 能够列出它被告知检查
的目录以及该目录下的任何子目录中的 ‘.el’ 文件。

   这为我们提供了构建 ‘files-in-below-directory’ 的线索：在目录内，该函
数应该将 ‘.el’ 文件名添加到列表中；而如果在目录内，该函数遇到子目录，它
应该进入该子目录并重复其操作。

   然而，我们应该注意到每个目录都包含一个指向自身的名称，称为 ‘.’（“点
”），以及一个指向其父目录的名称，称为 ‘..’（“点 点”）。 （在 ‘/’，即根目
录中，‘..’ 指向它自己，因为 ‘/’ 没有父目录。）显然，我们不希望我们的
‘files-in-below-directory’ 函数进入这些目录，因为它们始终直接或间接地导
致当前目录。

   因此，我们的 ‘files-in-below-directory’ 函数必须执行几个任务：

   • 检查是否正在查看以 ‘.el’ 结尾的文件名；如果是，则将其名称添加到列表
     中。

   • 检查是否正在查看是目录的名称；如果是，

        − 检查是否正在查看 ‘.’ 或 ‘..’；如果是，则跳过。

        − 否则，进入该目录并重复过程。

   让我们编写一个函数定义来执行这些任务。我们将使用一个 ‘while’ 循环来在
目录中从一个文件名移动到另一个文件名，检查需要执行的操作；我们将使用递归
调用来在每个子目录上重复这些操作。递归模式是 Accumulate（*note
Accumulate::），使用 ‘append’ 作为组合器。

   以下是该函数：

     (defun files-in-below-directory (directory)
       "列出 DIRECTORY 及其子目录中的 .el 文件。"
       ;; 尽管该函数将被非交互地使用，
       ;; 但如果我们将其设置为交互式，测试将更容易。
       ;; 目录的名称将类似于
       ;; "/usr/local/share/emacs/22.1.1/lisp/"
       (interactive "DDirectory name: ")
       (let (el-files-list
             (current-directory-list
              (directory-files-and-attributes directory t)))
         ;; 当我们在当前目录中时
         (while current-directory-list
           (cond
            ;; 检查文件名是否以 '.el' 结尾
            ;; 如果是，则将其名称添加到列表中。
            ((equal ".el" (substring (car (car current-directory-list)) -3))
             (setq el-files-list
                   (cons (car (car current-directory-list)) el-files-list)))
            ;; 检查文件名是否是目录的名称
            ((eq t (car (cdr (car current-directory-list))))
             ;; 决定是跳过还是递归
             (if
                 (equal "."
                        (substring (car (car current-directory-list)) -1))
                 ;; 然后什么都不做，因为文件名是
                 ;;   当前目录或父目录的名称，"." 或 ".."
                 ()
               ;; 否则，进入该目录并重复过程
               (setq el-files-list
                     (append
                      (files-in-below-directory
                       (car (car current-directory-list)))
                      el-files-list)))))
           ;; 移动到列表中的下一个文件名；这也
           ;; 缩短列表，因此 while 循环最终会结束
           (setq current-directory-list (cdr current-directory-list)))
         ;; 返回文件名
         el-files-list))

   ‘files-in-below-directory’ ‘directory-files’ 函数接受一个参数，即目录
的名称。

   因此，在我的系统上，

     (length
      (files-in-below-directory "/usr/local/share/emacs/22.1.1/lisp/"))

告诉我，在我的 Lisp 源代码目录及其子目录中有 1031 个 ‘.el’ 文件。

   ‘files-in-below-directory’ 以字母顺序的逆序返回一个列表。将列表按字母
顺序排序的表达式如下：

     (sort
      (files-in-below-directory "/usr/local/share/emacs/22.1.1/lisp/")
      'string-lessp)

   ---------- Footnotes ----------

   (1) 如果 ‘current-time-list’ 是 ‘nil’，则三个时间戳分别为
‘(1351051674579989697 . 1000000000)’，‘(1173477761000000000 .
1000000000)’ 和 ‘(1351050967734791805 . 1000000000)’。


File: eintr.info,  Node: Counting function definitions,  Prev: Files List,  Up: Prepare the data

14.9.3 统计函数定义数量
-----------------------

我们的即时目标是生成一个列表，告诉我们有多少个函数定义包含少于10个字和符
号，有多少包含10到19个字和符号，有多少包含20到29个字和符号，依此类推。

   有了一个排序过的数字列表，这很容易实现：统计列表中有多少元素小于10，
然后在移过刚刚计数的数字后，统计列表中有多少元素小于20，然后在移过刚刚计
数的数字后，统计列表中有多少元素小于30，依此类推。每个数字，10、20、30、
40以及类似的，都比该范围的顶部大1。我们可以称这个数字列表为
‘top-of-ranges’列表。

   如果愿意，我们可以自动生成这个列表，但手动编写列表更简单。下面是一个
例子：

     (defvar top-of-ranges
      '(10  20  30  40  50
        60  70  80  90 100
       110 120 130 140 150
       160 170 180 190 200
       210 220 230 240 250
       260 270 280 290 300)
      "指定 `defuns-per-range' 的范围的列表。")

   要更改范围，我们编辑此列表。

   接下来，我们需要编写一个函数，该函数创建包含在每个范围内的定义数量列
表。显然，此函数必须将‘sorted-lengths’和‘top-of-ranges’列表作为参数。

   ‘defuns-per-range’ 函数必须反复执行两件事：它必须计算在当前顶部范围值
指定的范围内的定义数量；并且在计算当前范围内的定义数量后，它必须转移到
‘top-of-ranges’列表中的下一个更高的值。由于每个动作都是重复的，我们可以
使用‘while’循环完成这项工作。一个循环计算当前范围内的定义数量，另一个循
环依次选择‘top-of-ranges’中的每个顶部范围值。

   ‘sorted-lengths’ 列表的每个条目都会计数多次，这意味着
‘sorted-lengths’列表的循环将在‘top-of-ranges’列表的循环内部，就像小齿轮
在大齿轮内部一样。

   内部循环计算范围内的定义数量。它是我们之前见过的简单计数循环的类型。
(*Note 具有增量计数器的循环: Incrementing Loop.)  循环的真假测试测试
‘sorted-lengths’ 列表中的值是否小于范围顶部的当前值。如果是，则函数增加
计数器并测试‘sorted-lengths’列表的下一个值。

   内部循环如下：

     (while LENGTH-ELEMENT-SMALLER-THAN-TOP-OF-RANGE
       (setq number-within-range (1+ number-within-range))
       (setq sorted-lengths (cdr sorted-lengths)))

   外部循环必须从‘top-of-ranges’列表的最小值开始，然后依次设置为每个后续
更高的值。可以使用如下循环实现：

     (while top-of-ranges
       BODY-OF-LOOP...
       (setq top-of-ranges (cdr top-of-ranges)))

   组合在一起，两个循环如下：

     (while top-of-ranges

       ;; 计算当前范围内的元素数量。
       (while LENGTH-ELEMENT-SMALLER-THAN-TOP-OF-RANGE
         (setq number-within-range (1+ number-within-range))
         (setq sorted-lengths (cdr sorted-lengths)))

       ;; 移到下一个范围。
       (setq top-of-ranges (cdr top-of-ranges)))

   此外，在外部循环的每一次迭代中，Emacs应该记录该范围内的定义数量（
‘number-within-range’的值）到一个列表中。我们可以使用‘cons’来完成这个目
的。(*Note ‘cons’: cons.)

   ‘cons’函数运行正常，但它构造的列表将以最大范围的定义数量开头，并以最
小范围的定义数量结尾。这是因为‘cons’将新元素附加到列表的开头，而由于两个
循环从较低端开始遍历长度的列表，因此‘defuns-per-range-list’将以最大的数
字开始。但我们希望以最小值优先打印我们的图形，然后再打印较大的值。解决方
案是颠倒‘defuns-per-range-list’的顺序。我们可以使用‘nreverse’函数实现这
一点，该函数颠倒列表的顺序。

   例如，

     (nreverse '(1 2 3 4))

产生：

     (4 3 2 1)

   请注意，‘nreverse’函数是破坏性的—也就是说，它改变了其应用的列表；这与
‘car’和‘cdr’函数不同，它们是非破坏性的。在这种情况下，我们不需要原始的
‘defuns-per-range-list’，因此它被销毁并不重要。(‘reverse’函数提供列表的
反向副本，保留原始列表不变。)

   全部组合在一起，‘defuns-per-range’如下：

     (defun defuns-per-range (sorted-lengths top-of-ranges)
       "在每个TOP-OF-RANGES范围内，对SORTED-LENGTHS进行函数定义。"
       (let ((top-of-range (car top-of-ranges))
             (number-within-range 0)
             defuns-per-range-list)

         ;; 外部循环。
         (while top-of-ranges

           ;; 内部循环。
           (while (and
                   ;; 需要用于数字测试的数字。
                   (car sorted-lengths)
                   (< (car sorted-lengths) top-of-range))

             ;; 计算当前范围内的定义数量。
             (setq number-within-range (1+ number-within-range))
             (setq sorted-lengths (cdr sorted-lengths)))

           ;; 退出内部循环但仍保持在外部循环中。

           (setq defuns-per-range-list
                 (cons number-within-range defuns-per-range-list))
           (setq number-within-range 0)      ; 将计数器重置为零。

           ;; 移至下一个范围。
           (setq top-of-ranges (cdr top-of-ranges))
           ;; 指定下一个范围的顶部值。
           (setq top-of-range (car top-of-ranges)))

         ;; 退出外部循环并计算大于
         ;; 最大顶部范围值的函数数量。
         (setq defuns-per-range-list
               (cons
                (length sorted-lengths)
                defuns-per-range-list))

         ;; 返回每个范围内定义数量的列表，
         ;; 从最小到最大。
         (nreverse defuns-per-range-list)))

该函数很直观，除了一个微妙的特征。内部循环的真假测试看起来像这样：

     (and (car sorted-lengths)
          (< (car sorted-lengths) top-of-range))

而不是像这样：

     (< (car sorted-lengths) top-of-range)

   该测试的目的是确定‘sorted-lengths’列表中的第一个项是否小于范围顶部的
值。

   简单版本的测试很好，除非‘sorted-lengths’列表有一个‘nil’值。在这种情况
下，‘(car sorted-lengths)’ 表达式函数返回‘nil’。‘<’函数无法将数字与
‘nil’（一个空列表）进行比较，因此Emacs会发出错误并阻止函数继续执行。

   当计数器达到列表末尾时，‘sorted-lengths’列表始终变为‘nil’。这意味着任
何尝试使用简单版本测试的‘defuns-per-range’函数都将失败。

   我们通过使用‘(car sorted-lengths)’ 表达式与‘and’ 表达式结合来解决问题
。‘(car sorted-lengths)’ 表达式只要列表中至少有一个数字，就会返回非
‘nil’值，但如果列表为空，则返回‘nil’。‘and’ 表达式首先评估‘(car
sorted-lengths)’ 表达式，如果它是‘nil’，则_不_评估‘<’ 表达式，直接返回
false。但如果‘(car sorted-lengths)’ 表达式返回非‘nil’值，则‘and’ 表达式
评估‘<’ 表达式，并将该值作为‘and’ 表达式的值返回。

   这样，我们避免了错误。 (有关‘and’的信息，请参阅‘kill-new’函数 *Note
‘kill-new’函数: kill-new function.)

   以下是对‘defuns-per-range’函数的简短测试。首先，评估将（缩短的）
‘top-of-ranges’ 列表绑定到值列表的表达式，然后评估绑定‘sorted-lengths’ 列
表的表达式，最后评估‘defuns-per-range’函数。

     ;; (比我们稍后将使用的列表更短.)
     (setq top-of-ranges
      '(110 120 130 140 150
        160 170 180 190 200))

     (setq sorted-lengths
           '(85 86 110 116 122 129 154 176 179 200 265 300 300))

     (defuns-per-range sorted-lengths top-of-ranges)

返回的列表如下：

     (2 2 2 0 0 1 0 2 0 0 4)

确实，‘sorted-lengths’列表中有两个小于110的元素，两个元素介于 110 和 119
之间，两个元素介于 120 和 129 之间，依此类推。有四个值等于或大于 200 的
元素。


File: eintr.info,  Node: Readying a Graph,  Next: Emacs Initialization,  Prev: Words in a defun,  Up: Top

15 准备图表
***********

我们的目标是构建一个图表，显示Emacs Lisp源代码中各个长度的函数定义数量。

   实际上，如果你要创建一个图表，你可能会使用诸如‘gnuplot’等程序来完成这
项工作。 （‘gnuplot’已经很好地集成到GNU Emacs中。）但在这种情况下，我们
将从头开始创建一个图表， 在这个过程中，我们将重新熟悉之前学到的一些知识
，并学到更多。

   在这一章中，我们将首先编写一个简单的图表打印函数。这个初步定义将是一
个“原型”， 一个迅速编写的函数，使我们能够侦察这个未知的制图领域。我们将
发现是否存在困难，或者它们只是虚构。 在侦察完地形后，我们将更加自信，并
增强该函数以自动标记坐标轴。

* Menu:

* Columns of a graph::
* graph-body-print::            如何打印图表的主体。
* recursive-graph-body-print::
* Printed Axes::
* Line Graph Exercise::


File: eintr.info,  Node: Columns of a graph,  Next: graph-body-print,  Up: Readying a Graph

打印图表的列
============

由于Emacs被设计为灵活且适用于各种终端，包括字符终端，图表需要由打字机符
号之一制作。 星号就可以；随着图表打印函数的改进，我们可以选择使用用户选
项来指定符号。

   我们可以将这个函数称为‘graph-body-print’；它将以‘numbers-list’作为其
唯一参数。 在这个阶段，我们不会为图表标记，而只会打印其主体。

   ‘graph-body-print’函数为‘numbers-list’中的每个元素插入一个垂直的星号
列。 每行的高度由‘numbers-list’的该元素的值确定。

   插入列是一种重复性的操作；这意味着可以使用‘while’循环或递归来编写此函
数。

   我们的第一个挑战是发现如何打印星号列。通常，在Emacs中，我们通过逐行输
入以水平方式将字符打印到屏幕上。 我们有两条路可以走：编写我们自己的列插
入函数或发现Emacs中是否存在这样一个函数。

   为了查看Emacs中是否存在这样的函数，我们可以使用‘M-x apropos’命令。此
命令类似于‘C-h a’（‘command-apropos’）命令， 但后者仅找到命令函数。‘M-x
apropos’命令列出与正则表达式匹配的所有符号，包括不是交互式的函数。

   我们要寻找的是某个打印或插入列的命令。很可能，该函数的名称将包含
“print”或“insert”或“column”这个词。 因此，我们可以简单地输入‘M-x apropos
<RET> print\|insert\|column <RET>’并查看结果。 在我的系统上，这个命令曾
经花费了相当长的时间，然后产生了一个包含79个函数和变量的列表。现在它几乎
不花费任何时间， 并生成包含211个函数和变量的列表。在列表中扫描，唯一看起
来可能完成这项工作的函数是‘insert-rectangle’。

   事实上，这正是我们想要的函数；其文档如下：

     insert-rectangle:
     在点的上左角插入RECTANGLE的文本。
     RECTANGLE的第一行插入在点处，
     其第二行插入在点的下面的垂直位置，依此类推。
     RECTANGLE应该是一个字符串列表。
     此命令执行后，标记位于左上角，
     点位于右下角。

   我们可以进行一次快速测试，确保它能够按照我们的期望工作。

   在将光标放在‘insert-rectangle’表达式之后，键入‘C-u C-x C-e’（
‘eval-last-sexp’）， 以下是在点和下面插入了字符串‘"first"’、‘"second"’和
‘"third"’的函数结果。 此外，该函数返回‘nil’。

     (insert-rectangle '("first" "second" "third"))first
                                                   second
                                                   thirdnil

当然，我们不会将‘insert-rectangle’表达式本身的文本插入我们正在创建图表的
缓冲区， 而是将从我们的程序中调用该函数。但是，我们必须确保点在缓冲区中
‘insert-rectangle’函数将插入其列的位置。

   如果您在Info中阅读此内容，您可以通过切换到另一个缓冲区，例如
‘*scratch*’缓冲区， 将点放在缓冲区的某个位置，键入‘M-:’，在提示符处键入
‘insert-rectangle’表达式， 然后键入<RET>。这会导致Emacs在小缓冲区中评估
表达式，但将点的值用作‘*scratch*’缓冲区中点的位置的值。 （‘M-:’是
‘eval-expression’的键绑定。此外，由于表达式在小缓冲区中评估，因此‘nil’不
会出现在‘*scratch*’缓冲区中， 因为表达式在小缓冲区中评估。）

   当我们这样做时，我们发现点最终位于最后插入行的末尾——也就是说，此函数
将点作为副作用移动了。 如果我们在此位置重复命令，将点放在此位置，下一个
插入将在上一个插入的下方和右侧。 我们不想要这个！如果我们要制作一个条形
图，那么列需要相互并列。

   因此，我们发现列插入‘while’循环的每个周期必须将点重新定位到我们想要的
位置， 并且该位置将位于列的顶部而不是底部。此外，我们记得当打印图表时，
我们不希望所有列的高度都相同。 这意味着每个列的顶部可能与前一个列的顶部
高度不同。我们不能简单地将点重新定位到相同的行，而是可能移到右边……。

   我们计划使用星号制作条形图的列。列中的星号数量是由‘numbers-list’的当
前元素指定的数量。 我们需要构建一个合适长度的星号列表，以便每次调用
‘insert-rectangle’时都会插入正确的位置。

   如果此列表仅包含所需数量的星号，则必须为图的打印正确位置将点移动到图
的基础上方的正确行。 这可能会很困难。

   另一方面，如果我们可以找到一种方法，将‘insert-rectangle’传递一个每次
都是相同长度的列表， 那么我们就可以每次都将点放在相同的行上，但对于每个
新列都将其右移一列。如果这样做，那么传递给‘insert-rectangle’的列表中的一
些条目必须是空白，而不是星号。 例如，如果图的最大高度为5，但列的高度为
3，则‘insert-rectangle’需要一个参数，如下所示：

     (" " " " "*" "*" "*")

   最后的提议并不那么困难，只要我们能确定列高度。我们有两种方法来指定列
高度：我们可以任意规定它将是多少，这对于该高度的图表是可以的； 或者我们
可以搜索数字列表，将其最大高度用作图的最大高度。如果后者的操作很困难，那
么前者的过程将是最简单的， 但是Emacs内置了一个确定其参数的最大值的函数。
我们可以使用该函数。该函数称为‘max’，它返回其参数的最大值，这些参数必须
是数字。例如，

     (max  3 4 6 5 7 3)

返回7。（相应的函数称为‘min’，返回其参数的最小值。）

   但我们不能简单地在‘numbers-list’上调用‘max’函数；‘max’函数期望数字作
为其参数，而不是数字列表。 因此，以下表达式，

     (max  '(3 4 6 5 7 3))

产生以下错误消息：

     Wrong type of argument:  number-or-marker-p, (3 4 6 5 7 3)

   我们需要一个函数，将参数列表传递给函数。这个函数是‘apply’。该函数将其
第一个参数（函数）应用于其余的参数， 其中最后一个参数可以是一个列表。

   例如，

     (apply 'max 3 4 7 3 '(4 8 5))

返回8。

   （顺便说一下，如果没有像这样的书，我不知道您将如何了解此函数。通过猜
测其名称的一部分，然后使用‘apropos’， 可以发现其他函数，如
‘search-forward’或‘insert-rectangle’。尽管它在隐喻上的基础很清晰——将其第
一个参数应用于其余部分——但我怀疑初学者在使用‘apropos’或其他工具时是否会
想到使用这个特定的词。当然，我可能是错的；毕竟，首次命名该函数的人必须发
明它。）

   ‘apply’的第二个和后续的参数是可选的，因此我们可以使用‘apply’来调用一
个函数并将其列表元素传递给它， 就像这样，它也返回8：

     (apply 'max '(4 8 5))

   我们将使用‘apply’的这种方式。‘recursive-lengths-list-many-files’函数
返回一个数字列表， 我们可以将‘max’应用于它（我们也可以将‘max’应用于排序
后的数字列表；列表是否排序都无关紧要）。

   因此，找到图的最大高度的操作是这样的：

     (setq max-graph-height (apply 'max numbers-list))

   现在我们可以回到创建图表列的问题。告诉了图的最大高度和列中星号的数量
后， 函数应返回‘insert-rectangle’命令插入的列表。

   每一列由星号或空格组成。由于函数传递了列的高度和列中星号的数量，因此
可以通过从列的高度中减去星号的数量来找到空格的数量。给定空格的数量和星号
的数量，可以使用两个 ‘while’ 循环构造列表：

     ;;; 第一个版本。
     (defun column-of-graph (max-graph-height actual-height)
       "返回一个图表列的字符串列表。"
       (let ((insert-list nil)
             (number-of-top-blanks
              (- max-graph-height actual-height)))

         ;; 填充星号。
         (while (> actual-height 0)
           (setq insert-list (cons "*" insert-list))
           (setq actual-height (1- actual-height)))

         ;; 填充空格。
         (while (> number-of-top-blanks 0)
           (setq insert-list (cons " " insert-list))
           (setq number-of-top-blanks
                 (1- number-of-top-blanks)))

         ;; 返回整个列表。
         insert-list))

   如果安装了此函数，然后评估以下表达式，您将看到它按预期返回列表：

     (column-of-graph 5 3)

返回

     (" " " " "*" "*" "*")

   如上所写，‘column-of-graph’ 包含一个主要缺陷：用于空白和列中标记条目
的符号是硬编码的，分别是空格和星号。这对于原型来说是可以的，但您或其他用
户可能希望使用其他符号。例如，在测试图函数时，您可能想要使用句点代替空格
，以确保每次调用 ‘insert-rectangle’ 函数时点被正确重新定位；或者您可能想
要用 ‘+’ 符号或其他符号替换星号。您甚至可能希望创建一个宽度超过一个显示
列的图表列。程序应该更加灵活。为了实现这一点，我们可以用两个变量
‘graph-blank’ 和 ‘graph-symbol’ 替换空白和星号，并分别定义这两个变量。

   此外，文档写得不好。这些考虑因素引导我们到函数的第二个版本：

     (defvar graph-symbol "*"
       "用于图表的符号字符串，通常是星号。")

     (defvar graph-blank " "
       "用于图表的空白字符串，通常是空格。
     graph-blank 的宽度必须与 graph-symbol 相同。")

（有关 ‘defvar’ 的解释，请参见 *note 用 ‘defvar’ 初始化变量: defvar.。）

     ;;; 第二个版本。
     (defun column-of-graph (max-graph-height actual-height)
       "返回 MAX-GRAPH-HEIGHT 个字符串；ACTUAL-HEIGHT 是图表符号。

     图表符号是列表末尾的连续条目。
     列表将作为图表的一列插入。
     这些字符串要么是 graph-blank，要么是 graph-symbol。"

       (let ((insert-list nil)
             (number-of-top-blanks
              (- max-graph-height actual-height)))

         ;; 填充 ‘graph-symbols’。
         (while (> actual-height 0)
           (setq insert-list (cons graph-symbol insert-list))
           (setq actual-height (1- actual-height)))

         ;; 填充 ‘graph-blanks’。
         (while (> number-of-top-blanks 0)
           (setq insert-list (cons graph-blank insert-list))
           (setq number-of-top-blanks
                 (1- number-of-top-blanks)))

         ;; 返回整个列表。
         insert-list))

   如果我们愿意，我们可以再次重写 ‘column-of-graph’，以提供线图和条形图
的可选支持。这不难做到。想象一下线图不过是每个条的顶部以下部分为空格的条
形图。为了构建线图的列，该函数首先构建一个比值短一的空格列表，然后使用
‘cons’ 将图符附加到列表；然后再次使用 ‘cons’ 将顶部空格附加到列表。

   容易看出如何编写这样的函数，但由于我们不需要它，我们将不予实现。但是
这项工作是可以完成的，如果完成了，将使用 ‘column-of-graph’ 完成。更重要
的是，几乎不需要在任何其他地方进行更改。如果我们有兴趣进行增强，这是个简
单的任务。

   现在，最后，我们来到我们的第一个实际图表打印函数。这将打印图表的主体
，而不是垂直和水平轴的标签，因此我们可以称其为 ‘graph-body-print’。


File: eintr.info,  Node: graph-body-print,  Next: recursive-graph-body-print,  Prev: Columns of a graph,  Up: Readying a Graph

15.1 函数 ‘graph-body-print’
============================

在前一节的准备工作完成后，‘graph-body-print’ 函数就很简单了。该函数将按
列打印星号和空格，使用数字列表中的元素来指定每列中星号的数量。这是一个重
复的操作，这意味着我们可以使用递减的 ‘while’ 循环或递归函数来完成这项工
作。在本节中，我们将使用 ‘while’ 循环来编写定义。

   ‘column-of-graph’ 函数需要图表的高度作为参数，因此我们应该确定并记录
它作为一个局部变量。

   这导致了以下 ‘while’ 循环版本的函数模板：

     (defun graph-body-print (numbers-list)
       "文档..."
       (let ((height  ...
              ...))

         (while numbers-list
           插入列并重新定位点
           (setq numbers-list (cdr numbers-list)))))

我们需要填写模板的空白部分。

   显然，我们可以使用表达式 ‘(apply 'max numbers-list)’ 来确定图表的高度
。

   ‘while’ 循环将逐个元素循环遍历 ‘numbers-list’。由于它被 ‘(setq
numbers-list (cdr numbers-list))’ 表达式缩短，列表的每个实例的 CAR 是传
递给 ‘column-of-graph’ 的参数值。

   在 ‘while’ 循环的每个循环中，‘insert-rectangle’ 函数插入由
‘column-of-graph’ 返回的列表。由于 ‘insert-rectangle’ 函数将点移动到插入
的矩形的右下角，我们需要保存矩形插入时点的位置，在插入矩形后返回到该位置
，然后水平移动到下一个调用 ‘insert-rectangle’ 的位置。

   如果插入的列只有一个字符宽，就像使用单个空格和星号时一样，重新定位命
令就是简单的 ‘(forward-char 1)’；然而，列的宽度可能大于一个字符。这意味
着重新定位命令应该写为 ‘(forward-char symbol-width)’。‘symbol-width’ 本
身是一个 ‘graph-blank’ 的长度，可以使用表达式 ‘(length graph-blank)’ 找
到。将 ‘symbol-width’ 变量绑定到图列的宽度值的最佳位置是在 ‘let’ 表达式
的 varlist 中。

   这些考虑导致了以下函数定义：

     (defun graph-body-print (numbers-list)
       "打印 NUMBERS-LIST 的条形图。
     numbers-list 由 Y 轴的值组成。"

       (let ((height (apply 'max numbers-list))
             (symbol-width (length graph-blank))
             from-position)

         (while numbers-list
           (setq from-position (point))
           (insert-rectangle
            (column-of-graph height (car numbers-list)))
           (goto-char from-position)
           (forward-char symbol-width)
           ;; 逐列绘制图形。
           (sit-for 0)
           (setq numbers-list (cdr numbers-list)))
         ;; 为 X 轴标签定位点。
         (forward-line height)
         (insert "\n")
     ))

这个函数中唯一意外的表达式是 ‘(sit-for 0)’ 表达式在 ‘while’ 循环中。这个
表达式使得图形打印操作比没有它更有趣。该表达式导致 Emacs 在零时间内“坐下
”或什么都不做，然后重新绘制屏幕。放在这里，它导致 Emacs 逐列重新绘制屏幕
。如果没有它，Emacs 将在函数退出时才重新绘制屏幕。

   我们可以使用一组短数字列表测试 ‘graph-body-print’。

  1. 安装 ‘graph-symbol’、‘graph-blank’、 ‘column-of-graph’，它们在
     *note Columns of a graph::, 以及 ‘graph-body-print’。

  2. 复制以下表达式：

          (graph-body-print '(1 2 3 4 6 4 3 5 7 6 5 2 3))

  3. 切换到 ‘*scratch*’ 缓冲区，并将光标放在要开始绘制图表的位置。

  4. 输入 ‘M-:’ (‘eval-expression’).

  5. 使用 ‘C-y’ (‘yank’) 将 ‘graph-body-print’ 表达式粘贴到迷你缓冲区中
     。

  6. 按 <RET> 以评估 ‘graph-body-print’ 表达式。

   Emacs 将打印一个类似于以下的图形：

                         *
                     *   **
                     *  ****
                    *** ****
                   ********* *
                  ************
                 *************


File: eintr.info,  Node: recursive-graph-body-print,  Next: Printed Axes,  Prev: graph-body-print,  Up: Readying a Graph

15.2 函数 ‘recursive-graph-body-print’
======================================

函数 ‘graph-body-print’ 也可以使用递归的方式来实现。递归解决方案分为两部
分：一个外部包装器，它使用 ‘let’ 表达式确定一些变量的值，这些变量只需找
到一次，例如图形的最大高度；以及一个内部函数，该函数被递归调用以打印图形
。

   外部包装器比较简单：

     (defun recursive-graph-body-print (numbers-list)
       "打印 NUMBERS-LIST 的条形图。"
       (let ((height (apply 'max numbers-list))
             (symbol-width (length graph-blank))
             from-position)
         (recursive-graph-body-print-internal
          numbers-list
          height
          symbol-width)))

   递归函数稍微复杂一些。它分为四个部分：再次执行测试、打印代码、递归调
用和下一步表达式。再次执行测试是一个 ‘when’ 表达式，用于确定
‘numbers-list’ 是否包含任何剩余元素；如果包含，则该函数使用打印代码打印
图的一列，并再次调用自身。函数再次调用自身的依据是下一步表达式产生的值，
该值导致调用作用在 ‘numbers-list’ 的较短版本上。

     (defun recursive-graph-body-print-internal
       (numbers-list height symbol-width)
       "打印条形图，在 recursive-graph-body-print 函数中使用。"

       (when numbers-list
             (setq from-position (point))
             (insert-rectangle
              (column-of-graph height (car numbers-list)))
             (goto-char from-position)
             (forward-char symbol-width)
             (sit-for 0)     ; 逐列绘制图形。
             (recursive-graph-body-print-internal
              (cdr numbers-list) height symbol-width)))

   安装完成后，可以测试此表达式；以下是一个示例：

     (recursive-graph-body-print '(3 2 5 6 7 5 3 4 6 4 3 2 1))

   这是 ‘recursive-graph-body-print’ 生成的结果：

                     *
                    **   *
                   ****  *
                   **** ***
                 * *********
                 ************
                 *************

   这两个函数之一，‘graph-body-print’ 或 ‘recursive-graph-body-print’，
都可以创建图形的主体。


File: eintr.info,  Node: Printed Axes,  Next: Line Graph Exercise,  Prev: recursive-graph-body-print,  Up: Readying a Graph

15.3 打印坐标轴的必要性
=======================

图表需要有打印的坐标轴，这样你就能更好地定位自己在图中的位置。对于一个一
次性的项目，手工使用Emacs的Picture mode绘制坐标轴可能是合理的；但是，一
个图形绘制函数可能会被多次使用。

   因此，我已经对基本的‘print-graph-body’函数进行了增强，使其能够自动打
印水平和垂直坐标轴的标签。由于标签打印函数并不包含太多新材料，我把它们的
描述放在了附录中。*Note 带有标记坐标轴的图表: Full Graph.


File: eintr.info,  Node: Line Graph Exercise,  Prev: Printed Axes,  Up: Readying a Graph

15.4 练习
=========

编写一个线图版本的图形打印函数。


File: eintr.info,  Node: Emacs Initialization,  Next: Debugging,  Prev: Readying a Graph,  Up: Top

16 你的 ‘.emacs’ 文件
*********************

“你不一定要喜欢Emacs才能喜欢它”—这个看似矛盾的说法是GNU Emacs的秘密。默
认的、开箱即用的Emacs是一个通用工具。大多数人使用它来进行定制，以适应自
己的需求。

   GNU Emacs主要由Emacs Lisp编写；这意味着通过编写Emacs Lisp表达式，你可
以改变或扩展Emacs的功能。

* Menu:

* Default Configuration::
* Site-wide Init::              你可以编写站点级别的初始化文件。
* defcustom::                   Emacs会为你生成代码。
* Beginning init File::         如何编写 ‘.emacs’ 初始化文件。
* Text and Auto-fill::          自动换行。
* Mail Aliases::                使用电子邮件地址的缩写。
* Indent Tabs Mode::            在TeX中不使用制表符。
* Key Bindings::                创建一些个人的键绑定。
* Keymaps::                     更多关于键绑定的信息。
* Loading Files::               自动加载文件（即，评估文件）。
* Autoload::                    使函数可用。
* Simple Extension::            定义一个函数；将其绑定到一个键上。
* X11 Colors::                  X中的颜色。
* Miscellaneous::
* Mode Line::                   如何定制你的模式行。


File: eintr.info,  Node: Default Configuration,  Next: Site-wide Init,  Up: Emacs Initialization

Emacs的默认配置
===============

有些人欣赏Emacs的默认配置。毕竟，当你编辑C文件时，Emacs会启动C模式，编辑
Fortran文件时会启动Fortran模式，而编辑未装饰的文件时会启动Fundamental模
式。如果你不知道谁将使用Emacs，这一切都是有道理的。谁知道一个人希望用未
装饰的文件做什么？对于这样的文件，Fundamental模式是正确的默认选择，就像
编辑C代码时C模式是正确的默认选择一样。（足够多的编程语言有语法使它们能够
共享或几乎共享功能，因此C模式现在由CC模式提供，即C集合。）

   但当你知道将要使用Emacs的是谁—就是你自己—那么定制Emacs就是有意义的。

   例如，当我编辑一个除了没有区别的文件时，我很少想要Fundamental模式；我
想要Text模式。这就是为什么我定制Emacs的原因：使其适合我。

   你可以通过编写或调整 ‘~/.emacs’ 文件来定制和扩展Emacs。这是你的个人初
始化文件；其中的内容，用Emacs Lisp编写，告诉Emacs应该做什么。(1)

   一个 ‘~/.emacs’ 文件包含Emacs Lisp代码。你可以自己编写这些代码；或者
你可以使用Emacs的 ‘customize’ 功能为你编写代码。你可以在你的 ‘.emacs’ 文
件中结合自己的表达式和自动生成的定制表达式。

   （我个人更喜欢编写自己的表达式，除非是那些，特别是字体之类，我发现使
用 ‘customize’ 命令更容易操作。我将这两种方法结合在一起。）

   本章的大部分内容是关于自己编写表达式的。它描述了一个简单的 ‘.emacs’ 文
件；有关更多信息，请参见 *note The Init File: (emacs)Init File. 和 *note
The Init File: (elisp)Init File.。

   ---------- Footnotes ----------

   (1) 你还可以将 ‘.el’ 添加到 ‘~/.emacs’ 并称之为 ‘~/.emacs.el’ 文件。
过去，你不能输入名称 ‘~/.emacs.el’ 需要的额外按键，但现在你可以。新的格
式符合Emacs Lisp文件命名规范；旧的格式节省了打字。


File: eintr.info,  Node: Site-wide Init,  Next: defcustom,  Prev: Default Configuration,  Up: Emacs Initialization

16.1 站点范围初始化文件
=======================

除了个人初始化文件外，Emacs 还会自动加载各种站点范围的初始化文件，如果这
些文件存在的话。这些文件与你的 ‘.emacs’ 文件具有相同的形式，但会被所有用
户加载。

   有两个站点范围的初始化文件，‘site-load.el’ 和 ‘site-init.el’，它们会
在 Emacs 启动时被加载，然后如果创建了 Emacs 的已转储版本，它们会被转储。
（已转储的 Emacs 拥有更快的加载速度。然而，一旦文件被加载并转储，对它的
更改不会导致 Emacs 的变化，除非你自己加载它或重新转储 Emacs。*Note
Building Emacs: (elisp)Building Emacs, 以及 ‘INSTALL’ 文件。）

   另外，还有三个站点范围的初始化文件，每次启动 Emacs 时都会自动加载，如
果它们存在的话。这些文件分别是 ‘site-start.el’，它在你的 ‘.emacs’ 文件之
前加载，以及 ‘default.el’ 和终端类型文件，它们在你的 ‘.emacs’ 文件之后加
载。

   在你的 ‘.emacs’ 文件中的设置和定义会覆盖 ‘site-start.el’ 文件中的冲突
设置和定义（如果存在的话）。但是，在 ‘default.el’ 或终端类型文件中的设置
和定义会覆盖你的 ‘.emacs’ 文件中的设置和定义。（你可以通过将
‘term-file-prefix’ 设置为 ‘nil’ 来阻止终端类型文件的干扰。*Note
一个简单的扩展: Simple Extension.）

   分发中附带的 ‘INSTALL’ 文件包含了对 ‘site-init.el’ 和 ‘site-load.el’
文件的描述。

   ‘loadup.el’、‘startup.el’ 和 ‘loaddefs.el’ 文件控制加载过程。这些文件
位于 Emacs 分发包的 ‘lisp’ 目录中，值得一读。

   ‘loaddefs.el’ 文件包含了许多关于要放入你自己的 ‘.emacs’ 文件或站点范
围初始化文件的建议。


File: eintr.info,  Node: defcustom,  Next: Beginning init File,  Prev: Site-wide Init,  Up: Emacs Initialization

16.2 使用 ‘defcustom’ 指定变量
==============================

您可以使用 ‘defcustom’ 指定变量，以便您和其他人可以使用 Emacs 的
‘customize’ 功能来设置它们的值。 （您不能使用 ‘customize’ 来编写函数定义
；但是您可以在您的 ‘.emacs’ 文件中编写 ‘defuns’。实际上，您可以在您的
‘.emacs’ 文件中写任何 Lisp 表达式。）

   ‘customize’ 功能依赖于 ‘defcustom’ 宏。虽然您可以使用 ‘defvar’ 或
‘setq’ 来定义用户设置的变量，但是 ‘defcustom’ 宏是专门设计用于此任务的。

   您可以使用对 ‘defvar’ 的了解来编写 ‘defcustom’ 的前三个参数。
‘defcustom’ 的第一个参数是变量的名称。第二个参数是变量的初始值，如果有的
话；并且仅当值尚未设置时才设置。第三个参数是文档。

   ‘defcustom’ 的第四个及以后的参数指定类型和选项；这在 ‘defvar’ 中没有
。 （这些参数是可选的。）

   每个参数都由一个关键字和一个值组成。每个关键字以冒号字符 ‘:’ 开头。

   例如，可定制的用户选项变量 ‘text-mode-hook’ 如下所示：

     (defcustom text-mode-hook nil
       "Normal hook run when entering Text mode and many related modes."
       :type 'hook
       :options '(turn-on-auto-fill flyspell-mode)
       :group 'wp)

变量的名称是 ‘text-mode-hook’；它没有默认值；其文档字符串告诉您其功能。

   ‘:type’ 关键字告诉 Emacs 应该将 ‘text-mode-hook’ 设置为哪种数据类型，
并且如何在自定义缓冲区中显示值。

   ‘:options’ 关键字指定变量的建议值列表。通常，‘:options’ 适用于钩子。
列表只是一个建议；它不是排他的；设置变量的人可以将其设置为其他值；
‘:options’ 关键字后面显示的列表旨在为用户提供方便的选择。

   最后，‘:group’ 关键字告诉 Emacs 自定义命令该变量位于哪个组中。这告诉
它在哪里找到它。

   ‘defcustom’ 宏识别超过十几个关键字。有关更多信息，请参见 *note
Writing Customization Definitions: (elisp)Customization.。

   以 ‘text-mode-hook’ 为例。

   有两种方法可以定制此变量。您可以使用定制命令，输入：

     M-x customize

然后找到文本文件编辑组的名称为“Text”。进入该组。 Text Mode Hook 是第一个
成员。您可以单击其各种选项，如 ‘turn-on-auto-fill’，以设置值。单击按钮

     Save for Future Sessions

Emacs 将在您的 ‘.emacs’ 文件中写入一个表达式。它看起来像这样：

     (custom-set-variables
       ;; custom-set-variables was added by Custom.
       ;; If you edit it by hand, you could mess it up, so be careful.
       ;; Your init file should contain only one such instance.
       ;; If there is more than one, they won't work right.
      '(text-mode-hook '(turn-on-auto-fill text-mode-hook-identify)))

（‘text-mode-hook-identify’ 函数告诉 ‘toggle-text-mode-auto-fill’ 哪些缓
冲区处于文本模式。它会自动启动。）

   与 ‘setq’ 不同，‘custom-set-variables’ 函数的工作方式有些不同。虽然我
从未学习过其中的区别，但我手动修改 ‘.emacs’ 文件中的
‘custom-set-variables’ 表达式：我以我认为合理的方式进行更改，并且没有遇
到任何问题。其他人喜欢使用定制命令，让 Emacs 为他们完成工作。

   另一个 ‘custom-set-...’ 函数是 ‘custom-set-faces’。该函数设置各种字体
样式。随着时间的推移，我已经设置了相当多的样式。有时候，我使用
‘customize’ 重新设置它们；其他时候，我只是编辑 ‘.emacs’ 文件中的
‘custom-set-faces’ 表达式本身。

   第二种自定义 ‘text-mode-hook’ 的方法是在 ‘.emacs’ 文件中使用与
‘custom-set-...’ 函数无关的代码自己设置它。

   当您这样做，并稍后使用 ‘customize’ 时，您会看到一个消息，上面写着

     在 Customize 之外更改；在这里操作可能不可靠。

   这只是一个警告。如果您单击按钮

     Save for Future Sessions

Emacs 将在您的 ‘.emacs’ 文件末尾附近写入一个 ‘custom-set-...’ 表达式，该
表达式将在您手写的表达式之后进行评估。因此，它将覆盖您手写的表达式。不会
有任何问题。但是，请务必记住哪个表达式是活动的；如果您忘记了，可能会使自
己困惑。

   只要记得值是在哪里设置的，就不会有问题。无论如何，这些值总是在您的初
始化文件中设置的，通常称为 ‘.emacs’。

   我个人几乎不使用 ‘customize’。大多数情况下，我自己编写表达式。

   顺便说一下，为了更完整地了解定义：‘defsubst’ 定义内联函数。语法与
‘defun’ 相同。‘defconst’ 将符号定义为常量。意图是既不应该由程序也不应该
由用户更改由 ‘defconst’ 设置的值。 （您可以更改它；设置的值是一个变量；
但请不要这样做。）


File: eintr.info,  Node: Beginning init File,  Next: Text and Auto-fill,  Prev: defcustom,  Up: Emacs Initialization

16.3 开始一个 ‘.emacs’ 文件
===========================

当你启动Emacs时，它会加载你的 ‘.emacs’ 文件，除非你在命令行上使用 ‘-q’ 参
数告诉它不要加载。（‘emacs -q’ 命令会给你一个原始、未配置的Emacs。）

   一个 ‘.emacs’ 文件包含Lisp表达式。通常，这些仅仅是设置值的表达式；有
时它们是函数定义。

   *Note 初始化文件 ‘~/.emacs’: (emacs)Init File, 提供了对初始化文件的简
短描述。

   本章节涉及相同的主题，但是是从一个完整且长时间使用的 ‘.emacs’ 文件中
提取的片段，这是我的文件。

   文件的第一部分包含注释：提醒给我自己的。当然，现在我记得这些事情，但
当我开始时，我不记得。

     ;;;; Bob的 .emacs 文件
     ; Robert J. Chassell
     ; 1985年9月26日

看那个日期！我很久以前就开始了这个文件。从那时起，我一直在添加内容。

     ; 该文件中的每个部分都由以四个分号开头的一行引入；
     ; 每个条目都由以三个分号开头的一行引入。

这描述了Emacs Lisp中注释的通常约定。在分号后面的行上的所有内容都是注释。
两个、三个和四个分号用作子部分和部分的标记。（*Note (elisp)Comments::，
了解更多关于注释的信息。）

     ;;;; 帮助键
     ; 控制键-h是帮助键；
     ; 在输入控制键-h后，输入一个字母表示你想要帮助的主题。
     ; 要了解帮助设施的说明，
     ; 连续输入两次控制键-h。

只需记住：输入 ‘C-h’ 两次来获取帮助。

     ; 要了解任何模式，输入控制键-h m
     ; 在该模式中。例如，要了解
     ; 关于邮件模式的信息，进入邮件模式然后输入
     ; 控制键-h m。

我称之为“模式帮助”，非常有帮助。通常，它告诉你所有你需要知道的。

   当然，你不需要在你的 ‘.emacs’ 文件中包含这些注释。我在我的文件中包含
它们是因为我老是忘记模式帮助或注释的约定——但我能记得在这里查看以提醒自己
。


File: eintr.info,  Node: Text and Auto-fill,  Next: Mail Aliases,  Prev: Beginning init File,  Up: Emacs Initialization

16.4 文本和自动填充模式
=======================

现在我们来讨论打开文本模式和自动填充模式的部分。

     ;;; 文本模式和自动填充模式
     ;; 下面两行将Emacs置于文本模式和自动填充模式，适用于希望开始写散文而非代码的作者。
     (setq-default major-mode 'text-mode)
     (add-hook 'text-mode-hook 'turn-on-auto-fill)

   这是这个 ‘.emacs’ 文件的第一部分，不仅提醒了健忘的人类！

   括号中的两行中的第一行告诉Emacs在找到文件时打开文本模式，_除非_该文件
应该进入其他模式，比如C模式。

   当Emacs读取一个文件时，它查看文件名的扩展名，如果有的话（扩展名是 ‘.’
后面的部分）。如果文件以 ‘.c’ 或 ‘.h’ 结尾，那么Emacs将打开C模式。此外，
Emacs查看文件的第一非空行；如果该行说 ‘-*- C -*-’，Emacs将打开C模式。
Emacs拥有一个自动使用的扩展名和规范列表。此外，Emacs在文件的最后一页附近
查找每个缓冲区的本地变量列表，如果有的话。

   *Note How Major Modes are Chosen: (emacs)Choosing Modes.

   *Note Local Variables in Files: (emacs)File Variables.

   现在，回到 ‘.emacs’ 文件。

   这里是上一行；它是如何工作的？

     (setq major-mode 'text-mode)

这一行是一个简短但完整的Emacs Lisp表达式。

   我们已经熟悉了 ‘setq’。它将变量 ‘major-mode’ 设置为后续的值，即
‘text-mode’。在 ‘text-mode’ 之前的单引号告诉Emacs直接处理 ‘text-mode’ 符
号，而不是处理它可能代表的任何东西。参见 *Note Setting the Value of a
Variable: set & setq, 了解 ‘setq’ 的工作原理。主要的观点是，在你的
‘.emacs’ 文件中设置值的过程与在Emacs的其他任何地方使用的过程没有区别。

   这是下一行：

     (add-hook 'text-mode-hook 'turn-on-auto-fill)

在这一行中，‘add-hook’ 命令将 ‘turn-on-auto-fill’ 添加到变量中。

   ‘turn-on-auto-fill’ 是一个程序的名称，猜对了！它打开自动填充模式。

   每次Emacs打开文本模式时，Emacs都会运行挂钩到文本模式的命令。因此，每
次Emacs打开文本模式时，Emacs也会打开自动填充模式。

   简而言之，第一行使Emacs在编辑文件时进入文本模式，除非文件名扩展名、第
一非空行或本地变量告诉Emacs使用其他模式。

   文本模式在其他操作中将语法表设置为方便写作者使用。在文本模式中，
Emacs将撇号视为单词的一部分，如字母一样；但Emacs不将句点或空格视为单词的
一部分。因此，‘M-f’ 可以将光标移到 ‘it's’ 上。另一方面，在C模式中，‘M-f’
在 ‘it's’ 的 ‘t’ 后停止。

   第二行使Emacs在打开文本模式时打开自动填充模式。在自动填充模式中，
Emacs会自动断开太宽的行，并将行的过宽部分移到下一行。Emacs在单词之间断开
行，而不是在它们内部。

   当关闭自动填充模式时，行将根据您输入它们而继续向右延伸。根据您设置的
‘truncate-lines’ 的值，您输入的单词可能会从屏幕右侧消失，或者以一种相当
丑陋和不可读的方式显示在屏幕上，作为续行。

   此外，在我的 ‘.emacs’ 文件的这一部分中，我告诉Emacs填充命令在冒号后插
入两个空格：

     (setq colon-double-space t)


File: eintr.info,  Node: Mail Aliases,  Next: Indent Tabs Mode,  Prev: Text and Auto-fill,  Up: Emacs Initialization

16.5 邮件别名
=============

以下是一个启用邮件别名的 ‘setq’，以及更多的提醒。

     ;;; 消息模式
     ; 进入消息模式，输入 'C-x m'
     ; 进入 RMAIL（阅读邮件），
     ; 输入 'M-x rmail'
     (setq mail-aliases t)

这个 ‘setq’ 将变量 ‘mail-aliases’ 的值设置为 ‘t’。由于 ‘t’ 表示真，这一
行实际上是说：“是的，使用邮件别名。”

   邮件别名是方便的短名称，用于表示长电子邮件地址或电子邮件地址列表。保
存别名的文件是 ‘~/.mailrc’。你可以这样写一个别名：

     alias geo george@foobar.wiz.edu

当你给George写一封邮件时，请将地址写为 ‘geo’；邮件客户端将自动将 ‘geo’ 展
开为完整的地址。


File: eintr.info,  Node: Indent Tabs Mode,  Next: Key Bindings,  Prev: Mail Aliases,  Up: Emacs Initialization

16.6 缩进选项
=============

默认情况下，Emacs在格式化区域时会用制表符替代多个空格。（例如，您可能会
一次性缩进多行文本，使用 ‘indent-region’ 命令。）在终端或普通打印中，制
表符看起来很好，但在使用 TeX 或 Texinfo 时会产生糟糕的缩进输出，因为 TeX
忽略制表符。

   以下是关闭缩进选项的方法：

     ;;; 防止多余的制表符
     (setq-default indent-tabs-mode nil)

   请注意，此行使用的是 ‘setq-default’，而不是我们之前见过的 ‘setq’；
‘setq-default’ 仅在变量在没有本地值的缓冲区中才设置值。

   *Note Tabs vs. Spaces: (emacs)Just Spaces.

   *Note Local Variables in Files: (emacs)File Variables.


File: eintr.info,  Node: Key Bindings,  Next: Keymaps,  Prev: Indent Tabs Mode,  Up: Emacs Initialization

16.7 一些按键绑定
=================

现在来看一些个人按键绑定：

     ;;; 比较窗口
     (global-set-key "\C-cw" 'compare-windows)

   ‘compare-windows’ 是一个巧妙的命令，用于比较当前窗口中的文本与下一个
窗口中的文本。它通过从每个窗口的光标位置开始，在每个窗口中移动文本，直到
找到不匹配的部分。我经常使用这个命令。

   这也展示了如何在所有模式中全局设置按键。

   该命令是 ‘global-set-key’。它后面跟着按键绑定。在 ‘.emacs’ 文件中，按
键绑定的写法如下：‘\C-c’ 代表 Control-C，意味着同时按下 Control 键和 ‘c’
键。‘w’ 代表按下 ‘w’ 键。按键绑定用双引号括起来。在文档中，你应该这样写
：‘C-c w’。（如果你要绑定一个 <META> 键，例如 ‘M-c’，而不是 <CTRL> 键，
你应该在 ‘.emacs’ 文件中写成 ‘\M-c’。详见 *Note
重新绑定按键在你的初始化文件中: (emacs)Init Rebinding, 获取详细信息。）

   由这些按键调用的命令是 ‘compare-windows’。注意，‘compare-windows’ 前
面有一个单引号；否则，Emacs 将首先尝试评估符号以确定其值。

   这三个元素，双引号、‘C’ 前面的反斜杠，以及单引号，是我经常忘记的按键
绑定的必要部分。幸运的是，我已经记住了应该查看我的现有 ‘.emacs’ 文件，并
适应其中的内容。

   至于按键绑定本身：‘C-c w’。这将前缀键 ‘C-c’ 与一个单字符 ‘w’ 结合在一
起。这组按键，‘C-c’ 后跟一个单字符，严格保留供个人使用。 （我称这些为 “个
人” 按键，因为这些是我自己使用的。）你应该始终能够创建这样的按键绑定，而
不会覆盖其他人的按键绑定。如果你曾经编写过 Emacs 的扩展，请避免为公共使
用占用这些按键。请创建一个类似 ‘C-c C-w’ 的按键。否则，我们将用完个人按
键。

   这里是另一个按键绑定，附有注释：

     ;;; 为 'occur' 绑定按键
     ; 我经常使用 occur，所以让我们绑定一个按键：
     (global-set-key "\C-co" 'occur)

   ‘occur’ 命令显示当前缓冲区中与正则表达式匹配的所有行。当区域处于活动
状态时，‘occur’ 限制匹配于该区域。否则，它使用整个缓冲区。匹配的行显示在
一个名为 ‘*Occur*’ 的缓冲区中。该缓冲区作为跳转到匹配行的菜单。

   以下是如何解绑按键，使其无效：

     ;;; 解绑 'C-x f'
     (global-unset-key "\C-xf")

   这解绑的原因是：我发现我在意图输入 ‘C-x C-f’ 时无意中键入了 ‘C-x f’。
与其找到一个文件，我无意中设置了填充文本的宽度，几乎总是设置成我不想要的
宽度。由于我几乎从不重新设置默认宽度，我简单地解绑了该按键。

   以下是如何重新绑定现有按键：

     ;;; 为 'buffer-menu' 重新绑定 'C-x C-b'
     (global-set-key "\C-x\C-b" 'buffer-menu)

   默认情况下，‘C-x C-b’ 运行 ‘list-buffers’ 命令。该命令在 _另一个_ 窗
口中列出你的缓冲区。由于我几乎总是想在那个窗口中执行某些操作，我更喜欢
‘buffer-menu’ 命令，它不仅列出缓冲区，还将光标移到该窗口。


File: eintr.info,  Node: Keymaps,  Next: Loading Files,  Prev: Key Bindings,  Up: Emacs Initialization

16.8 键位映射
=============

Emacs 使用 “键位映射” 记录哪些键调用哪些命令。当你使用 ‘global-set-key’
在 Emacs 的所有部分为单个命令设置键绑定时，你正在指定键绑定在
‘current-global-map’ 中。

   特定模式，如 C 模式或文本模式，有它们自己的键位映射；模式特定的键位映
射会覆盖所有缓冲区共享的全局映射。

   ‘global-set-key’ 函数绑定或重新绑定全局键位映射。例如，下面将键 ‘C-x
C-b’ 绑定到函数 ‘buffer-menu’：

     (global-set-key "\C-x\C-b" 'buffer-menu)

   模式特定的键位映射使用 ‘define-key’ 函数进行绑定，该函数接受特定的键
位映射作为参数，以及键和命令。例如，我的 ‘.emacs’ 文件包含以下表达式，将
命令 ‘texinfo-insert-@group’ 绑定到键 ‘C-c C-c g’：

     (define-key texinfo-mode-map "\C-c\C-cg" 'texinfo-insert-@group)

‘texinfo-insert-@group’ 函数本身是对 Texinfo 模式的一个小扩展，它在
Texinfo 文件中插入 ‘@group’。我经常使用这个命令，而且更喜欢输入三个按键
‘C-c C-c g’，而不是六个按键 ‘@ g r o u p’。 （‘@group’ 及其匹配的 ‘@end
group’ 是一对命令，将所有包含的文本保持在一页上；本书中的许多多行示例都
被 ‘@group ... @end group’ 包围。）

   以下是 ‘texinfo-insert-@group’ 函数的定义：

     (defun texinfo-insert-@group ()
       "在 Texinfo 缓冲区中插入字符串 @group。"
       (interactive)
       (beginning-of-line)
       (insert "@group\n"))

   （当然，我本可以使用 Abbrev 模式来节省输入，而不是编写一个插入单词的
函数；但我更喜欢与其他 Texinfo 模式键绑定一致的按键。）

   在 ‘loaddefs.el’ 以及各种模式库如 ‘cc-mode.el’ 和 ‘lisp-mode.el’ 中，
你会看到许多 ‘define-key’ 表达式。

   *Note 定制键绑定: (emacs)键绑定, 以及 *note 键位映射:
(elisp)键位映射.，获取更多关于键位映射的信息。


File: eintr.info,  Node: Loading Files,  Next: Autoload,  Prev: Keymaps,  Up: Emacs Initialization

16.9 载入文件
=============

GNU Emacs 社区的许多成员都编写了对 Emacs 的扩展。随着时间的推移，这些扩
展通常会被包含在新的发行版中。例如，日历和日记包现在是标准的 GNU Emacs 的
一部分，就像 Calc 一样。

   您可以使用 ‘load’ 命令来评估一个完整的文件，从而将文件中的所有函数和
变量安装到 Emacs 中。例如：

     (load "~/emacs/slowsplit")

   这将评估（即加载）‘slowsplit.el’文件，或者如果存在的话，加载‘emacs’子
目录中更快的、字节编译的‘slowsplit.elc’文件。该文件包含了 John Robinson
在 1989 年编写的函数 ‘split-window-quietly’。

   ‘split-window-quietly’ 函数以最小的重绘方式分割窗口。我在 1989 年安装
它，因为它在我当时使用的速度为 1200 波特的终端上运行良好。如今，我只偶尔
遇到这样的慢速连接，但我继续使用该函数，因为我喜欢它将缓冲区的下半部分留
在新窗口的下半部分，而将上半部分留在上面的窗口中。

   要替换默认的 ‘split-window-vertically’ 的键绑定，您还必须取消该键的绑
定，并将键绑定到 ‘split-window-quietly’，如下所示：

     (global-unset-key "\C-x2")
     (global-set-key "\C-x2" 'split-window-quietly)

   如果您像我一样加载了许多扩展，那么您可以将该扩展文件所在的确切位置指
定为 Emacs 的 ‘load-path’ 的一部分，而不是像上面那样。然后，当 Emacs 加
载文件时，它将在其默认目录列表以及该目录中搜索。 （默认列表在构建 Emacs
时在 ‘paths.h’ 中指定。）

   以下命令将您的 ‘~/emacs’ 目录添加到现有的加载路径中：

     ;;; Emacs 加载路径
     (setq load-path (cons "~/emacs" load-path))

   顺便说一下，‘load-library’ 是 ‘load’ 函数的交互式接口。完整的函数如下
：

     (defun load-library (library)
       "加载名为 LIBRARY 的 Emacs Lisp 库。
     这是对函数 `load' 的接口。在 `load-path' 中搜索 LIBRARY，既包括 `load-suffixes'，也包括（以及 `load-file-rep-suffixes'）。

     有关更多详细信息，请参见 Info 节点 `(emacs)Lisp Libraries'。
     有关 `load-file' 对 `load' 的另一种接口，请参见 `Lisp Libraries' 节点中的信息。"
       (interactive
        (list (completing-read "加载库: "
                               (apply-partially 'locate-file-completion-table
                                                load-path
                                                (get-load-suffixes)))))
       (load library))

   函数的名称 ‘load-library’ 来自于“library”作为“file”的传统同义词的使用
。该命令的源代码位于 ‘files.el’ 库中。

   另一个执行略有不同任务的交互式命令是 ‘load-file’。有关 ‘load-library’
与该命令之间区别的信息，请参阅 ‘Lisp Libraries, , Libraries of Lisp Code
for Emacs, emacs, The GNU Emacs Manual‘。


File: eintr.info,  Node: Autoload,  Next: Simple Extension,  Prev: Loading Files,  Up: Emacs Initialization

16.10 自动加载
==============

与通过加载包含函数的文件或评估函数定义来安装函数不同，您可以使函数可用，
但实际上只有在首次调用时才安装它。这称为“自动加载”。

   当执行一个自动加载的函数时，Emacs会自动评估包含定义的文件，然后调用该
函数。

   Emacs使用自动加载的函数启动更快，因为它们的库不会立即加载；但是当您首
次使用这样的函数时，需要等待片刻，因为其包含文件正在评估中。

   很少使用的函数经常被自动加载。‘loaddefs.el’库包含数千个自动加载的函数
，从‘5x5’到‘zone’。当然，您可能会经常使用一个罕见的函数。当您这样做时，
应该在‘.emacs’文件中使用‘load’表达式加载该函数的文件。

   在我的‘.emacs’文件中，我加载了14个包含函数的库，否则这些函数将被自动
加载。（实际上，最好在我的dumped Emacs中包含这些文件，但我忘了。有关
dumping的更多信息，请参阅*Note Building Emacs: (elisp)Building Emacs,
‘INSTALL’文件。）

   您可能还希望在‘.emacs’文件中包含自动加载的表达式。‘autoload’是一个内
置函数，最多接受五个参数，最后三个是可选的。第一个参数是要自动加载的函数
的名称；第二个是要加载的文件的名称。第三个参数是函数的文档，第四个告诉函
数是否可以通过交互调用。第五个参数告诉对象的类型——‘autoload’可以处理键位
图或宏以及函数（默认是函数）。

   这是一个典型的例子：

     (autoload 'html-helper-mode
       "html-helper-mode" "Edit HTML documents" t)

（‘html-helper-mode’是‘html-mode’的一个较旧的替代品，它是分发的标准部分
。）

此表达式自动加载了‘html-helper-mode’函数。它从‘html-helper-mode.el’文件
（或其字节编译版本‘html-helper-mode.elc’，如果存在的话）中获取。该文件必
须位于由‘load-path’指定的目录中。文档说明这是一种帮助您编辑用HyperText
Markup Language编写的文档的模式。您可以通过键入‘M-x html-helper-mode’以
交互方式调用此模式。（需要在自动加载表达式中重复函数的常规文档，因为常规
函数尚未加载，所以其文档尚不可用。）

   *Note Autoload: (elisp)Autoload, 了解更多信息。


File: eintr.info,  Node: Simple Extension,  Next: X11 Colors,  Prev: Autoload,  Up: Emacs Initialization

16.11 一个简单的扩展：‘line-to-top-of-window’
=============================================

下面是一个简单的Emacs扩展，将光标所在行移动到窗口顶部。我经常使用它，以
便更容易阅读文本。

   你可以将以下代码放入一个单独的文件中，然后从你的 ‘.emacs’ 文件中加载
它，或者直接包含在 ‘.emacs’ 文件中。

   下面是定义：

     ;;; 将行移到窗口顶部；
     ;;; 替代三个按键序列 C-u 0 C-l
     (defun line-to-top-of-window ()
       "将光标所在行移动到窗口顶部。"
       (interactive)
       (recenter 0))

   现在是按键绑定。

   函数键以及鼠标按钮事件和非ASCII字符用方括号括起，不加引号。

   我将 ‘line-to-top-of-window’ 绑定到我的 <F6> 函数键上，如下所示：

     (global-set-key [f6] 'line-to-top-of-window)

   有关更多信息，请参阅 *note 在你的初始化文件中重新绑定键: (emacs)Init
Rebinding.。

   如果你运行两个GNU Emacs版本，比如版本27和28，并使用一个 ‘.emacs’ 文件
，你可以使用以下条件选择要评估的代码：

     (cond
      ((= 27 emacs-major-version)
       ;; 评估版本27的代码
       ( ... ))
      ((= 28 emacs-major-version)
       ;; 评估版本28的代码
       ( ... )))

   例如，最近的版本默认闪烁光标。我不喜欢这种闪烁，以及其他一些功能，因
此我将以下内容放在我的 ‘.emacs’ 文件中(1)：

     (when (>= emacs-major-version 21)
       (blink-cursor-mode 0)
       ;; 在缓冲区末尾按 'C-n'（next-line）时插入换行符
       (setq next-line-add-newlines t)
       ;; 打开图像查看
       (auto-image-file-mode t)
       ;; 打开菜单栏（此栏具有文本）
       ;; （使用数值参数打开）
       (menu-bar-mode 1)
       ;; 关闭工具栏（此栏具有图标）
       ;; （使用数值参数打开）
       (tool-bar-mode nil)
       ;; 关闭工具栏的工具提示模式
       ;; （此模式导致图标解释弹出）
       ;; （使用数值参数打开）
       (tooltip-mode nil)
       ;; 如果启用工具提示，使提示迅速显示
       (setq tooltip-delay 0.1)  ; 默认为0.7秒
        )

   ---------- Footnotes ----------

   (1) 当我启动不加载我的 ‘.emacs’ 文件或任何站点文件的Emacs实例时，我还
会关闭闪烁：

     emacs -q --no-site-file -eval '(blink-cursor-mode nil)'

或者现在，使用一组更复杂的选项，

     emacs -Q -D


File: eintr.info,  Node: X11 Colors,  Next: Miscellaneous,  Prev: Simple Extension,  Up: Emacs Initialization

16.12 X11 颜色
==============

在使用 MIT X 窗口系统的 Emacs 中，您可以指定颜色。

   我不喜欢默认的颜色，因此我设置了自己的颜色。

   以下是我在 ‘.emacs’ 文件中设置值的表达式：

     ;; 设置光标颜色
     (set-cursor-color "white")

     ;; 设置鼠标颜色
     (set-mouse-color "white")

     ;; 设置前景和背景颜色
     (set-foreground-color "white")
     (set-background-color "darkblue")

     ;;; 为 isearch 和 drag 设置高亮颜色
     (set-face-foreground 'highlight "white")
     (set-face-background 'highlight "blue")

     (set-face-foreground 'region "cyan")
     (set-face-background 'region "blue")

     (set-face-foreground 'secondary-selection "skyblue")
     (set-face-background 'secondary-selection "darkblue")

     ;; 设置日历高亮颜色
     (with-eval-after-load 'calendar
       (set-face-foreground 'diary   "skyblue")
       (set-face-background 'holiday "slate blue")
       (set-face-foreground 'holiday "white"))

   各种蓝色调缓解了我的眼睛，并防止我看到屏幕闪烁。

   或者，我也可以在各种 X 初始化文件中设置我的规格。例如，我可以在
‘~/.Xresources’ 文件中设置前景、背景、光标和指针（即鼠标）颜色，如下所示
：

     Emacs*foreground:   white
     Emacs*background:   darkblue
     Emacs*cursorColor:  white
     Emacs*pointerColor: white

   无论如何，由于它不是 Emacs 的一部分，我在 ‘~/.xinitrc’ 文件中设置了我
的 X 窗口的根颜色，如下所示(1)：

     xsetroot -solid Navy -fg white &

   ---------- Footnotes ----------

   (1) 我还运行更现代的窗口管理器，如 Enlightenment、Gnome 或 KDE；在这
些情况下，我通常指定图像而不是纯色。


File: eintr.info,  Node: Miscellaneous,  Next: Mode Line,  Prev: X11 Colors,  Up: Emacs Initialization

16.13 Emacs ‘.emacs’ 文件的其他设置
===================================

以下是一些杂项设置：

   − 设置鼠标指针的形状和颜色：

          ; 鼠标指针形状在 '/usr/include/X11/cursorfont.h' 中定义；
          ; 例如，'target' 鼠标指针是编号 128；
          ; 'top_left_arrow' 鼠标指针是编号 132。

          (let ((mpointer (x-get-resource "*mpointer"
                                          "*emacs*mpointer")))
            ;; 如果你没有设置鼠标指针
            ;; 则设置它，否则保持原样:
            (if (eq mpointer nil)
                (setq mpointer "132")) ; top_left_arrow
            (setq x-pointer-shape (string-to-number mpointer))
            (set-mouse-color "white"))

   − 或者你可以在一个关联列表中设置各种特性的值，如下所示：

          (setq-default
           default-frame-alist
           '((cursor-color . "white")
             (mouse-color . "white")
             (foreground-color . "white")
             (background-color . "DodgerBlue4")
             ;; (cursor-type . bar)
             (cursor-type . box)
             (tool-bar-lines . 0)
             (menu-bar-lines . 1)
             (width . 80)
             (height . 58)
             (font .
                   "-Misc-Fixed-Medium-R-Normal--20-200-75-75-C-100-ISO8859-1")
             ))

   − 将 ‘<CTRL>-h’ 转换为 <DEL>，将 <DEL> 转换为 ‘<CTRL>-h’。
     (一些较旧的键盘可能需要这样做，尽管我最近没有遇到这个问题。)

          ;; 将 'C-h' 转换为 <DEL>。
          ; (keyboard-translate ?\C-h ?\C-?)

          ;; 将 <DEL> 转换为 'C-h'。
          (keyboard-translate ?\C-? ?\C-h)

   − 关闭光标的闪烁！

          (if (fboundp 'blink-cursor-mode)
              (blink-cursor-mode -1))

     或者使用命令 ‘emacs -nbc’ 启动 GNU Emacs。

   − 使用 ‘grep’
     ‘-i’   忽略大小写
     ‘-n’   在输出中添加每行的行号
     ‘-H’   为每个匹配项打印文件名
     ‘-e’   保护以连字符字符 ‘-’ 开头的模式

          (setq grep-command "grep -i -nH -e ")

   − 查找已存在的缓冲区，即使它有不同的名称
     这可以避免符号链接的问题。

          (setq find-file-existing-other-name t)

   − 设置语言环境和默认输入法

          (set-language-environment "latin-1")
          ;; 记住你可以使用 toggle-input-method' (C-\) 命令启用或禁用多语言文本输入
          (setq default-input-method "latin-1-prefix")

     如果你想用中文 GB 字符写作，请设置如下：

          (set-language-environment "Chinese-GB")
          (setq default-input-method "chinese-tonepy")

修复不愉快的键绑定
..................

一些系统将键绑定得不太舒服。有时，例如，<CTRL> 键出现在一个尴尬的位置，
而不是在键盘的最左侧。

   通常情况下，当人们修复这些类型的键绑定时，他们不会更改他们的
‘~/.emacs’ 文件。相反，他们会在启动脚本中使用 ‘loadkeys’ 或
‘install-keymap’ 命令在控制台上绑定正确的键，并在他们的 ‘.xinitrc’ 或
‘.Xsession’ 文件中包含 ‘xmodmap’ 命令以供 X 窗口系统使用。

对于启动脚本：

     loadkeys /usr/share/keymaps/i386/qwerty/emacs2.kmap.gz
或
     install-keymap emacs2

对于 ‘.xinitrc’ 或 ‘.Xsession’ 文件，当 <Caps Lock> 键位于键盘的最左侧时
：

     # 将标有 'Caps Lock' 的键绑定为 'Control'
     # (这样破碎的用户界面表明键盘制造商认为计算机是来自1885年的打字机。)

     xmodmap -e "clear Lock"
     xmodmap -e "add Control = Caps_Lock"

在 ‘.xinitrc’ 或 ‘.Xsession’ 文件中，将 <ALT> 键转换为 <META> 键：

     # 一些设计不当的键盘有一个标有 ALT 的键而没有 Meta
     xmodmap -e "keysym Alt_L = Meta_L Alt_L"


File: eintr.info,  Node: Mode Line,  Prev: Miscellaneous,  Up: Emacs Initialization

16.14 修改后的模式行
====================

最后，有一个我真的很喜欢的功能：修改后的模式行。

   当我通过网络工作时，我会忘记我使用的是哪台机器。而且，我往往会迷失在
当前位置、光标所在行等信息中。

   因此，我将我的模式行重置为以下样式：

     -:-- foo.texi   rattlesnake:/home/bob/  行 1  (Texinfo 填充) 顶部

   我正在访问一个名为‘foo.texi’的文件，位于我的机器‘rattlesnake’上，位于
‘/home/bob’缓冲区。我在第1行，在Texinfo模式下，并且位于缓冲区的顶部。

   我的‘.emacs’文件有一个如下的部分：

     ;; 设置一个模式行，告诉我所在的机器、目录和所在的行，以及其他通常的信息。
     (setq-default mode-line-format
      (quote
       (#("-" 0 1
          (help-echo
           "mouse-1: 选择窗口, mouse-2: 删除其他..."))
        mode-line-mule-info
        mode-line-modified
        mode-line-frame-identification
        "    "
        mode-line-buffer-identification
        "    "
        (:eval (substring
                (system-name) 0 (string-match "\\..+" (system-name))))
        ":"
        default-directory
        #(" " 0 1
          (help-echo
           "mouse-1: 选择窗口, mouse-2: 删除其他..."))
        (line-number-mode " 行 %l ")
        global-mode-string
        #("   %[(" 0 6
          (help-echo
           "mouse-1: 选择窗口, mouse-2: 删除其他..."))
        (:eval (format-time-string "%F"))
        mode-line-process
        minor-mode-alist
        #("%n" 0 2 (help-echo "mouse-2: 扩大" local-map (keymap ...)))
        ")%] "
        (-3 . "%P")
        ;;   "-%-"
        )))

在这里，我重新定义了默认的模式行。列表中的大多数部分来自原始模式行；但我
做了一些更改。我设置了_默认_的模式行格式，以允许各种模式（如Info）覆盖它
。

   列表中的许多元素都是不言自明的： ‘mode-line-modified’是一个变量，表示
缓冲区是否被修改，‘mode-name’表示模式的名称等等。但是，格式看起来很复杂
，是因为我们还没有讨论的两个特性。

   模式行中的第一个字符串是一个破折号，‘-’。在过去，它将简单地指定为
‘"-"’。但现在，Emacs可以为字符串添加属性，如高亮或者在本例中，一个帮助功
能。如果将鼠标光标放在连字符上，将显示一些帮助信息（默认情况下，您必须等
待七分之一秒才能看到信息。您可以通过更改‘tooltip-delay’的值来更改该时间
。）

   新字符串格式具有特殊的语法：

     #("-" 0 1 (help-echo "mouse-1: 选择窗口, ..."))

‘#(’开始一个列表。列表的第一个元素是字符串本身，只有一个‘-’。第二个和第
三个元素指定第四个元素适用的范围。范围从字符之后开始，所以零表示范围从第
一个字符之前开始；1表示范围在第一个字符之后结束。第三个元素是范围的属性
。它包含一个属性列表，一个属性名称，在本例中是‘help-echo’，后跟一个值，
在本例中是一个字符串。新字符串格式的第二、第三和第四个元素可以重复。

   *Note 文本属性: (elisp)Text Properties, 并参见*note 模式行格式:
(elisp)Mode Line Format.，获取更多信息。

   ‘mode-line-buffer-identification’ 显示当前缓冲区的名称。它是一个以
‘(#("%12b" 0 4 ...’开头的列表。 ‘#(’开始列表。

   ‘"%12b"’显示当前缓冲区的名称，使用我们熟悉的‘buffer-name’函数；‘12’指
定将显示的最大字符数。当名称字符较少时，将添加空格以填充到这个数字。 （
缓冲区名称可以并且通常应该比12个字符长；在典型的80列宽窗口中，此长度效果
很好。）

   ‘:eval’表示评估以下表达式，并将结果用作要显示的字符串。在这种情况下，
该表达式显示完整系统名称的第一个组成部分。第一个组成部分的末尾是‘.’（句
点），因此我使用‘string-match’函数告诉我第一个组成部分的长度。从第零个字
符到该长度的子字符串是机器的名称。

   这是表达式：

     (:eval (substring
             (system-name) 0 (string-match "\\..+" (system-name))))

   ‘%[’和‘%]’使每个递归编辑级别都出现一对方括号。 ‘%n’在缩小效果生效时说
“Narrow”。“%P”告诉您在窗口底部之上的缓冲区百分比，或者是“Top”、
“Bottom”或“All”（小写的‘p’告诉您在窗口顶部之上的百分比）。 ‘%-’插入足够
的破折号以填满整行。

   记住，你不一定非要喜欢Emacs才能使用它—你自己的Emacs可以有不同的颜色、
不同的命令和不同的键盘快捷键，与默认的Emacs不同。

   另一方面，如果您想要启动一个纯粹的开箱即用的Emacs，没有定制，请键入：

     emacs -q

这将启动一个不加载您的‘~/.emacs’初始化文件的Emacs。一个纯粹的、默认的
Emacs。没有更多。


File: eintr.info,  Node: Debugging,  Next: Conclusion,  Prev: Emacs Initialization,  Up: Top

17 调试
*******

GNU Emacs有两个调试器，‘debug’ 和 ‘edebug’。第一个内置于Emacs的内部，随
时可用；第二个需要在使用之前对函数进行仪表化。

   这两个调试器在 *note 调试Lisp程序: (elisp)Debugging. 中都有详细描述。
在本章中，我将分别演示这两种调试器的简短示例。

* Menu:

* debug::                       如何使用内置调试器。
* debug-on-entry::              在调用函数时开始调试。
* debug-on-quit::               在按下 ‘C-g’ 时开始调试。
* edebug::                      如何使用Edebug，一个源代码级调试器。
* Debugging Exercises::


File: eintr.info,  Node: debug,  Next: debug-on-entry,  Up: Debugging

17.1 ‘debug’
============

假设你已经编写了一个函数定义，该函数旨在返回给定数字范围内数字的总和。
(这是先前讨论的 ‘triangle’ 函数。*Note 具有递减计数器的示例:
Decrementing Example, 进行讨论。)

   然而，你的函数定义中存在一个错误。你误将 ‘1=’ 写成了 ‘1-’。以下是有问
题的定义：

     (defun triangle-bugged (number)
       "返回1到NUMBER（含）的数字之和。"
       (let ((total 0))
         (while (> number 0)
           (setq total (+ total number))
           (setq number (1= number)))      ; 这里有错误。
         total))

   如果你在Info中阅读这个，可以以正常方式评估这个定义。你将在回显区域看
到 ‘triangle-bugged’。

   现在用参数4评估 ‘triangle-bugged’ 函数：

     (triangle-bugged 4)

这将创建并进入一个 ‘*Backtrace*’ 缓冲区，显示：

     ---------- 缓冲区: *Backtrace* ----------
     Debugger entered--Lisp error: (void-function 1=)
       (1= number)
       (setq number (1= number))
       (while (> number 0) (setq total (+ total number))
             (setq number (1= number)))
       (let ((total 0)) (while (> number 0) (setq total ...)
         (setq number ...)) total)
       triangle-bugged(4)
       eval((triangle-bugged 4) nil)
       eval-expression((triangle-bugged 4) nil nil 127)
       funcall-interactively(eval-expression (triangle-bugged 4) nil nil 127)
       call-interactively(eval-expression nil nil)
       command-execute(eval-expression)
     ---------- 缓冲区: *Backtrace* ----------

（我稍微重新格式化了这个示例；调试器不会折叠长行。通常情况下，你可以在
‘*Backtrace*’ 缓冲区中键入 ‘q’ 退出调试器。）

   在实践中，对于这么简单的错误，Lisp错误行会告诉你正确的信息来修正定义
。函数 ‘1=’ 是无效的。

   然而，假设你不太确定发生了什么？你可以阅读完整的回溯信息。

   Emacs会自动启动调试器并将你放在 ‘*Backtrace*’ 缓冲区中。你也可以按照
下面的描述手动启动调试器。

   从下到上阅读 ‘*Backtrace*’ 缓冲区；它告诉你导致错误的Emacs操作。
Emacs进行了对 ‘C-x C-e’（‘eval-last-sexp’）的交互调用，这导致了对
‘triangle-bugged’ 表达式的评估。每一行以上告诉你Lisp解释器接下来评估了什
么。

   从缓冲区底部开始数第三行是

     (setq number (1= number))

Emacs试图评估这个表达式；为了这样做，它试图评估缓冲区从上到下显示的内部
表达式：

     (1= number)

这就是错误发生的地方；正如最上面的行所说：

     Debugger entered--Lisp error: (void-function 1=)

你可以纠正错误，重新评估函数定义，然后再次运行你的测试。


File: eintr.info,  Node: debug-on-entry,  Next: debug-on-quit,  Prev: debug,  Up: Debugging

17.2 ‘debug-on-entry’
=====================

当你的函数发生错误时，Emacs会自动启动调试器。

   顺便提一下，你可以手动启动调试器，适用于所有版本的Emacs；其中的优势是
，即使你的代码没有错误，调试器也会运行。有时候你的代码是没有bug的！

   你可以通过调用 ‘debug-on-entry’ 在调用函数时手动进入调试器。

输入以下命令：

     M-x debug-on-entry <RET> triangle-bugged <RET>

然后，评估以下表达式：

     (triangle-bugged 5)

所有版本的Emacs都会创建一个 ‘*Backtrace*’ 缓冲区，并告诉你它正在开始评估
‘triangle-bugged’ 函数：

     ---------- Buffer: *Backtrace* ----------
     Debugger entered--entering a function:
     * triangle-bugged(5)
       eval((triangle-bugged 5) nil)
       eval-expression((triangle-bugged 5) nil nil 127)
       funcall-interactively(eval-expression (triangle-bugged 5) nil nil 127)
       call-interactively(eval-expression nil nil)
       command-execute(eval-expression)
     ---------- Buffer: *Backtrace* ----------

   在 ‘*Backtrace*’ 缓冲区中，输入 ‘d’。Emacs将评估 ‘triangle-bugged’ 函
数中的第一个表达式；缓冲区将如下所示：

     ---------- Buffer: *Backtrace* ----------
     Debugger entered--beginning evaluation of function call form:
     * (let ((total 0)) (while (> number 0) (setq total ...)
             (setq number ...)) total)
     * triangle-bugged(5)
       eval((triangle-bugged 5))
       eval((triangle-bugged 5) nil)
       eval-expression((triangle-bugged 5) nil nil 127)
       funcall-interactively(eval-expression (triangle-bugged 5) nil nil 127)
       call-interactively(eval-expression nil nil)
       command-execute(eval-expression)
     ---------- Buffer: *Backtrace* ----------

现在，再次输入 ‘d’，慢慢输入八次。每次输入 ‘d’，Emacs将评估函数定义中的
另一个表达式。

   最终，缓冲区将如下所示：

     ---------- Buffer: *Backtrace* ----------
     Debugger entered--beginning evaluation of function call form:
     * (setq number (1= number))
     * (while (> number 0) (setq total (+ total number))
             (setq number (1= number)))
     * (let ((total 0)) (while (> number 0) (setq total ...)
             (setq number ...)) total)
     * triangle-bugged(5)
       eval((triangle-bugged 5) nil)
       eval-expression((triangle-bugged 5) nil)
       funcall-interactively((triangle-bugged 5) nil)
       call-interactively((triangle-bugged 5) nil)
       command-execute((triangle-bugged 5))
     ---------- Buffer: *Backtrace* ----------

最后，在再次输入 ‘d’ 两次后，Emacs将达到错误点，并且 ‘*Backtrace*’ 缓冲
区的前两行将如下所示：

     ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error: (void-function 1=)
     * (1= number)
     ...
     ---------- Buffer: *Backtrace* ----------

   通过输入 ‘d’，你能够逐步执行函数。

   你可以通过在 ‘*Backtrace*’ 缓冲区中输入 ‘q’ 来退出；这将退出跟踪，但
不会取消 ‘debug-on-entry’。

   要取消 ‘debug-on-entry’ 的效果，调用 ‘cancel-debug-on-entry’ 和函数的
名称，如下：

     M-x cancel-debug-on-entry <RET> triangle-bugged <RET>

(如果你在Info中阅读此内容，请现在取消 ‘debug-on-entry’。)


File: eintr.info,  Node: debug-on-quit,  Next: edebug,  Prev: debug-on-entry,  Up: Debugging

17.3 ‘debug-on-quit’和‘(debug)’
===============================

除了设置‘debug-on-error’或调用‘debug-on-entry’之外，还有两种启动
‘debug’的方法。

   通过将变量‘debug-on-quit’设置为‘t’，你可以在键入‘C-g’（
‘keyboard-quit’）时随时启动‘debug’。这对于调试无限循环非常有用。

   或者，你可以在代码中插入一行，如下所示，以在想要启动调试器的地方开始
‘(debug)’：

     (defun triangle-bugged (number)
       "返回从1累加到NUMBER的数字的总和。"
       (let ((total 0))
         (while (> number 0)
           (setq total (+ total number))
           (debug)                         ; 启动调试器。
           (setq number (1- number)))      ; 错误出现在这里。
         total))

   ‘debug’函数的详细信息在*note Lisp 调试器: (elisp)Debugger.中有描述。


File: eintr.info,  Node: edebug,  Next: Debugging Exercises,  Prev: debug-on-quit,  Up: Debugging

17.4 ‘edebug’ 源码级调试器
==========================

Edebug 是一个源码级调试器。Edebug 通常显示你正在调试的代码的源码，左边有
一个箭头，指示你当前执行的是哪一行。

   你可以逐行地走过函数的执行，或者快速运行直到达到一个“断点”，在那里停
止执行。

   有关 Edebug 的详细信息，请参阅*note (elisp)Edebug::。

   下面是一个有bug的 ‘triangle-recursively’ 函数定义。参见*Note
替代计数的递归: Recursive triangle function, 进行查看。

     (defun triangle-recursively-bugged (number)
       "返回1到NUMBER（包括）之间数字的和，使用递归。"
       (if (= number 1)
           1
         (+ number
            (triangle-recursively-bugged
             (1= number)))))               ; 这里有错误。

通常，你会通过将光标定位在函数的闭括号之后，然后输入 ‘C-x C-e’（
‘eval-last-sexp’），或者将光标定位在定义内部，然后输入 ‘C-M-x’（
‘eval-defun’）来安装这个定义。 （默认情况下，‘eval-defun’ 命令仅在 Emacs
Lisp 模式或 Lisp 交互模式下工作。）

   然而，为了准备这个函数定义以供 Edebug 使用，你必须首先使用不同的命令
进行“仪器化”。你可以将光标定位在定义内部或之后，然后输入

     M-x edebug-defun <RET>

这将导致 Emacs 在需要时自动加载 Edebug（如果尚未加载），并正确地仪器化该
函数。

   在仪器化函数之后，将光标放在以下表达式之后，然后输入 ‘C-x C-e’（
‘eval-last-sexp’）：

     (triangle-recursively-bugged 3)

你将跳转回 ‘triangle-recursively-bugged’ 的源码，光标定位在函数的 ‘if’ 行
的开头。此外，你将在该行的左侧看到一个箭头。箭头标记了函数执行的行。在下
面的示例中，我们使用‘=>’显示箭头；在窗口系统中，你可能会在窗口边缘看到箭
头作为一个实心三角形。

     =>★(if (= number 1)

在示例中，点的位置显示为 ‘★’（在印刷书籍中，它显示为一个五角星）。

   如果现在按下 <SPC> 键，点将移动到下一个要执行的表达式；该行将如下所示
：

     =>(if ★(= number 1)

随着你继续按下 <SPC>，点将从一个表达式移动到另一个表达式。与此同时，每当
一个表达式返回一个值时，该值将显示在回显区域。例如，当你将点移到
‘number’ 后面时，你将看到以下内容：

     Result: 3 (#o3, #x3, ?\C-c)

这意味着 ‘number’ 的值是3，即八进制三，十六进制三，和 ASCII 控制字符C（
字母表的第三个字母，如果你需要知道这些信息）。

   你可以继续移动代码，直到到达包含错误的行。在评估之前，该行看起来像这
样：

     =>        ★(1= number)))))               ; 这里有错误。

当你再次按下 <SPC> 时，将会产生一个错误消息，说：

     Symbol's function definition is void: 1=

这就是bug。

   按下 ‘q’ 退出 Edebug。

   要从函数定义中删除仪器化，只需使用不对其进行仪器化的命令重新评估它。
例如，你可以将光标放在定义的闭括号之后，然后输入 ‘C-x C-e’。

   Edebug 不仅仅能够与你一起逐步执行函数。你可以设置它，让它自己快速执行
，只在错误或指定的停止点停下；你可以让它显示各种表达式的变化值；你可以了
解一个函数被调用了多少次，等等。

   有关 Edebug 的详细信息，请参阅*note (elisp)Edebug::。


File: eintr.info,  Node: Debugging Exercises,  Prev: edebug,  Up: Debugging

17.5 调试练习
=============

   • 安装 ‘count-words-example’ 函数，然后在调用它时使其进入内置调试器。
     在包含两个单词的区域上运行该命令。你将需要按下 ‘d’ 键很多次。在你的
     系统上，命令完成后是否有一个叫做 hook 的钩子？（有关 hooks 的信息，
     请参见 *note Command Loop Overview: (elisp)Command Overview.。）

   • 将 ‘count-words-example’ 复制到 ‘*scratch*’ 缓冲区中，为 Edebug 工
     具为该函数设置断点，并步进执行。该函数不一定要有 bug，尽管你可以引
     入一个如果愿意的话。如果函数没有 bug，步进执行将顺利完成。

   • 在运行 Edebug 时，按下 ‘?’ 键以查看所有 Edebug 命令的列表。（
     ‘global-edebug-prefix’ 通常是 ‘C-x X’，即按下 ‘<CTRL>-x’ 后再按一个
     大写的 ‘X’；在 Edebug 调试缓冲区之外使用此前缀执行命令。）

   • 在 Edebug 调试缓冲区中，使用 ‘p’ 命令（‘edebug-bounce-point’）查看
     ‘count-words-example’ 在区域中的工作位置。

   • 将光标移动到函数内部的某个位置，然后键入 ‘h’ 命令（
     ‘edebug-goto-here’）跳转到该位置。

   • 使用 ‘t’ 命令（‘edebug-trace-mode’）使 Edebug 自动步进执行函数；使
     用大写的 ‘T’ 来使用 ‘edebug-Trace-fast-mode’。

   • 设置一个断点，然后在 Trace 模式下运行 Edebug，直到达到停止点。


File: eintr.info,  Node: Conclusion,  Next: the-the,  Prev: Debugging,  Up: Top

18 结论
*******

我们现在已经到达了这个介绍的结尾。您现在已经学到足够的关于在Emacs Lisp中
编程的知识，足以设置值、为自己和朋友编写简单的‘.emacs’文件，以及编写对
Emacs进行简单定制和扩展的代码。

   这是一个停下来的地方。或者，如果您愿意，现在可以继续前进，自己深入学
习。

   您已经学到了一些编程的基础知识。但仅仅是一些。有许多容易使用的括号和
铰链，我们尚未涉及。

   您现在可以追踪GNU Emacs的源代码以及 *note The GNU Emacs Lisp
Reference Manual: (elisp)Top.

   Emacs Lisp的源代码是一场冒险。当您阅读源代码并遇到一个陌生的函数或表
达式时，您需要弄清楚或找出它的作用。

   前往参考手册。它是对Emacs Lisp进行了详尽、完整且相当易读的描述。它不
仅是为专家编写的，还为像您一样有一定基础的人编写的。（‘参考手册’与标准
GNU Emacs发行版一起提供。与本介绍一样，它作为一个Texinfo源文件，因此您可
以在计算机上阅读它，并作为排版的印刷书籍阅读。）

   查看GNU Emacs的其他内置帮助：所有函数和变量的内置文档，以及
‘xref-find-definitions’，该程序可以带您转到源代码。

   这里是我探索源代码的一个示例。由于其名称，‘simple.el’是我很久以前首先
查看的文件。恰好‘simple.el’中的一些函数很复杂，或者至少乍一看很复杂。例
如，‘open-line’函数看起来很复杂。

   您可能想像这个函数的作用，就像我们之前使用‘forward-sentence’函数一样
慢慢地走一遍。(*Note The ‘forward-sentence’ function: forward-sentence.)
或者您可能想跳过该函数，查看另一个函数，比如‘split-line’。您不需要阅读所
有函数。根据 ‘count-words-in-defun’，‘split-line’函数包含102个单词和符号
。

   即使很短，‘split-line’包含我们尚未学习的表达式：
‘skip-chars-forward’，‘indent-to’，‘current-column’和
‘insert-and-inherit’。

   考虑‘skip-chars-forward’函数。 在GNU Emacs中，您可以通过键入‘C-h f’（
‘describe-function’）和函数的名称来查找有关‘skip-chars-forward’的更多信
息。这将显示函数文档。

   您可能能够猜到一个命名得当的函数（例如‘indent-to’）的作用；或者您也可
以查找它。顺便说一下，‘describe-function’函数本身位于‘help.el’中；它是那
些很长但可以解读的函数之一。您可以使用‘C-h f’命令查找
‘describe-function’！

   在这种情况下，由于代码是Lisp，‘*Help*’缓冲区包含包含函数源代码的库的
名称。您可以将光标放在库的名称上，按下<RET>键，在这种情况下它绑定到
‘help-follow’，直接转到源代码，方式类似于‘M-.’（
‘xref-find-definitions’）。

   ‘describe-function’的定义说明了如何定制‘interactive’表达式，而不使用
标准字符代码；它还展示了如何创建临时缓冲区。

   （‘indent-to’函数是用C而不是Emacs Lisp编写的；它是一个内置函数。
‘help-follow’会将您带到它的源代码，就像‘xref-find-definitions’一样，当正
确设置时。）

   您可以使用‘xref-find-definitions’查看函数的源代码，它绑定到‘M-.’。最
后，您可以查看Reference Manual中关于该函数的内容，方法是在Info中访问手册
，然后键入‘i’（‘Info-index’）和函数的名称，或者在印刷副本的索引中查找该
函数。

   同样，您可以找出‘insert-and-inherit’的含义。

   其他有趣的源文件包括‘paragraphs.el’、‘loaddefs.el’和‘loadup.el’。
‘paragraphs.el’文件包含简短、易于理解的函数以及较长的函数。
‘loaddefs.el’文件包含许多标准的自动加载和许多按键映射。我从未完全查看过
它；只是查看了部分。‘loadup.el’是加载Emacs标准部分的文件；它告诉您关于
Emacs构建方式的很多信息。(*Note Building Emacs: (elisp)Building Emacs, 了
解更多有关构建的信息。)

   正如我所说，您已经学到了一些基础知识；但是，非常重要的是，我们几乎没
有涉及编程的重要方面；我对如何排序信息一无所知，除了使用预定义的‘sort’函
数之外；我对如何存储信息一无所知，除了使用变量和列表之外；我对如何编写编
写程序的程序一无所知。这是另一种、不同类型的书籍、不同类型的学习的主题。

   您所做的是学到了足够在GNU Emacs中进行实际工作的知识。您所做的是开始。
这是一个开始的结束。


File: eintr.info,  Node: the-the,  Next: Kill Ring,  Prev: Conclusion,  Up: Top

Appendix A The ‘the-the’ 函数
*****************************

有时在写文本时，你会重复单词，就像本句子开头的 "you you" 一样。我发现最
常见的情况是重复 "the"，因此，我称检测重复单词的函数为 ‘the-the’。

   作为第一步，你可以使用以下正则表达式搜索重复项：

     \\(\\w+[ \t\n]+\\)\\1

这个正则表达式匹配一个或多个单词成分字符，后面跟着一个或多个空格、制表符
或换行符。然而，它不能检测不同行上的重复单词，因为第一个单词的结束，即行
尾，与第二个单词的结束，即空格，不同。 （有关正则表达式的更多信息，请参
见 *note 正则表达式搜索: Regexp Search.，以及 *note 正则表达式语法:
(emacs)Regexps. 和 *note 正则表达式: (elisp)Regular Expressions.。）

   你可能尝试仅搜索重复的单词成分字符，但这不起作用，因为该模式检测到类
似 "with the" 中的 "th" 的两个重复。

   另一个可能的正则表达式搜索单词成分字符后跟非单词成分字符的模式，再次
，这不是有用的。

   这是我使用的模式。它不是完美的，但足够好。 ‘\\b’ 匹配空字符串，只要它
位于单词的开头或结尾； ‘[^@ \n\t]+’ 匹配一个或多个字符，这


File: eintr.info,  Node: Kill Ring,  Next: Full Graph,  Prev: the-the,  Up: Top

Appendix B 处理 Kill Ring
*************************

Kill ring 是一个列表，通过 ‘current-kill’ 函数的作用被转化为一个环。
‘yank’ 和 ‘yank-pop’ 命令使用 ‘current-kill’ 函数。

   本附录描述了 ‘current-kill’ 函数以及 ‘yank’ 和 ‘yank-pop’ 命令，但首
先，让我们了解一下 kill ring 的工作原理。

* Menu:

* What the Kill Ring Does::
* current-kill::
* yank::                        粘贴剪贴板元素的副本。
* yank-pop::                    插入指向的元素。
* ring file::


File: eintr.info,  Node: What the Kill Ring Does,  Next: current-kill,  Up: Kill Ring

Kill Ring 的作用
================

Kill ring 的默认最大长度是六十个元素；这个数字对于解释来说太大了。相反，
将其设置为四。请执行以下操作：

     (setq old-kill-ring-max kill-ring-max)
     (setq kill-ring-max 4)

然后，请将以下缩进的示例中的每行复制到 kill ring 中。您可以使用 ‘C-k’ 杀
死每行，或者用 ‘M-w’ 标记并复制。

（在只读缓冲区中，如 ‘*info*’ 缓冲区中，杀死命令 ‘C-k’（‘kill-line’）不
会删除文本，只会将其复制到 kill ring 中。然而，您的机器可能会响铃。或者
，为了保持安静，您可以使用 ‘M-w’（‘kill-ring-save’）命令复制每行的区域。
您必须为该命令标记每一行，但无论将点放在哪一端都没有关系。）

请按顺序调用这些调用，以使五个元素尝试填充 kill ring：

     first some text
     second piece of text
     third line
     fourth line of text
     fifth bit of text

然后通过评估以下表达式找到 ‘kill-ring’ 的值：

     kill-ring

它是：

     ("fifth bit of text" "fourth line of text"
     "third line" "second piece of text")

第一个元素，‘first some text’，被删除。

   要恢复 kill ring 长度的旧值，请执行：

     (setq kill-ring-max old-kill-ring-max)


File: eintr.info,  Node: current-kill,  Next: yank,  Prev: What the Kill Ring Does,  Up: Kill Ring

B.1 The ‘current-kill’ 函数
===========================

‘current-kill’ 函数改变 kill 环中由 ‘kill-ring-yank-pointer’ 指向的元素
。 （同时，‘kill-new’ 函数将 ‘kill-ring-yank-pointer’ 设置为指向 kill 环
的最新元素。 ‘kill-new’ 函数直接或间接地被 ‘kill-append’、
‘copy-region-as-kill’、 ‘kill-ring-save’、‘kill-line’ 和 ‘kill-region’ 使
用。）

* Menu:

* Code for current-kill::
* Understanding current-kill::


File: eintr.info,  Node: Code for current-kill,  Next: Understanding current-kill,  Up: current-kill

‘current-kill’ 的代码
---------------------

‘current-kill’ 函数被 ‘yank’ 和 ‘yank-pop’ 使用。下面是 ‘current-kill’ 的
代码：

     (defun current-kill (n &optional do-not-move)
       "将插入点在 kill 环中旋转 N 个位置，然后返回该 kill。
     如果 N 为零，并且 `interprogram-paste-function' 设置为返回字符串或字符串列表的函数，
     并且该函数不返回 nil，则将该字符串（或列表）添加到 kill 环的最前面，并将该字符串
     （或列表的第一个字符串）作为最新的 kill 返回。

     如果 N 不为零，并且 `yank-pop-change-selection' 为非 nil，则使用
     `interprogram-cut-function' 将新的插入点处的 kill 转移到窗口系统的选择中。

     如果可选参数 DO-NOT-MOVE 为非 nil，则实际上不移动插入点；只是返回第 N 个 kill。"

       (let ((interprogram-paste (and (= n 0)
                                      interprogram-paste-function
                                      (funcall interprogram-paste-function))))
         (if interprogram-paste
             (progn
               ;; 在将新文本添加到 kill 环时禁用 interprogram cut 函数，
               ;; 以便 Emacs 不尝试拥有相同的文本选择。
               (let ((interprogram-cut-function nil))
                 (if (listp interprogram-paste)
                   (mapc 'kill-new (nreverse interprogram-paste))
                   (kill-new interprogram-paste)))
               (car kill-ring))
           (or kill-ring (error "Kill 环为空"))
           (let ((ARGth-kill-element
                  (nthcdr (mod (- n (length kill-ring-yank-pointer))
                               (length kill-ring))
                          kill-ring)))
             (unless do-not-move
               (setq kill-ring-yank-pointer ARGth-kill-element)
               (when (and yank-pop-change-selection
                          (> n 0)
                          interprogram-cut-function)
                 (funcall interprogram-cut-function (car ARGth-kill-element))))
             (car ARGth-kill-element)))))

   还要记住，‘kill-new’ 函数将 ‘kill-ring-yank-pointer’ 设置为 kill 环的
最新元素， 这意味着所有调用它的函数都间接地设置了该值：‘kill-append’、
‘copy-region-as-kill’、 ‘kill-ring-save’、‘kill-line’ 和 ‘kill-region’。

   下面是 ‘kill-new’ 中的一行，详见 *note ‘kill-new’ 函数: kill-new
function.。

     (setq kill-ring-yank-pointer kill-ring)


File: eintr.info,  Node: Understanding current-kill,  Prev: Code for current-kill,  Up: current-kill

在大纲中理解 ‘current-kill’
---------------------------

‘current-kill’ 函数看起来复杂，但通常情况下，通过逐步分解可以理解它。 首
先以骨架形式查看：

     (defun current-kill (n &optional do-not-move)
       "将插入点在 kill 环中旋转 N 个位置，然后返回该 kill。"
       (let VARLIST
         BODY...)

   此函数接受两个参数，其中一个是可选的。它有一个文档字符串。它 _不_是交
互式的。

* Menu:

* Body of current-kill::
* Digression concerning error:: 如何误导人类，但不是计算机。
* Determining the Element::


File: eintr.info,  Node: Body of current-kill,  Next: Digression concerning error,  Up: Understanding current-kill

‘current-kill’ 函数体
.....................

函数定义体是一个 ‘let’ 表达式，它本身有一个体和一个 VARLIST。

   ‘let’ 表达式声明了一个仅在此函数范围内可用的变量。这个变量称为
‘interprogram-paste’，用于复制到另一个程序，而不是在此 GNU Emacs 实例内
进行复制。大多数窗口系统提供了跨程序粘贴的功能。遗憾的是，这个功能通常只
提供最后一个元素。尽管 Emacs 几十年来一直提供了许多可能性的环形，但大多
数窗口系统尚未采用。

   ‘if’ 表达式有两个部分，一个是如果存在 ‘interprogram-paste’，另一个是
如果不存在。

   让我们考虑 ‘current-kill’ 函数的 else-部分。（then-部分使用我们已经描
述的 ‘kill-new’ 函数。*Note ‘kill-new’ 函数: kill-new function.）

     (or kill-ring (error "Kill ring is empty"))
     (let ((ARGth-kill-element
            (nthcdr (mod (- n (length kill-ring-yank-pointer))
                         (length kill-ring))
                    kill-ring)))
       (or do-not-move
           (setq kill-ring-yank-pointer ARGth-kill-element))
       (car ARGth-kill-element))

代码首先检查 kill 环是否有内容；否则，它会发出一个错误。

   请注意，‘or’ 表达式与使用 ‘if’ 测试长度非常相似：

     (if (zerop (length kill-ring))          ; if-部分
         (error "Kill ring is empty"))       ; then-部分
       ;; 没有 else-部分

如果 kill 环中没有任何内容，它的长度必须为零，并向用户发送错误消息：
‘Kill ring is empty’。‘current-kill’ 函数使用一个更简单的 ‘or’ 表达式。
但是，一个 ‘if’ 表达式提醒我们发生了什么。

   此 ‘if’ 表达式使用函数 ‘zerop’，如果它测试的值为零，则返回 true。当
‘zerop’ 测试为 true 时，‘if’ 的 then-部分将被评估。then-部分是以函数
‘error’ 开头的列表，它是一种类似于 ‘message’ 函数的函数 (*note The
‘message’ Function: message.)，因为它在回显区域打印一行消息。然而，除了
打印消息之外，‘error’ 还会停止它嵌套在其中的函数的评估。这意味着如果
kill 环的长度为零，则函数的其余部分将不会被评估。

   然后，‘current-kill’ 函数选择要返回的元素。选择取决于 ‘current-kill’
旋转的位置以及 ‘kill-ring-yank-pointer’ 指向的位置。

   接下来，如果可选的 ‘do-not-move’ 参数为 true，或者当前值
‘kill-ring-yank-pointer’ 被设置为指向列表。最后，另一个表达式返回列表的
第一个元素，即使 ‘do-not-move’ 参数为 true。


File: eintr.info,  Node: Digression concerning error,  Next: Determining the Element,  Prev: Body of current-kill,  Up: Understanding current-kill

有关术语“error”的离题讨论
.........................

在我看来，将“error”作为 ‘error’ 函数的名称，至少对人类来说，有点误导。一
个更好的术语应该是“cancel”（取消）。严格来说，当然，你不能指向，更不用说
旋转指向一个长度为零的列表，因此从计算机的角度来看，“error”一词是正确的
。但是人类期望尝试这种事情，即使只是为了找出 kill 环是满的还是空的。这是
一种探索的行为。

   从人类的角度来看，探索和发现的行为不一定是错误的，因此不应该被标记为
错误，即使在计算机的深处。事实上，Emacs 中的代码暗示了一个以探索环境为美
德的人类正在犯错误。这是不好的。即使计算机采取与错误相同的步骤，诸如
“cancel”这样的术语会有一个更清晰的内涵。


File: eintr.info,  Node: Determining the Element,  Prev: Digression concerning error,  Up: Understanding current-kill

确定元素
........

在 ‘if’ 表达式的 else 部分中，除了执行其他动作外，当 kill 环中有内容且
‘do-not-move’ 的值为 ‘nil’ 时，‘if’ 表达式的 else 部分会将
‘kill-ring-yank-pointer’ 的值设置为 ‘ARGth-kill-element’。

   代码如下：

     (nthcdr (mod (- n (length kill-ring-yank-pointer))
                  (length kill-ring))
             kill-ring)))

   这需要一些解释。除非不打算移动指针，‘current-kill’ 函数会改变
‘kill-ring-yank-pointer’ 指向的位置。 这就是
‘(setq kill-ring-yank-pointer ARGth-kill-element))’ 表达式的作用。 显然
，‘ARGth-kill-element’ 被设置为与 kill 环的某个 CDR 相等，使用了在前面一
节中描述的 ‘nthcdr’ 函数。 (*Note copy-region-as-kill::。) 它是如何实现
的呢？

   正如我们之前所看到的 (*note nthcdr::)，‘nthcdr’ 函数通过反复取列表的
CDR 来工作—它取 CDR 的 CDR 的 CDR ...

   以下两个表达式产生相同的结果：

     (setq kill-ring-yank-pointer (cdr kill-ring))

     (setq kill-ring-yank-pointer (nthcdr 1 kill-ring))

   然而，‘nthcdr’ 表达式更加复杂。它使用 ‘mod’ 函数来确定要选择哪个 CDR。

   (记得先看内部函数；事实上，我们将不得不深入了解 ‘mod’。)

   ‘mod’ 函数返回其第一个参数对第二个参数取模的值；换句话说，它返回第一
个参数除以第二个参数后的余数。返回值与第二个参数具有相同的符号。

   因此，

     (mod 12 4)
       ⇒ 0  ;; 因为没有余数
     (mod 13 4)
       ⇒ 1

   在这种情况下，第一个参数通常小于第二个参数。这没问题。

     (mod 0 4)
       ⇒ 0
     (mod 1 4)
       ⇒ 1

   我们可以猜测 ‘-’ 函数的作用。它类似于 ‘+’，但是执行减法而不是加法；
‘-’ 函数从其第一个参数中减去第二个参数。此外，我们已经知道 ‘length’ 函数
的作用 (*note length::)。它返回列表的长度。

   而 ‘n’ 是 ‘current-kill’ 函数的必需参数的名称。

   因此，当 ‘nthcdr’ 的第一个参数为零时，‘nthcdr’ 表达式返回整个列表，如
下所示：

     ;; kill-ring-yank-pointer 和 kill-ring 的长度均为四
     ;; 而 (mod (- 0 4) 4) 的结果为 0
     (nthcdr (mod (- 0 4) 4)
             '("fourth line of text"
               "third line"
               "second piece of text"
               "first some text"))

   当 ‘current-kill’ 函数的第一个参数为一时，‘nthcdr’ 表达式返回不包含其
第一个元素的列表。

     (nthcdr (mod (- 1 4) 4)
             '("fourth line of text"
               "third line"
               "second piece of text"
               "first some text"))

   顺便说一下，‘kill-ring’ 和 ‘kill-ring-yank-pointer’ 都是 “全局变量”。
这意味着 Emacs Lisp 中的任何表达式都可以访问它们。它们不像由 ‘let’ 定义
的局部变量或参数列表中指定的符号那样。局部变量只能在定义它们的 ‘let’ 内
部或在参数列表中指定它们的函数内访问（以及由它们调用的表达式内访问）。

   (*Note ‘let’ 避免混淆: Prevent confusion, 和 *note The ‘defun’ Macro:
defun.)


File: eintr.info,  Node: yank,  Next: yank-pop,  Prev: current-kill,  Up: Kill Ring

B.2 ‘yank’
==========

在学习了‘current-kill’之后，‘yank’函数的代码几乎变得很简单。

   ‘yank’函数不直接使用‘kill-ring-yank-pointer’变量。它调用
‘insert-for-yank’，而‘insert-for-yank’又调用‘current-kill’，后者设置了
‘kill-ring-yank-pointer’变量。

   代码如下：

     (defun yank (&optional arg)
       "重新插入（\"粘贴\"）最近一次删除的文本段。
     更准确地说，重新插入最近一次删除或粘贴的文本段。将光标放在末尾，并在开头设置标记。
     使用 \\[universal-argument] 作为参数时，效果相同，但将光标放在开头（标记放在末尾）。
     带有参数N时，重新插入第N个最近删除的文本段。

     当此命令将删除的文本插入缓冲区时，将遵循`yank-excluded-properties'和`yank-handler'，如`insert-for-yank-1'的文档字符串所述，请参见。

     还可以参考命令`yank-pop'（\\[yank-pop]）."
       (interactive "*P")
       (setq yank-window-start (window-start))
       ;; 如果没有完全执行，使last-command指示随后的命令。
       (setq this-command t)
       (push-mark (point))
       (insert-for-yank (current-kill (cond
                                       ((listp arg) 0)
                                       ((eq arg '-) -2)
                                       (t (1- arg)))))
       (if (consp arg)
           ;; 这类似于exchange-point-and-mark，但不激活标记。
           ;; 尽管命令循环会因为插入文本而取消激活标记，但避免激活更清晰。
           (goto-char (prog1 (mark t)
                        (set-marker (mark-marker) (point) (current-buffer)))))
       ;; 如果完全执行，使this-command指示。
       (if (eq this-command t)
           (setq this-command 'yank))
       nil)

   关键表达式是‘insert-for-yank’，它插入由‘current-kill’返回的字符串，但
从中删除了一些文本属性。

   然而，在到达该表达式之前，函数将‘yank-window-start’的值设置为
‘(window-start)’表达式返回的位置，即显示当前开始的位置。‘yank’函数还设置
了‘this-command’并推送了标记。

   在它插入适当的元素之后，如果可选参数是CONS而不是数字或为空，它将光标
放在插入的文本的开头，并在其末尾设置标记。

   （‘prog1’函数类似于‘progn’，但返回其第一个参数的值，而不是其最后一个
参数的值。其第一个参数被强制为整数返回缓冲区的标记。可以通过将光标置于此
缓冲区中的这些函数上，然后键入‘C-h f’（‘describe-function’）并随后键入
‘RET’来查看这些函数的文档；默认为函数。）

   函数成功时的最后部分说明了要做什么。


File: eintr.info,  Node: yank-pop,  Next: ring file,  Prev: yank,  Up: Kill Ring

B.3 ‘yank-pop’
==============

在理解了 ‘yank’ 和 ‘current-kill’ 之后，你就知道如何处理 ‘yank-pop’ 函数
了。为了节省空间，下面是省略了文档的函数定义：

     (defun yank-pop (&optional arg)
       "..."
       (interactive "*p")
       (if (not (eq last-command 'yank))
           (error "上一个命令不是 yank"))
       (setq this-command 'yank)
       (unless arg (setq arg 1))
       (let ((inhibit-read-only t)
             (before (< (point) (mark t))))
         (if before
             (funcall (or yank-undo-function 'delete-region) (point) (mark t))
           (funcall (or yank-undo-function 'delete-region) (mark t) (point)))
         (setq yank-undo-function nil)
         (set-marker (mark-marker) (point) (current-buffer))
         (insert-for-yank (current-kill arg))
         ;; 如果可能，将窗口的起始位置设置回 yank 命令之前的位置。
         (set-window-start (selected-window) yank-window-start t)
         (if before
             ;; 这类似于 exchange-point-and-mark，
             ;; 但不激活标记。
             ;; 即使命令循环会因为我们插入文本而取消激活标记，
             ;; 这样做更干净，因为我们避免了激活。
             (goto-char (prog1 (mark t)
                          (set-marker (mark-marker)
                                      (point)
                                      (current-buffer))))))
       nil)

   这个函数是交互式的，带有一个小的 ‘p’，因此前缀参数会被处理并传递给函
数。该命令只能在先前的 yank 后使用；否则会发送错误消息。此检查使用变量
‘last-command’，该变量由 ‘yank’ 设置，并在其他地方进行了讨论。(*Note
copy-region-as-kill::。)

   ‘let’ 子句将变量 ‘before’ 设置为 true 或 false，具体取决于 point 是否
在 mark 之前，然后删除 point 和 mark 之间的区域。这是由前一个 yank 命令
刚插入的区域，也就是将被替换的文本。

   ‘funcall’ 将其第一个参数作为函数调用，并将其余参数传递给它。第一个参
数是 ‘or’ 表达式返回的内容。其余两个参数是由前一个 ‘yank’ 命令设置的
point 和 mark 的位置。

   还有更多内容，但这是最难的部分。


File: eintr.info,  Node: ring file,  Prev: yank-pop,  Up: Kill Ring

B.4 The ‘ring.el’ File
======================

有趣的是，GNU Emacs 拥有一个名为 ‘ring.el’ 的文件，它提供了我们刚刚讨论
的许多功能。但诸如 ‘kill-ring-yank-pointer’ 等功能并未使用该库，可能是因
为它们是较早编写的。


File: eintr.info,  Node: Full Graph,  Next: Free Software and Free Manuals,  Prev: Kill Ring,  Up: Top

Appendix C 带有标记轴的图表
***************************

印刷的坐标轴有助于理解图表，它们传达了比例尺。在之前的章节中（*note
准备图表: Readying a Graph.），我们编写了打印图表主体的代码。在这里，我
们编写打印和标记垂直和水平轴的代码，以及图表主体本身。

* Menu:

* Labeled Example::
* print-graph Varlist::         ‘let’ 表达式在 ‘print-graph’ 中的使用。
* print-Y-axis::                打印垂直轴的标签。
* print-X-axis::                打印水平标签。
* Print Whole Graph::           用于打印完整图表的函数。


File: eintr.info,  Node: Labeled Example,  Next: print-graph Varlist,  Up: Full Graph

带标签示例图表
==============

由于插入会填充到点的右侧和下方的缓冲区，新的图表打印函数应该首先打印Y或
垂直轴，然后是图表的主体，最后是X或水平轴。这个顺序为我们规定了函数的内
容：

  1. 设置代码。

  2. 打印Y轴。

  3. 打印图表主体。

  4. 打印X轴。

   这是一个完成的图表应该看起来的示例：

         10 -
                       *
                       *  *
                       *  **
                       *  ***
          5 -      *   *******
                 * *** *******
                 *************
               ***************
          1 - ****************
              |   |    |    |
              1   5   10   15

在这个图表中，垂直轴和水平轴都用数字标记。然而，在一些图表中，水平轴表示
时间，最好用月份标记，就像这样：

          5 -      *
                 * ** *
                 *******
               ********** **
          1 - **************
              |    ^      |
              一月  六月   一月

   事实上，经过一点思考，我们可以轻松想出各种垂直和水平标记方案。我们的
任务可能变得复杂。但是复杂性会导致混淆。与其允许这种情况发生，不如为我们
的第一次尝试选择一个简单的标记方案，以后再进行修改或替换。

   这些考虑建议了‘print-graph’函数的以下大纲：

     (defun print-graph (numbers-list)
       "文档..."
       (let ((height  ...
             ...))
         (print-Y-axis height ... )
         (graph-body-print numbers-list)
         (print-X-axis ... )))

   我们可以逐步处理‘print-graph’函数定义的每个部分。


File: eintr.info,  Node: print-graph Varlist,  Next: print-Y-axis,  Prev: Labeled Example,  Up: Full Graph

C.1 打印图形的 ‘print-graph’ Varlist
====================================

在编写 ‘print-graph’ 函数时，第一项任务是在 ‘let’ 表达式中写入 varlist。
（我们暂时不考虑将函数设计成交互式的，也不考虑文档字符串的内容。）

   Varlist 应该设置几个值。显然，垂直轴标签的顶部必须至少与图形的高度相
同，这意味着我们必须在这里获取此信息。请注意，‘print-graph-body’ 函数也
需要此信息。在两个不同的地方计算图形的高度是没有必要的，因此我们应该修改
‘print-graph-body’ 的定义，以利用这个计算。

   同样，打印 X 轴标签的函数和 ‘print-graph-body’ 函数都需要获取每个符号
的宽度值。我们可以在这里执行计算，并更改前一章中定义的
‘print-graph-body’ 的方式。

   水平轴标签的长度必须至少与图形的长度相同。然而，此信息仅在打印水平轴
的函数中使用，因此不需要在这里进行计算。

   这些思考直接引导我们到 ‘print-graph’ 的 ‘let’ 中的以下形式的 varlist：

     (let ((height (apply 'max numbers-list)) ; 第一版。
           (symbol-width (length graph-blank)))

正如我们将看到的，这个表达式并不完全正确。


File: eintr.info,  Node: print-Y-axis,  Next: print-X-axis,  Prev: print-graph Varlist,  Up: Full Graph

C.2 ‘print-Y-axis’ 函数
=======================

‘print-Y-axis’ 函数的任务是打印垂直轴的标签，其外观如下：

         10 -




          5 -



          1 -

函数应该接收图形的高度，然后构建并插入相应的数字和标记。

* Menu:

* print-Y-axis in Detail::
* Height of label::             Y 轴的高度应该是多少？
* Compute a Remainder::         如何计算除法的余数。
* Y Axis Element::              构建 Y 轴线。
* Y-axis-column::               生成 Y 轴标签的列表。
* print-Y-axis Penultimate::    不太终极的版本。


File: eintr.info,  Node: print-Y-axis in Detail,  Next: Height of label,  Up: print-Y-axis

‘print-Y-axis’ 函数详解
-----------------------

很容易在图中看到 Y 轴标签应该是什么样子；但用文字表达，然后编写一个函数
定义来完成这项工作是另一回事。说“我们希望每五行有一个数字和一个刻度”并不
完全准确：在 ‘1’ 和 ‘5’ 之间只有三条线（2、3和4行），但在 ‘5’ 和 ‘10’ 之
间有四条线（6、7、8和9行）。更好的说法是，我们希望在基线上（数字 1）有一
个数字和一个刻度标记，然后在距离底部第五行以及每个是五的倍数的行上都有一
个数字和一个刻度。


File: eintr.info,  Node: Height of label,  Next: Compute a Remainder,  Prev: print-Y-axis in Detail,  Up: print-Y-axis

标签的高度应该是多少？
----------------------

下一个问题是标签应该是多高？假设图形中最高柱的高度是七。最高的 Y 轴标签
应该是 ‘5 -’ 吗？图形应该突出标签吗？还是最高标签应该是 ‘7 -’，标记图形
的峰值？还是最高标签应该是 ‘10 -’，是五的倍数，并且高于图形的最高值？

   我们更喜欢后一种形式。大多数图形都是在边长是整数步长的矩形内绘制的
——步长为五时为5、10、15等。但一旦我们决定在垂直轴上使用步幅，我们会发现
在计算高度的 varlist 中，简单的表达式是错误的。该表达式是 ‘(apply 'max
numbers-list)’。这返回精确的高度，而不是最大高度加上使其四舍五入到最近的
五的倍数所需的任何值。需要更复杂的表达式。

   像这样的复杂问题，如果分成几个较小的问题，通常会变得更简单。

   首先，考虑最高值是五的整数倍时的情况——当它是5、10、15或更高的五的倍数
时。我们可以将此值用作 Y 轴的高度。

   确定一个数字是否是五的倍数的一种相当简单的方法是将其除以五，看看除法
是否有余数。如果没有余数，那么该数字是五的倍数。因此，七除以五的余数是二
，七不是五的整数倍。稍微用不同的措辞，更像是课堂上的表达方式，五除以七一
次有余数二，但五除以十两次没有余数：十是五的整数倍。


File: eintr.info,  Node: Compute a Remainder,  Next: Y Axis Element,  Prev: Height of label,  Up: print-Y-axis

C.2.1 附录：计算余数
--------------------

在Lisp中，用于计算余数的函数是‘%’。该函数返回其第一个参数除以第二个参数
的余数。正巧，‘%’在Emacs Lisp中是一个无法通过‘apropos’发现的函数：如果输
入‘M-x apropos <RET> remainder <RET>’，你将找不到任何结果。了解‘%’存在的
唯一方式是通过阅读本书或Emacs Lisp源代码。

   你可以通过评估以下两个表达式来尝试‘%’函数：

     (% 7 5)

     (% 10 5)

第一个表达式返回2，第二个表达式返回0。

   为了测试返回值是否为零或其他数字，我们可以使用‘zerop’函数。该函数在其
参数（必须是数字）为零时返回‘t’。

     (zerop (% 7 5))
          ⇒ nil

     (zerop (% 10 5))
          ⇒ t

   因此，以下表达式将在图的高度能够被五整除时返回‘t’：

     (zerop (% height 5))

（当然，‘height’的值可以通过‘(apply 'max numbers-list)’获得。）

   另一方面，如果‘height’的值不是五的倍数，我们希望将其重置为下一个更高
的五的倍数。这是使用我们已经熟悉的函数进行的简单算术。首先，我们将
‘height’的值除以五，以确定五可以整除该数多少次。因此，五可以整除十二两次
。如果我们将这个商加一并乘以五，就会得到大于该高度的下一个五的倍数的值。
五可以整除十二两次。将二加一，并乘以五；结果是十五，这是大于十二的下一个
五的倍数。这个Lisp表达式是：

     (* (1+ (/ height 5)) 5)

例如，如果你评估以下表达式，结果将是15：

     (* (1+ (/ 12 5)) 5)

   在整个讨论中，我们一直使用5作为Y轴标签间隔的值；但我们可能想要使用其
他值。为了通用性，我们应该用一个变量替换5，以便我们可以为其赋值。我能想
到的这个变量的最佳名称是‘Y-axis-label-spacing’。

   使用这个术语和一个‘if’表达式，我们可以得到以下结果：

     (if (zerop (% height Y-axis-label-spacing))
         height
       ;; 否则
       (* (1+ (/ height Y-axis-label-spacing))
          Y-axis-label-spacing))

如果高度是‘Y-axis-label-spacing’的偶数倍，此表达式将返回‘height’本身，否
则它计算并返回一个等于‘Y-axis-label-spacing’的下一个更高倍数的‘height’值
。

   现在，我们可以将此表达式包含在‘print-graph’函数的‘let’表达式中（首先
设置‘Y-axis-label-spacing’的值）：

     (defvar Y-axis-label-spacing 5
       "从一个Y轴标签到下一个的行数。")

     ...
     (let* ((height (apply 'max numbers-list))
            (height-of-top-line
             (if (zerop (% height Y-axis-label-spacing))
                 height
               ;; 否则
               (* (1+ (/ height Y-axis-label-spacing))
                  Y-axis-label-spacing)))
            (symbol-width (length graph-blank))))
     ...

（注意使用‘let*’函数：通过‘(apply 'max numbers-list)’表达式计算一次
‘height’的初始值，然后使用‘height’的结果值计算其最终值。有关‘let*’的更多
信息，请参阅*Note The ‘let*’ expression: fwd-para let.）


File: eintr.info,  Node: Y Axis Element,  Next: Y-axis-column,  Prev: Compute a Remainder,  Up: print-Y-axis

C.2.2 构建Y轴元素
-----------------

当我们打印垂直轴时，我们希望在每五行插入诸如 ‘5 -’ 和 ‘10 - ’ 等字符串。
此外，我们希望数字和破折号对齐，因此较短的数字必须填充前导空格。 如果一
些字符串使用两位数字，则具有单个数字的字符串必须在数字前包含前导空格。

   为了确定数字的长度，使用了 ‘length’ 函数。 但是 ‘length’ 函数只能处理
字符串，而不能处理数字。因此，数字必须转换为字符串。 这是通过
‘number-to-string’ 函数完成的。例如，

     (length (number-to-string 35))
          ⇒ 2

     (length (number-to-string 100))
          ⇒ 3

   (‘number-to-string’ 也被称为 ‘int-to-string’；在各种来源中，您会看到
这个替代名称。)

   此外，在每个标签中，每个数字后面都跟着一个字符串，例如 ‘ - ’，我们将
其称为 ‘Y-axis-tic’ 标记。 该变量使用 ‘defvar’ 定义：

     (defvar Y-axis-tic " - "
        "Y轴标签中数字后面跟随的字符串。")

   Y标签的长度是Y轴标记的长度和图表顶部的数字的长度之和。

     (length (concat (number-to-string height) Y-axis-tic)))

   此值将由 ‘print-graph’ 函数在其 varlist 中作为 ‘full-Y-label-width’ 计
算，并传递给下一个函数。（请注意，在我们首次提出 varlist 时，我们没有考
虑包含这个。）

   为了创建完整的垂直轴标签，一个刻度标记与一个数字连接在一起；两者一起
可能在数字前包含一个或多个空格，这取决于数字有多长。 标签由三部分组成：
（可选的）前导空格、数字和刻度标记。 该函数接收特定行的数字值和由
‘print-graph’ 计算的顶部线的宽度的值，该值仅计算一次。

     (defun Y-axis-element (number full-Y-label-width)
       "构建一个带有数字的标签元素。
     数字元素的外观如下 `  5 - '，并根据最大数字的元素进行必要的填充，以使所有元素对齐。")
       (let* ((leading-spaces
              (- full-Y-label-width
                 (length
                  (concat (number-to-string number)
                          Y-axis-tic)))))
         (concat
          (make-string leading-spaces ? )
          (number-to-string number)
          Y-axis-tic)))

   ‘Y-axis-element’ 函数将前导空格（如果有的话）、作为字符串的数字和刻度
标记连接在一起。

   为了确定标签需要多少前导空格，该函数从实际标签的长度（数字长度加刻度
标记长度）中减去所需的标签宽度。

   使用 ‘make-string’ 函数插入空格。该函数接受两个参数：第一个参数告诉它
字符串的长度，第二个是要插入的字符的符号，以特殊的格式。格式是一个问号后
跟一个空格，如此，‘? ’。参见*Note Character Type: (elisp)Character Type,
以获取有关字符语法的描述。（当然，您可能希望将空格替换为其他字符... 您知
道该怎么做。）

   在连接表达式中使用 ‘number-to-string’ 函数，将数字转换为与前导空格和
刻度标记连接的字符串。


File: eintr.info,  Node: Y-axis-column,  Next: print-Y-axis Penultimate,  Prev: Y Axis Element,  Up: print-Y-axis

C.2.3 创建Y轴标签列
-------------------

前述函数提供了构建生成垂直轴标签的编号和空字符串列表所需的所有工具：

     (defun Y-axis-column (height width-of-label)
       "构建Y轴标签和空字符串的列表。
     对于线以上的高度和标签的宽度WIDTH-OF-LABEL。"
       (let (Y-axis)
         (while (> height 1)
           (if (zerop (% height Y-axis-label-spacing))
               ;; 插入标签。
               (setq Y-axis
                     (cons
                      (Y-axis-element height width-of-label)
                      Y-axis))
             ;; 否则，插入空白。
             (setq Y-axis
                   (cons
                    (make-string width-of-label ? )
                    Y-axis)))
           (setq height (1- height)))
         ;; 插入基准线。
         (setq Y-axis
               (cons (Y-axis-element 1 width-of-label) Y-axis))
         (nreverse Y-axis)))

   在这个函数中，我们从‘height’的值开始，重复减去1。在每次减法之后，我们
测试值是否是‘Y-axis-label-spacing’的整数倍。如果是，我们使用
‘Y-axis-element’函数构造一个带有编号的标签；如果不是，我们使用
‘make-string’函数构造一个空白标签。基准线由数字1和一个刻度标记组成。


File: eintr.info,  Node: print-Y-axis Penultimate,  Prev: Y-axis-column,  Up: print-Y-axis

C.2.4 ‘print-Y-axis’的未完全最终版本
------------------------------------

由‘Y-axis-column’函数构建的列表被传递给‘print-Y-axis’函数，该函数将列表
作为列插入。

     (defun print-Y-axis (height full-Y-label-width)
       "使用HEIGHT和FULL-Y-LABEL-WIDTH插入Y轴。
     Height必须是图形的最大高度。
     全宽度是最高标签元素的宽度。"
     ;; Height和full-Y-label-width的值由print-graph传递。
       (let ((start (point)))
         (insert-rectangle
          (Y-axis-column height full-Y-label-width))
         ;; 将点置于插入图形的正确位置。
         (goto-char start)
         ;; 将点向前移动FULL-Y-LABEL-WIDTH的值
         (forward-char full-Y-label-width)))

   ‘print-Y-axis’使用‘insert-rectangle’函数插入由‘Y-axis-column’函数创建
的Y轴标签。此外，它将点放置在正确的位置以打印图形的主体。

   您可以测试‘print-Y-axis’：

  1. 安装

          Y-axis-label-spacing
          Y-axis-tic
          Y-axis-element
          Y-axis-column
          print-Y-axis

  2. 复制以下表达式：

          (print-Y-axis 12 5)

  3. 切换到‘*scratch*’缓冲区，并将光标放在希望开始轴标签的位置。

  4. 键入‘M-:’（‘eval-expression’）。

  5. 使用‘C-y’（‘yank’）将‘graph-body-print’表达式粘贴到迷你缓冲区中。

  6. 按下<RET>以评估表达式。

   Emacs将垂直打印标签，顶部的标签为‘10 - ’.（在这种情况下，
‘print-graph’函数将传递‘height-of-top-line’的值，这将最终变为15，从而消
除可能出现的错误。）


File: eintr.info,  Node: print-X-axis,  Next: Print Whole Graph,  Prev: print-Y-axis,  Up: Full Graph

C.3 ‘print-X-axis’ 函数
=======================

X轴标签与Y轴标签类似，不同之处在于刻度位于数字上方的一条线上。标签应该如
下所示：

         |   |    |    |
         1   5   10   15

   第一个刻度位于图表的第一列下方，并且前面有几个空格。这些空格在上面的
行中为Y轴标签提供了空间。第二、第三、第四和随后的刻度都是等距的，根据
‘X-axis-label-spacing’ 的值确定。

   X轴的第二行包含数字，前面有几个空格，并且也根据变量
‘X-axis-label-spacing’ 的值分隔。

   变量 ‘X-axis-label-spacing’ 的值本身应该以 ‘symbol-width’ 的单位来衡
量，因为您可能希望更改用于打印图表主体的符号的宽度，而不改变图表的标签方
式。

* Menu:

* Similarities differences::    与 ‘print-Y-axis’ 类似，但不完全相同。
* X Axis Tic Marks::            为水平轴创建刻度标记。


File: eintr.info,  Node: Similarities differences,  Next: X Axis Tic Marks,  Up: print-X-axis

相似性与差异
------------

‘print-X-axis’ 函数的构建方式与 ‘print-Y-axis’ 函数几乎相同，只是它有两
行：刻度线和数字。我们将编写两个单独的函数分别打印这两行，然后在
‘print-X-axis’ 函数中将它们组合起来。

   这是一个三步过程：

  1. 编写一个用于打印X轴刻度标记的函数，‘print-X-axis-tic-line’。

  2. 编写一个用于打印X轴数字的函数，‘print-X-axis-numbered-line’。

  3. 编写一个用于同时打印两行的函数，即 ‘print-X-axis’ 函数，使用
     ‘print-X-axis-tic-line’ 和 ‘print-X-axis-numbered-line’。


File: eintr.info,  Node: X Axis Tic Marks,  Prev: Similarities differences,  Up: print-X-axis

C.3.1 X轴刻度标记
-----------------

第一个函数应该打印X轴的刻度标记。我们需要指定刻度标记本身及其间距：

     (defvar X-axis-label-spacing
       (if (boundp 'graph-blank)
           (* 5 (length graph-blank)) 5)
       "相邻X轴标签之间的单位数。")

（注意，‘graph-blank’的值由另一个‘defvar’设置。‘boundp’谓词检查它是否已
经被设置；如果尚未设置‘graph-blank’，并且我们没有使用此条件构造，将进入
调试器，并显示错误消息，其中包含 ‘Debugger entered--Lisp error:
(void-variable graph-blank)’。）

   这是‘X-axis-tic-symbol’的‘defvar’：

     (defvar X-axis-tic-symbol "|"
       "插入到X轴列的字符串。")

   目标是生成如下一行：

            |   |    |    |

   第一个刻度标记缩进，使其位于第一列下方，该列缩进以提供给Y轴标签留出空
间。

   刻度元素包括从一个刻度到下一个刻度的空格以及一个刻度符号。空格的数量
由刻度符号的宽度和‘X-axis-label-spacing’确定。

   代码如下：

     ;;; X-axis-tic-element
     ...
     (concat
      (make-string
       ;; 生成空格字符串。
       (-  (* symbol-width X-axis-label-spacing)
           (length X-axis-tic-symbol))
       ? )
      ;; 将空格与刻度符号连接起来。
      X-axis-tic-symbol)
     ...

   接下来，我们确定需要多少空格来缩进第一个刻度标记以对齐图表的第一列。
这使用由‘print-graph’函数传递的‘full-Y-label-width’的值。

   生成‘X-axis-leading-spaces’的代码如下：

     ;; X-axis-leading-spaces
     ...
     (make-string full-Y-label-width ? )
     ...

   我们还需要确定水平轴的长度，即数字列表的长度，以及水平轴上的刻度数：

     ;; X-length
     ...
     (length numbers-list)

     ;; tic-width
     ...
     (* symbol-width X-axis-label-spacing)

     ;; number-of-X-ticks
     (if (zerop (% (X-length tic-width)))
         (/ (X-length tic-width))
       (1+ (/ (X-length tic-width))))

   所有这些直接导致打印X轴刻度线的函数：

     (defun print-X-axis-tic-line
       (number-of-X-tics X-axis-leading-spaces X-axis-tic-element)
       "打印X轴的刻度标记。"
         (insert X-axis-leading-spaces)
         (insert X-axis-tic-symbol)  ; 在第一列下方插入刻度符号。
         ;; 在正确的位置插入第二个刻度。
         (insert (concat
                  (make-string
                   (-  (* symbol-width X-axis-label-spacing)
                       ;; 插入到第二个刻度符号的空格。
                       (* 2 (length X-axis-tic-symbol)))
                   ? )
                  X-axis-tic-symbol))
         ;; 插入剩余的刻度标记。
         (while (> number-of-X-tics 1)
           (insert X-axis-tic-element)
           (setq number-of-X-tics (1- number-of-X-tics))))

   数字行同样简单：

   首先，我们使用空格在每个数字之前创建一个带编号的元素：

     (defun X-axis-element (number)
       "构造带编号的X轴元素。"
       (let ((leading-spaces
              (-  (* symbol-width X-axis-label-spacing)
                  (length (number-to-string number)))))
         (concat (make-string leading-spaces ? )
                 (number-to-string number))))

   接下来，我们创建打印带编号行的函数，从数字1开始，位于第一列下方：

     (defun print-X-axis-numbered-line
       (number-of-X-tics X-axis-leading-spaces)
       "打印X轴数字行"
       (let ((number X-axis-label-spacing))
         (insert X-axis-leading-spaces)
         (insert "1")
         (insert (concat
                  (make-string
                   ;; 插入到下一个数字的空格。
                   (-  (* symbol-width X-axis-label-spacing) 2)
                   ? )
                  (number-to-string number)))
         ;; 插入剩余的数字。
         (setq number (+ number X-axis-label-spacing))
         (while (> number-of-X-tics 1)
           (insert (X-axis-element number))
           (setq number (+ number X-axis-label-spacing))
           (setq number-of-X-tics (1- number-of-X-tics)))))

   最后，我们需要编写‘print-X-axis’函数，该函数使用
‘print-X-axis-tic-line’和‘print-X-axis-numbered-line’。

   该函数必须确定两个函数都使用的变量的局部值，然后调用它们。此外，它必
须打印分隔两行的换行符。

   该函数包含一个varlist，指定了五个局部变量，并调用了两个打印行的函数：

     (defun print-X-axis (numbers-list)
       "打印X轴标签到NUMBERS-LIST的长度。"
       (let* ((leading-spaces
               (make-string full-Y-label-width ? ))
            ;; symbol-width 由 graph-body-print 提供
            (tic-width (* symbol-width X-axis-label-spacing))
            (X-length (length numbers-list))
            (X-tic
             (concat
              (make-string
               ;; 生成空格字符串。
               (-  (* symbol-width X-axis-label-spacing)
                   (length X-axis-tic-symbol))
               ? )
              ;; 将空格与刻度符号连接起来。
              X-axis-tic-symbol))
            (tic-number
             (if (zerop (% X-length tic-width))
                 (/ X-length tic-width)
               (1+ (/ X-length tic-width)))))
         (print-X-axis-tic-line tic-number leading-spaces X-tic)
         (insert "\n")
         (print-X-axis-numbered-line tic-number leading-spaces)))

   您可以测试‘print-X-axis’：

  1. 安装‘X-axis-tic-symbol’，‘X-axis-label-spacing’，
     ‘print-X-axis-tic-line’以及‘X-axis-element’，
     ‘print-X-axis-numbered-line’和‘print-X-axis’。

  2. 复制以下表达式：

          (progn
           (let ((full-Y-label-width 5)
                 (symbol-width 1))
             (print-X-axis
              '(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16))))

  3. 切换到‘*scratch*’缓冲区，并将光标放到希望开始轴标签的位置。

  4. 输入‘M-:’（‘eval-expression’）。

  5. 使用‘C-y’（‘yank’）将测试表达式粘贴到迷你缓冲区中。

  6. 按下<RET>以评估表达式。

   Emacs将打印出水平轴，如下所示：

          |   |    |    |    |
          1   5   10   15   20


File: eintr.info,  Node: Print Whole Graph,  Prev: print-X-axis,  Up: Full Graph

C.4 打印整个图表
================

现在我们几乎准备好打印整个图表了。

   打印带有适当标签的图表的函数遵循我们之前创建的大纲（*note
带标签的图表: Full Graph.），但是有一些增加。

   以下是大纲：

     (defun print-graph (numbers-list)
       "DOCUMENTATION..."
       (let ((height  ...
             ...))
         (print-Y-axis height ... )
         (graph-body-print numbers-list)
         (print-X-axis ... )))

* Menu:

* The final version::                   几处更改。
* Test print-graph::            运行简短测试。
* Graphing words in defuns::        执行最终代码。
* lambda::                      如何编写匿名函数。
* mapcar::                      对列表元素应用函数。
* Another Bug::                 又一个错误 ... 最隐匿。
* Final printed graph::             图表本身！


File: eintr.info,  Node: The final version,  Next: Test print-graph,  Up: Print Whole Graph

最终版本的更改
--------------

最终版本与我们计划的不同，有两点不同：首先，它包含了一次在变量列表中计算
的附加值；其次，它带有一个选项，用于指定标签每行的增量。 后者的功能证明
是必要的；否则，图表可能具有超过显示屏或纸张上能容纳的行数。

   这个新功能需要对 ‘Y-axis-column’ 函数进行更改，以添加
‘vertical-step’。该函数如下：

     ;;; 最终版本。
     (defun Y-axis-column
       (height width-of-label &optional vertical-step)
       "构建Y轴标签列表。
     HEIGHT 是图表的最大高度。
     WIDTH-OF-LABEL 是标签的最大宽度。
     VERTICAL-STEP，一个可选项，是一个正整数，
     用于指定每行的Y轴标签增量。
     例如，步长为5表示每行是图表的五个单位。"
       (let (Y-axis
             (number-per-line (or vertical-step 1)))
         (while (> height 1)
           (if (zerop (% height Y-axis-label-spacing))
               ;; 插入标签。
               (setq Y-axis
                     (cons
                      (Y-axis-element
                       (* height number-per-line)
                       width-of-label)
                      Y-axis))
             ;; 否则，插入空白。
             (setq Y-axis
                   (cons
                    (make-string width-of-label ? )
                    Y-axis)))
           (setq height (1- height)))
         ;; 插入基准线。
         (setq Y-axis (cons (Y-axis-element
                             (or vertical-step 1)
                             width-of-label)
                            Y-axis))
         (nreverse Y-axis)))

   图表的最大高度和符号宽度的值由 ‘print-graph’ 在其 ‘let’ 表达式中计算
；因此，‘graph-body-print’ 必须更改以接受它们。

     ;;; 最终版本。
     (defun graph-body-print (numbers-list height symbol-width)
       "打印NUMBERS-LIST的条形图。
     numbers-list 包含Y轴值。
     HEIGHT 是图表的最大高度。
     SYMBOL-WIDTH 是每列的数字。"
       (let (from-position)
         (while numbers-list
           (setq from-position (point))
           (insert-rectangle
            (column-of-graph height (car numbers-list)))
           (goto-char from-position)
           (forward-char symbol-width)
           ;; 逐列绘制图表。
           (sit-for 0)
           (setq numbers-list (cdr numbers-list)))
         ;; 放置X轴标签的点。
         (forward-line height)
         (insert "\n")))

   最后，‘print-graph’ 函数的代码：

     ;;; 最终版本。
     (defun print-graph
       (numbers-list &optional vertical-step)
       "打印带有标签的条形图 NUMBERS-LIST。
     numbers-list 包含Y轴值。

     可选的，VERTICAL-STEP，一个正整数，
     指定每行的Y轴标签增量。
     例如，步长为5表示每行是图表的五个单位。"
       (let* ((symbol-width (length graph-blank))
              ;; height 既是最大的数字
              ;; 也是数字位数最多的数字。
              (height (apply 'max numbers-list))
              (height-of-top-line
               (if (zerop (% height Y-axis-label-spacing))
                   height
                 ;; 否则
                 (* (1+ (/ height Y-axis-label-spacing))
                    Y-axis-label-spacing)))
              (vertical-step (or vertical-step 1))
              (full-Y-label-width
               (length
                (concat
                 (number-to-string
                  (* height-of-top-line vertical-step))
                 Y-axis-tic))))

         (print-Y-axis
          height-of-top-line full-Y-label-width vertical-step)
         (graph-body-print
          numbers-list height-of-top-line symbol-width)
         (print-X-axis numbers-list)))


File: eintr.info,  Node: Test print-graph,  Next: Graphing words in defuns,  Prev: The final version,  Up: Print Whole Graph

C.4.1 测试 ‘print-graph’
------------------------

我们可以使用一个短数字列表来测试 ‘print-graph’ 函数：

  1. 安装 ‘Y-axis-column’、‘graph-body-print’ 和 ‘print-graph’ 的最终版
     本（以及其余的代码）。

  2. 复制以下表达式：

          (print-graph '(3 2 5 6 7 5 3 4 6 4 3 2 1))

  3. 切换到 ‘*scratch*’ 缓冲区，并将光标放在你希望轴标签开始的位置。

  4. 键入 ‘M-:’（‘eval-expression’）。

  5. 使用 ‘C-y’（‘yank’）将测试表达式粘贴到迷你缓冲区中。

  6. 按下 <RET> 键来评估表达式。

   Emacs 将打印一个看起来像这样的图表：

     10 -


              *
             **   *
      5 -   ****  *
            **** ***
          * *********
          ************
      1 - *************

          |   |    |    |
          1   5   10   15

   另一方面，如果你将 ‘print-graph’ 的 ‘vertical-step’ 值设为 2，通过评
估以下表达式：

     (print-graph '(3 2 5 6 7 5 3 4 6 4 3 2 1) 2)

图表看起来像这样：

     20 -


              *
             **   *
     10 -   ****  *
            **** ***
          * *********
          ************
      2 - *************

          |   |    |    |
          1   5   10   15

（一个问题：垂直轴底部的 ‘2’ 是一个错误还是一个特性？如果你认为这是一个
错误，应该是 ‘1’ 而不是 ‘2’（甚至是 ‘0’），你可以修改源代码。）


File: eintr.info,  Node: Graphing words in defuns,  Next: lambda,  Prev: Test print-graph,  Up: Print Whole Graph

C.4.2 绘制单词和符号数量的函数图表
----------------------------------

现在是为了这段代码而编写的图表：显示包含少于 10 个单词和符号的函数定义的
数量，包含 10 到 19 个单词和符号的函数定义的数量，包含 20 到 29 个单词和
符号的函数定义的数量，依此类推。

   这是一个多步骤的过程。首先确保你已经加载了所有必要的代码。

   最好重置 ‘top-of-ranges’ 的值，以防你将其设置为不同的值。你可以评估以
下内容：

     (setq top-of-ranges
      '(10  20  30  40  50
        60  70  80  90 100
       110 120 130 140 150
       160 170 180 190 200
       210 220 230 240 250
       260 270 280 290 300)

接下来创建一个包含每个范围中单词和符号数量的列表。

评估以下内容：

     (setq list-for-graph
            (defuns-per-range
              (sort
               (recursive-lengths-list-many-files
                (directory-files "/usr/local/emacs/lisp"
                                 t ".+el$"))
               '<)
              top-of-ranges))

在我的旧机器上，这大约花费了一个小时。它遍历了我在 Emacs 版本 19.23 中的
303 个 Lisp 文件。在所有这些计算之后，‘list-for-graph’ 的值如下：

     (537 1027 955 785 594 483 349 292 224 199 166 120 116 99
     90 80 67 48 52 45 41 33 28 26 25 20 12 28 11 13 220)

这意味着我的 Emacs 副本中有 537 个包含少于 10 个单词或符号的函数定义，
1,027 个包含 10 到 19 个单词或符号的函数定义，955 个包含 20 到 29 个单词
或符号的函数定义，依此类推。

   显然，仅通过查看这个列表，我们就可以看到大多数函数定义包含十到三十个
单词和符号。

   现在是打印的时候。我们 _不_希望打印一个高达 1,030 行的图表 ... 相反，
我们应该打印一个不到二十五行高的图表。这样高度的图表可以显示在几乎任何显
示器上，并且可以轻松地打印在一张纸上。

   这意味着 ‘list-for-graph’ 中的每个值必须减少到其当前值的五十分之一。

   这里是一个用两个我们还没有看到的函数，‘mapcar’ 和 ‘lambda’，来做到这
一点的简短函数。

     (defun one-fiftieth (full-range)
       "返回一个列表，其中每个数字是先前值的五十分之一。"
      (mapcar (lambda (arg) (/ arg 50)) full-range))


File: eintr.info,  Node: lambda,  Next: mapcar,  Prev: Graphing words in defuns,  Up: Print Whole Graph

C.4.3 A ‘lambda’ 表达式：有用的匿名性
-------------------------------------

‘lambda’ 是匿名函数的符号，即没有名字的函数。每次使用匿名函数时，都需要
包含它的整个体。

因此，

     (lambda (arg) (/ arg 50))

是一个函数，返回将传递给它的‘arg’除以50的结果。

早些时候，例如，我们有一个函数‘multiply-by-seven’；它将其参数乘以7。这个
函数类似，只是它将其参数除以50；而且，它没有名字。‘multiply-by-seven’的
匿名等价物是：

     (lambda (number) (* 7 number))

（*Note ‘defun’ 宏: defun.）

如果我们想将3乘以7，我们可以写：

     (multiply-by-seven 3)
      \_______________/ ^
              |         |
           function  argument


这个表达式返回21。

同样，我们可以写：

     ((lambda (number) (* 7 number)) 3)
      \____________________________/ ^
                    |                |
           anonymous function     argument


如果我们想将100除以50，我们可以写：

     ((lambda (arg) (/ arg 50)) 100)
      \______________________/  \_/
                  |              |
         anonymous function   argument


这个表达式返回2。将100传递给函数，该函数将该数字除以50。

   *Note Lambda 表达式: (elisp)Lambda Expressions, 了解有关‘lambda’的更
多信息。Lisp 和 lambda 表达式源于 Lambda 演算。


File: eintr.info,  Node: mapcar,  Next: Another Bug,  Prev: lambda,  Up: Print Whole Graph

C.4.4 The ‘mapcar’ Function
---------------------------

‘mapcar’是一个函数，它依次调用它的第一个参数，并将第二个参数的每个元素传
递给它的第一个参数。第二个参数必须是一个序列。

   名称中的‘map’部分来自数学短语，“在一个域上进行映射”，意味着对域中的每
个元素应用一个函数。这个数学短语基于一个测量员逐步走过他正在绘制地图的区
域的隐喻。而‘car’当然来自Lisp中列表的第一个元素的概念。

例如，

     (mapcar '1+ '(2 4 6))
          ⇒ (3 5 7)

函数‘1+’，它将其参数加一，被执行在列表的_每个_元素上，并返回一个新的列表
。

   与之相对的是‘apply’，它将其第一个参数应用于其余的所有参数。 （*Note
准备图表: Readying a Graph, 有关‘apply’的解释。）

   在‘one-fiftieth’的定义中，第一个参数是匿名函数：

     (lambda (arg) (/ arg 50))

而第二个参数是‘full-range’，它将绑定到‘list-for-graph’。

   整个表达式看起来像这样：

     (mapcar (lambda (arg) (/ arg 50)) full-range))

   *Note Mapping Functions: (elisp)Mapping Functions, 有关‘mapcar’的更多
信息。

   使用‘one-fiftieth’函数，我们可以生成一个列表，其中每个元素都是
‘list-for-graph’中相应元素的1/50大小。

     (setq fiftieth-list-for-graph
           (one-fiftieth list-for-graph))

   生成的列表如下：

     (10 20 19 15 11 9 6 5 4 3 3 2 2
     1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 4)

这样，我们几乎可以打印出来了！（我们还注意到信息的丢失：许多较高的范围为
0，意味着少于50个defuns有那么多单词或符号，但不一定意味着没有那么多单词
或符号。）


File: eintr.info,  Node: Another Bug,  Next: Final printed graph,  Prev: mapcar,  Up: Print Whole Graph

C.4.5 另一个错误 ... 最阴险的
-----------------------------

我说过“几乎准备好打印”！当然，在‘print-graph’函数中存在一个错误 ... 它有
一个‘vertical-step’选项，但没有‘horizontal-step’选项。‘top-of-range’刻度
从10到300，间隔为十。但‘print-graph’函数只会打印每个单位。

   这是某些人认为最阴险类型的错误的典型例子，即遗漏错误。这不是你可以通
过研究代码找到的错误，因为它不在代码中；它是一个被遗漏的特性。你最好的行
动是尽早而经常地尝试你的程序；并且尽量安排，尽可能写出易于理解和修改的代
码。尽量在任何时候都意识到，无论你写了什么，_都_会被重新编写，如果不是很
快，那就是迟早的事。这是一个难以遵循的格言。

   需要对‘print-X-axis-numbered-line’函数进行修改；然后需要调整
‘print-X-axis’和‘print-graph’函数。不需要做太多事情；有一个小技巧：数字
应该对齐在刻度标记下方。这需要一点思考。

   以下是修正后的‘print-X-axis-numbered-line’：

     (defun print-X-axis-numbered-line
       (number-of-X-tics X-axis-leading-spaces
        &optional horizontal-step)
       "打印X轴数字线"
       (let ((number X-axis-label-spacing)
             (horizontal-step (or horizontal-step 1)))
         (insert X-axis-leading-spaces)
         ;; 删除多余的前导空格。
         (delete-char
          (- (1-
              (length (number-to-string horizontal-step)))))
         (insert (concat
                  (make-string
                   ;; 插入空白。
                   (-  (* symbol-width
                          X-axis-label-spacing)
                       (1-
                        (length
                         (number-to-string horizontal-step)))
                       2)
                   ? )
                  (number-to-string
                   (* number horizontal-step))))
         ;; 插入剩余的数字。
         (setq number (+ number X-axis-label-spacing))
         (while (> number-of-X-tics 1)
           (insert (X-axis-element
                    (* number horizontal-step)))
           (setq number (+ number X-axis-label-spacing))
           (setq number-of-X-tics (1- number-of-X-tics)))))

   如果你在Info中阅读此内容，你可以查看‘print-X-axis’和‘print-graph’的新
版本，并对其进行评估。如果你在印刷的书中阅读此内容，你可以在这里看到更改
的行（完整文本太长，无法打印）。

     (defun print-X-axis (numbers-list horizontal-step)
       "打印X轴标签，长度为NUMBERS-LIST。
     可选参数HORIZONTAL-STEP，一个正整数，
     指定每列的X轴标签增量。"
     ;; 符号宽度和full-Y-label-width的值由print-graph传递。
       (let* ((leading-spaces
               (make-string full-Y-label-width ? ))
            ;; 符号宽度由graph-body-print提供
            (tic-width (* symbol-width X-axis-label-spacing))
            (X-length (length numbers-list))
            (X-tic
             (concat
              (make-string
               ;; 制作一串空格。
               (-  (* symbol-width X-axis-label-spacing)
                   (length X-axis-tic-symbol))
               ? )
              ;; 用空格和刻度符号连接。
              X-axis-tic-symbol))
            (tic-number
             (if (zerop (% X-length tic-width))
                 (/ X-length tic-width)
               (1+ (/ X-length tic-width)))))

         (print-X-axis-tic-line
          tic-number leading-spaces X-tic)
         (insert "\n")
         (print-X-axis-numbered-line
          tic-number leading-spaces horizontal-step)))

     (defun print-graph
       (numbers-list &optional vertical-step horizontal-step)
       "打印带标签的条形图，NUMBERS-LIST的Y轴值构成。

     可选参数VERTICAL-STEP，一个正整数，
     指定每行的Y轴标签增量。例如，步长为5表示每行五个单位。

     可选参数HORIZONTAL-STEP，一个正整数，
     指定每列的X轴标签增量。"
       (let* ((symbol-width (length graph-blank))
              ;; height既是最大的数字，也是具有最多数字的数字。
              (height (apply 'max numbers-list))
              (height-of-top-line
               (if (zerop (% height Y-axis-label-spacing))
                   height
                 ;; 否则
                 (* (1+ (/ height Y-axis-label-spacing))
                    Y-axis-label-spacing)))
              (vertical-step (or vertical-step 1))
              (full-Y-label-width
               (length
                (concat
                 (number-to-string
                  (* height-of-top-line vertical-step))
                 Y-axis-tic))))
         (print-Y-axis
          height-of-top-line full-Y-label-width vertical-step)
         (graph-body-print
             numbers-list height-of-top-line symbol-width)
         (print-X-axis numbers-list horizontal-step)))


File: eintr.info,  Node: Final printed graph,  Prev: Another Bug,  Up: Print Whole Graph

C.4.6 打印图表
--------------

当制作并安装完成后，您可以像这样调用 ‘print-graph’ 命令：

     (print-graph fiftieth-list-for-graph 50 10)

这是图表：


     1000 -  *
             **
             **
             **
             **
      750 -  ***
             ***
             ***
             ***
             ****
      500 - *****
            ******
            ******
            ******
            *******
      250 - ********
            *********                     *
            ***********                   *
            *************                 *
       50 - ***************** *           *
            |   |    |    |    |    |    |    |
           10  50  100  150  200  250  300  350



最大的函数组包含每个函数 10–19 个字和符号。


File: eintr.info,  Node: Free Software and Free Manuals,  Next: GNU Free Documentation License,  Prev: Full Graph,  Up: Top

Appendix D 自由软件和自由手册
*****************************

*作者：理查德·斯托曼*

   自由操作系统中最大的不足之处不在于软件本身，而在于我们无法在这些系统
中包含好的自由手册。许多我们最重要的程序都没有附带完整的手册。文档是任何
软件包的基本组成部分；当一个重要的自由软件包没有附带自由手册时，这是一个
重大的缺陷。我们今天有许多这样的缺口。

   很多年前的一天，我想学习Perl。我找到了一本免费的手册副本，但我发现它
很难阅读。当我询问Perl用户是否有其他选择时，他们告诉我有更好的入门手册
—但那些手册并不是免费的。

   为什么会这样呢？好的手册作者为O’Reilly Associates编写了手册，该出版社
以限制性条款发布它们—禁止复制、禁止修改、源文件不可用—这些条件使它们无法
进入自由软件社区。

   这并不是这种情况发生的第一次，而且（令我们的社区丧失很多）远非最后一
次。自从那时以来，专有手册出版商引诱了许多作者限制他们的手册。许多次我听
到GNU用户热切地告诉我，他正在撰写一本手册，他希望能够帮助GNU项目—然后我
的希望落空，因为他继续解释说他已经签署了一份与出版商的合同，该合同将限制
使用，以至于我们无法使用它。

   鉴于写好英语是程序员中一种罕见的技能，我们不能承受以这种方式失去手册
的代价。

   自由文档，就像自由软件一样，是关乎自由而非价格的问题。这些手册的问题
并不在于O’Reilly Associates对印刷品收费—这本身是可以接受的。自由软件基金
会在官方商店 (https://shop.fsf.org)出售免费GNU手册
(https://www.gnu.org/doc/doc.html)的印刷本。但GNU手册以源代码形式提供，
而这些手册只能以纸质形式获得。GNU手册附带有复制和修改的权限；Perl手册则
没有。这些限制是问题所在。

   对于一个自由手册，标准几乎与自由软件相同：它涉及给予所有用户特定的自
由。必须允许重新分发（包括商业重新分发），以便手册可以随程序的每个副本一
起提供，无论是在线还是纸质的。修改的许可也是至关重要的。

   总的来说，我不认为人们有必要获得修改各种文章和书籍的权限。对于文学作
品，问题不一定与软件相同。例如，我认为你和我没有义务允许修改像这篇文章这
样描述我们行动和观点的文章。

   但是，为自由软件提供文档的关键原因之一是修改的自由至关重要。当人们行
使他们修改软件的权利，添加或更改其功能时，如果他们是尽责的，他们将同时更
改手册—以便他们可以为修改后的程序提供准确可用的文档。一份手册，禁止程序
员尽责并完成工作，或者更确切地说，如果他们更改程序，则要求他们从头开始编
写新手册，这将无法满足我们社区的需求。

   虽然对修改的全面禁令是不可接受的，但对修改方式的某些限制并不构成问题
。例如，要求保留原作者的版权声明、分发条款或作者列表是可以接受的。还要求
修改版本包含修改通知，甚至包含整个部分不得删除或更改，只要这些部分涉及非
技术主题，也没有问题（一些GNU手册有这些限制）。

   这些种类的限制不是问题，因为从实际角度来看，它们并不阻止认真的程序员
调整手册以适应修改后的程序。换句话说，它们并不阻止自由软件社区充分利用手
册。

   然而，必须有可能修改手册的所有技术内容，然后通过所有通常的媒体、通过
所有通常的渠道分发结果；否则，这些限制将阻碍社区，手册就不是自由的，因此
我们需要另一份手册。

   不幸的是，当存在专有手册时，很难找到愿意写另一份手册的人。阻碍在于许
多用户认为专有手册已经足够好—因此他们认为没有必要写一份自由手册。他们没
有意识到自由操作系统存在需要填补的空白。

   为什么用户认为专有手册已经足够好呢？有些人还没有考虑这个问题。我希望
这篇文章能够改变这种看法。

   其他用户认为专有手册是可以接受的，原因与许多人认为专有软件是可以接受
的原因相同：他们纯粹以实际的角度进行判断，而不使用自由作为标准。这些人有
权发表他们的观点，但由于这些观点源于不包括自由的价值观，对于那些重视自由
的人来说，它们并不是指导。

   请传播关于这个问题的信息。我们继续失去手册，因为它们受到专有出版的限
制。如果我们传播这样的信息，即专有手册是不够的，也许下一个想通过撰写文档
来帮助GNU的人在为时已晚之前会意识到，他首先必须使其自由。

   我们还可以鼓励商业出版商销售自由的、遵循版权的手册，而不是专有的手册
。你可以帮助实现这一点的一种方式是在购买手册之前检查其分发条款，并更喜欢
遵循版权的手册而不是非遵循版权的手册。



注：自由软件基金会在其网站上维护了一个页面，列出了其他出版商提供的免费图
书：
<https://www.gnu.org/doc/other-free-books.html>


File: eintr.info,  Node: GNU Free Documentation License,  Next: Index,  Prev: Free Software and Free Manuals,  Up: Top

Appendix E GNU Free Documentation License
*****************************************

                     Version 1.3, 3 November 2008

     Copyright © 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
     <https://fsf.org/>

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     functional and useful document “free” in the sense of freedom: to
     assure everyone the effective freedom to copy and redistribute it,
     with or without modifying it, either commercially or
     noncommercially.  Secondarily, this License preserves for the
     author and publisher a way to get credit for their work, while not
     being considered responsible for modifications made by others.

     This License is a kind of “copyleft”, which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.  We
     recommend this License principally for works whose purpose is
     instruction or reference.

  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work, in any medium,
     that contains a notice placed by the copyright holder saying it can
     be distributed under the terms of this License.  Such a notice
     grants a world-wide, royalty-free license, unlimited in duration,
     to use that work under the conditions stated herein.  The
     “Document”, below, refers to any such manual or work.  Any member
     of the public is a licensee, and is addressed as “you”.  You accept
     the license if you copy, modify or distribute the work in a way
     requiring permission under copyright law.

     A “Modified Version” of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A “Secondary Section” is a named appendix or a front-matter section
     of the Document that deals exclusively with the relationship of the
     publishers or authors of the Document to the Document’s overall
     subject (or to related matters) and contains nothing that could
     fall directly within that overall subject.  (Thus, if the Document
     is in part a textbook of mathematics, a Secondary Section may not
     explain any mathematics.)  The relationship could be a matter of
     historical connection with the subject or with related matters, or
     of legal, commercial, philosophical, ethical or political position
     regarding them.

     The “Invariant Sections” are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in the
     notice that says that the Document is released under this License.
     If a section does not fit the above definition of Secondary then it
     is not allowed to be designated as Invariant.  The Document may
     contain zero Invariant Sections.  If the Document does not identify
     any Invariant Sections then there are none.

     The “Cover Texts” are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.  A
     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
     be at most 25 words.

     A “Transparent” copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, that is suitable for revising the document
     straightforwardly with generic text editors or (for images composed
     of pixels) generic paint programs or (for drawings) some widely
     available drawing editor, and that is suitable for input to text
     formatters or for automatic translation to a variety of formats
     suitable for input to text formatters.  A copy made in an otherwise
     Transparent file format whose markup, or absence of markup, has
     been arranged to thwart or discourage subsequent modification by
     readers is not Transparent.  An image format is not Transparent if
     used for any substantial amount of text.  A copy that is not
     “Transparent” is called “Opaque”.

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and standard-conforming
     simple HTML, PostScript or PDF designed for human modification.
     Examples of transparent image formats include PNG, XCF and JPG.
     Opaque formats include proprietary formats that can be read and
     edited only by proprietary word processors, SGML or XML for which
     the DTD and/or processing tools are not generally available, and
     the machine-generated HTML, PostScript or PDF produced by some word
     processors for output purposes only.

     The “Title Page” means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, “Title
     Page” means the text near the most prominent appearance of the
     work’s title, preceding the beginning of the body of the text.

     The “publisher” means any person or entity that distributes copies
     of the Document to the public.

     A section “Entitled XYZ” means a named subunit of the Document
     whose title either is precisely XYZ or contains XYZ in parentheses
     following text that translates XYZ in another language.  (Here XYZ
     stands for a specific section name mentioned below, such as
     “Acknowledgements”, “Dedications”, “Endorsements”, or “History”.)
     To “Preserve the Title” of such a section when you modify the
     Document means that it remains a section “Entitled XYZ” according
     to this definition.

     The Document may include Warranty Disclaimers next to the notice
     which states that this License applies to the Document.  These
     Warranty Disclaimers are considered to be included by reference in
     this License, but only as regards disclaiming warranties: any other
     implication that these Warranty Disclaimers may have is void and
     has no effect on the meaning of this License.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow the
     conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies (or copies in media that commonly
     have printed covers) of the Document, numbering more than 100, and
     the Document’s license notice requires Cover Texts, you must
     enclose the copies in covers that carry, clearly and legibly, all
     these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the title
     equally prominent and visible.  You may add other material on the
     covers in addition.  Copying with changes limited to the covers, as
     long as they preserve the title of the Document and satisfy these
     conditions, can be treated as verbatim copying in other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a machine-readable
     Transparent copy along with each Opaque copy, or state in or with
     each Opaque copy a computer-network location from which the general
     network-using public has access to download using public-standard
     network protocols a complete Transparent copy of the Document, free
     of added material.  If you use the latter option, you must take
     reasonably prudent steps, when you begin distribution of Opaque
     copies in quantity, to ensure that this Transparent copy will
     remain thus accessible at the stated location until at least one
     year after the last time you distribute an Opaque copy (directly or
     through your agents or retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of copies,
     to give them a chance to provide you with an updated version of the
     Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with the
     Modified Version filling the role of the Document, thus licensing
     distribution and modification of the Modified Version to whoever
     possesses a copy of it.  In addition, you must do these things in
     the Modified Version:

       A. Use in the Title Page (and on the covers, if any) a title
          distinct from that of the Document, and from those of previous
          versions (which should, if there were any, be listed in the
          History section of the Document).  You may use the same title
          as a previous version if the original publisher of that
          version gives permission.

       B. List on the Title Page, as authors, one or more persons or
          entities responsible for authorship of the modifications in
          the Modified Version, together with at least five of the
          principal authors of the Document (all of its principal
          authors, if it has fewer than five), unless they release you
          from this requirement.

       C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.

       D. Preserve all the copyright notices of the Document.

       E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.

       F. Include, immediately after the copyright notices, a license
          notice giving the public permission to use the Modified
          Version under the terms of this License, in the form shown in
          the Addendum below.

       G. Preserve in that license notice the full lists of Invariant
          Sections and required Cover Texts given in the Document’s
          license notice.

       H. Include an unaltered copy of this License.

       I. Preserve the section Entitled “History”, Preserve its Title,
          and add to it an item stating at least the title, year, new
          authors, and publisher of the Modified Version as given on the
          Title Page.  If there is no section Entitled “History” in the
          Document, create one stating the title, year, authors, and
          publisher of the Document as given on its Title Page, then add
          an item describing the Modified Version as stated in the
          previous sentence.

       J. Preserve the network location, if any, given in the Document
          for public access to a Transparent copy of the Document, and
          likewise the network locations given in the Document for
          previous versions it was based on.  These may be placed in the
          “History” section.  You may omit a network location for a work
          that was published at least four years before the Document
          itself, or if the original publisher of the version it refers
          to gives permission.

       K. For any section Entitled “Acknowledgements” or “Dedications”,
          Preserve the Title of the section, and preserve in the section
          all the substance and tone of each of the contributor
          acknowledgements and/or dedications given therein.

       L. Preserve all the Invariant Sections of the Document, unaltered
          in their text and in their titles.  Section numbers or the
          equivalent are not considered part of the section titles.

       M. Delete any section Entitled “Endorsements”.  Such a section
          may not be included in the Modified Version.

       N. Do not retitle any existing section to be Entitled
          “Endorsements” or to conflict in title with any Invariant
          Section.

       O. Preserve any Warranty Disclaimers.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option designate
     some or all of these sections as invariant.  To do this, add their
     titles to the list of Invariant Sections in the Modified Version’s
     license notice.  These titles must be distinct from any other
     section titles.

     You may add a section Entitled “Endorsements”, provided it contains
     nothing but endorsements of your Modified Version by various
     parties—for example, statements of peer review or that the text has
     been approved by an organization as the authoritative definition of
     a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end of
     the list of Cover Texts in the Modified Version.  Only one passage
     of Front-Cover Text and one of Back-Cover Text may be added by (or
     through arrangements made by) any one entity.  If the Document
     already includes a cover text for the same cover, previously added
     by you or by arrangement made by the same entity you are acting on
     behalf of, you may not add another; but you may replace the old
     one, on explicit permission from the previous publisher that added
     the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination all
     of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice, and that you preserve all
     their Warranty Disclaimers.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections Entitled
     “History” in the various original documents, forming one section
     Entitled “History”; likewise combine any sections Entitled
     “Acknowledgements”, and any sections Entitled “Dedications”.  You
     must delete all sections Entitled “Endorsements.”

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the documents
     in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow this
     License in all other respects regarding verbatim copying of that
     document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of a
     storage or distribution medium, is called an “aggregate” if the
     copyright resulting from the compilation is not used to limit the
     legal rights of the compilation’s users beyond what the individual
     works permit.  When the Document is included in an aggregate, this
     License does not apply to the other works in the aggregate which
     are not themselves derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one half
     of the entire aggregate, the Document’s Cover Texts may be placed
     on covers that bracket the Document within the aggregate, or the
     electronic equivalent of covers if the Document is in electronic
     form.  Otherwise they must appear on printed covers that bracket
     the whole aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License, and all the license notices in the
     Document, and any Warranty Disclaimers, provided that you also
     include the original English version of this License and the
     original versions of those notices and disclaimers.  In case of a
     disagreement between the translation and the original version of
     this License or a notice or disclaimer, the original version will
     prevail.

     If a section in the Document is Entitled “Acknowledgements”,
     “Dedications”, or “History”, the requirement (section 4) to
     Preserve its Title (section 1) will typically require changing the
     actual title.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense, or distribute it is void,
     and will automatically terminate your rights under this License.

     However, if you cease all violation of this License, then your
     license from a particular copyright holder is reinstated (a)
     provisionally, unless and until the copyright holder explicitly and
     finally terminates your license, and (b) permanently, if the
     copyright holder fails to notify you of the violation by some
     reasonable means prior to 60 days after the cessation.

     Moreover, your license from a particular copyright holder is
     reinstated permanently if the copyright holder notifies you of the
     violation by some reasonable means, this is the first time you have
     received notice of violation of this License (for any work) from
     that copyright holder, and you cure the violation prior to 30 days
     after your receipt of the notice.

     Termination of your rights under this section does not terminate
     the licenses of parties who have received copies or rights from you
     under this License.  If your rights have been terminated and not
     permanently reinstated, receipt of a copy of some or all of the
     same material does not give you any rights to use it.

  10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     <https://www.gnu.org/licenses/>.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License “or any later version” applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If the
     Document does not specify a version number of this License, you may
     choose any version ever published (not as a draft) by the Free
     Software Foundation.  If the Document specifies that a proxy can
     decide which future versions of this License can be used, that
     proxy’s public statement of acceptance of a version permanently
     authorizes you to choose that version for the Document.

  11. RELICENSING

     “Massive Multiauthor Collaboration Site” (or “MMC Site”) means any
     World Wide Web server that publishes copyrightable works and also
     provides prominent facilities for anybody to edit those works.  A
     public wiki that anybody can edit is an example of such a server.
     A “Massive Multiauthor Collaboration” (or “MMC”) contained in the
     site means any set of copyrightable works thus published on the MMC
     site.

     “CC-BY-SA” means the Creative Commons Attribution-Share Alike 3.0
     license published by Creative Commons Corporation, a not-for-profit
     corporation with a principal place of business in San Francisco,
     California, as well as future copyleft versions of that license
     published by that same organization.

     “Incorporate” means to publish or republish a Document, in whole or
     in part, as part of another Document.

     An MMC is “eligible for relicensing” if it is licensed under this
     License, and if all works that were first published under this
     License somewhere other than this MMC, and subsequently
     incorporated in whole or in part into the MMC, (1) had no cover
     texts or invariant sections, and (2) were thus incorporated prior
     to November 1, 2008.

     The operator of an MMC Site may republish an MMC contained in the
     site under CC-BY-SA on the same site at any time before August 1,
     2009, provided the MMC is eligible for relicensing.

ADDENDUM: How to use this License for your documents
====================================================

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

       Copyright (C)  YEAR  YOUR NAME.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.3
       or any later version published by the Free Software Foundation;
       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
       Texts.  A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.

   If you have Invariant Sections, Front-Cover Texts and Back-Cover
Texts, replace the “with...Texts.” line with this:

         with the Invariant Sections being LIST THEIR TITLES, with
         the Front-Cover Texts being LIST, and with the Back-Cover Texts
         being LIST.

   If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

   If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of free
software license, such as the GNU General Public License, to permit
their use in free software.


File: eintr.info,  Node: Index,  Next: About the Author,  Prev: GNU Free Documentation License,  Up: Top

Index
*****

 [index ]
* Menu:

* % (余数函数):                          Compute a Remainder. (line   6)
* ' for quoting:                         Run a Program.       (line  11)
* * (乘法):                              defun.               (line  73)
* * 用于只读缓冲区:                      Read-only buffer.    (line   6)
* *scratch* 缓冲区:                      print-elements-of-list.
                                                              (line   8)
* .emacs 文件:                           Emacs Initialization.
                                                              (line   6)
* .emacs 文件，开始:                     Beginning init File. (line   6)
* / (division):                          Large buffer case.   (line  33)
* <= (小于或等于):                       Inc Example parts.   (line  34)
* > (greater than):                      if in more detail.   (line  25)
* add-hook:                              Text and Auto-fill.  (line  44)
* and:                                   kill-new function.   (line 184)
* apostrophe for quoting:                Run a Program.       (line  11)
* append-to-buffer:                      append-to-buffer.    (line   6)
* apply:                                 Columns of a graph.  (line 110)
* apropos:                               Columns of a graph.  (line  25)
* argument list defined:                 defun.               (line  47)
* argument 的定义:                       Arguments.           (line  14)
* beginning-of-buffer:                   beginning-of-buffer. (line   6)
* bind定义:                              set & setq.          (line   6)
* buffer-file-name:                      Buffer Names.        (line   6)
* buffer-menu，绑定到按键:               Key Bindings.        (line  57)
* buffer-name:                           Buffer Names.        (line   6)
* Byte compiling:                        Byte Compiling.      (line   6)
* call 定义:                             Switching Buffers.   (line  41)
* cancel-debug-on-entry:                 debug-on-entry.      (line  84)
* car, introduced:                       car cdr & cons.      (line   6)
* cdr, introduced:                       car cdr & cons.      (line   6)
* Common Lisp:                           Lisp History.        (line   9)
* compare-windows:                       Key Bindings.        (line  11)
* concat:                                Data types.          (line  10)
* cond:                                  Recursion with cond. (line   6)
* condition-case:                        condition-case.      (line   6)
* cons cell:                             Lists diagrammed.    (line  87)
* cons, introduced:                      cons.                (line   6)
* copy-region-as-kill:                   copy-region-as-kill. (line   6)
* copy-to-buffer:                        copy-to-buffer.      (line   6)
* count-words-example:                   count-words-example. (line   6)
* count-words-in-defun:                  count-words-in-defun.
                                                              (line  75)
* curly quotes:                          Complete zap-to-char.
                                                              (line  35)
* current-buffer:                        Getting Buffers.     (line   6)
* current-kill:                          current-kill.        (line   6)
* curved quotes:                         Complete zap-to-char.
                                                              (line  35)
* C语言原语:                             Primitive Functions. (line   6)
* C，进入C的插曲:                        Digression into C.   (line   6)
* debug:                                 debug.               (line   6)
* debug-on-entry:                        debug-on-entry.      (line   6)
* debug-on-quit:                         debug-on-quit.       (line   9)
* default.el 初始化文件:                 Site-wide Init.      (line   6)
* defconst:                              defcustom.           (line 100)
* defcustom:                             defcustom.           (line   6)
* defsubst:                              defcustom.           (line 100)
* defun:                                 defun.               (line   6)
* defun 中的单词和符号:                  Words and Symbols.   (line   6)
* defvar:                                defvar.              (line   6)
* defvar 带有星号:                       defvar and asterisk. (line   6)
* defvar 用于用户可定制的变量:           defvar and asterisk. (line   6)
* delete-and-extract-region:             Digression into C.   (line   6)
* describe-function:                     simplified-beginning-of-buffer.
                                                              (line  65)
* describe-function, introduced:         Finding More.        (line   6)
* directory-files:                       Files List.          (line  11)
* Division:                              Large buffer case.   (line  33)
* dolist:                                dolist.              (line   6)
* dotimes:                               dotimes.             (line   6)
* edebug:                                edebug.              (line   6)
* Else:                                  else.                (line   6)
* Emacs Lisp 中的假值和真值:             Truth & Falsehood.   (line   6)
* Emacs Lisp 中的真值和假值:             Truth & Falsehood.   (line   6)
* Emacs版本，选择:                       Simple Extension.    (line  32)
* empty list defined:                    Lisp Atoms.          (line  14)
* empty string定义:                      Review.              (line 114)
* eobp:                                  fwd-para while.      (line  56)
* eq:                                    Review.              (line 104)
* eq （用法示例）:                       last-command & this-command.
                                                              (line  30)
* equal:                                 Review.              (line 104)
* error:                                 Body of current-kill.
                                                              (line  33)
* Error message generation:              Making Errors.       (line   6)
* evaluate defined:                      Run a Program.       (line   6)
* Evaluating inner lists:                Evaluating Inner Lists.
                                                              (line   6)
* Evaluation:                            Evaluation.          (line   6)
* FDL, GNU Free Documentation License:   GNU Free Documentation License.
                                                              (line   6)
* files-in-below-directory:              Files List.          (line  20)
* fill-column，一个示例变量:             fill-column Example. (line   6)
* filter-buffer-substring:               last-command & this-command.
                                                              (line  25)
* Formatting help:                       Typing Lists.        (line   6)
* forward-paragraph:                     forward-paragraph.   (line   6)
* forward-sentence:                      forward-sentence.    (line   6)
* Generate an error message:             Making Errors.       (line   6)
* global-set-key:                        Key Bindings.        (line  17)
* global-unset-key:                      Key Bindings.        (line  48)
* graph-body-print:                      graph-body-print.    (line   6)
* graph-body-print 最终版本。:           The final version.   (line  49)
* Help typing lists:                     Typing Lists.        (line   6)
* if:                                    if.                  (line   6)
* if-part定义:                           if in more detail.   (line   6)
* indent-tabs-mode:                      Indent Tabs Mode.    (line   6)
* Inner list evaluation:                 Evaluating Inner Lists.
                                                              (line   6)
* insert-buffer:                         insert-buffer.       (line   6)
* insert-buffer 的新版本主体:            New insert-buffer.   (line   6)
* insert-buffer, 新版本主体:             New insert-buffer.   (line   6)
* insert-buffer-substring:               append-to-buffer overview.
                                                              (line   6)
* interactive:                           Interactive.         (line   6)
* interactive 的选项:                    Interactive Options. (line   6)
* interactive, 用法示例:                 insert-buffer interactive.
                                                              (line   6)
* Interpreter, Lisp, explained:          Run a Program.       (line  30)
* Interpreter, what it does:             Lisp Interpreter.    (line   6)
* Kill ring 处理:                        Kill Ring.           (line   6)
* kill-append:                           kill-append function.
                                                              (line   6)
* kill-new:                              kill-new function.   (line   6)
* kill-region:                           kill-region.         (line   6)
* lambda:                                lambda.              (line   6)
* length:                                length.              (line   6)
* lengths-list-file:                     lengths-list-file.   (line   9)
* lengths-list-many-files:               lengths-list-many-files.
                                                              (line  25)
* let:                                   let.                 (line   6)
* let 变量未初始化:                      Uninitialized let Variables.
                                                              (line   6)
* let 表达式的组成:                      Parts of let Expression.
                                                              (line   6)
* let 表达式示例:                        Sample let Expression.
                                                              (line   6)
* let 表达式，组成部分:                  Parts of let Expression.
                                                              (line   6)
* let*:                                  append save-excursion.
                                                              (line  44)
* let* <1>:                              fwd-para let.        (line   6)
* Library, 作为“文件”一词的用法:         Finding More.        (line  30)
* line-to-top-of-window:                 Simple Extension.    (line   6)
* Lisp Atoms:                            Lisp Atoms.          (line   6)
* Lisp history:                          Lisp History.        (line   6)
* Lisp interpreter, explained:           Run a Program.       (line  30)
* Lisp interpreter, what it does:        Lisp Interpreter.    (line   6)
* Lisp Lists:                            Lisp Lists.          (line   6)
* Lisp macro:                            Lisp macro.          (line   6)
* Lisp 代码中的注释:                     Change a defun.      (line  19)
* list-buffers，重新绑定:                Key Bindings.        (line  57)
* load-library:                          Loading Files.       (line  43)
* load-path:                             Loading Files.       (line  30)
* looking-at:                            fwd-para while.      (line  72)
* Maclisp:                               Lisp History.        (line   9)
* Macro, lisp:                           Lisp macro.          (line   6)
* make-string:                           Y Axis Element.      (line  61)
* mapcar:                                mapcar.              (line   6)
* mark:                                  save-excursion.      (line   6)
* mark-whole-buffer:                     mark-whole-buffer.   (line   6)
* match-beginning:                       fwd-para while.      (line 130)
* max:                                   Columns of a graph.  (line  99)
* message:                               message.             (line   6)
* min:                                   Columns of a graph.  (line  99)
* mode-line-format:                      Mode Line.           (line   6)
* narrowing定义:                         Buffer Size & Locations.
                                                              (line  35)
* nil:                                   Truth & Falsehood.   (line   6)
* nil，单词的历史:                       Buffer Names.        (line  33)
* nreverse:                              Counting function definitions.
                                                              (line  81)
* nth:                                   nth.                 (line   6)
* nthcdr:                                nthcdr.              (line   6)
* nthcdr <1>:                            copy-region-as-kill. (line   6)
* nthcdr, example:                       kill-new function.   (line 133)
* number-to-string:                      Y Axis Element.      (line  10)
* occur:                                 Key Bindings.        (line  44)
* optional:                              Optional Arguments.  (line   9)
* or:                                    Insert or.           (line  11)
* other-buffer:                          Getting Buffers.     (line   6)
* point:                                 save-excursion.      (line   6)
* Point and buffer preservation:         save-excursion.      (line   6)
* point定义:                             Buffer Size & Locations.
                                                              (line  16)
* predicate 的定义:                      Wrong Type of Argument.
                                                              (line  43)
* Preserving point and buffer:           save-excursion.      (line   6)
* print-elements-of-list:                print-elements-of-list.
                                                              (line   6)
* print-elements-recursively:            Recursion with list. (line  17)
* print-graph 变量列表:                  print-graph Varlist. (line   6)
* print-graph 最终版本。:                The final version.   (line  71)
* print-X-axis:                          X Axis Tic Marks.    (line 133)
* print-X-axis-numbered-line:            X Axis Tic Marks.    (line 106)
* print-X-axis-tic-line:                 X Axis Tic Marks.    (line  74)
* print-Y-axis:                          print-Y-axis Penultimate.
                                                              (line   9)
* progn:                                 progn.               (line   6)
* Program, running one:                  Run a Program.       (line   6)
* push, example:                         kill-new function.   (line 106)
* quote:                                 Run a Program.       (line  11)
* quoting using apostrophe:              Run a Program.       (line  11)
* re-search-forward:                     re-search-forward.   (line   6)
* recursive-count-words:                 recursive-count-words.
                                                              (line 213)
* recursive-graph-body-print:            recursive-graph-body-print.
                                                              (line   6)
* recursive-lengths-list-many-files:     Several files recursively.
                                                              (line  13)
* regexp-quote:                          fwd-para let.        (line  53)
* Region, what it is:                    save-excursion.      (line   6)
* returned value explained:              How the Interpreter Acts.
                                                              (line   6)
* reverse:                               Counting function definitions.
                                                              (line  94)
* ring.el file:                          ring file.           (line   6)
* Ring，生成类似列表的:                  Kill Ring.           (line   6)
* Run a program:                         Run a Program.       (line   6)
* save-excursion:                        save-excursion.      (line   6)
* save-restriction:                      save-restriction.    (line   6)
* search-forward:                        search-forward.      (line   6)
* sentence-end:                          sentence-end.        (line   6)
* set:                                   Using set.           (line   6)
* set-buffer:                            Switching Buffers.   (line   6)
* set-variable:                          defvar and asterisk. (line  18)
* setcar:                                setcar.              (line   6)
* setcdr:                                setcdr.              (line   6)
* setcdr, example:                       kill-new function.   (line 136)
* setq:                                  Using setq.          (line   6)
* side effect defined:                   How the Interpreter Acts.
                                                              (line  11)
* simplified-beginning-of-buffer:        simplified-beginning-of-buffer.
                                                              (line   6)
* site-init.el 初始化文件:               Site-wide Init.      (line   6)
* site-load.el 初始化文件:               Site-wide Init.      (line   6)
* sort:                                  Sorting.             (line   6)
* Special form:                          Complications.       (line  10)
* string defined:                        Lisp Atoms.          (line  46)
* substring:                             Data types.          (line  18)
* switch-to-buffer:                      Switching Buffers.   (line   6)
* Symbol names:                          Names & Definitions. (line   6)
* Symbolic expressions, introduced:      Lisp Atoms.          (line  19)
* Text between double quotation marks:   Lisp Atoms.          (line  42)
* the-the:                               the-the.             (line   6)
* then-part定义:                         if in more detail.   (line   6)
* top-of-ranges:                         Counting function definitions.
                                                              (line  16)
* triangle-bugged:                       debug.               (line  13)
* triangle-recursively:                  Recursive triangle function.
                                                              (line   6)
* Variables:                             Variables.           (line   6)
* varlist 的定义:                        Parts of let Expression.
                                                              (line   6)
* what-line:                             what-line.           (line   6)
* while:                                 while.               (line   6)
* Whitespace in lists:                   Whitespace in Lists. (line   6)
* X-axis-element:                        X Axis Tic Marks.    (line  96)
* X轴打印:                               print-X-axis.        (line   6)
* Y 轴打印:                              print-Y-axis.        (line   6)
* Y-axis-column:                         Y-axis-column.       (line   8)
* Y-axis-column 最终版本。:              The final version.   (line  13)
* Y-axis-label-spacing:                  Compute a Remainder. (line  66)
* Y-axis-tic:                            Y Axis Element.      (line  26)
* yank:                                  yank.                (line   6)
* yank-pop:                              yank-pop.            (line   6)
* zap-to-char:                           zap-to-char.         (line   6)
* zerop:                                 Body of current-kill.
                                                              (line  33)
* 交互函数定义:                          How to Evaluate.     (line   9)
* 交互式函数:                            Interactive.         (line   6)
* 交互选项:                              Interactive Options. (line   6)
* 代码安装:                              Permanent Installation.
                                                              (line   6)
* 余数函数，%:                           Compute a Remainder. (line   6)
* 使用 if 的条件语句:                    if.                  (line   6)
* 保留，一种递归模式:                    Keep.                (line   6)
* 修改函数定义:                          Change a defun.      (line   6)
* 全局变量 定义:                         Determining the Element.
                                                              (line  79)
* 全局按键设置:                          Key Bindings.        (line  17)
* 全局设置按键:                          Key Bindings.        (line  17)
* 关键字:                                Optional Arguments.  (line   9)
* 准备图表:                              Readying a Graph.    (line   6)
* 函数 defined:                          Making Errors.       (line  43)
* 函数 defined <1>:                      Making Errors.       (line  62)
* 函数体 已定义:                         defun.               (line  29)
* 函数定义 已定义:                       defun.               (line   6)
* 函数定义安装:                          Install.             (line   6)
* 函数定义编写:                          Writing Defuns.      (line   6)
* 函数定义，如何修改:                    Change a defun.      (line   6)
* 函数，原始:                            Primitive Functions. (line   6)
* 切换到缓冲区:                          Switching Buffers.   (line   6)
* 初始化变量:                            defvar.              (line   6)
* 初始化文件:                            Emacs Initialization.
                                                              (line   6)
* 删除文本:                              Cutting & Storing Text.
                                                              (line   6)
* 删除文本 <1>:                          Cutting & Storing Text.
                                                              (line   6)
* 剪切与存储文本:                        Cutting & Storing Text.
                                                              (line   6)
* 剪切文本:                              Cutting & Storing Text.
                                                              (line   6)
* 剪切环概述:                            Kill Ring Overview.  (line   6)
* 匿名函数:                              lambda.              (line   6)
* 单词, 重复:                            the-the.             (line   6)
* 单词，递归计数:                        recursive-count-words.
                                                              (line   6)
* 原型图表:                              Readying a Graph.    (line   6)
* 原始函数:                              Primitive Functions. (line   6)
* 参数:                                  Arguments.           (line   6)
* 参数作为局部变量:                      Dec Example altogether.
                                                              (line  26)
* 参数的数据类型:                        Data types.          (line   6)
* 参数，可变数量的:                      Variable Number of Arguments.
                                                              (line   6)
* 参数，错误类型的:                      Wrong Type of Argument.
                                                              (line   6)
* 变量, 全局，定义:                      Determining the Element.
                                                              (line  79)
* 变量, 局部, 定义:                      Prevent confusion.   (line   6)
* 变量初始化:                            defvar.              (line   6)
* 变量，示例，fill-column:               fill-column Example. (line   6)
* 变量，设置值:                          set & setq.          (line   6)
* 只读缓冲区:                            Read-only buffer.    (line   6)
* 可变数量的参数:                        Variable Number of Arguments.
                                                              (line   6)
* 可选参数:                              Optional Arguments.  (line   9)
* 命令定义:                              How to Evaluate.     (line   9)
* 图表主体:                              Readying a Graph.    (line   6)
* 图表原型:                              Readying a Graph.    (line   6)
* 图表，全部打印:                        Print Whole Graph.   (line   6)
* 在 .emacs 文件中的简单扩展:            Simple Extension.    (line   6)
* 在 defun 中的单词计数:                 Words in a defun.    (line   6)
* 在 defun 中计算单词数:                 Words in a defun.    (line   6)
* 在 defun 中计算单词数 <1>:             count-words-in-defun.
                                                              (line   6)
* 在两个版本的Emacs之间选择:             Simple Extension.    (line  32)
* 在代码中使用(debug):                   debug-on-quit.       (line  12)
* 在模式行示例中的属性:                  Mode Line.           (line  61)
* 坐标轴，水平打印:                      print-X-axis.        (line   6)
* 垂直轴打印:                            print-Y-axis.        (line   6)
* 垂直轴打印 <1>:                        print-Y-axis.        (line   6)
* 处理 kill ring:                        Kill Ring.           (line   6)
* 存储与剪切文本:                        Cutting & Storing Text.
                                                              (line   6)
* 安装函数定义:                          Install.             (line   6)
* 定义安装:                              Install.             (line   6)
* 定义编写:                              Writing Defuns.      (line   6)
* 定义，如何修改:                        Change a defun.      (line   6)
* 定制你的 .emacs 文件:                  Emacs Initialization.
                                                              (line   6)
* 将信息传递给函数:                      Arguments.           (line   6)
* 局部变量 定义:                         Prevent confusion.   (line   6)
* 属性提及 buffer-substring-no-properties: narrow Exercise.   (line  10)
* 形式 defined:                          Lisp Atoms.          (line  19)
* 循环:                                  while.               (line   6)
* 循环和递归:                            Loops & Recursion.   (line   6)
* 打印垂直轴:                            print-Y-axis.        (line   6)
* 打印整个图表:                          Print Whole Graph.   (line   6)
* 打印水平轴:                            print-X-axis.        (line   6)
* 打开文本模式:                          Text and Auto-fill.  (line  32)
* 打开自动填充模式:                      Text and Auto-fill.  (line  44)
* 扩大:                                  Narrowing & Widening.
                                                              (line   6)
* 扩展，示例:                            what-line.           (line   6)
* 抽屉式储物柜，作为符号的隐喻:          Symbols as Chest.    (line   6)
* 抽屉，抽屉式储物柜，作为符号的隐喻:    Symbols as Chest.    (line   6)
* 按键全局设置:                          Key Bindings.        (line  17)
* 按键解绑定:                            Key Bindings.        (line  48)
* 插入:                                  Yanking.             (line   6)
* 搜索，演示:                            Regexp Search.       (line   6)
* 擦除文本:                              Cutting & Storing Text.
                                                              (line   6)
* 数据的类型:                            Data types.          (line   6)
* 数据类型:                              Data types.          (line   6)
* 整个图表打印:                          Print Whole Graph.   (line   6)
* 文本检索:                              Yanking.             (line   6)
* 无推迟的解决方案:                      No deferment solution.
                                                              (line   6)
* 无推迟的递归:                          No Deferment.        (line   6)
* 无推迟解决方案:                        No deferment solution.
                                                              (line   6)
* 未初始化的 let 变量:                   Uninitialized let Variables.
                                                              (line   6)
* 本地变量列表，缓冲区特定的:            Text and Auto-fill.  (line  18)
* 机器人，构建:                          Building Robots.     (line   6)
* 构建机器人:                            Building Robots.     (line   6)
* 查找函数文档:                          Finding More.        (line   6)
* 查找函数源码:                          Finding More.        (line  11)
* 查找文件:                              Find a File.         (line   6)
* 格式化约定:                            append save-excursion.
                                                              (line  13)
* 检索文本:                              Yanking.             (line   6)
* 模式行格式:                            Mode Line.           (line   6)
* 模式选择，自动:                        Text and Auto-fill.  (line  18)
* 模式，搜索:                            Regexp Search.       (line   6)
* 正则表达式搜索:                        Regexp Search.       (line   6)
* 每个元素，递归模式类型:                Every.               (line   6)
* 水平轴打印:                            print-X-axis.        (line   6)
* 永久安装代码:                          Permanent Installation.
                                                              (line   6)
* 永久性代码安装:                        Permanent Installation.
                                                              (line   6)
* 没有值的符号错误:                      Void Variable.       (line   6)
* 没有值的符号错误消息:                  Void Variable.       (line   6)
* 没有函数的符号错误:                    Void Function.       (line   6)
* 没有函数的符号错误消息:                Void Function.       (line   6)
* 源码级调试器:                          edebug.              (line   6)
* 点对:                                  Lists diagrammed.    (line  87)
* 点的位置:                              Buffer Size & Locations.
                                                              (line   6)
* 点的位置 <1>:                          Buffer Size & Locations.
                                                              (line   6)
* 焦点集中（缩窄）:                      Narrowing & Widening.
                                                              (line   6)
* 用C编写的原语:                         Primitive Functions. (line   6)
* 用于只读缓冲区的星号:                  Read-only buffer.    (line   6)
* 田野中的花朵:                          Lisp Lists.          (line  15)
* 示例 let 表达式:                       Sample let Expression.
                                                              (line   6)
* 示例变量，fill-column:                 fill-column Example. (line   6)
* 符号作为抽屉式储物柜:                  Symbols as Chest.    (line   6)
* 粘贴文本:                              Yanking.             (line   6)
* 累积，一种递归模式:                    Accumulate.          (line   6)
* 练习评估:                              Practicing Evaluation.
                                                              (line   6)
* 绑定，键，修复不愉快的:                Miscellaneous.       (line  84)
* 缓冲区大小:                            Buffer Size & Locations.
                                                              (line   6)
* 缓冲区大小 <1>:                        Buffer Size & Locations.
                                                              (line   6)
* 缓冲区特定的本地变量列表:              Text and Auto-fill.  (line  18)
* 缓冲区，单词的历史:                    Buffer Names.        (line  52)
* 编写函数定义:                          Writing Defuns.      (line   6)
* 缩窄:                                  Narrowing & Widening.
                                                              (line   6)
* 缩进用于格式化:                        append save-excursion.
                                                              (line  13)
* 自动加载:                              Autoload.            (line   6)
* 自动模式选择:                          Text and Auto-fill.  (line  18)
* 获取缓冲区:                            Getting Buffers.     (line   6)
* 表达式 defined:                        Lisp Atoms.          (line  19)
* 解除按键绑定:                          Key Bindings.        (line  48)
* 计数:                                  Counting.            (line   6)
* 计算机中的列表:                        List Implementation. (line   6)
* 设置变量的值:                          set & setq.          (line   6)
* 评估练习:                              Practicing Evaluation.
                                                              (line   6)
* 语法类别和表:                          Syntax.              (line   6)
* 调试:                                  Debugging.           (line   6)
* 载入文件:                              Loading Files.       (line   6)
* 进入C的插曲:                           Digression into C.   (line   6)
* 选择Emacs版本:                         Simple Extension.    (line  32)
* 递归:                                  Recursion.           (line   6)
* 递归中的推迟:                          No Deferment.        (line   6)
* 递归单词计数:                          recursive-count-words.
                                                              (line   6)
* 递归和循环:                            Loops & Recursion.   (line   6)
* 递归定义的组成部分:                    Recursive Definition Parts.
                                                              (line   6)
* 递归定义的部分:                        Recursive Definition Parts.
                                                              (line   6)
* 递归模式:                              Recursive Patterns.  (line   6)
* 递归模式 - 保留:                       Keep.                (line   6)
* 递归模式 - 每个元素:                   Every.               (line   6)
* 递归模式 - 累积:                       Accumulate.          (line   6)
* 递归计算单词数:                        recursive-count-words.
                                                              (line   6)
* 通过句子和段落进行移动:                Regexp Search.       (line   6)
* 通过句子进行移动:                      Regexp Search.       (line   6)
* 通过正则表达式统计单词:                Counting Words.      (line   6)
* 通过段落进行移动:                      Regexp Search.       (line   6)
* 通过重复统计单词:                      Counting Words.      (line   6)
* 邮件别名:                              Mail Aliases.        (line  14)
* 重复单词函数:                          the-the.             (line   6)
* 重复（循环）:                          Loops & Recursion.   (line   6)
* 重新绑定键位:                          Keymaps.             (line   6)
* 错误类型的参数:                        Wrong Type of Argument.
                                                              (line   6)
* 错误，最阴险的类型:                    Another Bug.         (line   6)
* 键位映射:                              Keymaps.             (line   6)
* 键绑定，修复:                          Miscellaneous.       (line  84)
* 防止制表符:                            Indent Tabs Mode.    (line   6)
* 阴险类型的错误:                        Another Bug.         (line   6)


File: eintr.info,  Node: About the Author,  Prev: Index,  Up: Top

作者简介
********

     罗伯特·J·查瑟尔（1946–2017）于1985年开始使用GNU Emacs。他撰写和编辑
     了Emacs和Emacs Lisp的教材，并在世界各地演讲，倡导软件自由。查瑟尔是
     自由软件基金会（Free Software Foundation, Inc.）的创始董事兼财务主
     管。他是《Texinfo》手册的合著者，还编辑了十多本其他书籍。他毕业于英
     格兰剑桥大学，对社会和经济历史有浓厚兴趣，同时还是一名私人飞行爱好
     者。

     "向鲍勃·查瑟尔告别"
     (https://www.fsf.org/blogs/community/goodbye-to-bob-chassell)



Tag Table:
Node: Top1383
Node: Preface20620
Node: Why21785
Node: On Reading this Text22330
Node: Who You Are24225
Node: Lisp History26690
Node: Note for Novices27430
Node: Thank You29649
Node: List Processing30196
Ref: List Processing-Footnote-131470
Node: Lisp Lists31614
Node: Numbers Lists32398
Node: Lisp Atoms33489
Node: Whitespace in Lists36834
Node: Typing Lists37985
Node: Run a Program38914
Ref: Run a Program-Footnote-141163
Node: Making Errors41301
Node: Names & Definitions46146
Node: Lisp Interpreter47801
Node: Complications48872
Node: Byte Compiling50802
Node: Evaluation51797
Node: How the Interpreter Acts52343
Node: Evaluating Inner Lists53303
Node: Variables55605
Node: fill-column Example56966
Node: Void Function58450
Node: Void Variable59614
Node: Arguments61307
Ref: Arguments-Footnote-162635
Node: Data types63353
Node: Args as Variable or List65291
Node: Variable Number of Arguments66702
Node: Wrong Type of Argument67495
Ref: Wrong Type of Argument-Footnote-170669
Node: message70730
Ref: message-Footnote-174425
Node: set & setq74601
Node: Using set75257
Node: Using setq77392
Node: Counting79392
Node: Summary81192
Node: Error Message Exercises82838
Node: Practicing Evaluation83289
Node: How to Evaluate84342
Node: Buffer Names85652
Node: Getting Buffers90944
Ref: Getting Buffers-Footnote-193327
Node: Switching Buffers93548
Ref: Switching Buffers-Footnote-196714
Ref: Switching Buffers-Footnote-296980
Node: Buffer Size & Locations97649
Node: Evaluation Exercise99483
Node: Writing Defuns99754
Node: Primitive Functions100987
Node: defun102049
Node: Install107619
Node: Effect of installation108855
Node: Change a defun109627
Node: Interactive111205
Node: Interactive multiply-by-seven112158
Node: multiply-by-seven in detail113880
Node: Interactive Options116334
Node: Permanent Installation119242
Node: let121175
Node: Prevent confusion122370
Node: Parts of let Expression124261
Node: Sample let Expression125721
Ref: Sample let Expression-Footnote-1127383
Node: Uninitialized let Variables127633
Node: if129170
Node: if in more detail129950
Node: type-of-animal in detail132397
Node: else134649
Node: Truth & Falsehood137350
Node: nil explained138331
Node: save-excursion140233
Node: Point and mark140874
Node: Template for save-excursion143564
Node: Review144743
Node: defun Exercises151450
Node: Buffer Walk Through151828
Node: Finding More152916
Ref: Finding More-Footnote-1155473
Node: simplified-beginning-of-buffer155659
Node: mark-whole-buffer159528
Node: mark-whole-buffer overview160268
Node: Body of mark-whole-buffer161444
Node: append-to-buffer164195
Node: append-to-buffer overview164796
Node: append interactive167282
Node: append-to-buffer body169566
Node: append save-excursion171389
Ref: let* introduced173068
Node: Buffer Related Review176518
Node: Buffer Exercises178460
Node: More Complex178918
Node: copy-to-buffer179748
Node: insert-buffer182319
Node: insert-buffer code183583
Node: insert-buffer interactive184555
Node: Read-only buffer185050
Node: b for interactive185536
Node: insert-buffer body186470
Node: if & or187564
Node: Insert or190518
Node: Insert let192731
Node: New insert-buffer196182
Node: beginning-of-buffer197311
Node: Optional Arguments198614
Node: beginning-of-buffer opt arg201656
Node: Disentangle beginning-of-buffer202506
Node: Large buffer case203601
Node: Small buffer case205844
Node: beginning-of-buffer complete207317
Node: Second Buffer Related Review209625
Node: optional Exercise211130
Node: Narrowing & Widening211575
Node: Narrowing advantages212139
Node: save-restriction213810
Node: what-line215650
Node: narrow Exercise219268
Node: car cdr & cons220169
Node: Strange Names221155
Node: car & cdr221807
Node: cons226005
Node: Build a list226915
Ref: Build a list-Footnote-1228307
Node: length228482
Node: nthcdr229901
Node: nth232606
Node: setcar233892
Node: setcdr236549
Node: cons Exercise237958
Node: Cutting & Storing Text238336
Node: Storing Text239526
Node: zap-to-char241299
Node: Complete zap-to-char241883
Node: zap-to-char interactive244250
Node: zap-to-char body245647
Node: search-forward247105
Node: progn249736
Node: Summing up zap-to-char251236
Node: kill-region252260
Node: Complete kill-region253159
Node: condition-case257102
Node: Lisp macro259498
Node: copy-region-as-kill261644
Node: Complete copy-region-as-kill262547
Node: copy-region-as-kill body264904
Node: last-command & this-command265797
Node: kill-append function267833
Node: kill-new function271538
Node: Digression into C281271
Node: defvar285864
Node: See variable current value287277
Node: defvar and asterisk288889
Node: cons & search-fwd Review290492
Node: search Exercises293240
Node: List Implementation293908
Node: Lists diagrammed294852
Node: Symbols as Chest300486
Node: List Exercise302287
Node: Yanking302644
Node: Kill Ring Overview303864
Node: kill-ring-yank-pointer305422
Node: yank nthcdr Exercises307305
Node: Loops & Recursion307982
Ref: Loops & Recursion-Footnote-1308991
Node: while309440
Node: Looping with while310704
Node: Loop Example312210
Node: print-elements-of-list315255
Node: Incrementing Loop317576
Node: Incrementing Loop Details318106
Node: Incrementing Example319349
Node: Inc Example parts321525
Node: Inc Example altogether324629
Node: Decrementing Loop327762
Node: Decrementing Example329020
Node: Dec Example parts330311
Node: Dec Example altogether332019
Node: dolist dotimes334010
Node: dolist334737
Node: dotimes337705
Node: Recursion339053
Node: Building Robots340075
Node: Recursive Definition Parts341652
Node: Recursion with list343743
Node: Recursive triangle function346942
Node: Recursive Example arg of 1 or 2348126
Node: Recursive Example arg of 3 or 4350098
Node: Recursion with cond352779
Node: Recursive Patterns354920
Node: Every355297
Node: Accumulate357682
Node: Keep358834
Node: No Deferment360667
Node: No deferment solution363126
Ref: No deferment solution-Footnote-1366734
Ref: No deferment solution-Footnote-2366812
Node: Looping exercise367261
Node: Regexp Search368370
Node: sentence-end370025
Node: re-search-forward373350
Node: forward-sentence375548
Node: Complete forward-sentence376209
Node: fwd-sentence while loops379491
Node: fwd-sentence re-search382748
Node: forward-paragraph384512
Node: forward-paragraph in brief386023
Node: fwd-para let387381
Node: fwd-para while391945
Node: Regexp Review398910
Node: re-search Exercises401081
Node: Counting Words401798
Node: Why Count Words402386
Node: count-words-example403289
Node: Design count-words-example404449
Node: Whitespace Bug410371
Node: recursive-count-words419238
Node: Counting Exercise429936
Node: Words in a defun430287
Node: Divide and Conquer431820
Node: Words and Symbols432895
Node: Syntax434786
Node: count-words-in-defun437865
Node: Several defuns443483
Node: Find a File445593
Node: lengths-list-file447980
Node: Several files452934
Node: lengths-list-many-files453636
Node: append456135
Node: Several files recursively456731
Node: Prepare the data459381
Node: Data for Display in Detail460329
Node: Sorting461148
Node: Files List462713
Ref: Files List-Footnote-1469913
Node: Counting function definitions470128
Node: Readying a Graph478624
Node: Columns of a graph479741
Node: graph-body-print491971
Node: recursive-graph-body-print496293
Node: Printed Axes498767
Node: Line Graph Exercise499498
Node: Emacs Initialization499663
Node: Default Configuration501086
Ref: Default Configuration-Footnote-1503037
Node: Site-wide Init503312
Node: defcustom505355
Node: Beginning init File510711
Node: Text and Auto-fill512995
Node: Mail Aliases516645
Node: Indent Tabs Mode517554
Node: Key Bindings518436
Node: Keymaps521939
Node: Loading Files524150
Node: Autoload527346
Node: Simple Extension529929
Ref: Simple Extension-Footnote-1532349
Node: X11 Colors532601
Ref: X11 Colors-Footnote-1534382
Node: Miscellaneous534530
Node: Mode Line538620
Node: Debugging543901
Node: debug544668
Node: debug-on-entry547633
Node: debug-on-quit551174
Node: edebug552196
Node: Debugging Exercises555961
Node: Conclusion557591
Node: the-the562534
Node: Kill Ring563956
Node: What the Kill Ring Does564611
Node: current-kill566055
Node: Code for current-kill566662
Node: Understanding current-kill569367
Node: Body of current-kill570101
Node: Digression concerning error572994
Node: Determining the Element574045
Node: yank577523
Node: yank-pop580477
Node: ring file582915
Node: Full Graph583270
Node: Labeled Example584023
Node: print-graph Varlist585876
Node: print-Y-axis587312
Node: print-Y-axis in Detail588030
Node: Height of label588756
Node: Compute a Remainder590394
Node: Y Axis Element593821
Node: Y-axis-column597196
Node: print-Y-axis Penultimate598659
Node: print-X-axis600449
Node: Similarities differences601533
Node: X Axis Tic Marks602289
Node: Print Whole Graph608849
Node: The final version609837
Node: Test print-graph613837
Node: Graphing words in defuns615491
Node: lambda618079
Node: mapcar619638
Node: Another Bug621558
Node: Final printed graph626777
Node: Free Software and Free Manuals627677
Node: GNU Free Documentation License633328
Node: Index658697
Node: About the Author695092

End Tag Table


Local Variables:
coding: utf-8
End:
