\input texinfo                       @c -*- mode: texinfo; coding: utf-8 -*-
@comment %**start of header
@setfilename ../../info/eintr.info
@settitle Programming in Emacs Lisp
@include docstyle.texi
@syncodeindex vr cp
@syncodeindex fn cp
@finalout

@include emacsver.texi

@c ================ How to Print a Book in Various Sizes ================

@c This book can be printed in any of three different sizes.
@c Set the following @-commands appropriately.

@c     7 by 9.25 inches:
@c              @smallbook
@c              @clear largebook

@c     8.5 by 11 inches:
@c              @c smallbook
@c              @set largebook

@c     European A4 size paper:
@c              @c smallbook
@c              @afourpaper
@c              @set largebook

@c (Note: if you edit the book so as to change the length of the
@c table of contents, you may have to change the value of 'pageno' below.)

@c <<<< For hard copy printing, this file is now
@c      set for smallbook, which works for all sizes
@c      of paper, and with PostScript figures >>>>

@set smallbook
@ifset smallbook
@smallbook
@clear  largebook
@end ifset

@c ================ Included Figures ================

@c If you clear this, the figures will be printed as ASCII diagrams
@c rather than PostScript/PDF.
@c (This is not relevant to Info, since Info only handles ASCII.)
@set print-postscript-figures
@c clear print-postscript-figures

@comment %**end of header

@c per rms and peterb, use 10pt fonts for the main text, mostly to
@c save on paper cost.
@c Do this inside @tex for now, so current makeinfo does not complain.
@tex
@ifset smallbook
@fonttextsize 10

@end ifset
\global\hbadness=6666 % don't worry about not-too-underfull boxes
@end tex

@c For next or subsequent edition:
@c   create function using with-output-to-temp-buffer
@c   create a major mode, with keymaps
@c   run an asynchronous process, like grep or diff

@c For 8.5 by 11 inch format: do not use such a small amount of
@c whitespace between paragraphs as smallbook format
@ifset largebook
@tex
\global\parskip 6pt plus 1pt
@end tex
@end ifset

@c For all sized formats:  print within-book cross
@c reference with ``...''  rather than [...]

@c This works with the texinfo.tex file, version 2003-05-04.08,
@c in the Texinfo version 4.6 of the 2003 Jun 13 distribution.

@tex
\if \xrefprintnodename
 \global\def\xrefprintnodename#1{\unskip, ``#1''}
 \else
 \global\def\xrefprintnodename#1{ ``#1''}
\fi
% \global\def\xrefprintnodename#1{, ``#1''}
@end tex

@c ----------------------------------------------------

@dircategory Emacs lisp
@direntry
* Emacs Lisp Intro: (eintr).    A simple introduction to Emacs Lisp programming.
@end direntry

@c When printing, define edition-number to be the printed edition
@c number, titlepage-edition-number to be the spelled out edition
@c number suitable for the title page, and update-date to be the date,
@c in the preferred style for these.  E.g., run the shell command:
@c   texi2any -D 'edition-number 3.11' \
@c            -D 'titlepage-edition-number Revised Third Edition' \
@c            -D 'update-date 31 March 2020'
@c This relates mainly to the published book sold by the FSF.

@copying
这是针对非程序员的 @cite{Emacs Lisp 编程简介}
@sp 1
@ifset edition-number
版本 @value{edition-number}, @value{update-date}
@end ifset
@sp 1
随 Emacs 版本 @value{EMACSVER} 发行.
@sp 1
Copyright @copyright{} 1990--1995, 1997, 2001--2023 自由软件基金会.
@sp 1

@iftex
由以下机构出版:@*

GNU Press,               @hfill @uref{https://www.fsf.org/licensing/gnu-press/}@*
自由软件基金会旗下的一个分部               @hfill email: @email{sales@@fsf.org}@*
Free Software Foundation, Inc.  @hfill 电话: +1 (617) 542-5942@*
51 Franklin Street, Fifth Floor @hfill 传真: +1 (617) 542-2652@*
美国马萨诸塞州波士顿，邮编02110-1301
@end iftex

@ifnottex
纸质版本可在 @uref{https://shop.fsf.org/} 获得。由以下机构出版：

@example
GNU Press,                        https://www.fsf.org/licensing/gnu-press/
自由软件基金会旗下的一个分部                 电子邮件：sales@@fsf.org
Free Software Foundation, Inc.    电话：+1 (617) 542-5942
51 Franklin Street, Fifth Floor   传真：+1 (617) 542-2652
美国马萨诸塞州波士顿，邮编02110-1301
@end example
@end ifnottex

@sp 1
ISBN 1-882114-43-4

@quotation
允许复制、分发和/或修改本文档，遵循 GNU 自由文档许可证 1.3 版或由自由软件基金会发布的任何以后版本的条款；本文档没有不变章节，封面文本为“GNU 手册”，反面封面文本如 (a) 所示。许可证的副本包含在名为“GNU 自由文档许可证”的章节中。

(a) FSF 的背面封面文本是：“你有自由复制和修改这份 GNU 手册。从 FSF 购买副本支持其开发 GNU 并推广软件自由。”
@end quotation
@end copying

@c half title; two lines here, so do not use 'shorttitlepage'
@tex
{\begingroup%
    \hbox{}\vskip 1.5in \chaprm \centerline{An Introduction to}%
        \endgroup}%
{\begingroup\hbox{}\vskip 0.25in \chaprm%
        \centerline{Programming in Emacs Lisp}%
        \endgroup\page\hbox{}\page}
@end tex

@titlepage
@sp 6
@center @titlefont{An Introduction to}
@sp 2
@center @titlefont{Programming in Emacs Lisp}
@sp 2
@ifset titlepage-edition-number
@center @value{titlepage-edition-number}
@end ifset
@sp 4
@center by Robert J. Chassell

@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@iftex
@headings off
@evenheading @thispage @| @| @thischapter
@oddheading @thissection @| @| @thispage
@end iftex

@ifnothtml
@c     Keep T.O.C. short by tightening up for largebook
@ifset largebook
@tex
\global\parskip 2pt plus 1pt
\global\advance\baselineskip by -1pt
@end tex
@end ifset
@end ifnothtml

@c If you think this manual is too large for an introduction, please
@c consider this email exchange:
@c
@c       >> The intro is almost 300 pages in full.  I had expected 60 pages.
@c       >
@c       > This is an important point in its own right.  Could you
@c       > write a simplified introduction that is only 50 pages or so?
@c       > That would be helpful to many potential users, I'd think.
@c
@c   > The problem with the introduction is that it was written when
@c   > programming was only starting to be a skill "normal" people could
@c   > have access to.  So the text is extremely verbose and is
@c   > sometimes hard to follow because of that.  The gist of the
@c   > document could be summarized in 50 pages.
@c
@c This book is intentionally addressed to people who don't know how to
@c program.  That is its purpose.  We recommend people start learning to
@c program using this book.
@c
@c If you DO know how to program in some other language, you can probably
@c learn Emacs Lisp starting with the Emacs Lisp Reference Manual.
@c
@c        Richard Stallman <rms@gnu.org>,
@c        https://lists.gnu.org/r/emacs-devel/2018-05/msg00374.html

@shortcontents
@contents

@ifnottex
@node Top
@top Emacs Lisp 编程简介

@ifset WWW_GNU_ORG
@html
<p>GNU Emacs的网站位于
<a href="/software/emacs/">https://www.gnu.org/software/emacs/</a>.<br>
要查看其他格式的本手册，请点击
<a href="/software/emacs/manual/eintr.html">这里</a>.
@end html
@end ifset

@insertcopying

此主菜单首先列出每个章节和索引；然后列出每个章节中的每个节点。
@end ifnottex

@c Uncomment the 3 lines below, starting with @iftex, if you want the
@c pages of Preface to be numbered in roman numerals.  Use -9 instead
@c of -11 for smallbook format.

@c >>>> Set pageno appropriately <<<<

@c The first page of the Preface is a roman numeral; it is the first
@c right handed page after the Table of Contents; hence the following
@c setting must be for an odd negative number.

@c iftex
@c global@pageno = -11
@c end iftex

@set COUNT-WORDS count-words-example
@c Length of variable name chosen so that things still line up when expanded.

@menu
* Preface::                     What to look for.
* List Processing::             What is Lisp?
* Practicing Evaluation::       Running several programs.
* Writing Defuns::              How to write function definitions.
* Buffer Walk Through::         Exploring a few buffer-related functions.
* More Complex::                A few, even more complex functions.
* Narrowing & Widening::        Restricting your and Emacs attention to
                                    a region.
* car cdr & cons::              Fundamental functions in Lisp.
* Cutting & Storing Text::      Removing text and saving it.
* List Implementation::         How lists are implemented in the computer.
* Yanking::                     Pasting stored text.
* Loops & Recursion::           How to repeat a process.
* Regexp Search::               Regular expression searches.
* Counting Words::              A review of repetition and regexps.
* Words in a defun::            Counting words in a @code{defun}.
* Readying a Graph::            A prototype graph printing function.
* Emacs Initialization::        How to write a @file{.emacs} file.
* Debugging::                   How to run the Emacs Lisp debuggers.
* Conclusion::                  Now you have the basics.
* the-the::                     An appendix: how to find reduplicated words.
* Kill Ring::                   An appendix: how the kill ring works.
* Full Graph::                  How to create a graph with labeled axes.
* Free Software and Free Manuals::
* GNU Free Documentation License::
* Index::
* About the Author::

@detailmenu
 --- The Detailed Node Listing ---

Preface

* Why::                         Why learn Emacs Lisp?
* On Reading this Text::        Read, gain familiarity, pick up habits....
* Who You Are::                 For whom this is written.
* Lisp History::
* Note for Novices::            You can read this as a novice.
* Thank You::

List Processing

* Lisp Lists::                  What are lists?
* Run a Program::               Any list in Lisp is a program ready to run.
* Making Errors::               Generating an error message.
* Names & Definitions::         Names of symbols and function definitions.
* Lisp Interpreter::            What the Lisp interpreter does.
* Evaluation::                  Running a program.
* Variables::                   Returning a value from a variable.
* Arguments::                   Passing information to a function.
* set & setq::                  Setting the value of a variable.
* Summary::                     The major points.
* Error Message Exercises::

Lisp Lists

* Numbers Lists::               List have numbers, other lists, in them.
* Lisp Atoms::                  Elemental entities.
* Whitespace in Lists::         Formatting lists to be readable.
* Typing Lists::                How GNU Emacs helps you type lists.

The Lisp Interpreter

* Complications::               Variables, Special forms, Lists within.
* Byte Compiling::              Specially processing code for speed.

Evaluation

* How the Interpreter Acts::    Returns and Side Effects...
* Evaluating Inner Lists::      Lists within lists...

Variables

* fill-column Example::
* Void Function::               The error message for a symbol
                                  without a function.
* Void Variable::               The error message for a symbol without a value.

Arguments

* Data types::                  Types of data passed to a function.
* Args as Variable or List::    An argument can be the value
                                  of a variable or list.
* Variable Number of Arguments::  Some functions may take a
                                  variable number of arguments.
* Wrong Type of Argument::      Passing an argument of the wrong type
                                  to a function.
* message::                     A useful function for sending messages.

Setting the Value of a Variable

* Using set::                  Setting values.
* Using setq::                 Setting a quoted value.
* Counting::                   Using @code{setq} to count.

Practicing Evaluation

* How to Evaluate::            Typing editing commands or @kbd{C-x C-e}
                                 causes evaluation.
* Buffer Names::               Buffers and files are different.
* Getting Buffers::            Getting a buffer itself, not merely its name.
* Switching Buffers::          How to change to another buffer.
* Buffer Size & Locations::    Where point is located and the size of
                               the buffer.
* Evaluation Exercise::

How To Write Function Definitions

* Primitive Functions::
* defun::                        The @code{defun} macro.
* Install::                      Install a function definition.
* Interactive::                  Making a function interactive.
* Interactive Options::          Different options for @code{interactive}.
* Permanent Installation::       Installing code permanently.
* let::                          Creating and initializing local variables.
* if::                           What if?
* else::                         If--then--else expressions.
* Truth & Falsehood::            What Lisp considers false and true.
* save-excursion::               Keeping track of point and buffer.
* Review::
* defun Exercises::

Install a Function Definition

* Effect of installation::
* Change a defun::              How to change a function definition.

Make a Function Interactive

* Interactive multiply-by-seven::  An overview.
* multiply-by-seven in detail::    The interactive version.

@code{let}

* Prevent confusion::
* Parts of let Expression::
* Sample let Expression::
* Uninitialized let Variables::

The @code{if} Special Form

* if in more detail::
* type-of-animal in detail::    An example of an @code{if} expression.

Truth and Falsehood in Emacs Lisp

* nil explained::               @code{nil} has two meanings.

@code{save-excursion}

* Point and mark::              A review of various locations.
* Template for save-excursion::

A Few Buffer-Related Functions

* Finding More::                How to find more information.
* simplified-beginning-of-buffer::  Shows @code{goto-char},
                                @code{point-min}, and @code{push-mark}.
* mark-whole-buffer::           Almost the same as @code{beginning-of-buffer}.
* append-to-buffer::            Uses @code{save-excursion} and
                                @code{insert-buffer-substring}.
* Buffer Related Review::       Review.
* Buffer Exercises::

The Definition of @code{mark-whole-buffer}

* mark-whole-buffer overview::
* Body of mark-whole-buffer::   Only three lines of code.

The Definition of @code{append-to-buffer}

* append-to-buffer overview::
* append interactive::          A two part interactive expression.
* append-to-buffer body::       Incorporates a @code{let} expression.
* append save-excursion::       How the @code{save-excursion} works.

A Few More Complex Functions

* copy-to-buffer::              With @code{set-buffer}, @code{get-buffer-create}.
* insert-buffer::               Read-only, and with @code{or}.
* beginning-of-buffer::         Shows @code{goto-char},
                                @code{point-min}, and @code{push-mark}.
* Second Buffer Related Review::
* optional Exercise::

The Definition of @code{insert-buffer}

* insert-buffer code::
* insert-buffer interactive::   When you can read, but not write.
* insert-buffer body::          The body has an @code{or} and a @code{let}.
* if & or::                     Using an @code{if} instead of an @code{or}.
* Insert or::                   How the @code{or} expression works.
* Insert let::                  Two @code{save-excursion} expressions.
* New insert-buffer::

The Interactive Expression in @code{insert-buffer}

* Read-only buffer::            When a buffer cannot be modified.
* b for interactive::           An existing buffer or else its name.

Complete Definition of @code{beginning-of-buffer}

* Optional Arguments::
* beginning-of-buffer opt arg::  Example with optional argument.
* beginning-of-buffer complete::

@code{beginning-of-buffer} with an Argument

* Disentangle beginning-of-buffer::
* Large buffer case::
* Small buffer case::

Narrowing and Widening

* Narrowing advantages::        The advantages of narrowing
* save-restriction::            The @code{save-restriction} special form.
* what-line::                   The number of the line that point is on.
* narrow Exercise::

@code{car}, @code{cdr}, @code{cons}: Fundamental Functions

* Strange Names::               A historical aside: why the strange names?
* car & cdr::                   Functions for extracting part of a list.
* cons::                        Constructing a list.
* nthcdr::                      Calling @code{cdr} repeatedly.
* nth::
* setcar::                      Changing the first element of a list.
* setcdr::                      Changing the rest of a list.
* cons Exercise::

@code{cons}

* Build a list::
* length::                      How to find the length of a list.

Cutting and Storing Text

* Storing Text::                Text is stored in a list.
* zap-to-char::                 Cutting out text up to a character.
* kill-region::                 Cutting text out of a region.
* copy-region-as-kill::         A definition for copying text.
* Digression into C::           Minor note on C programming language macros.
* defvar::                      How to give a variable an initial value.
* cons & search-fwd Review::
* search Exercises::

@code{zap-to-char}

* Complete zap-to-char::        The complete implementation.
* zap-to-char interactive::     A three part interactive expression.
* zap-to-char body::            A short overview.
* search-forward::              How to search for a string.
* progn::                       The @code{progn} special form.
* Summing up zap-to-char::      Using @code{point} and @code{search-forward}.

@code{kill-region}

* Complete kill-region::        The function definition.
* condition-case::              Dealing with a problem.
* Lisp macro::

@code{copy-region-as-kill}

* Complete copy-region-as-kill::  The complete function definition.
* copy-region-as-kill body::      The body of @code{copy-region-as-kill}.

The Body of @code{copy-region-as-kill}

* last-command & this-command::
* kill-append function::
* kill-new function::

Initializing a Variable with @code{defvar}

* See variable current value::
* defvar and asterisk::

How Lists are Implemented

* Lists diagrammed::
* Symbols as Chest::            Exploring a powerful metaphor.
* List Exercise::

Yanking Text Back

* Kill Ring Overview::
* kill-ring-yank-pointer::      The kill ring is a list.
* yank nthcdr Exercises::       The @code{kill-ring-yank-pointer} variable.

Loops and Recursion

* while::                       Causing a stretch of code to repeat.
* dolist dotimes::
* Recursion::                   Causing a function to call itself.
* Looping exercise::

@code{while}

* Looping with while::          Repeat so long as test returns true.
* Loop Example::                A @code{while} loop that uses a list.
* print-elements-of-list::      Uses @code{while}, @code{car}, @code{cdr}.
* Incrementing Loop::           A loop with an incrementing counter.
* Incrementing Loop Details::
* Decrementing Loop::           A loop with a decrementing counter.

Details of an Incrementing Loop

* Incrementing Example::        Counting pebbles in a triangle.
* Inc Example parts::           The parts of the function definition.
* Inc Example altogether::      Putting the function definition together.

Loop with a Decrementing Counter

* Decrementing Example::        More pebbles on the beach.
* Dec Example parts::           The parts of the function definition.
* Dec Example altogether::      Putting the function definition together.

Save your time: @code{dolist} and @code{dotimes}

* dolist::
* dotimes::

Recursion

* Building Robots::             Same model, different serial number ...
* Recursive Definition Parts::  Walk until you stop ...
* Recursion with list::         Using a list as the test whether to recurse.
* Recursive triangle function::
* Recursion with cond::
* Recursive Patterns::          Often used templates.
* No Deferment::                Don't store up work ...
* No deferment solution::

Recursion in Place of a Counter

* Recursive Example arg of 1 or 2::
* Recursive Example arg of 3 or 4::

Recursive Patterns

* Every::
* Accumulate::
* Keep::

Regular Expression Searches

* sentence-end::                The regular expression for @code{sentence-end}.
* re-search-forward::           Very similar to @code{search-forward}.
* forward-sentence::            A straightforward example of regexp search.
* forward-paragraph::           A somewhat complex example.
* Regexp Review::
* re-search Exercises::

@code{forward-sentence}

* Complete forward-sentence::
* fwd-sentence while loops::    Two @code{while} loops.
* fwd-sentence re-search::      A regular expression search.

@code{forward-paragraph}: a Goldmine of Functions

* forward-paragraph in brief::  Key parts of the function definition.
* fwd-para let::                The @code{let*} expression.
* fwd-para while::              The forward motion @code{while} loop.

Counting: Repetition and Regexps

* Why Count Words::
* @value{COUNT-WORDS}::         Use a regexp, but find a problem.
* recursive-count-words::       Start with case of no words in region.
* Counting Exercise::

The @code{@value{COUNT-WORDS}} Function

* Design @value{COUNT-WORDS}::  The definition using a @code{while} loop.
* Whitespace Bug::              The Whitespace Bug in @code{@value{COUNT-WORDS}}.

Counting Words in a @code{defun}

* Divide and Conquer::
* Words and Symbols::           What to count?
* Syntax::                      What constitutes a word or symbol?
* count-words-in-defun::        Very like @code{@value{COUNT-WORDS}}.
* Several defuns::              Counting several defuns in a file.
* Find a File::                 Do you want to look at a file?
* lengths-list-file::           A list of the lengths of many definitions.
* Several files::               Counting in definitions in different files.
* Several files recursively::   Recursively counting in different files.
* Prepare the data::            Prepare the data for display in a graph.

Count Words in @code{defuns} in Different Files

* lengths-list-many-files::     Return a list of the lengths of defuns.
* append::                      Attach one list to another.

Prepare the Data for Display in a Graph

* Data for Display in Detail::
* Sorting::                     Sorting lists.
* Files List::                  Making a list of files.
* Counting function definitions::

Readying a Graph

* Columns of a graph::
* graph-body-print::            How to print the body of a graph.
* recursive-graph-body-print::
* Printed Axes::
* Line Graph Exercise::

Your @file{.emacs} File

* Default Configuration::
* Site-wide Init::              You can write site-wide init files.
* defcustom::                   Emacs will write code for you.
* Beginning init File::         How to write a @file{.emacs} init file.
* Text and Auto-fill::          Automatically wrap lines.
* Mail Aliases::                Use abbreviations for email addresses.
* Indent Tabs Mode::            Don't use tabs with @TeX{}
* Key Bindings::                Create some personal key bindings.
* Keymaps::                     More about key binding.
* Loading Files::               Load (i.e., evaluate) files automatically.
* Autoload::                    Make functions available.
* Simple Extension::            Define a function; bind it to a key.
* X11 Colors::                  Colors in X.
* Miscellaneous::
* Mode Line::                   How to customize your mode line.

Debugging

* debug::                       How to use the built-in debugger.
* debug-on-entry::              Start debugging when you call a function.
* debug-on-quit::               Start debugging when you quit with @kbd{C-g}.
* edebug::                      How to use Edebug, a source level debugger.
* Debugging Exercises::

Handling the Kill Ring

* What the Kill Ring Does::
* current-kill::
* yank::                        Paste a copy of a clipped element.
* yank-pop::                    Insert element pointed to.
* ring file::

The @code{current-kill} Function

* Code for current-kill::
* Understanding current-kill::

@code{current-kill} in Outline

* Body of current-kill::
* Digression concerning error::  How to mislead humans, but not computers.
* Determining the Element::

A Graph with Labeled Axes

* Labeled Example::
* print-graph Varlist::         @code{let} expression in @code{print-graph}.
* print-Y-axis::                Print a label for the vertical axis.
* print-X-axis::                Print a horizontal label.
* Print Whole Graph::           The function to print a complete graph.

The @code{print-Y-axis} Function

* print-Y-axis in Detail::
* Height of label::             What height for the Y axis?
* Compute a Remainder::         How to compute the remainder of a division.
* Y Axis Element::              Construct a line for the Y axis.
* Y-axis-column::               Generate a list of Y axis labels.
* print-Y-axis Penultimate::    A not quite final version.

The @code{print-X-axis} Function

* Similarities differences::    Much like @code{print-Y-axis}, but not exactly.
* X Axis Tic Marks::            Create tic marks for the horizontal axis.

Printing the Whole Graph

* The final version::           A few changes.
* Test print-graph::            Run a short test.
* Graphing words in defuns::    Executing the final code.
* lambda::                      How to write an anonymous function.
* mapcar::                      Apply a function to elements of a list.
* Another Bug::                 Yet another bug @dots{} most insidious.
* Final printed graph::         The graph itself!

@end detailmenu
@end menu

@node Preface
@unnumbered 前言

GNU Emacs集成环境的大部分都是用一种叫做Emacs Lisp的编程语言编写的。用这种编程语言编写的代码是软件，是一组指令，告诉计算机在你给它命令时应该做什么。Emacs被设计成可以用Emacs Lisp编写新代码，并轻松地将其安装为编辑器的扩展。

(GNU Emacs有时被称为“可扩展编辑器”，但它的功能远不止提供编辑功能。更恰当的称呼是将Emacs视为“可扩展计算环境”。然而，这个短语有点拗口。简单地将Emacs称为编辑器更容易理解。此外，在Emacs中的一切活动，如查找玛雅日期和月相、简化多项式、调试代码、管理文件、阅读邮件、撰写书籍，都可以看作是一种最一般意义上的编辑。)

@menu
* Why::                         Why learn Emacs Lisp?
* On Reading this Text::        Read, gain familiarity, pick up habits....
* Who You Are::                 For whom this is written.
* Lisp History::
* Note for Novices::            You can read this as a novice.
* Thank You::
@end menu

@ifnottex
@node Why
@unnumberedsec 为什么要学习 Emacs Lisp？
@end ifnottex

尽管Emacs Lisp通常只与Emacs相关，但它是一种完整的计算机编程语言。您可以像使用其他编程语言一样使用Emacs Lisp。

也许您想了解编程；也许您想扩展Emacs；或者也许您想成为一名程序员。这个关于Emacs Lisp的介绍旨在帮助您入门：引导您学习编程的基础知识，更重要的是，向您展示如何自学以更进一步。

@node On Reading this Text
@unnumberedsec 关于阅读本文

在本文中，您将看到一些可以在Emacs中运行的小示例程序。如果您正在使用GNU Emacs的Info模式阅读本文，您可以按照示例中的说明来运行这些程序（这很容易做到，当示例程序出现时会有解释）。或者，您可以在运行Emacs的计算机旁边阅读这本介绍性的书籍。（这是我个人偏好的方式；我喜欢纸质书籍。）如果您旁边没有正在运行的Emacs，您仍然可以阅读这本书，但在这种情况下，最好将其视为一部小说或一本尚未探索过的国家的旅行指南：虽然有趣，但不同于亲自实践。

这个介绍的大部分内容都是关于GNU Emacs中的代码演练和代码导览。这些导览有两个目的：首先，使您熟悉真实的、可工作的代码（您每天使用的代码）；其次，使您熟悉Emacs的工作方式。看到一个工作环境是如何实现的是非常有趣的。此外，我希望您会养成浏览源代码的习惯。您可以从中学习并获得灵感。拥有GNU Emacs就像拥有一个充满宝藏的巨龙巢穴。

除了学习作为编辑器的Emacs和作为编程语言的Emacs Lisp，示例和导览还将让您有机会熟悉作为Lisp编程环境的Emacs。GNU Emacs支持编程，并提供了各种工具，如@kbd{M-.}（调用@code{xref-find-definitions}命令的键）。您还将学习关于缓冲区和环境中的其他对象的信息。学习这些Emacs的特性就像探索自己家乡的新路线一样。

@ignore
In addition, I have written several programs as extended examples.
Although these are examples, the programs are real.  I use them.
Other people use them.  You may use them.  Beyond the fragments of
programs used for illustrations, there is very little in here that is
just for teaching purposes; what you see is used.  This is a great
advantage of Emacs Lisp: it is easy to learn to use it for work.
@end ignore

最后，我希望传授一些使用Emacs来学习您不了解的编程方面的技能。您通常可以使用Emacs来帮助您理解困扰您的事情或做一些新的东西。这种自力更生不仅是一种乐趣，还是一种优势。

@node Who You Are
@unnumberedsec 目标读者

本文是为那些不是程序员的人写的初级介绍。如果您是一名程序员，可能对这篇入门文章感到不满意。原因是您可能已经熟练掌握了阅读参考手册的技巧，并且可能不喜欢这篇文章的组织方式。

一位经验丰富的程序员在审阅这篇文章后对我说：

@quotation
@i{我更喜欢从参考手册中学习。我在每个段落中深入阅读，然后在段落之间稍作休息。}

@i{当我阅读完一个段落时，我假设该主题已经讲解完毕，我知道我需要的一切信息（除非下一个段落开始更详细地讨论它）。我期望一个写得很好的，不会有太多冗余的参考手册，而且会有出色的指向（一个）我想要的信息的链接。}
@end quotation

这个介绍不是针对这样的人写的！

首先，我尽量将每件事情都至少重复三次：首先是介绍它；其次是在上下文中展示它；第三是在不同的上下文中展示它，或者进行复习。

其次，我通常不会把有关某个主题的所有信息都集中在一个地方，更不用说一个段落了。根据我的思维方式，这会对读者造成过多的负担。相反，我只会尝试在您需要了解时提供解释。（有时我会包含一些额外信息，以便稍后当额外信息正式介绍时，您不会觉得突然)。

当您阅读这篇文章时，您不必一次性掌握所有内容。通常，您只需要对提到的一些项目有一点了解。我希望我已经结构化了这篇文章并提供了足够的提示，以便您能够意识到什么是重要的，并专注于它。

您需要深入研究一些段落；别无他法。但我已经尽量减少这类段落的数量。这本书旨在作为一个平易近人的小山丘，而不是一个令人望而却步的高峰。

这本名为 @cite{An Introduction to Programming in Emacs Lisp} 的书有一个配套文档,
@iftex
@cite{The GNU Emacs Lisp Reference Manual}.
@end iftex
@ifnottex
@ref{Top, , The GNU Emacs Lisp Reference Manual, elisp, The GNU
Emacs Lisp Reference Manual}.
@end ifnottex
参考手册比这个入门介绍包含更多细节。在参考手册中，有关一个主题的所有信息都集中在一个地方。如果您是像上面的程序员一样，就应该参考它。当然，在阅读完这本@cite{Introduction}后, 您在编写自己的程序时会发现 @cite{Reference Manual} 很有用.

@node Lisp History
@unnumberedsec Lisp的历史
@cindex Lisp history

Lisp语言在20世纪50年代晚期由麻省理工学院为人工智能研究而开发。Lisp语言的强大之处使其在其他领域也表现出色，例如编写编辑器命令和集成环境。

@cindex Maclisp
@cindex Common Lisp
GNU Emacs Lisp在很大程度上受到Maclisp的启发，Maclisp是在20世纪60年代由麻省理工学院开发的。它也在一定程度上受到Common Lisp的启发，Common Lisp在20世纪80年代成为了一种标准。然而，Emacs Lisp比Common Lisp简单得多。（标准的Emacs发行版包含一个可选的扩展文件@file{cl-lib.el}，它为Emacs Lisp添加了许多Common Lisp功能。）

@node Note for Novices
@unnumberedsec 新手须知

即使您不了解GNU Emacs，您仍然可以从本文中有所收获。但是，我建议您学习Emacs，即使只是为了学会在计算机屏幕上移动。您可以使用内置教程来自学如何使用Emacs。要使用它，输入@kbd{C-h t}。（这意味着您同时按下和释放@key{CTRL}键和@kbd{h}键，然后按下和释放@kbd{t}键。）

此外，我经常通过列出用于调用标准Emacs命令的按键，然后在括号中给出命令的名称，来引用Emacs的标准命令之一，就像这样：@kbd{M-C-\}（@code{indent-region}）。这意味着@code{indent-region}命令通常是通过键入@kbd{M-C-\}来调用的。（如果您愿意，您可以更改用于调用命令的按键；这被称为@dfn{rebinding, 重新绑定}。@xref{Keymaps, , 键位映射}.）@kbd{M-C-\}的缩写意味着你需要同时按下@key{META}键、@key{CTRL}键和@kbd{\}键。在许多现代键盘上，@key{META}键帽上标着@key{ALT}。像这样的组合被称为组合键(keychord)。如果你的键盘没有@key{META}键，单击@key{ESC}键来代替它。在这种情况下，@kbd{M-C-\}意味着您按下并释放@key{ESC}键，然后同时按下@key{CTRL}键和@kbd{\}键。但通常@kbd{M-C-\}意味着同时按下标有@key{ALT}的键和@key{CTRL}键，同时再按@kbd{\}键。

除了长按单个组合键外，您还可以在你输入的内容前加上@kbd{C-u}，这被称为@dfn{通用参数}。@kbd{C-u}组合键会将参数传递给后续的命令。因此，要以6空格缩进一段纯文本的区域，首先标记该区域，然后输入@w{@kbd{C-u 6 M-C-\}}。（如果您不指定一个数字，Emacs将默认数字为4，或者以不同于其他情况的方式运行该命令。）@xref{Arguments, , Numeric Arguments, emacs, The GNU Emacs Manual}.

如果您是在GNU Emacs中使用Info模式阅读这篇文章，您可以通过按下空格键@key{SPC}来浏览整个文档。（要了解Info，请输入@kbd{C-h i}，然后选择Info。）

关于术语的说明：当我单独使用Lisp这个词时，我通常是在泛指各种Lisp方言，但当我谈到Emacs Lisp时，我指的是特定的GNU Emacs Lisp。

@node Thank You
@unnumberedsec 致谢

感谢所有帮助我完成这本书的人。特别感谢@r{Jim Blandy}，@r{Noah Friedman}，@w{Jim Kingdon}，@r{Roland McGrath}，@w{Frank Ritter}，@w{Randy Smith}，@w{Richard M. Stallman}和@w{Melissa Weisshaus}。我还要感谢@w{Philip Johnson}和@w{David Stampe}，他们的耐心鼓励对我非常重要。如有遗漏是我的问题。

@flushright
Robert J. Chassell
@ifnothtml
@email{bob@@gnu.org}
@end ifnothtml
@ifhtml
bob@@gnu.org
@end ifhtml
@end flushright

@c ================ Beginning of main text ================

@c Start main text on right-hand (verso) page

@tex
\par\vfill\supereject
\headings off
\ifodd\pageno
    \par\vfill\supereject
\else
    \par\vfill\supereject
    \page\hbox{}\page
    \par\vfill\supereject
\fi
@end tex

@c Note: this resetting of the page number back to 1 causes TeX to gripe
@c about already having seen page numbers 1-4 before (in the preface):
@c   pdfTeX warning (ext4): destination with the same identifier (name{1})
@c   has been already used, duplicate ignored
@c I guess that is harmless (what happens if a later part of the text
@c makes a link to something in the first 4 pages though?).
@c E.g., note that the Emacs manual has a preface, but does not bother
@c resetting the page numbers back to 1 after that.
@c Alternatively, uncomment the 3 lines above (search for ``pageno'')
@c to have the preface numbered in roman numerals.
@iftex
@headings off
@evenheading @thispage @| @| @thischapter
@oddheading @thissection @| @| @thispage
@global@pageno = 1
@end iftex

@node List Processing
@chapter 列表处理

对于未经培训的人来说，Lisp 是一种奇特的编程语言。在 Lisp 代码中，到处都是括号。甚至有人声称这个名字代表“Lots of Isolated Silly Parentheses”（很多孤立的愚蠢括号）。但这种说法是不准确的。Lisp 代表 LISt Processing，这种编程语言通过处理括号中的@emph{列表}（以及列表的列表）来工作。括号标示着列表的边界。有时候，列表前面会有一个撇号@samp{'}，称作 Lisp 中的@dfn{单引号}。
@footnote{A single-quote is an
abbreviation for the special form @code{quote}; you need not think
about special forms now.
@ifnottex
@xref{Complications}.
@end ifnottex
@iftex
@xref{Lisp Interpreter}.
@end iftex
}  列表是 Lisp 的基础。

@menu
* Lisp Lists::                  什么是列表？
* Run a Program::               Lisp中的任何列表都可以直接运行
* Making Errors::               生成错误消息
* Names & Definitions::         符号的名称和函数定义
* Lisp Interpreter::            Lisp解释器的作用
* Evaluation::                  运行程序
* Variables::                   从变量返回值
* Arguments::                   向函数传递信息
* set & setq::                  设置变量的值
* Summary::                     总结
* Error Message Exercises::
@end menu

@node Lisp Lists
@section Lisp列表
@cindex Lisp Lists

在Lisp中，一个列表看起来像这样：@code{'(rose violet daisy buttercup)}。这个列表前面有一个单引号。它也可以写成如下形式，更像你可能熟悉的列表：

@smallexample
@group
'(rose
  violet
  daisy
  buttercup)
@end group
@end smallexample

@noindent
这个列表的元素是四种不同花的名称，它们之间用空格分隔，被括号包围，就像田野中的花朵被一堵石墙围绕着。
@cindex 田野中的花朵

@menu
* Numbers Lists::               包含数字和其他列表的列表。
* Lisp Atoms::                  基本实体。
* Whitespace in Lists::         格式化使列表更易阅读。
* Typing Lists::                GNU Emacs如何帮助您输入列表。
@end menu

@ifnottex
@node Numbers Lists
@unnumberedsubsec 列表中的数字与列表
@end ifnottex

在 Lisp 中,列表也可以包含数值，就像这个列表：@code{(+ 2 2)}。
这个列表包含一个加号，@samp{+}，后面跟着两个 @samp{2}，它们之间用空格分隔。

在Lisp中，数据和程序都以相同的方式表示；也就是说，它们都是由单词、数字或其他列表组成，之间用空格分隔，括在括号中。 (由于程序看起来像数据，一个程序可以轻松地作为另一个程序的数据；这是Lisp的一个非常强大的特性。) (顺便说一下，这两个括号中的注释@emph{不是}Lisp列表，因为它们包含了分号 @samp{;} 和句点 @samp{.} 作为标点符号。)

@need 1200
这里还有一个列表，这次里面包含了一个列表：

@smallexample
'(this list has (a list inside of it))
@end smallexample

这个列表的组成部分包括单词 @samp{this}, @samp{list},
@samp{has}, 和列表 @samp{(a list inside of it)}.  内部列表由单词 @samp{a}, @samp{list}, @samp{inside},
@samp{of}, @samp{it} 组成。

@node Lisp Atoms
@subsection Lisp原子
@cindex Lisp Atoms

在Lisp中，我们一直称之为单词的东西被称为@dfn{原子}。这个术语来自于“原子”一词的历史含义，即“不可分割”。就Lisp而言，我们在列表中使用的单词不能再分割成更小的部分，仍然具有与程序的某个部分相同的含义；数字和单字符符号（如@samp{+}）也是如此。然而，与古代的原子不同，列表可以被分割成部分。 (@xref{car cdr & cons,
, @code{car} @code{cdr} & @code{cons} Fundamental Functions}.)

在列表中，原子之间由空格分隔。它们可以紧邻括号。

@cindex @samp{empty list} defined
从技术上讲，Lisp中的列表由括号括起，括号内部包含由空格分隔的原子，或者括号内部包含其他列表，或者同时包含原子和其他列表。一个列表可以只包含一个原子，也可以什么都不包含。一个什么都不包含的列表看起来像这样：@code{()}，称为@dfn{空列表}。与其他东西不同，空列表既是原子又是列表。

@cindex Symbolic expressions, introduced
@cindex @samp{表达式} defined
@cindex @samp{形式} defined
原子和列表的打印表示被称为@dfn{符号表达式}，或更简洁地称为@dfn{s-表达式}。单词@dfn{表达式}本身可以指的是打印表示，也可以指的是计算机内部保存的原子或列表。通常，人们会不加区分地使用@dfn{表达式}一词。 (此外，许多文本中，@dfn{形式}也被用作表达式的同义词。)

@c This and the next paragraph say ``kinds of atom'', but that is not
@c a typo, just slightly ``old-fashioned wording which adds a fillip
@c of interest to it'', and ``is more elegant writing'', according to
@c RMS.
顺便提一下，构成我们宇宙的原子最初被认为是不可分割的。但后来发现，原子并非不可分割。原子可以分裂成两个大致相等的部分，或者可以有部分组成从原子中分离出来。也就是说，原子在其真正性质被发现之前就被过早地命名了。在Lisp中，某些类型的原子，例如数组，也可以被分割成部分，但这种分割数组的机制与分割列表的机制不同。就列表操作而言，列表的原子是不可分割的。

与汉语词语的含义不同于单个汉字的含义一样,Lisp语言中的原子也不等同于组成它的字母。例如，熊猫，与"熊" 和 "猫"完全不同。

自然界中有许多种类的原子，而在Lisp中只有少数几种：例如，@dfn{数字}，比如37、511或1729，以及@dfn{符号}，比如@samp{+}、@samp{foo}或@samp{forward-line}。我们在上面的示例中列出的单词都是符号。在日常的Lisp对话中，“原子”这个术语很少被直接使用，因为程序员通常会尽量明确他们正在处理哪一类型的原子。Lisp编程主要涉及列表中符号的处理（有时还涉及数字）。(顺便一提，前文中的括号注释也是一个合法的Lisp列表，因为它由原子组成，这些原子是符号，被空格分隔并用括号括起，没有任何非Lisp符号。)

@need 1250
用双引号括起的文本，即使是句子或段落，也会被视为一个原子。下面是一个例子：
@cindex Text between double quotation marks

@smallexample
'(this list includes "text between quotation marks.")
@end smallexample

@cindex @samp{string} defined
@noindent
在Lisp中，所有引号括起的内容，包括标点符号和空格，都会被视为一个单独的原子。这种类型的原子被称为@dfn{字符串}(string)，通常用于让计算机打印出人类可读的消息。字符串与数字或符号不同，使用方式也有区别。

@node Whitespace in Lists
@subsection 列表中的空格
@cindex Whitespace in lists

@need 1200
在Lisp语言中，表中的空格数量并不重要。从Lisp的角度看，

@smallexample
@group
'(this list
   looks like this)
@end group
@end smallexample

@need 800
@noindent
与这个表达式完全等价：

@smallexample
'(this list looks like this)
@end smallexample

这两个例子展示了在Lisp中相同的一个列表，它由这些符号 @samp{this}、@samp{list}、@samp{looks}、@samp{like} 和 @samp{this} 按顺序组成。

额外的空格和换行只是为了让人更容易阅读列表。当Lisp读取表达式时，会忽略额外的空格（但原子之间至少需要一个空格来区分）。

尽管看起来很奇怪，但我们已经涵盖了Lisp中几乎所有列表的情况！Lisp中的其他列表都或多或少与这些例子相似，只是列表可能更长更复杂。简而言之，列表在括号内，字符串在引号内，符号看起来像单词，数字看起来像数字。（对于某些情况，可能会使用方括号、点号等一些特殊字符；但即使没有它们，我们也已经可以处理很多情况了。）

@node Typing Lists
@subsection GNU Emacs帮助您输入列表
@cindex Help typing lists
@cindex Formatting help

在GNU Emacs中，当您在Lisp交互模式或Lisp模式下输入Lisp表达式时，可以使用一些命令来格式化Lisp表达式，以提高代码的可读性。例如，按下@key{TAB}键会自动合理缩进当前行。通常，用于正确缩进区域中的代码的快捷键绑定为@kbd{M-C-\}。代码缩进可以让您清楚地看出哪些元素属于某个列表---子列表的元素缩进会比包含它的列表更深。

此外，当您键入右括号时，Emacs会短暂地将光标跳回到对应的左括号，这样您可以看到右括号与哪个左括号匹配。这非常有用，因为在Lisp中，您写的每个列表都必须有对应的右括号和左括号。（有关Emacs模式的更多信息，@xref{Major Modes, , Major Modes, emacs, The GNU Emacs Manual}.）

@node Run a Program
@section 运行程序
@cindex Run a program
@cindex Program, running one

@cindex @samp{evaluate} defined
在Lisp中，任何列表本身都可以作为一个准备执行的程序。如果对列表进行求值（在Lisp术语中称为@dfn{评估}(evaluate, eval)），计算机会执行以下三种操作之一：直接返回列表本身且不做任何处理；显示错误信息；或者将列表中的第一个符号视为命令并执行相应操作。 （当然，通常您期望的是最后一种情况！）

@c 用代码表示单引号，而不是samp。
@findex quote
@cindex @code{'} for quoting
@cindex quoting using apostrophe
@cindex apostrophe for quoting
在前面章节的示例中，我在某些列表之前使用的@code{'}，称为@dfn{单引号}；它的作用是告诉Lisp直接原样输出这个列表，不做任何处理。但是，如果列表前没有单引号，那么列表中的第一个元素就具有特殊意义：它是计算机要执行的命令。 （在Lisp中，这些命令被称为@emph{函数}。）上例中的@code{(+ 2 2)}列表没有单引号，因此Lisp会将@code{+}视为指示对后面的数字进行相加运算的命令。

@need 1250
如果您在GNU Emacs中的Info模式下阅读此文档，可以通过以下步骤来执行Lisp表达式的计算：将光标置于以下列表的右括号之后，键入@kbd{C-x C-e}：

@smallexample
(+ 2 2)
@end smallexample

@c 这里使用代码格式表示数字四，而不是samp。
@noindent
您将在回显区域看到数字@code{4}@footnote{Emacs以十进制、八进制和十六进制以及字符的方式显示整数值，但现在让我们忽略这个便利功能。}。 （您刚刚对该列表进行了评估。回显区域位于屏幕底部区域，或是输出文本信息。）现在尝试对一个带引号的列表执行相同的操作：将光标放在下例列表的右括号后，键入@kbd{C-x C-e}：

@smallexample
'(this is a quoted list)
@end smallexample

@noindent
您将在回显区域看到 @code{(this is a quoted list)}。

@cindex Lisp interpreter, explained
@cindex Interpreter, Lisp, explained
在上述两种情况下，您所做的是向GNU Emacs内部的一个叫做@dfn{Lisp解释器}的程序发送一个命令，即给解释器一个要评估的表达式。Lisp解释器(interpreter)得名于它解释表达式含义的功能,就像一个人在解释一样。

您也可以评估一个不是列表的原子，即一个没有被括号包围的原子；同样，Lisp解释器会将这种人类可读的表达式翻译成计算机语言。但在讨论这个之前（@pxref{Variables}），我们先来看当出现错误时Lisp解释器会做什么。

@node Making Errors
@section 生成错误信息
@cindex Generate an error message
@cindex Error message generation

部分原因是,如果您不小心出错了,也不用担心，我们现在将向 Lisp 解释器发出一个命令，让它生成一条错误信息。 这是一项无害的尝试； 事实上，我们经常会尝试故意生成错误信息。 一旦您理解了相关术语，错误信息就可以提供丰富的信息帮助。 它们不应该被称为“错误”信息，而更应该被称为“帮助”信息。 它们就像异国游客遇到的路标； 解读这些信息可能很困难，但一旦理解其含义，它们就能指明道路。

错误信息是由GNU Emacs内置的调试器生成的。我们将进入调试器环境。您可以通过键入 @code{q} 来退出调试器。

我们要做的是对一个没有加单引号且第一个元素不是有效命令的列表进行评估。这个列表和我们之前用过的类似,只是没有加上单引号。将光标定位到该列表的后面，然后输入 @kbd{C-x C-e}：

@smallexample
(this is an unquoted list)
@end smallexample

这将打开一个 @file{*Backtrace*} 的窗口，您应该在其中看到以下内容：

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function this)
  (this is an unquoted list)
  eval((this is an unquoted list) nil)
  elisp--eval-last-sexp(nil)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@need 1200
@noindent
此时光标会定位在这个窗口中（可能需要等待几秒才显示出来）。要退出调试器并关闭调试器窗口，请输入：

@smallexample
q
@end smallexample

@noindent
请现在按下 @kbd{q}键，以确保您能退出调试器。然后再次输入 @kbd{C-x C-e} 重新进入调试器。

@cindex @samp{函数} defined
根据我们已经了解的知识，我们基本可以解析这个错误信息的含义。

从下往上查看 @file{*Backtrace*} 缓冲区的内容；它记录了Emacs执行的步骤。当您输入 @kbd{C-x C-e} 时，向命令 @code{eval-last-sexp} 发起了交互调用。@code{eval} 是“evaluate（评估）”的缩写，@code{sexp} 是“symbolic expression（符号表达式）”的缩写。该命令的含义是“评估最后一个符号表达式”，也就是光标前的那个表达式。

以上每一行都在告诉我们Lisp解释器接下来评估的内容。最新的操作在顶部。这个缓冲区被称为 @file{*Backtrace*} ，因为它允许我们回溯Emacs的执行步骤。

@need 800
在 @file{*Backtrace*} 缓冲区的顶部，您可以看到这样一行：

@smallexample
Debugger entered--Lisp error: (void-function this)
@end smallexample

@noindent
Lisp 解释器试图对列表的第一个原子 @samp{this} 进行评估。正是这个操作产生了错误信息 @samp{void-function this}。

这个信息包含了 @samp{void-function} 和 @samp{this} 两个词。

@cindex @samp{函数} defined
@samp{函数} (function)这个词之前提到过一次。这是一个非常重要的概念。对我们而言，可以定义简单理解为一组指令，用于告诉计算机要执行什么操作。

现在我们可以开始解析这个错误信息@samp{void-function this}的含义了。这个函数（也就是，@samp{this}这个词）没有关联任何一组指令来告诉计算机要执行什么操作。

这个比较奇怪的词@samp{void-function}是为了反映Emacs Lisp的实现方式，也就是说，当一个符号没有绑定函数定义时，原本要包含执行指令的位置是空的。

另一方面，由于我们可以成功对2和2进行相加（通过评估 @code{(+ 2 2)}），我们可以推断符号 @code{+} 一定有一组与之关联的指令，这些指令会指示计算机将紧随其后的数字相加。

在这种情况下，可以避免Emacs进入调试器。我们暂不解释如何实现，但会提及结果的样子，因为当您在使用某段Emacs代码遇到类似情况时，也可能看到类似的效果。在这种情况下，您只会看到一行错误信息；它会出现在回显区，看起来像这样：

@smallexample
Symbol's function definition is void:@: this
@end smallexample

@noindent
@ignore
(Also, your terminal may beep at you---some do, some don't; and others
blink.  This is just a device to get your attention.)
@end ignore
当你输入任何键，哪怕只是移动一下光标，这个消息就会消失。

我们知道@samp{Symbol}这个词的含义。它指代的是列表中的第一个原子，也就是词@samp{this}。@samp{function}一词表示用于告知计算机要执行什么操作的指令。（技术上来说，这个符号会告知计算机在何处可以找到这些指令，但这个复杂问题我们暂时可以忽略。）

所以错误信息可以这样理解：@samp{Symbol's function definition is void:@: this}。这个符号(Symbol)（也就是词@samp{this}）缺少可供计算机执行的指令。

@node Names & Definitions
@section 符号名称和函数定义
@cindex Symbol names

根据目前我们的讨论,我们可以归纳出Lisp的另一关键特性：像 @code{+} 这样的符号本身并不是计算机可执行的一组指令。相反，这些符号仅用于暂时定位相关的定义或指令集。我们看到的只是通过该符号名称才能找到实际指令的方式。人的名字也是一样的。我可以被称为 @samp{Bob}；然而，我不是字母 @samp{B}、@samp{o}、@samp{b} 的组合，而是（或者曾是）一个与特定生命形式长期关联的意识。名字并不是我，但可以用来指称我。

在 Lisp 中，一组指令可以被关联到多个名字上。例如，加法运算的计算机指令可以关联到符号 @code{plus}，也可以关联到符号 @code{+}上（在某些 Lisp 方言中是这样的）。对于人名，我可以被称为 @samp{Robert}，也可以被称为 @samp{Bob}，以及其他词汇。

但是，一个符号一次只能有一个函数定义与之关联。否则，计算机就会困惑应该使用哪个定义。如果这种情况发生在人类身上，世界上也只能有一个人被命名为 @samp{Bob}。然而，符号所代表的函数定义可以很容易地被更改。(@xref{Install, , 安装函数定义}.)

由于 Emacs Lisp 非常庞大，通常会以能够指明函数属于Emacs的哪个部分的方式来命名符号。因此，所有涉及 Texinfo 处理的函数名都以 @samp{texinfo-} 开头，而处理邮件读取的函数则以 @samp{rmail-} 开头。

@node Lisp Interpreter
@section Lisp解释器
@cindex Lisp interpreter, what it does
@cindex Interpreter, what it does

基于我们所见，现在我们可以开始弄清楚当命令Lisp解释器评估列表时它会做什么。首先，它会查看列表前是否有引号；如果有，解释器会直接返回这个列表。另一方面，如果没有引号，解释器会查看列表中的第一个元素，检查它是否有一个函数定义与之关联。如果有，解释器就会执行该函数定义中的指令。否则，解释器会打印错误信息。

这就是Lisp的工作原理。简单明了。当然，还有一些额外的复杂性，我们后面会提到，但这些是基础。想要编写Lisp程序，您还需要了解如何编写函数定义并将其关联到函数名上，以及如何在不使自己和计算机产生困惑的情况下实现这一点。

@menu
* Complications::               变量、特殊形式、内部列表。
* Byte Compiling::              为加速对代码特殊处理。
@end menu

@ifnottex
@node Complications
@unnumberedsubsec 复杂情况
@end ifnottex

现在，我们来看第一个复杂情况。除了列表，Lisp 解释器还可以对没有引号且没有被括号包围的单个符号进行评估。在这种情况下，Lisp 解释器会试图确定该符号作为@dfn{变量}的值。这种情况我们会在变量部分进行描述。(@xref{Variables}.)

@cindex Special form
第二个复杂情况是，有一些函数的工作方式与常规函数不同，那些不同寻常的函数被称为@dfn{特殊形式}。它们用于处理特定任务，比如定义函数，而且数量并不多。在后续章节中，您会了解到一些更重要的特殊形式。

除特殊形式外，还有@dfn{宏}。宏是Lisp中定义的一种构造，不同于函数的地方在于，它会将一个Lisp表达式转换成另一个要代替原始表达式进行评估的表达式。(@xref{Lisp macro}。)

就本书而言，您无需过于担心某个东西是特殊形式、宏还是普通函数。例如，@code{if} 是一个特殊形式（@pxref{if}），而@code{when} 是一个宏（@pxref{Lisp macro}）。在Emacs的早期版本中，@code{defun} 是一个特殊形式，但现在它是一个宏（@pxref{defun}），不过它的用法没有改变。

最后一个复杂情况是：如果Lisp解释器正在处理的函数不是特殊形式，并且它是列表的一部分，Lisp解释器会检查这个列表是否包含内部列表。如果存在内部列表，Lisp解释器先确定应该如何处理内部列表，然后再处理外部列表。如果内部列表中还嵌套了另一个列表，它还会先处理那个列表，以此类推。解释器总是先处理最内层的列表。它会首先对最内层列表进行评估，得到结果用于外层表达式。

否则，解释器会从左到右顺序处理表达式，每个表达式依次处理。

@node Byte Compiling
@subsection 字节编译
@cindex Byte compiling

Lisp解释器可以处理两种实体：人类可读的代码，这会是我们的重点；以及经过特殊处理的代码，称为 @dfn{字节编译}的代码，后者不是人类可读的。字节编译的代码的运行速度比人类可读的代码要快。

您可以通过运行像 @code{byte-compile-file} 这样的编译命令，将人类可读的代码转换为字节编译的代码。字节编译后的代码通常保存在以 @file{.elc} 为扩展名的文件中，而不是 @file{.el}。在 @file{emacs/lisp} 目录下您会看到这两种类型的文件；需要阅读的是那些 @file{.el} 扩展名的文件。

实际上，对于大多数自定义和扩展Emacs的需要，您不一定要进行字节编译；我在这里也不会详细讨论这个话题。要获取字节编译的完整描述，@xref{Byte Compilation, , Byte Compilation, elisp, The GNU Emacs Lisp Reference Manual}.

@node Evaluation
@section 评估
@cindex Evaluation

当Lisp解释器对表达式进行处理时，这个活动被称为 @dfn{评估}。我们说解释器 "评估表达式"。我之前已经多次使用过这个术语。这个词来源于日常语言中的 "确定价值或数量"，根据 @cite{Webster's New Collegiate Dictionary} 的定义。

@menu
* How the Interpreter Acts::    返回值和副作用...
* Evaluating Inner Lists::      列表内部的列表...
@end menu

@ifnottex
@node How the Interpreter Acts
@unnumberedsubsec Lisp 解释器的行为方式
@end ifnottex

@cindex @samp{returned value} explained
在对表达式评估后，Lisp 解释器很可能会@dfn{返回}计算机通过执行函数定义中的指令得到的值，或者它可能放弃对该函数的处理并生成错误消息。（也可能出现解释器被抛入另一个函数的执行,或者陷入无限循环的情况,但这些比较少见,我们可以忽略。）最常见的情况是，解释器返回一个值。

@cindex @samp{side effect} defined
与此同时，解释器还可能执行其他操作，如移动光标或复制文件；这类被称为@dfn{副作用}。我们人类认为重要的操作，比如打印结果，通常是 Lisp 解释器的副作用。学习使用副作用相对比较简单。

综上所述，对符号表达式评估通常会导致 Lisp 解释器返回一个值，并可能产生副作用；否则就会产生错误信息。

@node Evaluating Inner Lists
@subsection 评估内部列表
@cindex Inner list evaluation
@cindex Evaluating inner lists

如果对嵌套在另一个列表中的内部列表进行评估，外部列表在评估时可能会使用内层列表的评估结果作为信息。这解释了为什么要首先对内部表达式进行评估：它们的返回值会被外部表达式使用。

@need 1250
我们可以通过对另一个加法示例进行评估来调查这个过程。将光标置于以下表达式之后，键入@kbd{C-x C-e}：

@smallexample
(+ 2 (+ 3 3))
@end smallexample

@noindent
数字8将会出现在回显区域。

过程是这样的，Lisp解释器首先对内部表达式@code{(+ 3 3)}进行评估，返回值是6；然后它对外部表达式评估，就像表达式写成@code{(+ 2 6)}一样，返回值是8。由于没有更多外层表达式需要评估，解释器将这个值打印在回显区域。

现在很容易理解@kbd{C-x C-e}这个快捷键所调用命令的名称 @code{eval-last-sexp}。@code{sexp}是“symbolic expression”（符号表达式）的缩写，而@code{eval}是“evaluate”（评估）的缩写。该命令对最后一个符号表达式进行评估。

作为实验，您可以尝试通过将光标放在表达式后面紧跟的下一行行首，或者放在表达式内部来评估该表达式。

@need 800
下面是表达式的另一份副本：

@smallexample
(+ 2 (+ 3 3))
@end smallexample

@noindent
如果将光标放在紧随表达式后面的空白行行首，然后键入 @kbd{C-x C-e}，您仍然会在回显区域中看到打印的值8。现在试着将光标放在表达式内部。如果将光标放在倒数第二个括号后（使它看起来位于最后一个括号上方），您会在回显区域看到打印的值6！这是因为该命令评估了表达式 @code{(+ 3 3)}。

现在将光标放在一个数字后面。键入 @kbd{C-x C-e}，您会得到那个数字本身。在Lisp中，对一个数字评估会直接返回这个数字本身——这是数字与符号的区别。如果对以像 @code{+} 这样的符号开头的列表评估，您会得到一个返回值，该返回值是计算机执行附加在该符号上的函数定义中的指令所得到的结果。如果单独对一个符号评估，会发生一些不同的事情，我们将在下一节看到。

@node Variables
@section 变量
@cindex Variables

在 Emacs Lisp 中，一个符号可以附加一个值，就像它可以附加一个函数定义一样。这两者是不同的。函数定义是计算机将执行的一组指令。值，另一方面，是一些可以变化的东西，比如一个数字或一个名称（这就是为什么这样的符号被称为变量的原因）。一个符号的值可以是Lisp中的任何表达式，比如一个符号、数字、列表或字符串。一个具有值的符号通常被称为@dfn{变量}。

一个符号可以同时有一个函数定义和一个值。或者它可以只有其中之一。这两者是独立的。这与剑桥这个名称既可以指代马萨诸塞州的城市，又可以附带一些信息，比如“伟大的编程中心”，有些相似。

@ignore
（顺便说一下，在Emacs Lisp中，一个符号还可以附加两个其他东西：属性列表和文档字符串；这些稍后会讨论。）
@end ignore

另一种思考这个问题的方式是将一个符号想象成一个抽屉柜。函数定义放在一个抽屉里，值放在另一个抽屉里，依此类推。在值的抽屉里放置的东西可以更改，而不影响放置函数定义的抽屉的内容，反之亦然。

@menu
* fill-column Example::
* Void Function::               一个没有函数的符号的错误消息。
* Void Variable::               一个没有值的符号的错误消息。
@end menu

@ifnottex
@node fill-column Example
@unnumberedsubsec @code{fill-column}，一个示例变量
@end ifnottex

@findex fill-column@r{，一个示例变量}
@cindex 示例变量，@code{fill-column}
@cindex 变量，示例，@code{fill-column}
变量 @code{fill-column} 说明了一个带有值的符号：在每个 GNU Emacs 缓冲区中，该符号被设置为某个值，通常是 72 或 70，但有时也可能是其他值。要找到此符号的值，请通过单独评估它来执行。如果您在 GNU Emacs 中的 Info 中阅读此信息，可以将光标放在符号后面，然后键入 @kbd{C-x C-e} 来执行：

@smallexample
fill-column
@end smallexample

@noindent
在我键入 @kbd{C-x C-e} 后，Emacs 在我的回显区打印了数字 72。这是我在编写此内容时为 @code{fill-column} 设置的值。在您的 Info 缓冲区中，这个值可能是不同的。请注意，变量返回的值与执行其指令的函数返回的值的打印方式完全相同。从 Lisp 解释器的角度来看，返回的值就是返回的值。一旦知道值是什么，它来自哪种表达式就不再重要。

一个符号可以附有任何值，或者用行话说，我们可以将变量@dfn{绑定}到一个值上：可以是一个数字，比如 72；可以是一个字符串，比如 @code{"如此"}；可以是一个列表，比如 @code{(云杉 松树 橡树)}；我们甚至可以将变量绑定到一个函数定义上。

一个符号可以以多种方式绑定到一个值。有关如何执行此操作的信息，请参阅@xref{set & setq, , Setting the Value of a Variable}.

@node Void Function
@subsection 没有函数的符号的错误消息
@cindex 没有函数的符号错误
@cindex 没有函数的符号错误消息

当我们评估变量 @code{fill-column} 以获取其值时，我们没有在单词周围加括号。这是因为我们没有打算将其用作函数名称。

如果 @code{fill-column} 是列表的第一个或唯一元素，Lisp 解释器将尝试找到与之关联的函数定义。但是 @code{fill-column} 没有函数定义。尝试评估以下内容：

@smallexample
(fill-column)
@end smallexample

@need 1250
@noindent
将会创建一个 @file{*Backtrace*} 缓冲区，其中显示：

@smallexample
@group
---------- 缓冲区：*Backtrace* ----------
Debugger entered--Lisp error: (void-function fill-column)
  (fill-column)
  eval((fill-column) nil)
  elisp--eval-last-sexp(nil)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
---------- 缓冲区：*Backtrace* ----------
@end group
@end smallexample

@noindent
（记住，要退出调试器并关闭调试器窗口，请在 @file{*Backtrace*} 缓冲区中键入 @kbd{q}。）

@node Void Variable
@subsection 没有值的符号的错误消息
@cindex 没有值的符号错误
@cindex 没有值的符号错误消息

如果你尝试评估一个没有绑定值的符号，你将收到一个错误消息。你可以通过尝试我们的2加2的加法来看到这一点。在下面的表达式中，将光标放在第一个数字2之前的@code{+}右边，然后输入@kbd{C-x C-e}：

@smallexample
(+ 2 2)
@end smallexample

@need 1500
@noindent
在GNU Emacs 22中，你将创建一个名为@file{*Backtrace*}的缓冲区，显示如下错误消息：

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-variable +)
  eval(+)
  elisp--eval-last-sexp(nil)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@noindent
（同样，你可以在@file{*Backtrace*}缓冲区中输入@kbd{q}来退出调试器。）

这个回溯与我们最初看到的第一个错误消息不同，它说的是@samp{Debugger entered--Lisp error: (void-function this)}。在这种情况下，该函数没有作为变量的值；而在其他错误消息中，函数（单词@samp{this}）没有定义。

在这个对@code{+}的实验中，我们的做法是导致Lisp解释器评估@code{+}并寻找变量的值，而不是函数的定义。我们通过将光标放在符号右边而不是在封闭列表的括号后面，使Lisp解释器执行了前一个S表达式，这种情况下是单独的@code{+}。

由于@code{+}没有绑定到任何值，只有函数定义，错误消息报告该符号作为变量的值为空。

@node Arguments
@section 参数
@cindex 参数
@cindex 将信息传递给函数

为了了解信息是如何传递给函数的，让我们再次看看我们的老朋友，@code{2 + 2}。在Lisp中，它被写成如下形式：

@smallexample
(+ 2 2)
@end smallexample

如果你评估这个表达式，数字4将出现在你的回显区。Lisp解释器所做的是将跟随@code{+}的数字相加。

@cindex @samp{argument} 的定义
由@code{+}相加的数字被称为函数@code{+}的@dfn{参数}。这些数字是传递给函数的信息。

“参数”这个词来自数学中的用法，不是指两个人之间的辩论；而是指提供给函数的信息，在这种情况下，是提供给@code{+}的信息。在Lisp中，函数的参数是跟随函数的原子或列表。通过评估这些原子或列表的结果值传递给函数。不同的函数需要不同数量的参数；有些函数根本不需要参数。@footnote{追踪“参数”这个词如何在数学中和日常英语中拥有两个不同的含义是很有趣的。根据《牛津英语词典》的说法，这个词源于拉丁语，意思是“澄清，证明”；因此，它通过一条推导线的方式，来表示“作为证据提供的信息”，也就是说，“提供的信息”，这导致了它在Lisp中的含义。但在另一条推导线上，它的意思变成了“以一种其他人可以提出反对主张的方式断言”，这解释了这个词作为争论的含义。(注意这里英语单词同时拥有两个不同的定义。相比之下，在Emacs Lisp中，一个符号在同一时间不能拥有两个不同的函数定义。)}

@menu
* Data types::                  传递给函数的数据类型。
* Args as Variable or List::    参数可以是变量或列表的值。
* Variable Number of Arguments::  一些函数可能接受可变数量的参数。
* Wrong Type of Argument::      将错误类型的参数传递给函数。
* message::                     用于发送消息的有用函数。
@end menu

@node Data types
@subsection 参数的数据类型
@cindex 数据类型
@cindex 数据的类型
@cindex 参数的数据类型

应传递给函数的数据类型取决于它使用的信息的种类。例如，像@code{+}这样的函数的参数必须是数字，因为@code{+}是对数字进行加法运算的。其他函数使用不同类型的数据作为它们的参数。

@need 1250
@findex concat
例如，@code{concat}函数将两个或多个文本字符串连接或合并成一个字符串。其参数是字符串。连接两个字符字符串@code{abc}和@code{def}将产生单个字符串@code{abcdef}。通过评估以下表达式可以看到这一点：

@smallexample
(concat "abc" "def")
@end smallexample

@noindent
评估这个表达式产生的值是@code{"abcdef"}。

@cindex substring
像@code{substring}这样的函数使用字符串和数字作为参数。该函数返回字符串的一部分，即第一个参数的@dfn{子字符串}。该函数接受三个参数。其第一个参数是字符字符串，第二个和第三个参数是指示子字符串的开始（包括）和结束（不包括）的数字。这些数字表示从字符串开头开始的字符数（包括空格和标点符号）。注意字符串中的字符是从零开始编号的，而不是从一开始。

@need 800
例如，如果你评估以下表达式：

@smallexample
(substring "The quick brown fox jumped." 16 19)
@end smallexample

@noindent
你将在回显区看到@code{"fox"}。这些参数分别是字符串和两个数字。

请注意，传递给@code{substring}的字符串是一个单一的原子，即使它由多个用空格分隔的单词组成。Lisp将引号之间的所有内容都计为字符串的一部分，包括空格。你可以将@code{substring}函数看作是一种原子粒子解体器，因为它从一个否则不可分割的原子中提取了一部分。但是，@code{substring}只能从参数是字符串的原子中提取子字符串，而不能从其他类型的原子（如数字或符号）中提取。

@node Args as Variable or List
@subsection 参数作为变量或列表的值

参数可以是一个符号，在评估时返回一个值。例如，当单独评估符号@code{fill-column}时，它会返回一个数字。这个数字可以在加法中使用。

@need 1250
将光标定位到以下表达式后，键入@kbd{C-x C-e}：

@smallexample
(+ 2 fill-column)
@end smallexample

@noindent
该值将是比仅评估@code{fill-column}得到的数字多两个。对我来说，这是74，因为我的@code{fill-column}值是72。

正如我们刚刚看到的，参数可以是在评估时返回值的符号。此外，参数还可以是在评估时返回值的列表。例如，在以下表达式中，函数@code{concat}的参数是字符串@w{@code{"The "}}和@w{@code{" red foxes."}}，以及列表@code{(number-to-string (+ 2 fill-column))}。

@smallexample
(concat "The " (number-to-string (+ 2 fill-column)) " red foxes.")
@end smallexample

@noindent
如果你评估这个表达式——如果像我的Emacs一样，@code{fill-column}评估为72——@code{"The 74 red foxes."}将出现在回显区。 (注意，你必须在单词@samp{The}后面和单词@samp{red}前面加上空格，这样它们才会出现在最终的字符串中。函数@code{number-to-string}将加法函数返回的整数转换为字符串。@code{number-to-string}也被称为@code{int-to-string}。)

@node Variable Number of Arguments
@subsection 可变数量的参数
@cindex 可变数量的参数
@cindex 参数，可变数量的

一些函数，如@code{concat}，@code{+}或@code{*}，可以接受任意数量的参数。（@code{*}是乘法的符号。）这可以通过以通常的方式评估以下每个表达式来看到。在回显区域中看到的内容在此文本中以@samp{@result{}}打印出来，你可以将其理解为“求值为”。

@need 1250
在第一组中，函数没有参数：

@smallexample
@group
(+)       @result{} 0

(*)       @result{} 1
@end group
@end smallexample

@need 1250
在这一组中，函数每个都有一个参数：

@smallexample
@group
(+ 3)     @result{} 3

(* 3)     @result{} 3
@end group
@end smallexample

@need 1250
在这一组中，函数每个都有三个参数：

@smallexample
@group
(+ 3 4 5) @result{} 12

(* 3 4 5) @result{} 60
@end group
@end smallexample

@node Wrong Type of Argument
@subsection 使用错误类型的对象作为参数
@cindex 错误类型的参数
@cindex 参数，错误类型的

当一个函数被传递一个错误类型的参数时，Lisp解释器会产生一个错误消息。例如，@code{+}函数期望其参数的值为数字。作为实验，我们可以传递给它带引号的符号@code{hello}，而不是一个数字。将光标放在以下表达式后，然后输入@kbd{C-x C-e}：

@smallexample
(+ 2 'hello)
@end smallexample

@noindent
当你这样做时，将生成一个错误消息。发生的情况是，@code{+}试图将2添加到@code{'hello}返回的值，但@code{'hello}返回的值是符号@code{hello}，而不是一个数字。只有数字可以相加。所以@code{+}无法执行其加法运算。

@need 1250
你将创建并进入一个@file{*Backtrace*}缓冲区，其中显示：

@noindent
@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error:
         (wrong-type-argument number-or-marker-p hello)
  +(2 hello)
  eval((+ 2 'hello) nil)
  elisp--eval-last-sexp(t)
  eval-last-sexp(nil)
  funcall-interactively(eval-print-last-sexp nil)
  call-interactively(eval-print-last-sexp nil nil)
  command-execute(eval-print-last-sexp)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@need 1250
和往常一样，错误消息试图提供帮助，并在学会如何阅读后变得有意义。@footnote{@code{(quote hello)}是@code{'hello}缩写的扩展。}

错误消息的第一部分很简单，它说@samp{wrong type argument}。接下来是神秘的行话词@samp{number-or-marker-p}。这个词试图告诉你@code{+}期望的参数类型。

符号@code{number-or-marker-p}表示Lisp解释器正在尝试确定所呈现的信息（参数的值）是一个数字还是一个标记（表示缓冲区位置的特殊对象）。它的操作是测试@code{+}是否被赋予要相加的数字。它还测试参数是否是一种称为标记的东西，这是Emacs Lisp的一个特定特性。（在Emacs中，缓冲区中的位置被记录为标记。当使用@kbd{C-@@}或@kbd{C-@key{SPC}}命令设置标记时，其位置被保留为标记。标记可以被视为一个数字---表示该位置距离缓冲区开头的字符数。在Emacs Lisp中，@code{+}可以用于将标记位置的数值作为数字相加。

@cindex @samp{predicate} 的定义
@code{number-or-marker-p}中的@samp{p}体现了Lisp编程早期实践的一种做法。@samp{p}代表@dfn{谓词}。在早期Lisp研究者使用的行话中，谓词是指一个函数，用于确定某个属性是否为真或为假。因此，@samp{p}告诉我们@code{number-or-marker-p}是一个函数的名称，该函数确定所提供的参数是否为数字或标记。其他以@samp{p}结尾的Lisp符号包括@code{zerop}，一个测试其参数是否为零值的函数，以及@code{listp}，一个测试其参数是否为列表的函数。

最后，错误消息的最后部分是符号@code{hello}。这是传递给@code{+}的参数的值。如果相加操作传递了正确类型的对象，传递的值将是一个数字，如37，而不是像@code{hello}这样的符号。但那样你就不会收到错误消息。

@node message
@subsection @code{message} 函数
@findex message

类似于@code{+}函数，@code{message}函数接受可变数量的参数。它用于向用户发送消息，非常实用，我们将在这里描述它。

@need 1250
消息将被打印在回显区。例如，通过评估以下列表，您可以在回显区中打印一条消息：

@smallexample
(message "This message appears in the echo area!")
@end smallexample

双引号之间的整个字符串是一个单一的参数，并被整体打印出来。（请注意，在这个例子中，消息本身将在回显区中用双引号括起来；这是因为您看到了@code{message}函数返回的值。在您编写的程序中，@code{message}的大多数用法将作为副作用将文本在回显区中打印出来，而不带引号。@xref{multiply-by-seven in detail, , @code{multiply-by-seven} in
detail}, 了解其中的一个示例。）

然而，如果在带引号的字符字符串中有一个@samp{%s}，@code{message}函数不会像这样打印@samp{%s}，而是查看跟随字符串的参数。它评估第二个参数，并在字符串中@samp{%s}的位置打印该值。

@need 1250
您可以通过将光标定位在以下表达式之后，然后键入@kbd{C-x C-e}来查看这一点：

@smallexample
(message "The name of this buffer is: %s." (buffer-name))
@end smallexample

@noindent
在Info中，@code{"The name of this buffer is: *info*."} 将出现在回显区。函数 @code{buffer-name} 返回缓冲区的名称作为字符串，@code{message} 函数将其插入到 @code{%s} 的位置。

要将值以整数形式打印，可以使用 @samp{%d}，与 @samp{%s} 的使用方式相同。例如，要在回显区中打印一条消息，指出 @code{fill-column} 的值，请评估以下内容：

@smallexample
(message "The value of fill-column is %d." fill-column)
@end smallexample

@noindent
在我的系统上，当我评估这个列表时，@code{"The value of fill-column is 72."} 将出现在我的回显区@footnote{实际上，你可以使用 @code{%s} 打印一个数字。它是非具体的。@code{%d} 只打印小数点左边的数字部分，而不包括任何非数字内容。}。

如果在引用的字符串中有多个 @samp{%s}，则在第一个 @samp{%s} 的位置打印跟在引用字符串后的第一个参数的值，并在第二个 @samp{%s} 的位置打印第二个参数的值，依此类推。

@need 1250
例如，如果你评估以下内容，

@smallexample
@group
(message "There are %d %s in the office!"
         (- fill-column 14) "pink elephants")
@end group
@end smallexample

@noindent
你的回显区将显示一条相当奇特的消息。在我的系统上，它会显示，@code{"There are 58 pink elephants in the office!"}。

表达式@code{(- fill-column 14)}被评估，生成的数字插入到@samp{%d}的位置；双引号中的字符串@code{"pink elephants"}被视为单个参数，插入到@samp{%s}的位置。（也就是说，双引号之间的字符串评估为它本身，就像一个数字一样。）

最后，这里有一个稍微复杂的例子，不仅说明了一个数字的计算，而且还展示了如何在一个表达式中使用另一个表达式来生成替代@samp{%s}的文本：

@smallexample
@group
(message "He saw %d %s"
         (- fill-column 32)
         (concat "red "
                 (substring
                  "The quick brown foxes jumped." 16 21)
                 " leaping."))
@end group
@end smallexample

在这个例子中，@code{message}有三个参数：字符串@code{"He saw %d %s"}，表达式@code{(- fill-column 32)}，以及以@code{concat}函数开头的表达式。通过评估@code{(- fill-column 32)}生成的值插入到@samp{%d}的位置；以及通过评估以@code{concat}开头的表达式生成的值插入到@samp{%s}的位置。

当你的填充列为70时，评估这个表达式，消息@code{"He saw 38 red foxes leaping."}将出现在你的回显区。

@node set & setq
@section 设置变量的值
@cindex 变量，设置值
@cindex 设置变量的值

@cindex @samp{bind}定义
有几种方式可以给一个变量赋值。其中一种方式是使用函数@code{set}或特殊形式@code{setq}。另一种方式是使用@code{let}（@pxref{let}）。（这个过程的行话术语是将变量@dfn{bind}到一个值上。）

以下章节不仅描述了@code{set}和@code{setq}的工作方式，还说明了如何传递参数。

@menu
* Using set::                  设置值。
* Using setq::                 设置引用值。
* Counting::                      使用@code{setq}进行计数。
@end menu

@node Using set
@subsection 使用 @code{set}
@findex set

要将符号 @code{flowers} 的值设置为列表 @code{'(rose violet daisy buttercup)}，请通过将光标定位在表达式后并键入 @kbd{C-x C-e} 来评估以下表达式。

@smallexample
(set 'flowers '(rose violet daisy buttercup))
@end smallexample

@noindent
列表 @code{(rose violet daisy buttercup)} 将出现在回显区域。这是由 @code{set} 函数@emph{返回}的内容。作为副作用，符号 @code{flowers} 被绑定到该列表；也就是说，可以将符号 @code{flowers} 视为变量，然后将该列表赋给它作为值。（顺便说一下，这个过程说明了对于Lisp解释器来说，设置值是我们人类感兴趣的主要效果。这是因为如果Lisp函数没有出错，它必须返回一个值，但只有在设计为具有副作用时才会有副作用。）

在评估 @code{set} 表达式后，可以评估符号 @code{flowers}，它将返回刚刚设置的值。这是该符号。将光标放在其后，然后键入 @kbd{C-x C-e}。

@smallexample
flowers
@end smallexample

@noindent
当你评估 @code{flowers} 时，列表 @code{(rose violet daisy buttercup)} 将出现在回显区域。

顺便说一下，如果你评估 @code{'flowers}，在带引号的变量前面，你将在回显区域看到符号本身，即 @code{flowers}。这是带引号的符号，所以你可以试一下：

@smallexample
'flowers
@end smallexample

还要注意，当你使用 @code{set} 时，需要引用 @code{set} 的两个参数，除非你想要它们被评估。因为我们不想让任何一个参数被评估，所以变量 @code{flowers} 和列表 @code{(rose violet daisy buttercup)} 都被引用。（当你使用 @code{set} 而不引用其第一个参数时，第一个参数在执行任何其他操作之前被评估。如果你这样做而且 @code{flowers} 没有一个已经存在的值，你会得到一个错误消息，指明 @samp{Symbol's value as variable is void}；另一方面，如果在评估后 @code{flowers} 返回了一个值，@code{set} 将尝试设置返回的值。有些情况下这是函数正确的行为，但这样的情况很少见。）

@node Using setq
@subsection 使用 @code{setq}
@findex setq

实际上，几乎总是对@code{set}的第一个参数加引号。@code{set}和引用的第一个参数的组合是如此常见，以至于它有自己的名称：特殊形式@code{setq}。这个特殊形式与@code{set}几乎相同，只是第一个参数被@code{setq}自动引用，因此您不需要自己输入引号。此外，作为额外的便利，@code{setq}允许您在一个表达式中设置多个不同的变量为不同的值。

为了使用@code{setq}将变量@code{carnivores}的值设置为列表@code{'(lion tiger leopard)}，可以使用以下表达式：

@smallexample
(setq carnivores '(lion tiger leopard))
@end smallexample

@noindent
这与使用@code{set}完全相同，只是@code{setq}自动引用了第一个参数。（@code{setq}中的@samp{q}表示@code{quote}。）

@need 1250
使用@code{set}，表达式如下：

@smallexample
(set 'carnivores '(lion tiger leopard))
@end smallexample

此外，@code{setq}还可以用于为不同的变量分配不同的值。第一个参数绑定到第二个参数的值，第三个参数绑定到第四个参数的值，依此类推。例如，您可以使用以下表达式将树的列表分配给符号@code{trees}，将食草动物的列表分配给符号@code{herbivores}：

@smallexample
@group
(setq trees '(pine fir oak maple)
      herbivores '(gazelle antelope zebra))
@end group
@end smallexample

@noindent
（表达式同样可以在一行上，但它可能不适合一页；并且人们更容易阅读格式良好的列表。）

尽管我一直在使用术语“分配”，但还有一种理解@code{set}和@code{setq}运作方式的方式；即@code{set}和@code{setq}使符号@emph{指向}列表。这种思考方式非常常见，在接下来的章节中，我们将至少遇到一个其名称中包含“指针”的符号。之所以选择这个名称，是因为符号有一个值，具体来说是一个列表，与之相关联；或者，换句话说，该符号被设置为指向该列表。

@node Counting
@subsection 计数
@cindex 计数

以下是一个示例，展示了如何在计数器中使用@code{setq}。您可以使用这种方法来计算程序的某个部分重复的次数。首先将一个变量设置为零；然后在程序重复自身时每次将该数字加一。为此，您需要一个用作计数器的变量，以及两个表达式：一个初始的@code{setq}表达式，将计数器变量设置为零；和第二个@code{setq}表达式，在每次评估时递增计数器。

@smallexample
@group
(setq counter 0)                ; @r{我们称之为初始化器。}

(setq counter (+ counter 1))    ; @r{这是递增器。}

counter                         ; @r{这是计数器。}
@end group
@end smallexample

@noindent
（在@samp{;}之后的文本是注释。@xref{Change a defun, , 修改函数定义}.）

如果您评估这些表达式中的第一个，即初始化器@code{(setq counter 0)}，然后评估第三个表达式@code{counter}，数字@code{0}将显示在回显区域中。然后，如果您评估第二个表达式，即递增器@code{(setq counter (+ counter 1))}，计数器将获得值1。因此，如果您再次评估@code{counter}，数字@code{1}将显示在回显区域中。每次评估第二个表达式时，计数器的值将递增。

当您评估递增器@code{(setq counter (+ counter 1))}时，Lisp解释器首先评估最内层的列表；这是加法。为了评估此列表，它必须评估变量@code{counter}和数字@code{1}。当它评估变量@code{counter}时，它会得到它的当前值。它将这个值和数字@code{1}传递给@code{+}，将它们相加。然后，总和作为内部列表的值返回，并传递给@code{setq}，将变量@code{counter}设置为这个新值。因此，变量@code{counter}的值被更改。

@node Summary
@section 总结

学习 Lisp 就像攀登一座山，其中的第一部分是最陡峭的。你现在已经攀登过最困难的部分；随着你继续前进，剩下的部分会变得更容易。

@need 1000
总的来说，

@itemize @bullet

@item
Lisp 程序由表达式组成，这些表达式可以是列表或单个原子。

@item
列表由零个或多个原子或内部列表组成，它们之间由空格分隔，并用括号括起来。列表可以为空。

@item
原子可以是多字符符号，比如 @code{forward-paragraph}，也可以是单字符符号，比如 @code{+}，还可以是双引号之间的字符字符串或数字。

@item
数字在求值时等于其自身。

@item
双引号之间的字符串在求值时也等于其自身。

@item
当你对一个符号进行单独求值时，它的值会被返回。

@item
当你对一个列表进行求值时，Lisp 解释器首先查看列表中的第一个符号，然后查找与该符号绑定的函数定义。然后执行函数定义中的指令。

@item
单引号 @samp{'} 告诉 Lisp 解释器它应该按照写法返回后面的表达式，而不是像没有引号那样对其进行求值。

@item
参数是传递给函数的信息。函数的参数是通过求值列表的其余元素来计算的，其中函数是第一个元素。

@item
函数在求值时总是返回一个值（除非出现错误）；此外，它还可能执行一些是副作用的动作。在许多情况下，函数的主要目的是创建副作用。
@end itemize

@node Error Message Exercises
@section 练习

一些简单的练习：

@itemize @bullet
@item
通过评估一个适当的不在括号内的符号生成一个错误消息。

@item
通过评估一个适当的在括号之间的符号生成一个错误消息。

@item
创建一个计数器，其增量为两而不是一。

@item
编写一个在评估时在回显区域打印消息的表达式。
@end itemize

@node Practicing Evaluation
@chapter 练习评估
@cindex 练习评估
@cindex 评估练习

在学习如何在Emacs Lisp中编写函数定义之前，花一点时间评估已经编写的各种表达式是很有用的。这些表达式将是具有函数作为它们的第一个（通常是唯一的）元素的列表。由于与缓冲区相关的一些函数既简单又有趣，我们将从这些函数开始。在本节中，我们将评估其中的一些。在另一节中，我们将研究其他几个与缓冲区相关的函数的代码，以了解它们是如何编写的。

@menu
* How to Evaluate::            键入编辑命令或 @kbd{C-x C-e} 会导致评估。
* Buffer Names::               缓冲区和文件是不同的。
* Getting Buffers::               获取缓冲区本身，而不仅仅是它的名称。
* Switching Buffers::               如何切换到另一个缓冲区。
* Buffer Size & Locations::         point 的位置以及缓冲区的大小。
* Evaluation Exercise::
@end menu

@ifnottex
@node How to Evaluate
@unnumberedsec 如何进行评估
@end ifnottex

@i{每当你向Emacs Lisp发送一个编辑命令}，比如移动光标或滚动屏幕时，@i{你都在评估一个表达式，}其第一个元素是一个函数。@i{这就是Emacs的工作原理。}

@cindex @samp{交互函数}定义
@cindex @samp{命令}定义
当你键入键位时，你会导致Lisp解释器评估一个表达式，这就是你获得结果的方式。甚至键入纯文本也涉及评估一个Emacs Lisp函数，这种情况下，使用的是@code{self-insert-command}，它简单地插入你键入的字符。通过键入按键而评估的函数称为@dfn{交互}函数或@dfn{命令}；如何使函数具有交互性将在编写函数定义的章节中说明。@xref{Interactive, , 使函数具有交互性}。

除了键入键盘命令，我们已经看到第二种评估表达式的方法：将光标定位在列表后面，然后键入@kbd{C-x C-e}。这是本节其余部分将要做的事情。还有其他评估表达式的方式；当我们遇到它们时会进行描述。

除了用于练习评估之外，下面几节中显示的函数在其自身方面也是重要的。研究这些函数清晰地展示了缓冲区和文件之间的区别，如何切换到一个缓冲区以及如何确定其中的位置。

@node Buffer Names
@section 缓冲区名称
@findex buffer-name
@findex buffer-file-name

两个函数，@code{buffer-name} 和 @code{buffer-file-name}，展示了文件和缓冲区之间的区别。当你评估下面的表达式 @code{(buffer-name)} 时，缓冲区的名称会出现在回显区。当你评估 @code{(buffer-file-name)} 时，缓冲区所引用的文件的名称会出现在回显区。通常，由 @code{(buffer-name)} 返回的名称与它引用的文件的名称相同，而由 @code{(buffer-file-name)} 返回的名称是文件的完整路径名。

文件和缓冲区是两个不同的实体。文件是永久记录在计算机中的信息（除非你删除它）。另一方面，缓冲区是 Emacs 内部的信息，在编辑会话结束时（或者当你杀死缓冲区时）将会消失。通常，缓冲区包含你从文件中复制的信息；我们说缓冲区正在@dfn{访问}该文件。这份副本是你要操作和修改的。对缓冲区的更改不会影响文件，直到你保存缓冲区。当你保存缓冲区时，缓冲区被复制到文件中，因此被永久保存。

@need 1250
如果你正在 GNU Emacs 中的 Info 中阅读本文，你可以通过将光标定位在表达式后并键入 @kbd{C-x C-e} 来评估以下每个表达式。

@example
@group
(buffer-name)

(buffer-file-name)
@end group
@end example

@noindent
在 Info 中执行 @code{(buffer-name)} 时，返回的值是 @file{"*info*"}，而执行 @code{(buffer-file-name)} 时返回的值是 @file{nil}。

另一方面，在我编写这个文档时，执行 @code{(buffer-name)} 返回的值是 @file{"introduction.texinfo"}，而执行 @code{(buffer-file-name)} 返回的值是 @file{"/gnu/work/intro/introduction.texinfo"}。

@cindex @code{nil}，单词的历史
前者是缓冲区的名称，而后者是文件的名称。在 Info 中，缓冲区名称是 @file{"*info*"}。Info 没有指向任何文件，因此执行 @code{(buffer-file-name)} 的结果是 @file{nil}。符号 @code{nil} 源自拉丁语单词 "nothing"，在这种情况下，它表示该缓冲区未关联任何文件。（在 Lisp 中，@code{nil} 也用于表示 "false"，并且是空列表 @code{()} 的同义词。）

在编写文档时，我的缓冲区名称是 @file{"introduction.texinfo"}。它指向的文件名称是 @file{"/gnu/work/intro/introduction.texinfo"}。

（在这些表达式中，括号告诉 Lisp 解释器将 @w{@code{buffer-name}} 和 @w{@code{buffer-file-name}} 视为函数；没有括号，解释器将尝试将这些符号评估为变量。@xref{Variables}。）

尽管文件和缓冲区之间有区别，但你经常会发现人们在指代文件时实际上是指缓冲区，反之亦然。实际上，大多数人会说：“我正在编辑一个文件”，而不是说：“我正在编辑一个缓冲区，稍后将保存到文件。” 从上下文中几乎总能清楚人们的意思。然而，在处理计算机程序时，保持区别是重要的，因为计算机没有人类那么智能。

@cindex 缓冲区，单词的历史
顺便说一下，“缓冲区”这个词的意义来源于它作为减缓碰撞力的缓冲物。在早期计算机中，缓冲区起到了文件与计算机中央处理单元之间相互作用的缓冲作用。持有文件的磁鼓或磁带和中央处理单元是非常不同的设备，它们以各自的速度、断断续续地工作。缓冲区使它们能够有效地协同工作。最终，缓冲区从一个中介、一个临时存放的地方，发展成为工作完成的地方。这种转变有点像一个小港口发展成为一个大城市：曾经它只是在货物被装上船之前的临时仓库；然后它成为一个独立的商业和文化中心。

并非所有的缓冲区都与文件相关。例如，`*scratch*` 缓冲区没有访问任何文件。同样，`*Help*` 缓冲区也没有与任何文件相关。

在过去，当你没有 `~/.emacs` 文件，通过输入 `emacs` 命令启动 Emacs 会话时，不指定任何文件，Emacs 会以 `*scratch*` 缓冲区可见的状态启动。现在，你会看到一个启动画面。你可以按照启动画面上建议的命令之一，访问一个文件，或按 `q` 键退出启动画面并进入 `*scratch*` 缓冲区。

如果切换到 `*scratch*` 缓冲区，输入 `(buffer-name)`，将光标定位到其后，然后键入 `C-x C-e` 以评估表达式。将返回并显示 `*scratch*` 的名称在回显区。`*scratch*` 就是该缓冲区的名称。当你在 `*scratch*` 缓冲区中输入 `(buffer-file-name)` 并评估时，回显区将显示 `nil`，就像在 Info 中评估 `(buffer-file-name)` 时一样。

顺便提一下，如果你在 `*scratch*` 缓冲区中，想要将表达式返回的值显示在 `*scratch*` 缓冲区本身而不是在回显区，可以键入 `C-u C-x C-e` 而不是 `C-x C-e`。这将导致返回的值出现在表达式之后。缓冲区会看起来像这样：

@smallexample
(buffer-name)"*scratch*"
@end smallexample

@noindent
在 Info 中你不能这样做，因为 Info 是只读的，它不允许你更改缓冲区的内容。但是在任何你可以编辑的缓冲区中，你都可以这样做；当你编写代码或文档（比如这本书）时，这个功能非常有用。

@node Getting Buffers
@section 获取缓冲区
@findex current-buffer
@findex other-buffer
@cindex 获取缓冲区

函数@code{buffer-name}返回缓冲区的@emph{名称}；要获取缓冲区@emph{本身}，需要使用另一个函数：@code{current-buffer}函数。如果在代码中使用这个函数，你将得到缓冲区本身。

名称和名称所指代的对象或实体是不同的。你不是你的名字。你是一个被别人用名字指称的人。如果你要求与George交谈，而有人递给你一张写有字母@samp{G}、@samp{e}、@samp{o}、@samp{r}、@samp{g}和@samp{e}的卡片，你可能会感到有趣，但你不会满意。你不想和名字交谈，而是想和名字所指代的人交谈。缓冲区类似：临时缓冲区的名称是@file{*scratch*}，但名称不是缓冲区。要获取缓冲区本身，需要使用诸如@code{current-buffer}这样的函数。

然而，有一个小复杂性：如果在一个表达式中评估@code{current-buffer}，就像我们在这里所做的那样，你所看到的是缓冲区名称的打印表示，而不是缓冲区的内容。Emacs之所以以这种方式工作有两个原因：缓冲区可能有成千上万行长---太长了无法方便地显示；另一个缓冲区可能具有相同的内容但具有不同的名称，区分它们是很重要的。

@need 800
下面是包含该函数的表达式：

@smallexample
(current-buffer)
@end smallexample

@noindent
如果你在Emacs中通常的方式下在Info中评估这个表达式，@file{#<buffer *info*>} 将会出现在回显区。这个特殊的格式表示正在返回的是缓冲区本身，而不仅仅是它的名称。

顺便提一下，虽然你可以在程序中键入数字或符号，但不能在缓冲区的打印表示中这样做：获取缓冲区本身的唯一方式是使用诸如@code{current-buffer}的函数。

一个相关的函数是@code{other-buffer}。它返回除了当前所在的缓冲区之外最近选择的缓冲区，而不是其名称的打印表示。如果你最近在@file{*scratch*}缓冲区之间切换，@code{other-buffer}将返回该缓冲区。

@need 800
你可以通过评估以下表达式来看到这一点：

@smallexample
(other-buffer)
@end smallexample

@noindent
你应该在回显区看到@file{#<buffer *scratch*>}出现，或者是你最近切换回来的任何其他缓冲区的名称@footnote{实际上，默认情况下，如果你刚刚从中切换的缓冲区在另一个窗口中可见，@code{other-buffer}将选择你无法看到的最近的缓冲区；这是我经常忘记的一个细微之处。}。

@node Switching Buffers
@section 切换缓冲区
@findex switch-to-buffer
@findex set-buffer
@cindex 切换到缓冲区

实际上，当将@code{other-buffer}函数用作需要缓冲区参数的函数的参数时，它实际上提供了一个缓冲区。通过使用@code{other-buffer}和@code{switch-to-buffer}来切换到不同的缓冲区，我们可以看到这一点。

但首先，让我们简要介绍一下@code{switch-to-buffer}函数。当你在Info和@file{*scratch*}缓冲区之间切换以评估@code{(buffer-name)}时，你很可能会输入@kbd{C-x b}，然后在迷你缓冲区中输入@file{*scratch*}。@footnote{或者更确切地说，为了节省输入，如果默认缓冲区是@file{*scratch*}，你可能只输入@kbd{RET}，或者如果它不同，则只输入部分名称，如@code{*sc}，按下@kbd{TAB}键使其扩展为完整名称，然后输入@kbd{RET}。} 用于切换到所需缓冲区的名称。按下@kbd{C-x b}这些按键会导致Lisp解释器评估交互函数@code{switch-to-buffer}。正如我们之前所说，这就是Emacs的工作原理：不同的按键调用或运行不同的函数。例如，@kbd{C-f}调用@code{forward-char}，@kbd{M-e}调用@code{forward-sentence}等等。

通过在表达式中编写@code{switch-to-buffer}，并给它一个要切换到的缓冲区，我们可以像@kbd{C-x b}一样切换缓冲区：

@smallexample
(switch-to-buffer (other-buffer))
@end smallexample

@noindent
符号 @code{switch-to-buffer} 是列表的第一个元素，因此Lisp解释器将其视为一个函数并执行与其关联的指令。但在执行之前，解释器会注意到 @code{other-buffer} 在括号内，并首先处理该符号。@code{other-buffer} 是此列表的第一个元素（在这种情况下，也是唯一的元素），因此Lisp解释器调用或运行该函数。它返回另一个缓冲区。接下来，解释器运行 @code{switch-to-buffer}，将另一个缓冲区作为参数传递给它，这就是Emacs将要切换到的缓冲区。如果您正在Info中阅读此内容，请立即尝试。评估此表达式。（要返回，请键入 @kbd{C-x b @key{RET}}。）@footnote{请记住，此表达式将将您移动到您无法看到的最近的其他缓冲区。如果您真的想转到最近选择的缓冲区，即使您仍然可以看到它，您需要评估以下更复杂的表达式：

@smallexample
(switch-to-buffer (other-buffer (current-buffer) t))
@end smallexample

@c noindent
在这种情况下，@code{other-buffer} 的第一个参数告诉它要跳过的缓冲区（当前的缓冲区），第二个参数告诉 @code{other-buffer} 可以切换到可见的缓冲区。在常规用法中，@code{switch-to-buffer}将您带到窗口中不可见的缓冲区，因为您很可能使用 @kbd{C-x o}（@code{other-window}）转到另一个可见的缓冲区。}

在本文档后面的编程示例中，您将更频繁地看到函数 @code{set-buffer} 而不是 @code{switch-to-buffer}。这是因为计算机程序和人类之间存在一个差异：人类有眼睛，并期望在计算机终端上看到他们正在操作的缓冲区。这是如此明显，几乎不言而喻。然而，程序没有眼睛。当计算机程序在缓冲区上工作时，该缓冲区不需要在屏幕上可见。

@code{switch-to-buffer} 是为人类设计的，它执行两个不同的操作：它切换Emacs关注的缓冲区，并将窗口显示的缓冲区切换到新的缓冲区。另一方面，@code{set-buffer} 只执行一项任务：它将计算机程序的注意力切换到另一个缓冲区。屏幕上的缓冲区保持不变（当然，通常在命令运行完成之前不会发生任何变化）。

@cindex @samp{call} 定义
此外，我们刚刚介绍了另一个行话术语，即词语 @dfn{call}。当您评估一个列表，其中第一个符号是一个函数时，您正在调用该函数。该术语的使用来自于将函数视为如果您调用它可以为您做一些事情的实体的概念，就像水管工是一个实体，如果您呼叫他或她，他或她可以修理漏水一样。

@node Buffer Size & Locations
@section 缓冲区大小和点的位置
@cindex 缓冲区大小
@cindex 缓冲区大小
@cindex 点的位置
@cindex 点的位置

最后，让我们看一些相当简单的函数，@code{buffer-size}、@code{point}、@code{point-min}和@code{point-max}。它们提供有关缓冲区大小和点在其中的位置的信息。

函数@code{buffer-size}告诉您当前缓冲区的大小；也就是说，该函数返回缓冲区中字符的数量。

@smallexample
(buffer-size)
@end smallexample

@noindent
您可以通过将光标放置在表达式后，并键入@kbd{C-x C-e}来评估它。

@cindex @samp{point}定义
在Emacs中，光标的当前位置被称为@dfn{point}。表达式@code{(point)}返回一个数字，告诉您光标的位置，以字符数表示，从缓冲区开头到point的位置。

@need 1250
您可以通过以通常的方式评估以下表达式来查看point在该缓冲区的字符计数：

@smallexample
(point)
@end smallexample

@noindent
在我写这篇文章的时候，point的值是65724。@code{point}函数在本书的一些后面的示例中经常被使用。

@need 1250
point的值当然取决于它在缓冲区内的位置。如果在这个位置评估point，数字会更大：

@smallexample
(point)
@end smallexample

@noindent
对我而言，在这个位置，point的值是66043，这意味着两个表达式之间有319个字符（包括空格）。 （毫无疑问，由于我首次评估point后进行了编辑，你可能会看到不同的数字。）

@cindex @samp{narrowing}定义
函数@code{point-min}与@code{point}有些相似，但它返回当前缓冲区中point的最小允许值。这个值是1，除非启用了@dfn{narrowing}。（Narrowing是一种机制，通过它，您可以将自己或程序限制在仅对缓冲区的一部分进行操作。@xref{Narrowing & Widening, , 窄化和扩展}.）同样，函数@code{point-max}返回当前缓冲区中point的最大允许值。

@node Evaluation Exercise
@section 练习

找到您正在使用的文件，并移动到其中间。
找到其缓冲区名称、文件名称、长度以及您在文件中的位置。

@node Writing Defuns
@chapter 如何编写函数定义
@cindex 定义编写
@cindex 函数定义编写
@cindex 编写函数定义

当Lisp解释器评估一个列表时，它会查看列表上的第一个符号是否附有一个函数定义；或者换句话说，该符号是否指向一个函数定义。如果是的话，计算机将执行定义中的指令。一个具有函数定义的符号被简单地称为函数（尽管严格来说，定义是函数，符号是它的引用）。

@menu
* Primitive Functions::
* defun::                        @code{defun} 宏。
* Install::                          安装函数定义。
* Interactive::                        使函数具有交互性。
* Interactive Options::                    @code{interactive} 的不同选项。
* Permanent Installation::                      永久安装代码。
* let::                          创建并初始化局部变量。
* if::                           如果是这样怎么办？
* else::                         If--then--else 表达式。
* Truth & Falsehood::                       Lisp认为的真和假。
* save-excursion::               跟踪点和缓冲区。
* Review::
* defun Exercises::
@end menu

@ifnottex
@node Primitive Functions
@unnumberedsec 关于原始函数的一些说明
@end ifnottex
@cindex 原始函数
@cindex 函数，原始

@cindex C语言原语
@cindex 用C编写的原语
所有函数都是基于其他函数定义的，除了一些用C编写的@dfn{原始}函数。当你编写函数定义时，你将使用Emacs Lisp编写它们，并将其他函数作为构建块。你将使用的一些函数本身是用Emacs Lisp编写的（也许是由你编写的），而另一些是用C编写的原语。这些原始函数的使用方式与用Emacs Lisp编写的函数完全相同，并且其行为也相同。它们是用C编写的，以便我们可以轻松地在任何具有足够计算能力且能够运行C的计算机上运行GNU Emacs。

让我再强调一下：当你在Emacs Lisp中编写代码时，你不区分是使用用C编写的函数还是使用用Emacs Lisp编写的函数。这种区别是无关紧要的。我提到这个区别只是因为它是有趣的。实际上，除非你调查，你不会知道一个已经编写好的函数是用Emacs Lisp还是C编写的。

@node defun
@section @code{defun} 宏
@findex defun

@cindex @samp{函数定义} 已定义
在Lisp中，像 @code{mark-whole-buffer} 这样的符号附有与其关联的代码，告诉计算机在调用该函数时应该执行什么操作。这段代码称为 @dfn{函数定义}，它是通过评估以符号 @code{defun}（它是 @emph{define function} 的缩写）开头的Lisp表达式创建的。

在后续的章节中，我们将查看Emacs源代码中的函数定义，比如 @code{mark-whole-buffer}。在本节中，我们将描述一个简单的函数定义，以便您了解其外观。这个函数定义使用算术运算，因为这样做可以提供一个简单的例子。有些人不喜欢使用算术的例子；然而，如果您是这样的人，请不要绝望。在本介绍的其余部分中，我们将几乎不涉及算术或数学的代码。例子主要涉及以某种方式涉及文本的内容。

一个函数定义由跟在 @code{defun} 之后的最多五个部分组成：

@enumerate
@item
应该附加函数定义的符号的名称。

@item
将传递给函数的参数列表。如果不会传递任何参数给函数，这是一个空列表，即 @code{()}。

@item
描述函数的文档。（从技术上讲是可选的，但强烈推荐。）

@item
可选地，一个表达式，使函数具有交互性，以便您可以通过键入 @kbd{M-x}，然后输入函数的名称来使用它；或通过输入适当的键或键组。

@cindex @samp{函数体} 已定义
@item
告诉计算机要执行的代码：函数定义的 @dfn{函数体}。
@end enumerate

有助于将函数定义的五个部分视为一个模板，其中为每个部分都留有槽位：

@smallexample
@group
(defun @var{function-name} (@var{arguments}@dots{})
  "@var{optional-documentation}@dots{}"
  (interactive @var{argument-passing-info})     ; @r{可选}
  @var{body}@dots{})
@end group
@end smallexample

以一个将其参数乘以7的函数为例说明。 （此示例不是交互式的。有关此信息，请参阅@xref{Interactive,,使函数具有交互性}。）

@smallexample
@group
(defun multiply-by-seven (number)
  "将NUMBER乘以七。"
  (* 7 number))
@end group
@end smallexample

这个定义以括号和符号@code{defun}开始，后跟函数的名称。

@cindex @samp{argument list} defined
函数名称后面是一个包含将传递给函数的参数的列表。 这个列表称为@dfn{参数列表}。 在这个例子中，列表只有一个元素，即符号@code{number}。 当使用函数时，该符号将绑定到作为函数参数的值。

与选择@code{number}作为参数名称不同，我可以选择任何其他名称。 例如，我可以选择单词@code{multiplicand}。 我选择了单词“number”是因为它说明了此槽位所需的值的类型； 但是我完全可以选择单词“multiplicand”来指示在函数运作中放入此槽位的值所起的作用。 我可以称其为@code{foogle}，但那是一个不好的选择，因为它不会告诉人们它的含义。 名称的选择由程序员决定，应该选择使函数的含义清晰的名称。

确实，你可以为参数列表中的符号选择任何你喜欢的名称，甚至是在其他函数中使用的符号的名称：在参数列表中使用的名称对于该特定定义是私有的。在该定义中，该名称指的是与函数定义之外使用的同名实体不同的实体。假设在你的家庭中你有一个绰号“矮子”；当你的家庭成员提到“矮子”时，他们指的是你。但在你的家庭之外，比如在电影中，“矮子”这个名字指的是别人。因为参数列表中的名称对函数定义是私有的，你可以在函数体内改变这样一个符号的值，而不会改变它在函数外的值。这个效果类似于`let`表达式（@xref{let, , @code{let}}）。

@ignore
还要注意，我们以两种不同的方式讨论“number”这个词：一是作为代码中出现的符号，二是作为在函数评估过程中将被其他东西替换的东西的名称。在第一种情况下，@code{number}是一个符号，而不是一个数字；恰巧在函数内部，它是一个其值为相应数字的变量，但我们对它的主要关注是作为一个符号。另一方面，当我们谈论该函数时，我们关注的是我们将用一个数字替换掉@var{number}这个词。为了保持这种区别清晰，我们在这两种情况下使用不同的排版。当我们谈论这个函数，或者它的工作原理时，我们通过写@var{number}来引用这个数字。在函数本身中，我们通过写@code{number}来引用它。
@end ignore

参数列表后面是描述函数的文档字符串。这是当你键入@w{@kbd{C-h f}}和函数的名称时所看到的内容。顺便说一句，当你编写这样的文档字符串时，应该将第一行写成完整的句子，因为有些命令（比如@code{apropos}）只打印多行文档字符串的第一行。此外，如果有第二行文档字符串，不应该对其进行缩进，因为在使用@kbd{C-h f}（@code{describe-function}）时，这样看起来很奇怪。文档字符串是可选的，但它非常有用，几乎应该包含在你编写的每个函数中。

@findex * @r{(乘法)}
该示例的第三行是函数定义的主体。 （当然，大多数函数的定义要比这个长。）在这个函数中，主体是列表@code{(* 7 number)}，它表示将@var{number}的值乘以7。（在Emacs Lisp中，@code{*}是乘法的函数，就像@code{+}是加法的函数一样。）

当你使用 @code{multiply-by-seven} 函数时，参数 @code{number} 会被评估为你希望使用的实际数字。下面是展示如何使用 @code{multiply-by-seven} 的示例；但现在不要尝试评估它！

@smallexample
(multiply-by-seven 3)
@end smallexample

@noindent
在函数定义的下一部分中指定的符号 @code{number} 在实际使用函数时被绑定到值 3。请注意，尽管在函数定义中 @code{number} 处于括号中，但传递给 @code{multiply-by-seven} 函数的参数不在括号中。括号写在函数定义中，这样计算机可以确定参数列表的结束位置和函数定义的其余部分的开始位置。

如果你评估这个示例，很可能会收到错误消息。（试试看吧！）这是因为我们已经写了函数定义，但还没有告诉计算机有关定义——我们还没有在Emacs中加载函数定义。安装函数是告诉Lisp解释器函数定义的过程。安装过程在下一部分中描述。

@node Install
@section 安装函数定义
@cindex 安装函数定义
@cindex 定义安装
@cindex 函数定义安装

如果你正在 Emacs 的 Info 中阅读本文，你可以尝试执行 @code{multiply-by-seven} 函数，首先评估函数定义，然后评估 @code{(multiply-by-seven 3)}。函数定义的副本如下。将光标放在函数定义的最后一个括号之后，然后键入 @kbd{C-x C-e}。当你这样做时，@code{multiply-by-seven} 将显示在回显区域。（这意味着当评估函数定义时，它返回的值是定义的函数的名称。）与此同时，此操作安装了函数定义。

@smallexample
@group
(defun multiply-by-seven (number)
  "将 NUMBER 乘以七。"
  (* 7 number))
@end group
@end smallexample

@noindent
通过评估这个 @code{defun}，你刚刚在 Emacs 中安装了 @code{multiply-by-seven}。该函数现在与 Emacs 中的其他编辑函数（如 @code{forward-word}）一样成为 Emacs 的一部分。（@code{multiply-by-seven} 将一直保持安装状态，直到你退出 Emacs。要在每次启动 Emacs 时自动重新加载代码，请参阅 @ref{Permanent Installation, , 永久安装代码}。）

@menu
* Effect of installation::
* Change a defun::              如何更改函数定义。
@end menu

@ifnottex
@node Effect of installation
@unnumberedsubsec 安装的效果
@end ifnottex

通过评估以下示例，您可以看到安装 @code{multiply-by-seven} 的效果。将光标放在下面的表达式之后，然后键入 @kbd{C-x C-e}。数字 21 将出现在回显区域。

@smallexample
(multiply-by-seven 3)
@end smallexample

如果您愿意，可以通过键入 @kbd{C-h f}（@code{describe-function}）然后输入函数的名称 @code{multiply-by-seven} 来阅读该函数的文档。这样做时，您的屏幕上将出现一个 @file{*Help*} 窗口，内容如下：

@smallexample
@group
multiply-by-seven 是一个 Lisp 函数。

(multiply-by-seven NUMBER)

将 NUMBER 乘以七。
@end group
@end smallexample

@noindent
（要返回到屏幕上的单个窗口，请键入 @kbd{C-x 1}。）

@node Change a defun
@subsection 修改函数定义
@cindex 修改函数定义
@cindex 函数定义，如何修改
@cindex 定义，如何修改

如果你想修改 @code{multiply-by-seven} 中的代码，只需重新编写它。要将新版本安装到旧版本的位置，重新评估函数定义即可。这就是在Emacs中修改代码的方式，非常简单。

举个例子，你可以将 @code{multiply-by-seven} 函数更改为将数字加到自身七次，而不是将数字乘以七。它产生相同的答案，但是通过不同的路径。同时，我们将在代码中添加一条注释；注释是Lisp解释器忽略的文本，但对人类读者可能很有用或启发。注释是这是第二个版本。

@smallexample
@group
(defun multiply-by-seven (number)       ; @r{第二个版本。}
  "将 NUMBER 乘以七。"
  (+ number number number number number number number))
@end group
@end smallexample

@cindex Lisp 代码中的注释
注释以分号 @samp{;} 开头。在Lisp中，分号后面的一行上的所有内容都是注释。行的结尾是注释的结尾。要将注释延伸到两行或更多行，请在每一行开头加上分号。

@xref{Beginning init File, , 开始一个 @file{.emacs} 文件}，和 @ref{Comments, , 注释, elisp, GNU Emacs Lisp 参考手册}, 了解更多关于注释的信息。

你可以通过以与第一个函数相同的方式评估它来安装 @code{multiply-by-seven} 函数的这个版本：将光标放在最后一个括号后，然后输入 @kbd{C-x C-e}。

总之，这就是在Emacs Lisp中编写代码的方式：编写函数；安装它；测试它；然后进行修复或增强，并再次安装它。

@node Interactive
@section 使函数具有交互性
@cindex 交互式函数
@findex interactive

通过在文档后面紧跟以特殊形式 @code{interactive} 开头的列表，可以使函数具有交互性。用户可以通过键入 @kbd{M-x}，然后键入函数名，或者通过键入其绑定的键来调用交互式函数，例如通过键入 @kbd{C-n} 调用 @code{next-line}，或者通过键入 @kbd{C-x h} 调用 @code{mark-whole-buffer}。

有趣的是，当你以交互方式调用交互式函数时，返回的值不会自动显示在回显区。这是因为通常你调用交互式函数是为了其副作用，比如按单词或行前进，而不是为了返回的值。如果每次键入一个键时都在回显区显示返回的值，会非常分散注意力。

@menu
* Interactive multiply-by-seven::  概述。
* multiply-by-seven in detail::  交互式版本。
@end menu

@ifnottex
@node Interactive multiply-by-seven
@unnumberedsubsec 交互式 @code{multiply-by-seven}，概述
@end ifnottex

通过创建 @code{multiply-by-seven} 的交互式版本，可以演示特殊形式 @code{interactive} 的使用以及在回显区域显示值的一种方式。

@need 1250
以下是代码：

@smallexample
@group
(defun multiply-by-seven (number)       ; @r{交互式版本.}
  "将 NUMBER 乘以七。"
  (interactive "p")
  (message "结果是 %d" (* 7 number)))
@end group
@end smallexample

@noindent
您可以通过将光标放置在代码后并键入 @kbd{C-x C-e} 来安装此代码。函数的名称将出现在回显区域中。然后，您可以通过键入 @kbd{C-u} 和一个数字，然后键入 @kbd{M-x multiply-by-seven} 并按 @key{RET} 使用此代码。回显区域中将出现短语 @samp{结果是 @dots{}}，后面跟着乘积。

更一般地说，可以通过以下两种方式调用这样的函数：

@enumerate
@item
通过键入包含要传递的数字的前缀参数，然后键入 @kbd{M-x} 和函数的名称，如 @kbd{C-u 3 M-x forward-sentence}；或者，

@item
通过键入函数绑定的键或键序列，如 @kbd{C-u 3 M-e}。
@end enumerate

@noindent
刚才提到的两个示例均以相同的方式工作，将光标向前移动三个句子。 (由于 @code{multiply-by-seven} 未绑定到键，它无法用作绑定键的示例。)

(@xref{Key Bindings, , 一些按键绑定}, 了解如何将命令绑定到键。)

通过键入数字键后跟一个数字，例如 @kbd{M-3 M-e}，或者通过键入 @kbd{C-u} 然后是一个数字，例如 @kbd{C-u 3 M-e}，将一个 @dfn{前缀参数} 传递给交互式函数（如果键入 @kbd{C-u} 而没有数字，则默认为 4）。

@node multiply-by-seven in detail
@subsection 交互式 @code{multiply-by-seven} 详解

让我们看一下特殊形式 @code{interactive} 的使用，然后再看一下@code{multiply-by-seven} 的交互版本中的函数 @code{message}。你会记得该函数定义如下：

@smallexample
@group
(defun multiply-by-seven (number)       ; @r{交互版本。}
  "将 NUMBER 乘以七。"
  (interactive "p")
  (message "结果是 %d" (* 7 number)))
@end group
@end smallexample

在这个函数中，表达式 @code{(interactive "p")} 是一个包含两个元素的列表。@code{"p"} 告诉 Emacs 将前缀参数传递给函数，并将其值用作函数的参数。

@need 1000
参数将是一个数字。这意味着在以下行中，符号@code{number} 将绑定到一个数字：

@smallexample
(message "结果是 %d" (* 7 number))
@end smallexample

@need 1250
@noindent
例如，如果你的前缀参数是 5，Lisp 解释器将将该行解释为：

@smallexample
(message "结果是 %d" (* 7 5))
@end smallexample

@noindent
(如果你在 GNU Emacs 中阅读此文，你可以自行评估这个表达式。)首先，解释器将评估内部列表，即 @code{(* 7 5)}。这将返回一个值为 35。接下来，它将评估外部列表，将列表的第二个和随后的元素的值传递给函数 @code{message}。

正如我们所见，@code{message} 是一个专为向用户发送单行消息而设计的 Emacs Lisp 函数。（@xref{message, , The @code{message} function}。）总体而言，@code{message} 函数会将其第一个参数原样打印在回显区域，但会替换@samp{%d} 或 @samp{%s}（以及我们未提及的其他各种 %-sequences）的出现。当它看到控制序列时，该函数会查找第二个或随后的参数，并在字符串中的控制序列位置打印参数的值。

在交互式 @code{multiply-by-seven} 函数中，控制字符串是 @samp{%d}，需要一个数字，而通过评估 @code{(* 7 5)} 返回的值是数字 35。因此，数字 35 将在 @samp{%d} 的位置打印，消息为 @samp{结果是 35}。

（请注意，当调用函数 @code{multiply-by-seven} 时，消息会以无引号形式打印，但调用 @code{message} 时，文本将以双引号形式打印。这是因为 @code{message} 返回的值是在评估其第一个元素为 @code{message} 的表达式时出现在回显区域中的内容；但在嵌入函数中时，@code{message} 以副作用的方式打印文本，没有引号。）

@node Interactive Options
@section @code{interactive} 的不同选项
@cindex @code{interactive} 的选项
@cindex 交互选项

在例子中，@code{multiply-by-seven} 使用 @code{"p"} 作为@code{interactive} 的参数。这个参数告诉 Emacs 解释你的输入，无论是 @kbd{C-u} 后跟一个数字还是 @key{META} 后跟一个数字，都是将该数字作为参数传递给函数。Emacs 预定义了超过二十个字符，可以用于 @code{interactive}。在几乎所有情况下，这些选项之一将使你能够以交互方式向函数传递正确的信息。(@xref{Interactive Codes, , @code{interactive} 代码章节, elisp, GNU Emacs Lisp 参考手册}.)

@need 1250
考虑函数 @code{zap-to-char}。它的交互表达式为

@c FIXME: zap-to-char 的交互表达式已更改
@c (在2012-04-10)。

@smallexample
(interactive "p\ncZap to char: ")
@end smallexample

@code{interactive} 的参数的第一部分是 @samp{p}，这是你已经熟悉的。这个参数告诉 Emacs 解释一个前缀，作为传递给函数的数字。你可以通过键入 @kbd{C-u} 后跟一个数字或者键入 @key{META} 后跟一个数字来指定前缀。前缀是指定的字符数。因此，如果你的前缀是三，指定的字符是@samp{x}，那么你将删除所有文本，包括第三个 @samp{x}。如果你没有设置前缀，那么你将删除所有文本，包括指定的字符，但不包括之后的文本。

@samp{c} 告诉函数要删除的字符的名称。

更正式地说，具有两个或更多参数的函数可以通过向跟随 @code{interactive} 的字符串添加部分来将信息传递给每个参数。当你这样做时，信息将按照它在@code{interactive} 列表中指定的顺序传递给每个参数。在字符串中，每个部分都由一个 @samp{\n}（换行符）与下一个部分分隔开。例如，你可以在 @samp{p} 后面加上一个 @samp{\n} 和一个 @samp{cZap to char:}。这将导致 Emacs 传递前缀参数的值（如果有的话）和字符。

在这种情况下，函数定义如下，其中 @code{arg} 和 @code{char} 是由 @code{interactive} 绑定的前缀参数和指定字符：

@smallexample
@group
(defun @var{name-of-function} (arg char)
  "@var{documentation}@dots{}"
  (interactive "p\ncZap to char: ")
  @var{body-of-function}@dots{})
@end group
@end smallexample

@noindent
（在提示符的冒号后加一个空格使其看起来更好。@xref{copy-to-buffer, , 函数 @code{copy-to-buffer} 的定义}，提供一个例子。）

当函数不接受参数时，@code{interactive} 不需要任何参数。这样的函数包含简单的表达式 @code{(interactive)}。@code{mark-whole-buffer} 函数就是这样的一个例子。

或者，如果特殊的字母代码不适合你的应用程序，你可以将自己的参数作为列表传递给 @code{interactive}。

@xref{append-to-buffer, , 函数 @code{append-to-buffer} 的定义}，提供一个例子。@xref{Using Interactive, , 使用 @code{Interactive}, elisp, GNU Emacs Lisp 参考手册}，提供有关这一技术的更完整解释。

@node Permanent Installation
@section 永久安装代码
@cindex 永久安装代码
@cindex 永久性代码安装
@cindex 代码安装

当通过评估来安装函数定义时，它将一直保持安装状态，直到退出 Emacs。下次启动 Emacs 时，除非重新评估函数定义，否则该函数将不会安装。

在某个时刻，您可能希望在每次启动新的 Emacs 会话时自动安装代码。有几种方法可以实现这一点：

@itemize @bullet
@item
如果您的代码只是针对您个人的，您可以将函数定义的代码放入您的 @file{.emacs} 初始化文件中。当您启动 Emacs 时，您的 @file{.emacs} 文件会自动评估，并安装其中的所有函数定义。@xref{Emacs Initialization, , 您的 @file{.emacs} 文件}。

@item
或者，您可以将要安装的函数定义放入一个或多个单独的文件中，并使用 @code{load} 函数使 Emacs 评估并安装这些文件中的每个函数。@xref{Loading Files, , 加载文件}。

@item
第三，如果您有整个站点都会使用的代码，通常将其放入一个名为 @file{site-init.el} 的文件中，在构建 Emacs 时加载该文件。这使得代码对使用您的计算机的每个人都可用。（请参阅 Emacs 发行版的 @file{INSTALL} 文件。）
@end itemize

最后，如果您的代码是每个使用 Emacs 的人都可能需要的，您可以将其发布到计算机网络上，或将副本发送给自由软件基金会。（在执行此操作时，请使用许可证许可代码及其文档，允许其他人运行、复制、研究、修改和重新分发代码，并保护您免受他人夺走您的工作的风险。）如果您向自由软件基金会发送代码的副本，并正确保护自己和其他人，它可能会包含在下一个 Emacs 发布版中。在很大程度上，这就是 Emacs 在过去几年中发展的方式，通过捐赠。

@node let
@section @code{let}
@findex let

@code{let}表达式是Lisp中的一种特殊形式，你在大多数函数定义中都需要使用它。

@code{let}用于以一种方式将符号绑定到值，使得Lisp解释器不会将该变量与不属于函数的同名变量混淆。

为了理解为什么需要@code{let}特殊形式，考虑以下情况：假设你拥有一所房子，通常将其称为“房子”，就像在句子中说：“房子需要粉刷。” 如果你正在访问朋友，而你的主人提到“房子”，他可能是在指的是@emph{他}的房子，而不是你的，也就是说，是另一座房子。

如果你的朋友正在指他的房子，而你认为他正在指你的房子，那么可能会产生一些混乱。在Lisp中，如果在一个函数内部使用的变量与另一个函数内部使用的同名变量相同，并且两者意图不是引用相同的值，则可能发生类似的情况。@code{let}特殊形式防止了这种混淆。

@menu
* Prevent confusion::
* Parts of let Expression::
* Sample let Expression::
* Uninitialized let Variables::
@end menu

@ifnottex
@node Prevent confusion
@unnumberedsubsec @code{let} 避免混淆
@end ifnottex

@cindex @samp{局部变量} 定义
@cindex @samp{变量, 局部}, 定义
特殊形式 @code{let} 可以避免混淆。@code{let} 创建一个@dfn{局部变量}的名称，它会遮蔽任何在 @code{let} 表达式之外使用相同名称的情况。这就像理解当你的主机提到“房子”时，他指的是他的房子，而不是你的房子一样。（在参数列表中使用的符号也是同样的道理。@xref{defun, , @code{defun} 宏}。）

由 @code{let} 表达式创建的局部变量只在 @code{let} 表达式本身（以及在 @code{let} 表达式内调用的表达式中）中保持其值；这些局部变量在 @code{let} 表达式之外没有影响。

另一种理解 @code{let} 的方式是，它就像一个临时和局部的 @code{setq}。由 @code{let} 设置的值在 @code{let} 结束时会自动撤销。这个设置只影响在 @code{let} 表达式边界内的表达式。在计算机科学的术语中，我们会说符号的绑定仅在 @code{let} 表单中调用的函数中可见；在 Emacs Lisp 中，默认的作用域是动态的，而不是词法的。 （非默认的词法绑定在本手册中未讨论。）

@code{let} 可以一次创建多个变量。此外，@code{let} 为它创建的每个变量都提供一个初始值，可以是你指定的值，也可以是 @code{nil}。（在术语中，这是将变量绑定到值。）在 @code{let} 创建并绑定了变量之后，它会执行 @code{let} 主体中的代码，并返回主体中最后一个表达式的值，作为整个 @code{let} 表达式的值。（“执行”是一个术语，指的是评估列表；它源自“实施”一词的使用，意味着“实际生效”（@cite{Oxford English Dictionary}）。由于你评估一个表达式来执行一个动作，“执行”已经演变为“评估”的同义词。）

@node Parts of let Expression
@subsection @code{let} 表达式的组成部分
@cindex @code{let} 表达式，组成部分
@cindex @code{let} 表达式的组成

@cindex @samp{varlist} 的定义
一个 @code{let} 表达式包含三个部分。第一部分是符号 @code{let}。第二部分是一个列表，称为@dfn{varlist}，其中每个元素要么是一个单独的符号，要么是一个两元素列表，其中第一个元素是一个符号。@code{let} 表达式的第三部分是 @code{let} 的主体。主体通常包含一个或多个列表。

@need 800
@code{let} 表达式的模板如下：

@smallexample
(let @var{varlist} @var{body}@dots{})
@end smallexample

@noindent
varlist 中的符号是由 @code{let} 特殊形式给予初始值的变量。单独的符号被赋予 @code{nil} 的初始值；而每个作为两元素列表的第一个元素的符号则被绑定到 Lisp 解释器评估第二个元素时返回的值。

因此，varlist 可以看起来像这样：@code{(thread (needles 3))}。在这种情况下，在 @code{let} 表达式中，Emacs 将符号 @code{thread} 绑定到初始值 @code{nil}，并将符号 @code{needles} 绑定到初始值 3。

当编写 @code{let} 表达式时，你要做的是将适当的表达式放入 @code{let} 表达式模板的各个部分。

如果 varlist 由两元素列表组成，这在许多情况下是常见的，那么 @code{let} 表达式的模板如下：

@smallexample
@group
(let ((@var{variable} @var{value})
      (@var{variable} @var{value})
      @dots{})
  @var{body}@dots{})
@end group
@end smallexample

@node Sample let Expression
@subsection 示例 @code{let} 表达式
@cindex 示例 @code{let} 表达式
@cindex @code{let} 表达式示例

以下表达式创建并为两个变量 @code{zebra} 和 @code{tiger} 赋予初始值。@code{let} 表达式的主体是一个调用 @code{message} 函数的列表。

@smallexample
@group
(let ((zebra "条纹")
      (tiger "凶猛"))
  (message "一种动物有 %s，另一种是 %s。"
           zebra tiger))
@end group
@end smallexample

在这里，varlist 是 @code{((zebra "条纹") (tiger "凶猛"))}。

这两个变量是 @code{zebra} 和 @code{tiger}。每个变量都是两元素列表的第一个元素，每个值都是其两元素列表的第二个元素。在 varlist 中，Emacs 将变量 @code{zebra} 绑定到值 @code{"条纹"}@footnote{根据Jared Diamond在 @cite{枪炮、病菌与钢铁} 中的说法，“@dots{} 斑马在变老时变得异常危险”，但这里的说法是它们不会像老虎一样变得凶猛。(1997, W. W. Norton 和 Co., ISBN 0-393-03894-2, 第171页)}，并将变量 @code{tiger} 绑定到值 @code{"凶猛"}。在这个例子中，两个值都是字符串。这些值同样可以是另一个列表或符号。@code{let} 的主体紧随包含变量的列表之后。在这个例子中，主体是一个列表，使用 @code{message} 函数在回显区域打印一个字符串。

@need 1500
您可以按照通常的方式评估这个示例，将光标放在最后一个括号后，然后键入 @kbd{C-x C-e}。这样做时，回显区域将显示以下内容：

@smallexample
"一种动物有条纹，另一种是凶猛。"
@end smallexample

正如我们之前看到的，@code{message} 函数打印其第一个参数，除了 @samp{%s}。在这个例子中，变量 @code{zebra} 的值将打印在第一个 @samp{%s} 的位置，而变量 @code{tiger} 的值将打印在第二个 @samp{%s} 的位置。

@node Uninitialized let Variables
@subsection @code{let} 语句中的未初始化变量
@cindex 未初始化的 @code{let} 变量
@cindex @code{let} 变量未初始化

如果在 @code{let} 语句中不将变量绑定到特定的初始值，它们将自动绑定到初始值为 @code{nil}，如下面的表达式所示：

@smallexample
@group
(let ((birch 3)
      pine
      fir
      (oak 'some))
  (message
   "这里有 %d 个变量，分别具有 %s、%s 和 %s 的值。"
   birch pine fir oak))
@end group
@end smallexample

@noindent
这里，变量列表是 @code{((birch 3) pine fir (oak 'some))}。

@need 1250
如果以通常的方式评估此表达式，将在你的回显区域中看到以下内容：

@smallexample
"这里有 3 个变量，分别具有 nil、nil 和 some 的值。"
@end smallexample

@noindent
在这个例子中，Emacs将符号 @code{birch} 绑定到数字3，将符号 @code{pine} 和 @code{fir} 绑定到 @code{nil}，并将符号 @code{oak} 绑定到值 @code{some}。

注意，在 @code{let} 的第一部分中，变量 @code{pine} 和 @code{fir} 作为不带括号的原子独立存在；这是因为它们被绑定到 @code{nil}，即空列表。但是，@code{oak} 被绑定到 @code{some}，因此是列表 @code{(oak 'some)} 的一部分。类似地，@code{birch} 被绑定到数字3，因此在具有该数字的列表中。 (由于数字在评估时为自身，因此数字不需要引用。此外，消息中使用 @samp{%d} 而不是 @samp{%s} 打印数字。) 这四个变量作为一个组被放入列表中，以将它们与 @code{let} 的主体分开。

@node if
@section 特殊形式 @code{if}
@findex if
@cindex 使用 @code{if} 的条件语句

另一种特殊形式是条件语句 @code{if}。该形式用于指导计算机进行决策。您可以编写不使用 @code{if} 的函数定义，但它被经常使用且足够重要，因此在这里进行介绍。例如，在函数 @code{beginning-of-buffer} 的代码中就使用了它。

@code{if} 的基本思想是，@emph{如果}测试为真，@emph{那么}就会评估一个表达式。如果测试不为真，则不会评估该表达式。例如，您可能会做出这样的决定：“如果天气暖和而且阳光明媚，那么就去海滩！”

@menu
* if in more detail::
* type-of-animal in detail::    一个 @code{if} 表达式的示例。
@end menu

@ifnottex
@node if in more detail
@unnumberedsubsec @code{if}详细说明
@end ifnottex

@cindex @samp{if-part}定义
@cindex @samp{then-part}定义
在Lisp中，@code{if}表达式不使用单词“then”；测试和动作是列表的第二个和第三个元素，其第一个元素是@code{if}。尽管如此，@code{if}表达式的测试部分通常称为@dfn{if-part}，第二个参数通常称为@dfn{then-part}。

此外，当编写@code{if}表达式时，通常将真假测试写在与符号@code{if}相同的行上，但如果测试为真，则执行的操作，即then-part，会写在第二行及后续行。这样可以使@code{if}表达式更易读。

@smallexample
@group
(if @var{true-or-false-test}
    @var{action-to-carry-out-if-test-is-true})
@end group
@end smallexample

@noindent
真假测试将是由Lisp解释器评估的表达式。

以下是一个您可以按照通常方式评估的示例。测试是数字5是否大于数字4。由于是，将打印消息@samp{5 is greater than 4!}。

@smallexample
@group
(if (> 5 4)                             ; @r{if-part}
    (message "5 is greater than 4!"))   ; @r{then-part}
@end group
@end smallexample

@noindent
（函数@code{>}测试其第一个参数是否大于其第二个参数，并在其为真时返回true。）
@findex > @r{(greater than)}

当然，在实际使用中，@code{if} 表达式中的测试将不会像表达式 @code{(> 5 4)} 中那样永远固定。相反，测试中至少一个变量将被绑定到一个预先未知的值。
（如果值在预先知道，我们就不需要运行测试了！）

例如，该值可以绑定到函数定义的参数上。在以下函数定义中，动物的特性是传递给函数的值。如果绑定到 @code{characteristic} 的值是 @code{"fierce"}，则将打印消息 @samp{It is a tiger!}；否则，将返回 @code{nil}。

@smallexample
@group
(defun type-of-animal (characteristic)
  "根据 CHARACTERISTIC 在回显区打印消息。
如果 CHARACTERISTIC 是字符串 \"fierce\"，
则警告是一只老虎。"
  (if (equal characteristic "fierce")
      (message "It is a tiger!")))
@end group
@end smallexample

@need 1500
@noindent
如果您正在 GNU Emacs 中阅读此文档，您可以按照通常的方式评估函数定义以在 Emacs 中安装它，然后可以评估以下两个表达式以查看结果：

@smallexample
@group
(type-of-animal "fierce")

(type-of-animal "striped")
@end group
@end smallexample

@c 以下句子已重新编写以防止 hbox 溢出。
@noindent
当您评估 @code{(type-of-animal "fierce")} 时，您将在回显区看到打印的以下消息：@code{"It is a tiger!"}；当您评估 @code{(type-of-animal "striped")} 时，您将在回显区看到打印的 @code{nil}。

@node type-of-animal in detail
@subsection 详细介绍 @code{type-of-animal} 函数

让我们详细看一下 @code{type-of-animal} 函数。

@code{type-of-animal} 函数的定义是通过填充两个模板而完成的，一个用于整个函数定义，另一个用于 @code{if} 表达式。

@need 1250
每个非交互式函数的模板如下：

@smallexample
@group
(defun @var{name-of-function} (@var{argument-list})
  "@var{documentation}@dots{}"
  @var{body}@dots{})
@end group
@end smallexample

@need 800
符合此模板的函数部分如下：

@smallexample
@group
(defun type-of-animal (characteristic)
  "根据 CHARACTERISTIC 在回显区域打印消息。
如果 CHARACTERISTIC 是字符串 \"fierce\"，则警告可能是老虎。"
  @var{body: the} @code{if} @var{expression})
@end group
@end smallexample

函数的名称是 @code{type-of-animal}；它接受一个参数的值。参数列表后面是多行文档字符串。在示例中包含文档字符串是一个良好的习惯，建议为每个函数定义都编写文档字符串。函数定义的主体由 @code{if} 表达式组成。

@need 800
@code{if} 表达式的模板如下：

@smallexample
@group
(if @var{true-or-false-test}
    @var{action-to-carry-out-if-the-test-returns-true})
@end group
@end smallexample

@need 1250
在 @code{type-of-animal} 函数中，@code{if} 的代码如下：

@smallexample
@group
(if (equal characteristic "fierce")
    (message "它是一只老虎！"))
@end group
@end smallexample

@need 800
在这里，true-or-false-test 是表达式：

@smallexample
(equal characteristic "fierce")
@end smallexample

在 Lisp 中，@code{equal} 是一个函数，它确定其第一个参数是否等于第二个参数。第二个参数是字符串 @code{"fierce"}，第一个参数是符号 @code{characteristic} 的值，换句话说，就是传递给该函数的参数。

在 @code{type-of-animal} 的第一个示例中，传递了参数 @code{"fierce"}。由于 @code{"fierce"} 等于 @code{"fierce"}，表达式 @code{(equal characteristic "fierce")} 返回 true。当发生这种情况时，@code{if} 会评估 @code{if} 的第二个参数或 true 部分：@code{(message "它是一只老虎！")}。

另一方面，在 @code{type-of-animal} 的第二个示例中，传递了参数 @code{"striped"}。@code{"striped"} 不等于 @code{"fierce"}，因此 true 部分不会被评估，@code{if} 表达式返回 @code{nil}。

@node else
@section If--then--else 表达式
@cindex Else

一个 @code{if} 表达式可能有一个可选的第三个参数，称为 @dfn{else-部分}，用于当真假测试返回 false 时的情况。当这种情况发生时，整个 @code{if} 表达式的第二个参数或者 then-部分 @emph{不会} 被评估，而第三个参数或 else-部分 @emph{会} 被评估。你可以将其看作是决策的“如果天气温暖且晴朗，则去海滩，否则读一本书”的多云日备选方案。

在Lisp代码中并没有写下单词 "else"；@code{if} 表达式的 else-部分在 then-部分之后。在书写的Lisp中，else-部分通常写在自己的一行上，并且比 then-部分的缩进少：

@smallexample
@group
(if @var{真假测试}
    @var{真时执行的动作}
  @var{假时执行的动作})
@end group
@end smallexample

例如，下面的 @code{if} 表达式在通常的情况下，当你对其进行求值时，会打印消息 @samp{4不大于5！}：

@smallexample
@group
(if (> 4 5)                               ; @r{if-部分}
    (message "4 falsely greater than 5!") ; @r{then-部分}
  (message "4 is not greater than 5!"))   ; @r{else-部分}
@end group
@end smallexample

@noindent
请注意，不同缩进级别使得很容易区分 then-部分 和 else-部分。（GNU Emacs 有几个命令可以自动正确缩进 @code{if} 表达式。@xref{Typing Lists, , GNU Emacs Helps You Type Lists}.）

我们可以通过在 @code{type-of-animal} 函数中加入一个 else 部分来扩展它，只需在 @code{if} 表达式中加入一个额外的部分即可。

@need 1500
如果你评估以下版本的 @code{type-of-animal} 函数定义以安装它，然后评估两个后续表达式，将不同的参数传递给函数，你就能看到这样做的后果。

@smallexample
@group
(defun type-of-animal (characteristic)  ; @r{第二个版本。}
  "根据 CHARACTERISTIC 在回显区域打印消息。
如果 CHARACTERISTIC 是字符串 \"fierce\"，
则警告是一只老虎；否则说它不凶猛。"
  (if (equal characteristic "fierce")
      (message "这是一只老虎！")
    (message "它不凶猛！")))
@end group
@end smallexample
@sp 1

@smallexample
@group
(type-of-animal "fierce")

(type-of-animal "striped")

@end group
@end smallexample

@c 为了防止 hbox 过满，以下句子已重新编写。
@noindent
当你评估 @code{(type-of-animal "fierce")} 时，你将在回显区域看到以下消息打印出来：@code{"这是一只老虎！"}；但是当你评估 @code{(type-of-animal "striped")} 时，你将看到 @code{"它不凶猛！"}。

（当然，如果 @var{characteristic} 是 @code{"ferocious"}，则将打印消息 @code{"它不凶猛！"}；这可能会产生误导！在编写代码时，你需要考虑到 @code{if} 可能会测试到这样的参数，并相应地编写你的程序。）

@node Truth & Falsehood
@section Emacs Lisp 中的真值和假值
@cindex Emacs Lisp 中的真值和假值
@cindex Emacs Lisp 中的假值和真值
@findex nil

在 @code{if} 表达式中，有一个重要的关于真值测试的方面。到目前为止，我们已经谈到“true”和“false”作为谓词的值，好像它们是新种类的 Emacs Lisp 对象一样。实际上，“false”只是我们的老朋友 @code{nil}。任何其他东西——无论什么——都是“true”。

对真值进行测试的表达式在解释时会被视为 @dfn{真}，如果它的求值结果不是 @code{nil}。换句话说，如果返回的值是一个数字，比如 47，一个字符串，比如 @code{"hello"}，或者一个符号（除了 @code{nil} 之外的任何符号），或者一个列表（只要它不是空的），甚至是一个缓冲区，测试的结果就被认为是真的！

@menu
* nil explained::               @code{nil} 有两个含义。
@end menu

@ifnottex
@node nil explained
@unnumberedsubsec @code{nil}的解释
@end ifnottex

在说明真值测试之前，我们需要解释一下 @code{nil}。

在Emacs Lisp中，符号 @code{nil} 有两个含义。首先，它表示空列表。其次，它表示假，是在真假测试返回假时返回的值。@code{nil}可以被写成空列表，@code{()}，或者写作 @code{nil}。就Lisp解释器而言，@code{()} 和 @code{nil} 是一样的。然而，人们倾向于将 @code{nil} 用于表示假，而将 @code{()} 用于表示空列表。

在Emacs Lisp中，任何不是 @code{nil}，即非空列表的值，被认为是真。这意味着如果一个求值返回了不是空列表的值，一个 @code{if} 表达式将测试为真。例如，如果一个数字被放在测试的槽位，它将被求值并返回它自己，因为这是数字在被求值时所做的。在这个条件语句中，@code{if} 表达式将测试为真。该表达式仅在通过求值表达式返回 @code{nil}，即空列表时测试为假。

通过对以下示例中的两个表达式进行求值，您可以看到这一点。

在第一个示例中，数字4作为 @code{if} 表达式中的测试被求值并返回自己；因此，表达式的then部分被求值并返回：在回显区域中显示 @samp{true}。在第二个示例中，@code{nil} 表示假；因此，表达式的else部分被求值并返回：在回显区域中显示 @samp{false}。

@smallexample
@group
(if 4
    'true
  'false)
@end group

@group
(if nil
    'true
  'false)
@end group
@end smallexample

@need 1250
顺便说一句，如果某个有用的值在返回真的测试时不可用，那么Lisp解释器将返回符号 @code{t} 代表真。例如，表达式 @code{(> 5 4)} 在被求值时返回 @code{t}，您可以通过通常的方式进行求值查看：

@smallexample
(> 5 4)
@end smallexample

@need 1250
@noindent
另一方面，如果测试为假，则该函数返回 @code{nil}。

@smallexample
(> 4 5)
@end smallexample

@node save-excursion
@section @code{save-excursion}
@findex save-excursion
@cindex Region, what it is
@cindex Preserving point and buffer
@cindex Point and buffer preservation
@findex point
@findex mark

@code{save-excursion}函数是我们将在本章中讨论的最后一个特殊形式。

在用于编辑的Emacs Lisp程序中，@code{save-excursion}函数非常常见。它保存点（point）的位置，执行函数体，然后如果点的位置发生了变化，则将点还原到其先前的位置。其主要目的是防止用户因点的意外移动而感到惊讶和困扰。

@menu
* Point and mark::              各种位置的回顾。
* Template for save-excursion::
@end menu

@ifnottex
@node Point and mark
@unnumberedsubsec 光标位置和标记
@end ifnottex

然而，在讨论 @code{save-excursion} 之前，首先回顾一下在 GNU Emacs 中点（Point）和标记（Mark）的概念可能会很有用。@dfn{点} 是光标的当前位置。光标所在的位置就是点。更准确地说，在光标位于字符之上的终端上，点位于紧接在字符之前。在 Emacs Lisp 中，点是一个整数。缓冲区中的第一个字符是编号为一，第二个是编号为二，依此类推。函数 @code{point} 返回光标的当前位置作为一个数字。每个缓冲区都有其自己的点值。

@dfn{标记} 是缓冲区中的另一个位置；它的值可以通过诸如 @kbd{C-@key{SPC}}（@code{set-mark-command}）的命令设置。如果已经设置了标记，可以使用命令 @kbd{C-x C-x}（@code{exchange-point-and-mark}）使光标跳到标记位置，并将标记设置为点的先前位置。此外，如果设置了另一个标记，前一个标记的位置将保存在标记环中。可以通过键入 @kbd{C-u C-@key{SPC}} 一次或多次将光标跳到保存的标记位置。

点和标记之间的缓冲区部分称为@dfn{区域}。许多命令在区域上起作用，包括 @code{center-region}、@code{count-words-region}、@code{kill-region} 和 @code{print-region}。

@code{save-excursion} 特殊形式保存点的位置，并在该特殊形式的主体内的代码被 Lisp 解释器评估后恢复这个位置。因此，如果点在文本的开头，某些代码将点移到缓冲区的末尾，@code{save-excursion} 将在函数主体中的表达式被评估后将点放回到它之前的位置。

在 Emacs 中，一个函数通常会在其内部工作的过程中移动点，尽管用户不希望这样。例如，@code{count-words-region} 会移动点。为了防止用户受到既意外又（从用户的角度）不必要的跳跃的困扰，通常使用 @code{save-excursion} 来保持点在用户预期的位置上。使用 @code{save-excursion} 是良好的编码风格。

为了确保代码书写规范，@code{save-excursion} 即使在其内部代码发生错误时也会恢复点的值（或者更准确地说，``在异常退出的情况下''）。这个特性非常有帮助。

除了记录点的值，@code{save-excursion} 还跟踪当前缓冲区，并在需要时进行恢复。这意味着你可以编写改变缓冲区的代码，并通过 @code{save-excursion} 切换回原始缓冲区。这就是 @code{save-excursion} 在 @code{append-to-buffer} 中的使用方式。(@xref{append-to-buffer, , @code{append-to-buffer} 的定义}.) 

@node Template for save-excursion
@subsection @code{save-excursion} 表达式的模板

@need 800
使用 @code{save-excursion} 的代码模板很简单：

@smallexample
@group
(save-excursion
  @var{body}@dots{})
@end group
@end smallexample

@noindent
函数体是一个或多个表达式，它们将按顺序由Lisp解释器求值。如果在函数体中有多个表达式，则最后一个表达式的值将作为 @code{save-excursion} 函数的返回值。函数体中的其他表达式仅用于它们的副作用；而 @code{save-excursion} 本身仅用于其副作用（即还原point的位置）。

@need 1250
更详细地说，@code{save-excursion} 表达式的模板如下：

@smallexample
@group
(save-excursion
  @var{函数体中的第一个表达式}
  @var{函数体中的第二个表达式}
  @var{函数体中的第三个表达式}
   @dots{}
  @var{函数体中的最后一个表达式})
@end group
@end smallexample

@noindent
一个表达式当然可以是一个独立的符号或一个列表。

在Emacs Lisp代码中，@code{save-excursion} 表达式经常出现在 @code{let} 表达式的体内。它的形式如下：

@smallexample
@group
(let @var{变量列表}
  (save-excursion
    @var{函数体}@dots{}))
@end group
@end smallexample

@node Review
@section 复习

在过去的几章中，我们介绍了一个宏和相当多的函数和特殊形式。这里对它们进行简要描述，以及一些尚未提到的类似函数。

@table @code
@item eval-last-sexp
评估光标前的最后一个符号表达式。除非在调用该函数时使用参数，否则该值将打印在回显区域；在这种情况下，输出将打印在当前缓冲区中。通常，此命令绑定到 @kbd{C-x C-e}。

@item defun
定义函数。此宏最多有五个部分：名称、传递给函数的参数的模板、文档、可选的交互声明和定义的主体。

@need 1250
例如，在Emacs中，@code{dired-unmark-all-marks} 的函数定义如下。

@smallexample
@group
(defun dired-unmark-all-marks ()
  "从Dired缓冲区中的所有文件中删除所有标记。"
  (interactive)
  (dired-unmark-all-files ?\r))
@end group
@end smallexample

@item interactive
声明函数可交互使用。此特殊形式后面可能跟着一个包含一个或多个部分的字符串，将信息传递给函数的参数，按顺序。这些部分还可以告诉解释器提示信息。字符串的各部分由新行，即 @samp{\n} 分隔。

@need 1000
常见的代码字符包括：

@table @code
@item b
现有缓冲区的名称。

@item f
现有文件的名称。

@item p
数值前缀参数。（注意，此处的 @code{p} 是小写。）

@item r
光标和标记，作为两个数值参数，从最小到最大。这是唯一指定两个连续参数而不是一个参数的代码字母。
@end table

@xref{Interactive Codes, , 用于 @samp{interactive} 的代码字符, elisp, GNU Emacs Lisp参考手册}，以获取完整的代码字符列表。

@item let
声明一个变量列表，用于在@code{let}体内使用，并给它们一个初始值，可以是@code{nil}或指定的值；然后评估@code{let}体内的其余表达式，并返回最后一个表达式的值。在@code{let}体内，Lisp解释器看不到与外部绑定的同名变量的值。

@need 1250
例如，

@smallexample
@group
(let ((foo (buffer-name))
      (bar (buffer-size)))
  (message
   "当前缓冲区是 %s，包含 %d 个字符。"
   foo bar))
@end group
@end smallexample

@item save-excursion
在评估此特殊形式的体之前，记录point和当前缓冲区的值。在评估完体后，恢复point和缓冲区的值。

@need 1250
例如，

@smallexample
@group
(message "我们已经在这个缓冲区中 %d 个字符。"
         (- (point)
            (save-excursion
              (goto-char (point-min)) (point))))
@end group
@end smallexample

@item if
评估函数的第一个参数；如果为真，则评估第二个参数；否则，如果存在第三个参数，则评估第三个参数。

@code{if}特殊形式被称为@dfn{条件语句}。Emacs Lisp中还有其他条件语句，但@code{if}可能是最常用的。

@need 1250
例如，

@smallexample
@group
(if (= 22 emacs-major-version)
    (message "这是22版的Emacs")
  (message "这不是22版的Emacs"))
@end group
@end smallexample

@need 1250
@item <
@itemx >
@itemx <=
@itemx >=
@code{<}函数测试其第一个参数是否小于第二个参数。相应的函数@code{>}测试第一个参数是否大于第二个参数。类似地，@code{<=}测试第一个参数是否小于或等于第二个参数，而@code{>=}测试第一个参数是否大于或等于第二个参数。在所有情况下，两个参数必须是数字或标记（标记表示缓冲区中的位置）。

@need 800
@item =
@code{=}函数测试两个参数是否相等，这两个参数都必须是数字或标记。

@need 1250
@item equal
@itemx eq
测试两个对象是否相同。@code{equal}使用“相同”一词的一种含义，而@code{eq}使用另一种含义：如果两个对象具有相似的结构和内容，例如同一本书的两个副本，则@code{equal}返回真。另一方面，@code{eq}返回真，如果两个参数实际上是同一个对象。

@findex equal
@findex eq

@need 1250
@item string<
@itemx string-lessp
@itemx string=
@itemx string-equal
@code{string-lessp}函数测试其第一个参数是否小于第二个参数。同样功能的较短名称（@code{defalias}）是@code{string<}。

@code{string-lessp}的参数必须是字符串或符号；排序是词法的，因此大小写是敏感的。使用符号的打印名称而不是符号本身。

@cindex @samp{empty string}定义
空字符串，即@samp{""}，即不包含字符的字符串，小于任何包含字符的字符串。

@code{string-equal}提供相应的相等测试。它的较短名称是@code{string=}。没有与@var{>}，@code{>=}或@code{<=}相对应的字符串测试函数。

@item message
在回显区域打印消息。第一个参数是一个字符串，可以包含@samp{%s}，@samp{%d}或@samp{%c}，用于打印紧随其后的参数的值。由@samp{%s}使用的参数必须是字符串或符号；由@samp{%d}使用的参数必须是数字。由@samp{%c}使用的参数必须是@sc{ascii}代码数字；它将被打印为具有该@sc{ascii}代码的字符。 （其他各种未提到的%-序列未在此提及。）

@item setq
@itemx set
@code{setq}特殊形式将其第一个参数的值设置为第二个参数的值。第一个参数由@code{setq}自动引用。它对后续的参数对执行相同的操作。另一个函数@code{set}只接受两个参数，并在设置其第一个参数返回的值之前评估两个参数。

@item buffer-name
没有参数时，返回缓冲区的名称，作为字符串。

@item buffer-file-name
没有参数时，返回缓冲区正在访问的文件的名称。

@item current-buffer
返回Emacs处于活动状态的缓冲区；它可能不是屏幕上可见的缓冲区。

@item other-buffer
返回最近选择的缓冲区（不包括作为参数传递给@code{other-buffer}的缓冲区和当前缓冲区）。

@item switch-to-buffer
选择Emacs处于活动状态并在当前窗口中显示的缓冲区，以便用户可以查看它。通常绑定到@kbd{C-x b}。

@item set-buffer
切换Emacs的注意力到将运行程序的缓冲区。不更改窗口显示的内容。

@item buffer-size
返回当前缓冲区中字符的数量。

@item point
返回光标当前位置的值，作为从缓冲区开头计算的整数字符数。

@item point-min
返回当前缓冲区中point的最小允许值。除非限制了缩小，否则为1。

@item point-max
返回当前缓冲区中point的最大允许值。除非限制了缩小，否则为缓冲区的末尾。
@end table

@need 1500
@node defun Exercises
@section 练习

@itemize @bullet
@item
编写一个非交互式函数，它将其参数（一个数字）的值加倍。将该函数设为交互式。

@item
编写一个函数，检查当前的@code{fill-column}值是否大于传递给函数的参数，如果是，则打印相应的消息。
@end itemize

@node Buffer Walk Through
@chapter 几个与缓冲区相关的函数

在这一章中，我们详细研究了GNU Emacs中使用的几个函数。这被称为“步进演示”。这些函数被用作Lisp代码的示例，但它们并不是虚构的例子；除了第一个简化的函数定义之外，这些函数展示了GNU Emacs中实际使用的代码。你可以从这些定义中学到很多东西。这里描述的函数都与缓冲区有关。稍后，我们将研究其他函数。

@menu
* Finding More::                  如何查找更多信息。
* simplified-beginning-of-buffer::  展示了 @code{goto-char}、
                                  @code{point-min} 和 @code{push-mark}。
* mark-whole-buffer::             几乎与 @code{beginning-of-buffer} 相同。
* append-to-buffer::              使用 @code{save-excursion} 和
                                  @code{insert-buffer-substring}。
* Buffer Related Review::                  回顾。
* Buffer Exercises::
@end menu

@node Finding More
@section 查找更多信息

@findex describe-function@r{, introduced}
@cindex 查找函数文档
在这个步骤中，我将在遇到新函数时逐一描述它，有时详细介绍，有时简要说明。如果你感兴趣，你可以随时通过输入@kbd{C-h f}，然后输入函数的名称（然后按@key{RET}）获取任何Emacs Lisp函数的完整文档。类似地，你可以通过输入@kbd{C-h v}，然后输入变量的名称（然后按@key{RET}）获取变量的完整文档。

@cindex 查找函数源码
@c 在版本22中，告诉C和Emacs Lisp的函数定义位置
此外，@code{describe-function}还会告诉你函数定义的位置。

将光标放在包含函数的文件名上，然后按@key{RET}键。在这种情况下，@key{RET}意味着@code{push-button}，而不是“return”或“enter”。Emacs将直接跳转到函数定义处。

@ignore
在版本22中不存在

如果将光标移到文件名上并按@key{RET}键，这种情况下@key{RET}意味着@code{help-follow}而不是“return”或“enter”，Emacs将直接跳转到函数定义处。
@end ignore

更一般地说，如果你想在原始源文件中查看函数，你可以使用@code{xref-find-definitions}函数跳转到它。@code{xref-find-definitions}适用于各种语言，不仅限于Lisp和C，它还适用于非编程文本。例如，@code{xref-find-definitions}将跳转到本文档的Texinfo源文件的各个节点（前提是你已经运行@command{etags}实用程序记录了Emacs附带手册中的所有节点；@pxref{Create Tags Table,,, emacs, The GNU Emacs Manual}）。

要使用@code{xref-find-definitions}命令，输入@kbd{M-.}（即，按住@key{META}键的同时按下句点键，或者按@key{ESC}键，然后输入句点键），然后在提示符处输入你想要查看源代码的函数的名称，比如@code{mark-whole-buffer}，然后输入@key{RET}。 （如果命令没有提示，带一个参数调用它：@kbd{C-u M-.}；@pxref{Interactive Options}。）Emacs将切换缓冲区并在屏幕上显示函数的源代码@footnote{
如果Emacs不是显示Lisp函数的源代码，而是询问你要访问哪个标签表，请在其主要模式为Emacs Lisp或Lisp Interaction的缓冲区中调用@kbd{M-.}。
}。要切换回当前缓冲区，输入@kbd{M-,}或@kbd{C-x b @key{RET}}。（在某些键盘上，@key{META}键标记为@key{ALT}。）

@cindex Library, 作为“文件”一词的用法
顺便说一下，包含Lisp代码的文件通常被称为@dfn{库}。这个比喻来源于专业图书馆的概念，比如法律图书馆或工程图书馆，而不是普通图书馆。每个库或文件都包含与特定主题或活动相关的函数，比如处理缩写和其他输入快捷方式的@file{abbrev.el}，以及用于帮助的@file{help.el}。（有时，多个库提供单个活动的代码，就像各种@file{rmail@dots{}}文件提供阅读电子邮件的代码一样。）在@cite{The GNU Emacs Manual}中，你会看到类似“@kbd{C-h p}命令允许你按主题关键字搜索标准的Emacs Lisp库。”的句子。

@node simplified-beginning-of-buffer
@section 一个简化的 @code{beginning-of-buffer} 定义
@findex simplified-beginning-of-buffer

@code{beginning-of-buffer} 命令是一个很好的起点函数，因为你可能熟悉它，并且它易于理解。作为交互式命令使用时，@code{beginning-of-buffer} 将光标移动到缓冲区的开头，同时在先前的位置留下标记。通常绑定到 @kbd{M-<}。

在这一节中，我们将讨论该函数的一个简化版本，展示它最常用的形式。这个简化的函数按原样工作，但不包含复杂选项的代码。在另一节中，我们将描述整个函数。(@xref{beginning-of-buffer, , @code{beginning-of-buffer} 的完整定义}。)

在查看代码之前，让我们考虑函数定义必须包含的内容：必须包括一个使函数可交互的表达式，以便通过键入 @kbd{M-x beginning-of-buffer} 或键入键序（如 @kbd{M-<}）来调用它；必须包括代码以在缓冲区中原始位置留下一个标记；必须包括将光标移动到缓冲区开头的代码。

@need 1250
以下是该函数简化版本的完整文本：

@smallexample
@group
(defun simplified-beginning-of-buffer ()
  "将光标移动到缓冲区开头；在先前位置留下标记。"
  (interactive)
  (push-mark)
  (goto-char (point-min)))
@end group
@end smallexample

与所有函数定义一样，此定义在宏 @code{defun} 之后有五个部分：

@enumerate
@item
名称：在这个例子中是 @code{simplified-beginning-of-buffer}。

@item
参数列表：在这个例子中是一个空列表，@code{()}。

@item
文档字符串。

@item
交互表达式。

@item
主体。
@end enumerate

@noindent
在此函数定义中，参数列表为空，这意味着此函数不需要任何参数。 （当我们查看完整函数定义时，我们将看到它可以传递一个可选参数。）

交互式表达式告诉Emacs该函数旨在以交互方式使用。在这个例子中，@code{interactive} 没有参数，因为 @code{simplified-beginning-of-buffer} 不需要参数。

@need 800
函数的主体包括两行：

@smallexample
@group
(push-mark)
(goto-char (point-min))
@end group
@end smallexample

这些行中的第一行是表达式 @code{(push-mark)}。当Lisp解释器评估此表达式时，它在光标当前位置设置一个标记，无论光标在哪里。该标记的位置保存在标记环中。

接下来的一行是 @code{(goto-char (point-min))}。此表达式将光标跳到缓冲区的最小点，即缓冲区的开头（如果缩小了，则是缓冲区的可访问部分的开头。@xref{Narrowing & Widening, , 缩小和扩大}.)

@code{push-mark} 命令在光标被 @code{(goto-char (point-min))} 表达式移动到缓冲区开头之前的位置设置一个标记。因此，如果愿意，可以通过键入 @kbd{C-x C-x} 返回到最初的位置。

这就是整个函数定义的全部内容！

@findex describe-function
当阅读这样的代码并遇到不熟悉的函数时，比如 @code{goto-char}，可以使用 @code{describe-function} 命令了解它的作用。要使用此命令，输入 @kbd{C-h f}，然后输入函数的名称并按 @key{RET}。@code{describe-function} 命令将在 @file{*Help*} 窗口中打印函数的文档字符串。例如，@code{goto-char} 的文档如下：

@smallexample
@group
将点设置为 POSITION，一个数字或标记。
缓冲区的开头是位置 (point-min)，结束是 (point-max)。
@end group
@end smallexample

@noindent
函数的一个参数是所需的位置。

@noindent
（对于 @code{describe-function} 的提示将提供光标下或之前的符号，因此您可以通过将光标直接定位到函数上方或之后，然后键入 @kbd{C-h f @key{RET}} 以节省输入。）

@code{end-of-buffer} 函数定义与 @code{beginning-of-buffer} 定义的方式相同，只是函数的主体包含 @code{(goto-char (point-max))} 表达式，而不是 @code{(goto-char (point-min))}。

@node mark-whole-buffer
@section 定义 @code{mark-whole-buffer}
@findex mark-whole-buffer

@code{mark-whole-buffer} 函数的理解并不比 @code{simplified-beginning-of-buffer} 函数更难。然而，在这种情况下，我们将看一下完整的函数，而不是缩短版本。

@code{mark-whole-buffer} 函数并不像 @code{beginning-of-buffer} 函数那样常用，但仍然很有用：它通过将点放在开头并在缓冲区末尾放置标记来标记整个缓冲区作为一个区域。通常绑定到 @kbd{C-x h}。

@menu
* mark-whole-buffer overview::
* Body of mark-whole-buffer::   只有三行代码。
@end menu

@ifnottex
@node mark-whole-buffer overview
@unnumberedsubsec @code{mark-whole-buffer} 概述
@end ifnottex

@need 1250
在GNU Emacs 22中，完整函数的代码如下：

@smallexample
@group
(defun mark-whole-buffer ()
  "将点放在缓冲区的开头，将标记放在缓冲区的末尾。
在Lisp程序中，您可能不应该使用此函数；
让Lisp函数使用使用或设置标记的任何子例程通常是一个错误。"
  (interactive)
  (push-mark (point))
  (push-mark (point-max) nil t)
  (goto-char (point-min)))
@end group
@end smallexample

@need 1250
与所有其他函数一样，@code{mark-whole-buffer} 函数符合函数定义的模板。模板如下：

@smallexample
@group
(defun @var{name-of-function} (@var{argument-list})
  "@var{documentation}@dots{}"
  (@var{interactive-expression}@dots{})
  @var{body}@dots{})
@end group
@end smallexample

函数的名称是 @code{mark-whole-buffer}；后面是一个空的参数列表，@samp{()} 表示函数不需要参数。接下来是文档。

下一行是一个 @code{(interactive)} 表达式，告诉Emacs该函数将以交互方式使用。这些细节类似于前一节中描述的 @code{simplified-beginning-of-buffer} 函数。

@need 1250
@node Body of mark-whole-buffer
@subsection @code{mark-whole-buffer} 函数体

@code{mark-whole-buffer} 函数的主体由三行代码组成：

@c GNU Emacs 22
@smallexample
@group
(push-mark (point))
(push-mark (point-max) nil t)
(goto-char (point-min))
@end group
@end smallexample

这些行中的第一行是表达式 @code{(push-mark (point))}。

这行与 @code{simplified-beginning-of-buffer} 函数体的第一行 @code{(push-mark)} 完全相同。在这两种情况下，Lisp解释器在光标的当前位置设置一个标记。

我不知道为什么 @code{mark-whole-buffer} 中的表达式写为 @code{(push-mark (point))}，而在 @code{beginning-of-buffer} 中的表达式写为 @code{(push-mark)}。也许编写代码的人不知道 @code{push-mark} 的参数是可选的，如果 @code{push-mark} 没有传递参数，该函数默认会在点的位置自动设置标记。或者也许该表达式是为了与下一行的结构相呼应而写的。无论如何，这行使Emacs确定点的位置并在那里设置一个标记。

在GNU Emacs的早期版本中，@code{mark-whole-buffer} 的下一行是 @code{(push-mark (point-max))}。此表达式在缓冲区中具有最大编号的地方设置一个标记。这将是缓冲区的末尾（或者，如果缓冲区被缩小，缓冲区的可访问部分的末尾。有关缩小的更多信息，请参见 @xref{Narrowing & Widening, , Narrowing and Widening}）。设置了此标记后，前一个标记（在点处设置的标记）不再设置，但Emacs记住了其位置，就像始终记住所有其他最近的标记一样。这意味着您可以通过键入 @kbd{C-u C-@key{SPC}} 两次返回到该位置，如果您愿意的话。

@need 1250
在GNU Emacs 22中，@code{(point-max)} 稍微复杂一些。该行读取

@smallexample
(push-mark (point-max) nil t)
@end smallexample

@noindent
该表达式几乎与之前相同。它在缓冲区中具有最大编号的位置设置一个标记。然而，在此版本中，@code{push-mark} 有两个额外的参数。@code{push-mark} 的第二个参数是 @code{nil}。这告诉函数在推送标记时应显示一个消息，该消息说“标记已设置”。第三个参数是 @code{t}。这告诉 @code{push-mark} 在启用瞬时标记模式时激活标记。瞬时标记模式突出显示当前活动的区域。通常情况下会关闭它。

最后，函数的最后一行是 @code{(goto-char (point-min)))}。这与 @code{beginning-of-buffer} 中写得一样。该表达式将光标移动到缓冲区的最小点，即缓冲区的开头（或者可访问部分的开头）。因此，点被放置在缓冲区的开头，标记被设置在缓冲区的末尾。整个缓冲区因此成为了一个区域。

@node append-to-buffer
@section @code{append-to-buffer}的定义
@findex append-to-buffer

@code{append-to-buffer}命令比@code{mark-whole-buffer}命令更复杂。其功能是将当前缓冲区中点和标记之间的区域复制到指定的缓冲区。

@menu
* append-to-buffer overview::
* append interactive::          由两部分交互式表达式组成。
* append-to-buffer body::       包含@code{let}表达式。
* append save-excursion::       @code{save-excursion}的工作原理。
@end menu

@ifnottex
@node append-to-buffer overview
@unnumberedsubsec @code{append-to-buffer}的概述
@end ifnottex

@findex insert-buffer-substring
@code{append-to-buffer}命令使用@code{insert-buffer-substring}函数来复制区域。@code{insert-buffer-substring}的名称已经解释了它的功能：它从一个缓冲区中取出子字符串，然后插入到另一个缓冲区中。

大部分@code{append-to-buffer}涉及设置@code{insert-buffer-substring}工作条件：代码必须指定文本将进入的缓冲区，它来自的窗口以及它要去的窗口，以及将被复制的区域。

@need 1250
下面是该函数的可能实现：

@c GNU Emacs 22
@smallexample
@group
(defun append-to-buffer (buffer start end)
  "将区域的文本附加到指定缓冲区。
它插入到该缓冲区的点之前。
@end group

@group
在从程序调用时，提供三个参数：
BUFFER（或缓冲区名称），START和END。
START和END指定要复制的当前缓冲区的部分。"
  (interactive
   (list (read-buffer "追加到缓冲区：" (other-buffer
                                            (current-buffer) t))
         (region-beginning) (region-end)))
@end group
@group
  (let ((oldbuf (current-buffer)))
    (save-excursion
      (let* ((append-to (get-buffer-create buffer))
             (windows (get-buffer-window-list append-to t t))
             point)
        (set-buffer append-to)
        (setq point (point))
        (barf-if-buffer-read-only)
        (insert-buffer-substring oldbuf start end)
        (dolist (window windows)
          (when (= (window-point window) point)
            (set-window-point window (point))))))))
@end group
@end smallexample

通过查看该函数，可以理解它是一系列填充模板。

最外层模板是函数定义。在这个函数中，它看起来像这样（填充了几个槽）：

@smallexample
@group
(defun append-to-buffer (buffer start end)
  "@var{文档}@dots{}"
  (interactive @dots{})
  @var{主体}@dots{})
@end group
@end smallexample

函数的第一行包括其名称和三个参数。这些参数是文本将要复制到的@code{buffer}，以及将要复制的当前缓冲区的@code{start}和@code{end}。

函数的下一部分是文档，非常清晰而完整。按照惯例，这三个参数以大写字母写入，以便您轻松注意到它们。更好的是，它们按照参数列表中的顺序进行描述。

请注意文档区分了缓冲区和其名称。（该函数可以处理任何一种。）

@node append interactive
@subsection @code{append-to-buffer} 交互式表达式

由于 @code{append-to-buffer} 函数将被交互使用，该函数必须具有一个 @code{interactive} 表达式。 (有关 @code{interactive} 的详细信息，请参阅 @ref{Interactive, , 使函数具有交互性}。)

表达式如下：

@smallexample
@group
(interactive
 (list (read-buffer
        "追加到缓冲区: "
        (other-buffer (current-buffer) t))
       (region-beginning)
       (region-end)))
@end group
@end smallexample

@noindent
该表达式不是一个字母代表部分的表达式，如前所述。相反，它以这些部分开始一个列表：

列表的第一部分是一个表达式，用于读取缓冲区的名称并将其作为字符串返回。那就是 @code{read-buffer}。该函数需要一个提示作为其第一个参数，即 @samp{"追加到缓冲区: "}。其第二个参数告诉命令如果不指定任何值，应提供什么值。

在这种情况下，第二个参数是一个包含函数 @code{other-buffer}、一个异常和 @samp{t} 的表达式，表示为真。

@code{other-buffer} 的第一个参数是异常，是另一个函数 @code{current-buffer}。这不会被返回。第二个参数是真的符号，即 @code{t}。这告诉 @code{other-buffer} 它可以显示可见缓冲区（在这种情况下，它将不显示当前缓冲区，这是有道理的）。

@need 1250
表达式如下：

@smallexample
(other-buffer (current-buffer) t)
@end smallexample

@code{list} 表达式的第二个和第三个参数是 @code{(region-beginning)} 和 @code{(region-end)}。这两个函数指定要追加的文本的开头和结尾。

@need 1250
最初，该命令使用字母 @samp{B} 和 @samp{r}。整个 @code{interactive} 表达式如下：

@smallexample
(interactive "B追加到缓冲区:@: \nr")
@end smallexample

@noindent
但是当这样做时，切换到的缓冲区的默认值变为不可见。这是不想要的。

（提示与第二个参数之间用换行符 @samp{\n} 分隔。它后面跟着一个 @samp{r}，告诉 Emacs 将跟随函数参数列表中 @code{buffer} 符号后面的两个参数（即 @code{start} 和 @code{end}）绑定到点和标记的值。这个参数运行良好。）

@node append-to-buffer body
@subsection @code{append-to-buffer} 函数体

@code{append-to-buffer} 函数的体部分以 @code{let} 开始。

正如我们之前所见 (@pxref{let, , @code{let}})，@code{let} 表达式的目的是在 @code{let} 的体内创建并给予一个或多个变量初始值。这意味着这样的变量不会与 @code{let} 表达式外部同名的任何变量混淆。

通过以下提纲展示了 @code{append-to-buffer} 函数的模板，其中包含 @code{let} 表达式：

@smallexample
@group
(defun append-to-buffer (buffer start end)
  "@var{documentation}@dots{}"
  (interactive @dots{})
  (let ((@var{variable} @var{value}))
        @var{body}@dots{}))
@end group
@end smallexample

@code{let} 表达式包含三个元素：

@enumerate
@item
符号 @code{let}；

@item
一个 varlist，包含一个两元素列表，即 @code{(@var{variable} @var{value})}；

@item
@code{let} 表达式的体部分。
@end enumerate

@need 800
在 @code{append-to-buffer} 函数中，varlist 的样式如下：

@smallexample
(oldbuf (current-buffer))
@end smallexample

@noindent
在 @code{let} 表达式的这部分中，唯一的变量 @code{oldbuf} 被绑定到 @code{(current-buffer)} 表达式返回的值。这个变量 @code{oldbuf} 用于跟踪你正在操作的缓冲区，并从中复制。

varlist 的元素或元素组被一对括号括起，以便 Lisp 解释器能够区分 varlist 和 @code{let} 的体部分。因此，varlist 中的两元素列表被一对括号包围。这一行看起来像这样：

@smallexample
@group
(let ((oldbuf (current-buffer)))
  @dots{} )
@end group
@end smallexample

@noindent
在 @code{oldbuf} 之前的两个括号可能会让你感到惊讶，如果你没有意识到 @code{oldbuf} 之前的第一个括号标记了 varlist 的边界，而第二个括号标记了两元素列表 @code{(oldbuf (current-buffer))} 的开始。

@node append save-excursion
@subsection @code{save-excursion} 在 @code{append-to-buffer} 中的应用

在 @code{append-to-buffer} 中的 @code{let} 表达式的主体由一个 @code{save-excursion} 表达式组成。

@code{save-excursion} 函数保存 point 的位置，并在 @code{save-excursion} 主体表达式执行完成后将其恢复到该位置。此外，@code{save-excursion} 还跟踪原始缓冲区并将其恢复，这就是在 @code{append-to-buffer} 中使用 @code{save-excursion} 的方式。

@need 1500
@cindex 缩进用于格式化
@cindex 格式化约定
顺便提一下，值得注意的是，Lisp 函数通常格式化为多行展开的形式，其中所有被包裹在多行展开的内容都比第一个符号缩进得更多。在这个函数定义中，@code{let} 的缩进比 @code{defun} 大，而 @code{save-excursion} 的缩进比 @code{let} 大，就像这样：

@smallexample
@group
(defun @dots{}
  @dots{}
  @dots{}
  (let@dots{}
    (save-excursion
      @dots{}
@end group
@end smallexample

@need 1500
@noindent
这种格式约定使得很容易看到 @code{save-excursion} 主体中的行是由与 @code{save-excursion} 相关的括号括起来的，就像 @code{save-excursion} 本身由与 @code{let} 相关的括号括起来一样：

@smallexample
@group
(let ((oldbuf (current-buffer)))
  (save-excursion
    @dots{}
    (set-buffer @dots{})
    (insert-buffer-substring oldbuf start end)
    @dots{}))
@end group
@end smallexample

@need 1200
使用 @code{save-excursion} 函数的方式可以看作是填充模板的过程：

@smallexample
@group
(save-excursion
  @var{主体中的第一个表达式}
  @var{主体中的第二个表达式}
   @dots{}
  @var{主体中的最后一个表达式})
@end group
@end smallexample

@need 1200
@noindent
@anchor{let* introduced}
@findex let*
在这个函数中，@code{save-excursion} 的主体只包含一个表达式，即 @code{let*} 表达式。你已经了解了 @code{let} 函数，而 @code{let*} 函数则不同。它允许 Emacs 按顺序设置 varlist 中的每个变量，依次设置在 varlist 较早部分设置的变量的值，以便 varlist 较后部分的变量可以使用 varlist 较早部分设置的值。

观察 @code{append-to-buffer} 中的 @code{let*} 表达式：

@smallexample
@group
(let* ((append-to (get-buffer-create buffer))
       (windows (get-buffer-window-list append-to t t))
       point)
  BODY...)
@end group
@end smallexample

@noindent
我们可以看到，@code{append-to} 被绑定到由 @w{@code{(get-buffer-create buffer)}} 返回的值上。在下一行，@code{append-to} 作为参数传递给了 @code{get-buffer-window-list}；这在 @code{let} 表达式中是不可能的。注意，@code{point} 被自动绑定为 @code{nil}，就像在 @code{let} 语句中一样。

现在让我们专注于 @code{let*} 表达式的主体中的 @code{set-buffer} 和 @code{insert-buffer-substring} 函数。

@need 1250
在旧版本中，@code{set-buffer} 表达式是简单的

@smallexample
(set-buffer (get-buffer-create buffer))
@end smallexample

@need 1250
@noindent
但现在它是

@smallexample
(set-buffer append-to)
@end smallexample

@noindent
这是因为 @code{append-to} 在 @code{let*} 表达式中先绑定到了 @code{(get-buffer-create buffer)} 的值上。

@code{append-to-buffer} 函数定义将文本从当前缓冲区插入到一个命名的缓冲区中。巧合的是，@code{insert-buffer-substring} 恰好相反——它从另一个缓冲区复制文本到当前缓冲区——这就是为什么 @code{append-to-buffer} 定义以一个 @code{let} 开始的原因，该 @code{let} 将本地符号 @code{oldbuf} 绑定到在执行 @code{append-to-buffer} 命令时的 @code{current-buffer} 的值上。

@need 1250
@code{insert-buffer-substring} 表达式看起来像这样：

@smallexample
(insert-buffer-substring oldbuf start end)
@end smallexample

@noindent
@code{insert-buffer-substring} 函数将一个字符串从其第一个参数指定的缓冲区中复制并插入到当前缓冲区。在这种情况下，@code{insert-buffer-substring} 的参数是由 @code{let} 创建并绑定的变量的值，即 @code{oldbuf} 的值，这是在给出 @code{append-to-buffer} 命令时的当前缓冲区。

在 @code{insert-buffer-substring} 完成其工作后，@code{save-excursion} 将恢复操作到原始缓冲区，而 @code{append-to-buffer} 将完成其工作。

@need 800
以骨架形式编写，主体的工作看起来像这样：

@smallexample
@group
(let (@var{将-}@code{current-buffer}@var{的值绑定到-}@code{oldbuf})
  (save-excursion                       ; @r{跟踪缓冲区。}
    @var{更改缓冲区}
    @var{从-}@code{oldbuf}@var{中插入子串到缓冲区})

  @var{完成时切换回原始缓冲区}
  @var{完成时使-}@code{oldbuf}@var{的局部含义消失}
@end group
@end smallexample

总之，@code{append-to-buffer} 的工作方式如下：它保存了当前缓冲区的值在名为 @code{oldbuf} 的变量中。它获取新的缓冲区（如果需要，创建一个），并将 Emacs 的注意力切换到它。使用 @code{oldbuf} 的值，它将来自旧缓冲区的文本区域插入新缓冲区；然后使用 @code{save-excursion}，它将你带回原始缓冲区。

通过查看 @code{append-to-buffer}，你已经探索了一个相当复杂的函数。它展示了如何使用 @code{let}、@code{save-excursion} 以及如何在不同缓冲区之间切换和返回的方法。许多函数定义都以这种方式使用 @code{let}、@code{save-excursion} 和 @code{set-buffer}。

@node Buffer Related Review
@section 复习

这里是本章讨论的各种函数的简要总结。

@table @code
@item describe-function
@itemx describe-variable
打印函数或变量的文档。通常绑定到 @kbd{C-h f} 和 @kbd{C-h v}。

@item xref-find-definitions
查找包含函数或变量源代码的文件，并切换到该文件，将光标定位在该项的开头。通常绑定到 @kbd{M-.}（这是在 @key{META} 键后面加上句点）。

@item save-excursion
保存光标位置，并在评估 @code{save-excursion} 参数后还原其值。还记住当前缓冲区并返回到它。

@item push-mark
在某个位置设置标记，并记录标记环上前一个标记的值。标记是缓冲区中的一个位置，即使在缓冲区中添加或删除文本，它也会保持相对位置。

@item goto-char
将光标设置为由参数的值指定的位置，该参数可以是数字、标记或返回位置数字的表达式，例如 @code{(point-min)}。

@item insert-buffer-substring
从作为参数传递给函数的缓冲区中复制文本区域，并将该区域插入到当前缓冲区中。

@item mark-whole-buffer
将整个缓冲区标记为一个区域。通常绑定到 @kbd{C-x h}。

@item let*
声明一个变量列表并为它们赋初始值；然后评估 @code{let*} 体中的其余表达式。变量的值可以用来绑定列表中随后的变量。

@item set-buffer
将Emacs的注意力切换到另一个缓冲区，但不更改显示的窗口。在程序而不是人类要在不同的缓冲区上工作时使用。

@item get-buffer-create
@itemx get-buffer
查找命名的缓冲区，如果不存在该名称的缓冲区，则创建一个。如果命名的缓冲区不存在，@code{get-buffer} 函数返回 @code{nil}。
@end table

@need 1500
@node Buffer Exercises
@section 练习

@itemize @bullet
@item
编写自己的 @code{simplified-end-of-buffer} 函数定义；然后测试它是否有效。

@item
使用 @code{if} 和 @code{get-buffer} 编写一个函数，该函数打印一条消息，告诉您缓冲区是否存在。

@item
使用 @code{xref-find-definitions} 查找 @code{copy-to-buffer} 函数的源代码。
@end itemize

@node More Complex
@chapter 几个更复杂的函数

在这一章中，我们在前几章学到的基础上，深入研究更复杂的函数。@code{copy-to-buffer} 函数演示了在一个定义中使用两个 @code{save-excursion} 表达式，而 @code{insert-buffer} 函数则演示了在 @code{interactive} 表达式中使用星号、使用 @code{or}，以及名称和名称引用的对象之间的重要区别。

@menu
* copy-to-buffer::              使用 @code{set-buffer}、@code{get-buffer-create}。
* insert-buffer::               只读，并带有 @code{or}。
* beginning-of-buffer::         展示了 @code{goto-char}、@code{point-min} 和 @code{push-mark}。
* Second Buffer Related Review::
* optional Exercise::
@end menu

@node copy-to-buffer
@section 函数 @code{copy-to-buffer} 的定义
@findex copy-to-buffer

在理解了 @code{append-to-buffer} 的工作原理后，很容易理解 @code{copy-to-buffer}。这个函数将文本复制到一个缓冲区，但与其向第二个缓冲区添加文本不同，它替换了第二个缓冲区中的所有先前文本。

@need 800
@code{copy-to-buffer} 的主体如下，

@smallexample
@group
@dots{}
(interactive "BCopy to buffer: \nr")
(let ((oldbuf (current-buffer)))
  (with-current-buffer (get-buffer-create buffer)
    (barf-if-buffer-read-only)
    (erase-buffer)
    (save-excursion
      (insert-buffer-substring oldbuf start end)))))
@end group
@end smallexample

与 @code{append-to-buffer} 不同，@code{copy-to-buffer} 函数的交互表达式更简单。

@need 800
接下来的定义如下

@smallexample
(with-current-buffer (get-buffer-create buffer) @dots{}
@end smallexample

首先，看最内部的表达式；它首先被评估。该表达式以 @code{get-buffer-create buffer} 开头。该函数告诉计算机使用指定为要复制到的缓冲区的名称，或者如果不存在这样的缓冲区，则创建它。然后，@code{with-current-buffer} 函数使用该缓冲区临时作为当前缓冲区来评估其主体。

（这展示了另一种改变计算机注意力但不改变用户注意力的方法。@code{append-to-buffer} 函数展示了如何使用 @code{save-excursion} 和 @code{set-buffer} 来实现相同的效果。@code{with-current-buffer} 是一种较新、可能更简单的机制。）

@code{barf-if-buffer-read-only} 函数在您无法修改缓冲区时发送错误消息，指示该缓冲区为只读。

接下来的一行只包含 @code{erase-buffer} 函数。该函数擦除缓冲区。

最后，最后两行包含 @code{save-excursion} 表达式，其主体是 @code{insert-buffer-substring}。@code{insert-buffer-substring} 表达式将文本从当前缓冲区复制到另一个缓冲区（您并没有看到计算机改变其注意力，因此您不知道该缓冲区现在被称为 @code{oldbuf}）。

顺便说一下，这就是“替换”的含义。为了替换文本，Emacs 先擦除先前的文本，然后插入新文本。

@need 1250
大致上，@code{copy-to-buffer} 的主体如下：

@smallexample
@group
(let (@var{bind-}@code{oldbuf}@var{-to-value-of-}@code{current-buffer})
    (@var{with-the-buffer-you-are-copying-to}
      (@var{but-do-not-erase-or-copy-to-a-read-only-buffer})
      (erase-buffer)
      (save-excursion
        @var{insert-substring-from-}@code{oldbuf}@var{-into-buffer})))
@end group
@end smallexample

@node insert-buffer
@section 函数 @code{insert-buffer} 的定义
@findex insert-buffer

@code{insert-buffer} 是另一个与缓冲区相关的函数。该命令将另一个缓冲区的内容@emph{插入}到当前缓冲区中。它是 @code{append-to-buffer} 或 @code{copy-to-buffer} 的反向操作，因为它们将文本区域从当前缓冲区@emph{复制到}另一个缓冲区。

以下讨论基于原始代码。该代码在2003年进行了简化，变得更难理解。

(@xref{New insert-buffer, , @code{insert-buffer} 的新主体}, 以查看新主体的讨论。)

此外，这段代码说明了与可能是@dfn{只读}的缓冲区一起使用@code{interactive}的用法，以及对象名称与实际引用的对象之间的重要区别。

@menu
* insert-buffer code::
* insert-buffer interactive::   当您能读取但无法写入时。
* insert-buffer body::          主体包含一个 @code{or} 和一个 @code{let}。
* if & or::                     使用 @code{if} 而不是 @code{or}。
* Insert or::                   @code{or} 表达式的工作原理。
* Insert let::                  两个 @code{save-excursion} 表达式。
* New insert-buffer::
@end menu

@ifnottex
@node insert-buffer code
@unnumberedsubsec @code{insert-buffer} 的代码
@end ifnottex

@need 800
以下是早期的代码：

@smallexample
@group
(defun insert-buffer (buffer)
  "在点之后插入缓冲区的内容。
在插入的文本之后设置标记。
BUFFER 可以是缓冲区或缓冲区名称。"
  (interactive "*bInsert buffer:@: ")
@end group
@group
  (or (bufferp buffer)
      (setq buffer (get-buffer buffer)))
  (let (start end newmark)
    (save-excursion
      (save-excursion
        (set-buffer buffer)
        (setq start (point-min) end (point-max)))
@end group
@group
      (insert-buffer-substring buffer start end)
      (setq newmark (point)))
    (push-mark newmark)))
@end group
@end smallexample

@need 1200
与其他函数定义一样，您可以使用模板查看函数的轮廓：

@smallexample
@group
(defun insert-buffer (buffer)
  "@var{documentation}@dots{}"
  (interactive "*bInsert buffer:@: ")
  @var{body}@dots{})
@end group
@end smallexample

@node insert-buffer interactive
@subsection @code{insert-buffer} 函数中的交互表达式
@findex interactive@r{, 用法示例}

在 @code{insert-buffer} 中，@code{interactive} 声明的参数有两部分，一个星号 @samp{*} 和 @samp{bInsert buffer:@: }。

@menu
* Read-only buffer::            当缓冲区无法修改时。
* b for interactive::             存在的缓冲区或其名称。
@end menu

@node Read-only buffer
@unnumberedsubsubsec 只读缓冲区
@cindex 只读缓冲区
@cindex 用于只读缓冲区的星号
@findex * @r{用于只读缓冲区}

星号用于当前缓冲区为只读缓冲区的情况---无法修改的缓冲区。如果在当前缓冲区为只读时调用 @code{insert-buffer}，将在回显区打印相应的消息，并且终端可能会发出哔声或闪烁；您将无法将任何内容插入当前缓冲区。星号后无需加换行符以将其与下一个参数分隔开。

@node b for interactive
@unnumberedsubsubsec 交互表达式中的 @samp{b}

交互表达式中的下一个参数以小写 @samp{b} 开头。 （这与 @code{append-to-buffer} 的代码不同，后者使用大写 @samp{B}。@xref{append-to-buffer, , @code{append-to-buffer} 的定义}。）小写 @samp{b} 表示 Lisp 解释器应该将 @code{insert-buffer} 的参数绑定到一个现有缓冲区，否则应该绑定到其名称。Emacs 将提示您输入缓冲区的名称，并提供默认缓冲区，并启用名称补全。如果缓冲区不存在，您将收到消息“没有匹配”；终端也可能会哔哔作响。

新的简化代码生成了 @code{interactive} 的列表。它使用我们已经熟悉的 @code{barf-if-buffer-read-only} 和 @code{read-buffer} 函数以及我们尚不熟悉的 @code{progn} 特殊形式（稍后将进行描述）。

@node insert-buffer body
@subsection @code{insert-buffer} 函数的主体

@code{insert-buffer} 函数的主体有两个主要部分：一个 @code{or} 表达式和一个 @code{let} 表达式。 @code{or} 表达式的目的是确保参数 @code{buffer} 绑定到一个缓冲区，而不仅仅是缓冲区的名称。 @code{let} 表达式的主体包含将另一个缓冲区复制到当前缓冲区的代码。

@need 1250
简而言之，这两个表达式适合于 @code{insert-buffer} 函数，如下所示：

@smallexample
@group
(defun insert-buffer (buffer)
  "@var{documentation}@dots{}"
  (interactive "*bInsert buffer:@: ")
  (or @dots{}
      @dots{}
@end group
@group
  (let (@var{varlist})
      @var{body-of-}@code{let}@dots{} )
@end group
@end smallexample

要理解 @code{or} 表达式如何确保参数 @code{buffer} 绑定到一个缓冲区而不是缓冲区的名称，首先需要了解 @code{or} 函数。

在这之前，让我使用 @code{if} 重新编写此函数的一部分，以便您可以以熟悉的方式看到所做的事情。

@node if & or
@subsection 使用 @code{if} 替代 @code{or} 的 @code{insert-buffer}

要完成的任务是确保 @code{buffer} 的值是一个缓冲区本身，而不是缓冲区的名称。如果值是名称，则必须获取缓冲区本身。

你可以想象自己在一个会议上，一个引座员正拿着一张带有你的名字的名单四处寻找你：引座员与你的名字绑定，而不是与你绑定；但当引座员找到你并搀扶你的手臂时，引座员就与你绑定了。

@need 800
在 Lisp 中，你可以这样描述这种情况：

@smallexample
@group
(if (not (holding-on-to-guest))
    (find-and-take-arm-of-guest))
@end group
@end smallexample

我们想要使用缓冲区做同样的事情——如果我们没有缓冲区本身，我们就希望获取它。

@need 1200
使用一个叫做 @code{bufferp} 的谓词，它告诉我们是否有一个缓冲区（而不是它的名称），我们可以这样编写代码：

@smallexample
@group
(if (not (bufferp buffer))              ; @r{if-部分}
    (setq buffer (get-buffer buffer)))  ; @r{then-部分}
@end group
@end smallexample

@noindent
这里，@code{if} 表达式的真假测试是 @w{@code{(not (bufferp buffer))}}；然后部分是表达式 @w{@code{(setq buffer (get-buffer buffer))}}。

在测试中，函数 @code{bufferp} 如果其参数是一个缓冲区，则返回 true——但如果其参数是缓冲区的名称，则返回 false。 （函数名 @code{bufferp} 的最后一个字符是字符 @samp{p}；正如我们前面看到的，@samp{p} 的这种用法是一个约定，表示该函数是一个谓词，这是一个术语，表示该函数将确定某个属性是真还是假。@xref{Wrong Type of Argument, , 使用错误类型的对象作为参数}.)

@need 1200
函数 @code{not} 位于表达式 @code{(bufferp buffer)} 之前，因此真假测试看起来像这样：

@smallexample
(not (bufferp buffer))
@end smallexample

@noindent
@code{not} 是一个函数，如果其参数为 false，则返回 true；如果其参数为 true，则返回 false。因此，如果 @code{(bufferp buffer)} 返回 true，则 @code{not} 表达式返回 false，反之亦然。

使用这个测试，@code{if} 表达式的工作方式如下：当变量 @code{buffer} 的值实际上是一个缓冲区而不是其名称时，真假测试返回 false，@code{if} 表达式不会评估 then-部分。这是可以的，因为如果它确实是一个缓冲区，我们就不需要对变量 @code{buffer} 做任何操作。

另一方面，当 @code{buffer} 的值不是一个缓冲区本身，而是缓冲区的名称时，真假测试返回 true，并且评估表达式的 then-部分。在这种情况下，then-部分是 @code{(setq buffer (get-buffer buffer))}。该表达式使用 @code{get-buffer} 函数通过名称返回实际的缓冲区本身。然后，@code{setq} 将变量 @code{buffer} 设置为缓冲区本身的值，替换其先前的值（该值是缓冲区的名称）。

@node Insert or
@subsection @code{insert-buffer} 中的 @code{or} 表达式

@code{insert-buffer} 函数中 @code{or} 表达式的目的是确保参数 @code{buffer} 绑定到一个缓冲区，而不仅仅是缓冲区的名称。前一节展示了如何使用 @code{if} 表达式完成此任务。然而，@code{insert-buffer} 函数实际上使用了 @code{or}。要理解这一点，有必要了解 @code{or} 的工作原理。

@findex or
一个 @code{or} 函数可以有任意数量的参数。它依次评估每个参数，并返回其参数中第一个不是 @code{nil} 的值。此外，这是 @code{or} 的一个关键特性，即在返回第一个非 @code{nil} 值后，它不再评估任何后续参数。

@need 800
@code{or} 表达式如下：

@smallexample
@group
(or (bufferp buffer)
    (setq buffer (get-buffer buffer)))
@end group
@end smallexample

@noindent
@code{or} 的第一个参数是表达式 @code{(bufferp buffer)}。如果缓冲区实际上是一个缓冲区而不仅仅是缓冲区的名称，则此表达式返回 true（一个非 @code{nil} 值）。在 @code{or} 表达式中，如果是这种情况，@code{or} 表达式返回这个 true 值，并且不评估下一个表达式——这对我们来说是可以的，因为如果它确实是一个缓冲区，我们就不希望对 @code{buffer} 的值做任何操作。

另一方面，如果 @code{(bufferp buffer)} 的值是 @code{nil}，那么如果 @code{buffer} 的值是缓冲区的名称，Lisp 解释器将评估 @code{or} 表达式的下一个元素。这是表达式 @code{(setq buffer (get-buffer buffer))}。此表达式返回一个非 @code{nil} 值，这是它设置变量 @code{buffer} 的值——并且这个值是缓冲区本身，而不是缓冲区的名称。

所有这些的结果是，符号 @code{buffer} 总是绑定到缓冲区本身而不是缓冲区的名称。所有这些是必要的，因为后面的一行中的 @code{set-buffer} 函数只能与缓冲区本身一起使用，而不能与缓冲区的名称一起使用。

@need 1250
顺便说一下，使用 @code{or}，引座员的情况可以写成这样：

@smallexample
(or (holding-on-to-guest) (find-and-take-arm-of-guest))
@end smallexample

@node Insert let
@subsection @code{insert-buffer} 中的 @code{let} 表达式

在确保变量 @code{buffer} 引用的是缓冲区本身而不仅仅是缓冲区的名称后，@code{insert-buffer} 函数继续使用 @code{let} 表达式。这个表达式指定了三个局部变量 @code{start}、@code{end} 和 @code{newmark}，并将它们绑定到初始值 @code{nil}。这些变量在 @code{let} 的其余部分中被使用，并在 @code{let} 结束之前暂时隐藏了任何同名变量的其他出现。

@need 1200
@code{let} 的主体包含两个 @code{save-excursion} 表达式。首先，我们将详细查看内部 @code{save-excursion} 表达式。表达式如下：

@smallexample
@group
(save-excursion
  (set-buffer buffer)
  (setq start (point-min) end (point-max)))
@end group
@end smallexample

@noindent
表达式 @code{(set-buffer buffer)} 将 Emacs 的注意力从当前缓冲区切换到将要复制文本的缓冲区。在该缓冲区中，使用命令 @code{point-min} 和 @code{point-max} 将变量 @code{start} 和 @code{end} 设置为缓冲区的开始和结束。请注意，这里演示了 @code{setq} 如何能够在同一个表达式中设置两个变量。@code{setq} 的第一个参数设置为其第二个参数的值，其第三个参数设置为其第四个参数的值。

在内部 @code{save-excursion} 的主体被评估之后，@code{save-excursion} 会恢复原始缓冲区，但是 @code{start} 和 @code{end} 仍然设置为将要复制文本的缓冲区的开始和结束的值。

@need 1250
外部 @code{save-excursion} 表达式如下：

@smallexample
@group
(save-excursion
  (@var{inner-}@code{save-excursion}@var{-expression}
     (@var{go-to-new-buffer-and-set-}@code{start}@var{-and-}@code{end})
  (insert-buffer-substring buffer start end)
  (setq newmark (point)))
@end group
@end smallexample

@noindent
@code{insert-buffer-substring} 函数将文本从 @code{buffer} 中的 @code{start} 和 @code{end} 位置插入到当前缓冲区中。由于第二个缓冲区的整体位于 @code{start} 和 @code{end} 之间，第二个缓冲区的整体被复制到你正在编辑的缓冲区中。接下来，点的值，它将位于插入文本的末尾，被记录在变量 @code{newmark} 中。

在外部 @code{save-excursion} 的主体被评估之后，点被重新定位到其原始位置。

然而，方便的是在新插入的文本的末尾放置一个标记，并将点定位在其开头。@code{newmark} 变量记录了插入文本的末尾。在 @code{let} 表达式的最后一行中，@code{(push-mark newmark)} 表达式函数将标记设置为此位置。（标记的先前位置仍然可访问；它记录在标记环上，你可以使用 @kbd{C-u C-@key{SPC}} 返回到它。）与此同时，点位于插入文本的开头，这是你调用插入函数之前的位置，该位置由第一个 @code{save-excursion} 保存。

@need 1250
整个 @code{let} 表达式如下：

@smallexample
@group
(let (start end newmark)
  (save-excursion
    (save-excursion
      (set-buffer buffer)
      (setq start (point-min) end (point-max)))
    (insert-buffer-substring buffer start end)
    (setq newmark (point)))
  (push-mark newmark))
@end group
@end smallexample

与 @code{append-to-buffer} 函数一样，@code{insert-buffer} 函数使用了 @code{let}、@code{save-excursion} 和 @code{set-buffer}。此外，该函数演示了使用 @code{or} 的一种方式。所有这些函数都是我们将一遍又一遍找到并使用的构建块。

@node New insert-buffer
@subsection @code{insert-buffer} 的新主体
@findex insert-buffer@r{, 新版本主体}
@cindex @code{insert-buffer} 的新版本主体

GNU Emacs 22 版本中的主体比原始版本更令人困惑。

@need 1250
它包含两个表达式，

@smallexample
@group
  (push-mark
   (save-excursion
     (insert-buffer-substring (get-buffer buffer))
     (point)))

   nil
@end group
@end smallexample

@noindent
除外，这是使初学者困惑的地方，@code{push-mark} 表达式内部执行了非常重要的工作。

@code{get-buffer} 函数返回一个以提供的名称命名的缓冲区。请注意，该函数并@emph{不}被称为 @code{get-buffer-create}；如果不存在缓冲区，则不会创建一个。由 @code{get-buffer} 返回的缓冲区（已存在的缓冲区）被传递给 @code{insert-buffer-substring}，该函数插入整个缓冲区（因为您没有指定其他内容）。

@code{push-mark} 记录插入缓冲区的位置。然后，该函数返回 @code{nil}，即其最后一条命令的值。换句话说，@code{insert-buffer} 函数仅用于产生副作用，即插入另一个缓冲区，而不是返回任何值。

@node beginning-of-buffer
@section @code{beginning-of-buffer} 函数的完整定义
@findex beginning-of-buffer

@code{beginning-of-buffer} 函数的基本结构已经讨论过了。(@xref{simplified-beginning-of-buffer, , 一个简化的 @code{beginning-of-buffer} 定义}.) 本节描述了定义的复杂部分。

如前所述，当没有参数调用时，@code{beginning-of-buffer} 将光标移动到缓冲区的开头（实际上是可访问部分的开头），并将标记留在先前的位置。然而，当以介于一到十之间的数字调用该命令时，该函数将该数字视为缓冲区长度的十分之一，Emacs 将光标移动到缓冲区的该部分。因此，您可以使用键命令 @kbd{M-<} 调用该函数，将光标移动到缓冲区的开头，或者使用键命令，例如 @kbd{C-u 7 M-<}，将光标移动到缓冲区的70％处。如果使用大于十的数字作为参数，则光标将移动到缓冲区的末尾。

@code{beginning-of-buffer} 函数可以带有或不带有参数调用。使用参数是可选的。

@menu
* Optional Arguments::
* beginning-of-buffer opt arg::  带有可选参数的示例。
* beginning-of-buffer complete::
@end menu

@node Optional Arguments
@subsection 可选参数

除非另有说明，Lisp 期望具有函数定义中参数的函数在调用时将为该参数传递一个值。如果没有这样做，将出现错误并显示消息 @samp{Wrong number of arguments}。

@cindex 可选参数
@cindex 关键字
@findex optional
然而，可选参数是Lisp的一个特性：使用特定的@dfn{关键字}告诉Lisp解释器该参数是可选的。关键字是 @code{&optional}。 （@samp{&} 在 @samp{optional} 前面是关键字的一部分。）在函数定义中，如果一个参数跟在关键字 @code{&optional} 后面，那么在调用函数时无需传递值给该参数。

@need 1200
因此，@code{beginning-of-buffer} 函数的函数定义的第一行看起来像这样：

@smallexample
(defun beginning-of-buffer (&optional arg)
@end smallexample

@need 1250
概括而言，整个函数看起来像这样：

@smallexample
@group
(defun beginning-of-buffer (&optional arg)
  "@var{documentation}@dots{}"
  (interactive "P")
  (or (@var{is-the-argument-a-cons-cell} arg)
      (and @var{are-both-transient-mark-mode-and-mark-active-true})
      (push-mark))
  (let (@var{determine-size-and-set-it})
  (goto-char
    (@var{if-there-is-an-argument}
        @var{figure-out-where-to-go}
      @var{else-go-to}
      (point-min))))
   @var{do-nicety}
@end group
@end smallexample

该函数类似于 @code{simplified-beginning-of-buffer} 函数，只是 @code{interactive} 表达式的参数是 @code{"P"}，并且 @code{goto-char} 函数后面跟着一个 if-then-else 表达式，用于确定如果有一个不是 cons cell 的参数，光标应该放在哪里。

（由于我在很多章节里都没有解释 cons cell，请考虑忽略函数 @code{consp}。@xref{List Implementation, , 如何实现列表}，以及 @ref{Cons Cell Type, , Cons Cell and List Types, elisp, The GNU Emacs Lisp Reference Manual}。）

@code{interactive} 表达式中的 @code{"P"} 告诉 Emacs 将前缀参数（如果有的话）以原始形式传递给函数。前缀参数是通过按 @key{META} 键后面跟一个数字，或者按 @kbd{C-u} 然后是一个数字来生成的。（如果不输入数字，@kbd{C-u} 默认为带有 4 的 cons cell。在 @code{interactive} 表达式中的小写 @code{"p"} 会导致函数将前缀参数转换为数字。）

@code{if} 表达式的真值测试看起来复杂，但实际上并不复杂：它检查 @code{arg} 是否具有非 @code{nil} 的值，以及它是否是 cons cell。 （这就是 @code{consp} 做的事情；它检查其参数是否为 cons cell。）如果 @code{arg} 具有非 @code{nil} 的值（并且不是 cons cell），这个真值测试将返回 true，并且 @code{if} 表达式的 then-部分将被评估。另一方面，如果 @code{beginning-of-buffer} 没有带参数调用，@code{arg} 的值将为 @code{nil}，并且 @code{if} 表达式的 else-部分将被评估。else-部分就是 @code{point-min}，当这是结果时，整个 @code{goto-char} 表达式是 @code{(goto-char (point-min))}，这就是我们在简化形式中看到的 @code{beginning-of-buffer} 函数。

@node beginning-of-buffer opt arg
@subsection @code{beginning-of-buffer} with an Argument

当使用参数调用@code{beginning-of-buffer}时，将计算一个表达式来确定传递给@code{goto-char}的值。这个表达式乍一看相当复杂。它包括一个内部的@code{if}表达式和许多算术运算。具体如下：

@smallexample
@group
(if (> (buffer-size) 10000)
    ;; @r{避免大缓冲区大小溢出！}
                          (* (prefix-numeric-value arg)
                             (/ size 10))
  (/
   (+ 10
      (*
       size (prefix-numeric-value arg))) 10)))
@end group
@end smallexample

@menu
* Disentangle beginning-of-buffer::
* Large buffer case::
* Small buffer case::
@end menu

@ifnottex
@node Disentangle beginning-of-buffer
@unnumberedsubsubsec Disentangle @code{beginning-of-buffer}
@end ifnottex

与其他复杂的表达式一样，@code{beginning-of-buffer}中的条件表达式可以通过将其视为模板的一部分（在这种情况下，是if-then-else表达式的模板）来解开。在骨架形式中，该表达式如下：

@smallexample
@group
(if (@var{buffer-is-large}
    @var{divide-buffer-size-by-10-and-multiply-by-arg}
  @var{else-use-alternate-calculation}
@end group
@end smallexample

这个内部的@code{if}表达式的真值或假值测试检查缓冲区的大小。这样做的原因是，旧版本的Emacs使用的数字不超过八百万左右，在随后的计算中，程序员担心如果缓冲区很大，Emacs可能会尝试使用过大的数字。注释中提到的术语“溢出”意味着数字过大。更近期的Emacs版本使用更大的数字，但由于人们现在查看的缓冲区远远大于以往，这段代码没有被更改。

有两种情况：如果缓冲区很大，如果不大。

@node Large buffer case
@unnumberedsubsubsec 在大缓冲区中发生了什么

在@code{beginning-of-buffer}中，内部的@code{if}表达式测试缓冲区的大小是否大于10,000个字符。为了做到这一点，它使用了@code{>}函数和来自let表达式的@code{size}计算。

在旧版本中，使用了@code{buffer-size}函数。不仅调用了该函数多次，而且它给出的是整个缓冲区的大小，而不是可访问部分的大小。当只处理可访问部分时，计算会更有意义。关于将注意力集中到可访问部分的更多信息，请参阅《缩小和扩大》。

@need 800
这一行看起来像这样：

@smallexample
(if (> size 10000)
@end smallexample

@need 1200
@noindent
当缓冲区很大时，@code{if}表达式的then部分将被评估。它读起来像这样（格式化以便阅读）：

@smallexample
@group
(*
  (prefix-numeric-value arg)
  (/ size 10))
@end group
@end smallexample

@noindent
这个表达式是一个乘法，具有@code{*}函数的两个参数。

第一个参数是@code{(prefix-numeric-value arg)}。当@code{interactive}的参数为@code{"P"}时，传递给函数的参数是一个@dfn{原始前缀参数}，而不是一个数字（它是一个列表中的数字）。为了进行算术运算，需要进行转换，@code{prefix-numeric-value}完成了这个任务。

@findex / @r{(division)}
@cindex Division
第二个参数是@code{(/ size 10)}。这个表达式将数值除以十---可访问部分缓冲区大小的数值。这产生一个数字，告诉我们十分之一缓冲区大小由多少字符组成。在Lisp中，@code{/}用于除法，就像@code{*}用于乘法一样。

@need 1200
在整个乘法表达式中，这个数量被乘以前缀参数的值---乘法看起来像这样：

@smallexample
@group
(* @var{numeric-value-of-prefix-arg}
   @var{number-of-characters-in-one-tenth-of-the-accessible-buffer})
@end group
@end smallexample

@noindent
例如，如果前缀参数是@samp{7}，那么十分之一的值将乘以7，以给出在缓冲区大小的70%的位置。

@need 1200
所有这些的结果是，如果可访问部分的缓冲区很大，那么@code{goto-char}表达式将如下：

@smallexample
@group
(goto-char (* (prefix-numeric-value arg)
              (/ size 10)))
@end group
@end smallexample

这把光标放在我们想要的位置。

@node Small buffer case
@unnumberedsubsubsec 小缓冲区中的情况

如果缓冲区包含的字符少于10,000个，将执行略有不同的计算。你可能认为这是不必要的，因为第一种计算方法可以完成工作。然而，在小缓冲区中，第一种方法可能无法将光标精确放置在所需的行上；而第二种方法效果更好。

@need 800
以下是代码：

@c 请将此内容放在一行上。
@smallexample
(/ (+ 10 (* size (prefix-numeric-value arg))) 10))
@end smallexample

@need 1200
@noindent
这是一段代码，你可以通过发现函数嵌套在括号中的方式来理解它的运行。如果每个表达式都比其封闭表达式缩进得更深，那么代码会更容易阅读：

@smallexample
@group
  (/
   (+ 10
      (*
       size
       (prefix-numeric-value arg)))
   10))
@end group
@end smallexample

@need 1200
@noindent
通过查看括号，我们可以看到最内层的操作是@code{(prefix-numeric-value arg)}，它将原始参数转换为数字。在下面的表达式中，这个数字被乘以缓冲区的可访问部分的大小：

@smallexample
(* size (prefix-numeric-value arg))
@end smallexample

@noindent
这个乘法会产生一个可能比缓冲区的大小更大的数字——例如，如果参数是7，那么这个数字会大七倍。然后，这个数字加上10，最终将这个大数字除以10，得到的值比缓冲区中的百分比位置多一个字符。

所有这些计算得到的数字被传递给@code{goto-char}，并将光标移动到该位置。

@need 1500
@node beginning-of-buffer complete
@subsection 完整的@code{beginning-of-buffer}

@need 1000
下面是@code{beginning-of-buffer}函数的完整文本：
@sp 1

@c 在GNU Emacs 22中
@smallexample
@group
(defun beginning-of-buffer (&optional arg)
  "将点移到缓冲区的开头；在先前位置留下标记。
使用 \\[universal-argument] 前缀时，不在先前位置设置标记。
使用数值参数 N 时，将点设置为从开头开始的 N/10 处。

如果缩小了缓冲区，
此命令使用缓冲区的可访问部分的开头和大小。
@end group

@group
不要在Lisp程序中使用这个命令！
\(goto-char (point-min))更快
且不会破坏标记。"
  (interactive "P")
  (or (consp arg)
      (and transient-mark-mode mark-active)
      (push-mark))
@end group
@group
  (let ((size (- (point-max) (point-min))))
    (goto-char (if (and arg (not (consp arg)))
                   (+ (point-min)
                      (if (> size 10000)
                          ;; 避免大缓冲区大小的溢出！
                          (* (prefix-numeric-value arg)
                             (/ size 10))
                        (/ (+ 10 (* size (prefix-numeric-value arg)))
                           10)))
                 (point-min))))
  (if (and arg (not (consp arg))) (forward-line 1)))
@end group
@end smallexample

@ignore
从GNU Emacs 22之前
@smallexample
@group
(defun beginning-of-buffer (&optional arg)
  "将点移到缓冲区的开头；在先前位置留下标记。
如果有参数 N，则将点设置为从真正开头开始的 N/10 处。
@end group
@group
不要在Lisp程序中使用这个！
\(goto-char (point-min))更快
且不会设置标记。"
  (interactive "P")
  (push-mark)
@end group
@group
  (goto-char
   (if arg
       (if (> (buffer-size) 10000)
           ;; @r{避免大缓冲区大小的溢出！}
           (* (prefix-numeric-value arg)
              (/ (buffer-size) 10))
@end group
@group
         (/ (+ 10 (* (buffer-size)
                     (prefix-numeric-value arg)))
            10))
     (point-min)))
  (if arg (forward-line 1)))
@end group
@end smallexample
@end ignore

@noindent
除了文档字符串中的一个细节和函数的最后一行之外，前面的讨论展示了这个函数的工作原理。

@need 800
在文档字符串中，有一个表达式的引用：

@smallexample
\\[universal-argument]
@end smallexample

@noindent
在这个表达式的第一个方括号之前使用了@samp{\\}。这个@samp{\\}告诉Lisp解释器替换当前绑定到@samp{[@dots{}]}的键。在@code{universal-argument}的情况下，通常是@kbd{C-u}，但也可能不同。有关更多信息，@xref{Documentation Tips, ,文档字符串提示, GNU Emacs Lisp参考手册}。

@need 1200
最后，@code{beginning-of-buffer}命令的最后一行指示，如果带有参数调用命令：

@smallexample
(if (and arg (not (consp arg))) (forward-line 1))
@end smallexample

@noindent
如果使用@kbd{C-u}指定命令，但没有数字，也就是说，原始前缀参数只是一个cons单元，该命令将光标放在第二行的开头。

@node Second Buffer Related Review
@section 复习

这里是对本章涵盖的一些主题的简要总结。

@table @code
@item or
依次评估每个参数，并返回第一个不是 @code{nil} 的参数的值；如果没有返回一个不是 @code{nil} 的值，则返回 @code{nil}。简言之，返回参数中的第一个真值；如果其中任何一个是真值，则返回真值。

@item and
依次评估每个参数，并且如果任何一个是 @code{nil}，则返回 @code{nil}；如果没有一个是 @code{nil}，则返回最后一个参数的值。简言之，只有当所有参数都为真时才返回真值；如果其中任何一个为真，则返回真值。

@item &optional
用于指示函数定义中的参数是可选的关键字；这意味着如果需要，可以在不提供参数的情况下评估函数。

@item prefix-numeric-value
将由 @code{(interactive "P")} 生成的原始前缀参数转换为数值。

@item forward-line
将点移动到下一行的开头，或者如果参数大于一，则向前移动那么多行。如果无法移动到应该移动到的位置，@code{forward-line} 将尽量向前移动，并返回无法移动的额外行数的计数。

@item erase-buffer
删除当前缓冲区的所有内容。

@item bufferp
如果其参数是缓冲区，则返回 @code{t}；否则返回 @code{nil}。
@end table

@node optional Exercise
@section @code{optional} 参数练习

编写一个交互式函数，该函数带有一个可选参数，用于测试其参数（一个数字）是否大于或等于 @code{fill-column} 的值，否则，小于该值，并通过消息告诉您结果。然而，如果您没有向函数传递参数，则使用默认值56。

@node Narrowing & Widening
@chapter 缩窄与扩大
@cindex 焦点集中（缩窄）
@cindex 缩窄
@cindex 扩大

缩窄是Emacs的一个功能，使您能够专注于缓冲区的特定部分，并且在不小心更改其他部分的情况下工作。通常情况下，缩窄是禁用的，因为它可能使初学者感到困惑。

@menu
* Narrowing advantages::              缩窄的优势
* save-restriction::        @code{save-restriction} 特殊形式。
* what-line::               光标所在行的行号。
* narrow Exercise::
@end menu

@ifnottex
@node Narrowing advantages
@unnumberedsec 缩小的优势
@end ifnottex

通过缩小，缓冲区的其余部分被隐藏起来，就好像它们不存在一样。这是一个优势，例如，如果你想替换缓冲区的某个部分中的一个单词，而不影响其他部分，你可以缩小到你想要的部分，替换只在该部分进行，而不影响缓冲区的其余部分。搜索也仅在缩小的区域内工作，而不在外部，因此如果你正在修复文档的一部分，你可以通过缩小到你想要的区域来防止意外地找到不需要修复的部分。
（@code{narrow-to-region}的键绑定是@kbd{C-x n n}。）

然而，缩小会使缓冲区的其余部分变得不可见，这可能会吓到那些不小心调用缩小并认为已删除文件的一部分的人。此外，@code{undo}命令（通常绑定到@kbd{C-x u}）不会取消缩小（也不应该取消），所以如果人们不知道可以使用@code{widen}命令将缓冲区的其余部分恢复为可见状态，他们可能会变得相当绝望。
（@code{widen}的键绑定是@kbd{C-x n w}。）

缩小对Lisp解释器和人类一样有用。通常，Emacs Lisp函数被设计为仅在缓冲区的一部分上工作；或者相反，Emacs Lisp函数需要在已经缩小的整个缓冲区上工作。例如，@code{what-line}函数会在缓冲区存在缩小的情况下移除缩小，并在完成工作后将缩小恢复到原来的状态。另一方面，@code{count-lines}函数使用缩小来限制自己只在其感兴趣的缓冲区部分中运行，然后恢复到先前的情况。

@node save-restriction
@section 特殊形式 @code{save-restriction}
@findex save-restriction

在Emacs Lisp中，你可以使用特殊形式 @code{save-restriction} 来追踪当前是否存在缩小范围的情况。当Lisp解释器遇到 @code{save-restriction} 时，它会执行 @code{save-restriction} 表达式体中的代码，然后撤销代码引起的任何缩小范围的更改。例如，如果缓冲区被缩小，而跟在 @code{save-restriction} 后面的代码消除了缩小，则 @code{save-restriction} 将在之后将缓冲区恢复到缩小的区域。在 @code{what-line} 命令中，由 @code{save-restriction} 命令后立即执行的 @code{widen} 命令会撤销缓冲区可能存在的任何缩小。任何原始的缩小在函数完成之前都会被恢复。

@need 1250
@code{save-restriction} 表达式的模板很简单：

@smallexample
@group
(save-restriction
  @var{body}@dots{} )
@end group
@end smallexample

@noindent
@code{save-restriction} 的体是一个或多个将由Lisp解释器按顺序评估的表达式。

最后，需要注意的一点是：当你同时使用 @code{save-excursion} 和 @code{save-restriction}，并且它们紧跟在彼此之后时，应该将 @code{save-excursion} 放在最外层。如果你以相反的顺序编写它们，可能无法记录Emacs在调用 @code{save-excursion} 后切换到的缓冲区的缩小。因此，在一起编写时，@code{save-excursion} 和 @code{save-restriction} 应该像这样编写：

@smallexample
@group
(save-excursion
  (save-restriction
    @var{body}@dots{}))
@end group
@end smallexample

在其他情况下，当它们没有一起编写时，@code{save-excursion} 和 @code{save-restriction} 特殊形式必须按照适合函数的顺序编写。

@need 1250
例如，

@smallexample
@group
  (save-restriction
    (widen)
    (save-excursion
    @var{body}@dots{}))
@end group
@end smallexample

@ignore
Emacs 22
/usr/local/src/emacs/lisp/simple.el

(defun what-line ()
  "Print the current buffer line number and narrowed line number of point."
  (interactive)
  (let ((start (point-min))
        (n (line-number-at-pos)))
    (if (= start 1)
        (message "Line %d" n)
      (save-excursion
        (save-restriction
          (widen)
          (message "line %d (narrowed line %d)"
                   (+ n (line-number-at-pos start) -1) n))))))

(defun line-number-at-pos (&optional pos)
  "Return (narrowed) buffer line number at position POS.
If POS is nil, use current buffer location.
Counting starts at (point-min), so the value refers
to the contents of the accessible portion of the buffer."
  (let ((opoint (or pos (point))) start)
    (save-excursion
      (goto-char (point-min))
      (setq start (point))
      (goto-char opoint)
      (forward-line 0)
      (1+ (count-lines start (point))))))

(defun count-lines (start end)
  "Return number of lines between START and END.
This is usually the number of newlines between them,
but can be one more if START is not equal to END
and the greater of them is not at the start of a line."
  (save-excursion
    (save-restriction
      (narrow-to-region start end)
      (goto-char (point-min))
      (if (eq selective-display t)
          (save-match-data
            (let ((done 0))
              (while (re-search-forward "[\n\C-m]" nil t 40)
                (setq done (+ 40 done)))
              (while (re-search-forward "[\n\C-m]" nil t 1)
                (setq done (+ 1 done)))
              (goto-char (point-max))
              (if (and (/= start end)
                       (not (bolp)))
                  (1+ done)
                done)))
        (- (buffer-size) (forward-line (buffer-size)))))))
@end ignore

@node what-line
@section @code{what-line}
@findex what-line
@cindex 扩展，示例

@code{what-line}命令告诉您光标所在位置的行号。该函数演示了@code{save-restriction}和@code{save-excursion}命令的用法。以下是该函数的原始文本：

@smallexample
@group
(defun what-line ()
  "打印光标所在位置（在缓冲区中）的当前行号。"
  (interactive)
  (save-restriction
    (widen)
    (save-excursion
      (beginning-of-line)
      (message "第%d行"
               (1+ (count-lines 1 (point)))))))
@end group
@end smallexample

（在GNU Emacs的现代版本中，@code{what-line}函数已经扩展，不仅告诉您在扩展缓冲区中的行号，还告诉您在狭窄缓冲区中的行号。现代版本比这里展示的版本更复杂。如果您感到有冒险精神，可以在弄清楚此版本的工作原理后查看它。您可能需要使用@kbd{C-h f}（@code{describe-function}）。新版本使用条件判断确定缓冲区是否已经被狭窄。

此外，@code{what-line}的现代版本使用@code{line-number-at-pos}，它除了简单的表达式（例如@code{(goto-char (point-min))}）外，还使用@code{(forward-line 0)}将光标移动到当前行的开头，而不是@code{beginning-of-line}。）

这里展示的@code{what-line}函数具有文档行并且是交互式的，正如您所期望的那样。接下来的两行使用了@code{save-restriction}和@code{widen}函数。

@code{save-restriction}特殊形式记录当前缓冲区中任何有效的缩小范围（如果有的话），并在@code{save-restriction}的主体代码被评估后恢复该缩小范围。

@code{save-restriction}特殊形式后跟@code{widen}。此函数撤消了在调用@code{what-line}时当前缓冲区可能存在的任何缩小。 （@code{save-restriction}记住的是存在的缩小。）这种扩展使得行计数命令能够从缓冲区的开头计数。否则，它们将受限于在可访问区域内计数。任何原始缩小都在@code{save-restriction}特殊形式完成函数后立即恢复。

对@code{widen}的调用后跟@code{save-excursion}，该函数保存光标（即点）的位置，并在@code{save-excursion}的主体代码使用@code{beginning-of-line}函数移动点后恢复它。

（请注意，@code{(widen)}表达式位于@code{save-restriction}和@code{save-excursion}特殊形式之间。当您按顺序编写两个@code{save- @dots{}}表达式时，将@code{save-excursion}写在最外层。）

@need 1200
@code{what-line}函数的最后两行是用于计算缓冲区中行数然后在回显区打印该数字的函数。

@smallexample
@group
(message "第%d行"
         (1+ (count-lines 1 (point)))))))
@end group
@end smallexample

@code{message}函数在Emacs屏幕底部打印一行消息。第一个参数位于引号中，被打印为一个字符串。但是，它可能包含@samp{%d}表达式，以打印后续参数。@samp{%d}将参数打印为十进制数，因此消息将显示类似于@samp{第243行}的内容。

@need 1200
替换@samp{%d}的位置打印的数字由函数的最后一行计算：

@smallexample
(1+ (count-lines 1 (point)))
@end smallexample

@ignore
GNU Emacs 22

(defun count-lines (start end)
  "返回START和END之间的行数。
通常这是它们之间的换行符数，
但是如果START不等于END并且它们中的较大者不在行的开头，则可能多一行。"
  (save-excursion
    (save-restriction
      (narrow-to-region start end)
      (goto-char (point-min))
      (if (eq selective-display t)
          (save-match-data
            (let ((done 0))
              (while (re-search-forward "[\n\C-m]" nil t 40)
                (setq done (+ 40 done)))
              (while (re-search-forward "[\n\C-m]" nil t 1)
                (setq done (+ 1 done)))
              (goto-char (point-max))
              (if (and (/= start end)
                       (not (bolp)))
                  (1+ done)
                done)))
        (- (buffer-size) (forward-line (buffer-size)))))))
@end ignore

@noindent
这是从缓冲区的第一个位置（由@code{1}指示）到@code{(point)}的行数，然后将其加一。 （@code{1+}函数将其参数加一。）我们加一是因为第2行之前只有一行，而@code{count-lines}只计算当前行之前的行。

在@code{count-lines}完成其工作并且消息已经在回显区打印后，@code{save-excursion}将点还原到其原始位置；@code{save-restriction}恢复原始的缩小（如果有的话）。

@node narrow Exercise
@section 使用 Narrowing 进行练习

编写一个函数，即使将缓冲区缩小到其后半部分以至于第一行不可访问，也能显示当前缓冲区的前60个字符。需要使用一系列函数，包括 @code{save-restriction}、@code{widen}、@code{goto-char}、@code{point-min}、@code{message} 和 @code{buffer-substring}。

@cindex 属性提及 @code{buffer-substring-no-properties}
（@code{buffer-substring} 是一个先前未提及的函数，您需要自行查阅；或者您可能需要使用 @code{buffer-substring-no-properties} 或 @code{filter-buffer-substring} @dots{}，还有其他函数。文本属性是本文未讨论的另一个功能。@xref{文本属性, , 文本属性, elisp, The GNU Emacs Lisp Reference Manual}。）

另外，是否真的需要 @code{goto-char} 或 @code{point-min}？或者您能否在不使用它们的情况下编写该函数？

@node car cdr & cons
@chapter @code{car}、@code{cdr} 和 @code{cons}：基本函数
@findex car@r{, introduced}
@findex cdr@r{, introduced}

在 Lisp 中，@code{car}、@code{cdr} 和 @code{cons} 是基本函数。@code{cons} 函数用于构建列表，而 @code{car} 和 @code{cdr} 函数用于分解列表。

在 @code{copy-region-as-kill} 函数的演练中，我们将看到 @code{cons} 以及两个变体的 @code{cdr}，即 @code{setcdr} 和 @code{nthcdr}。(@xref{copy-region-as-kill}.)

@menu
* Strange Names::               一个历史插曲：为什么是这些奇怪的名字？
* car & cdr::                   用于提取列表的部分的函数。
* cons::                        构建列表。
* nthcdr::                      反复调用 @code{cdr}。
* nth::
* setcar::                      更改列表的第一个元素。
* setcdr::                      更改列表的其余部分。
* cons Exercise::
@end menu

@ifnottex
@node Strange Names
@unnumberedsec Strange Names
@end ifnottex

@code{cons} 函数的名称并不无道理：它是“construct”一词的缩写。另一方面，@code{car} 和 @code{cdr} 的命名起源有些深奥：@code{car} 是短语“Contents of the Address part of the Register”的首字母缩写；而 @code{cdr}（发音为“could-er”）是短语“Contents of the Decrement part of the Register”的首字母缩写。这些短语指的是原始 Lisp 开发时使用的 IBM 704 计算机。

IBM 704 在历史上留下了痕迹，但这些名字现在已经成为 Lisp 珍爱的传统。

@node car & cdr
@section @code{car} 和 @code{cdr}

列表的 @sc{car}（首元素）简单地就是列表中的第一个项。因此，列表 @code{(rose violet daisy buttercup)} 的 @sc{car} 就是 @code{rose}。

@need 1200
如果你在 GNU Emacs 的 Info 中阅读此文档，你可以通过执行以下命令来验证：

@smallexample
(car '(rose violet daisy buttercup))
@end smallexample

@noindent
在执行此表达式之后，@code{rose} 将会出现在回显区域。

@code{car} 不会从列表中删除第一个项；它只是报告这个项是什么。在术语中，@code{car} 是“非破坏性”的。这一特性事实上变得很重要。

列表的 @sc{cdr}（剩余元素）是列表中剩下的部分，即 @code{cdr} 函数返回紧随第一个项之后的列表部分。因此，虽然列表 @code{'(rose violet daisy buttercup)} 的 @sc{car} 是 @code{rose}，但列表的其余部分，即 @code{cdr} 函数返回的值，是 @code{(violet daisy buttercup)}。

@need 800
你可以通过以通常的方式执行以下命令来验证这一点：

@smallexample
(cdr '(rose violet daisy buttercup))
@end smallexample

@noindent
当你执行此命令时，@code{(violet daisy buttercup)} 将会出现在回显区域。

与 @code{car} 一样，@code{cdr} 也不会从列表中移除任何元素，它只是返回第二个及后续元素的报告。

顺便说一下，在例子中，花卉列表是被引用的。如果没有引用，Lisp 解释器会尝试通过调用 @code{rose} 作为函数来评估列表。在这个例子中，我们不想这样做。

在处理列表时，使用 @code{first} 和 @code{rest} 这样的名称可能比 @code{car} 和 @code{cdr} 更有意义。事实上，一些程序员会将 @code{first} 和 @code{rest} 定义为 @code{car} 和 @code{cdr} 的别名，然后在代码中使用 @code{first} 和 @code{rest}。

然而，在Lisp中，列表是使用称为“cons单元”（@pxref{List Implementation}）的较低级结构构建的，在其中“第一个”或“剩余”这样的概念是不存在的，而 @sc{car} 和 @sc{cdr} 是对称的。Lisp 不会隐藏 cons 单元的存在，程序也会将它们用于除列表之外的其他事物。因此，这些名称有助于提醒程序员，尽管在列表中它们是不对称使用的，但 @code{car} 和 @code{cdr} 实际上是对称的。

@ignore
很显然，对于 @code{cdr} 来说，一个更合理的名字应该是 @code{rest}。

（这里有一个教训：当给新函数命名时，要非常谨慎，因为你可能会一直使用这些名称的时间比你预期的长。这份文档之所以延续使用这些名称，是因为 Emacs Lisp 源代码使用了它们，如果我不使用它们，你将很难阅读代码；但请尽量避免在自己的代码中使用这些术语。以后的人会感激你的。）
@end ignore

当 @code{car} 和 @code{cdr} 应用于由符号组成的列表时（例如，列表 @code{(pine fir oak maple)}），函数 @code{car} 返回的列表元素是符号 @code{pine} 而没有括号。@code{pine} 是列表中的第一个元素。然而，列表的 @sc{cdr} 本身是一个列表，即 @code{(fir oak maple)}，你可以通过以通常的方式执行以下表达式来验证：

@smallexample
@group
(car '(pine fir oak maple))

(cdr '(pine fir oak maple))
@end group
@end smallexample

另一方面，在列表的列表中，第一个元素本身是一个列表。例如，以下列表包含三个子列表，一个肉食动物列表，一个食草动物列表和一个海洋哺乳动物列表：

@smallexample
@group
(car '((lion tiger cheetah)
       (gazelle antelope zebra)
       (whale dolphin seal)))
@end group
@end smallexample

@noindent
在这个例子中，列表的第一个元素或 @sc{car} 是肉食动物列表 @code{(lion tiger cheetah)}，而列表的其余部分是 @code{((gazelle antelope zebra) (whale dolphin seal))}。

@smallexample
@group
(cdr '((lion tiger cheetah)
       (gazelle antelope zebra)
       (whale dolphin seal)))
@end group
@end smallexample

值得再次强调的是，@code{car} 和 @code{cdr} 是非破坏性的——也就是说，它们不会修改或改变应用到它们的列表。这对它们的使用非常重要。

另外，在第一章中，关于原子的讨论中，我提到在Lisp中，某些类型的原子，例如数组，可以被分解成部分；但这个机制与拆分列表的机制不同。就Lisp而言，列表的原子是不可分割的。(@xref{Lisp Atoms}.) @code{car} 和 @code{cdr} 函数用于拆分列表，被认为是Lisp的基本功能。由于它们不能拆分或访问数组的部分，数组被认为是原子。相反，另一个基本函数 @code{cons} 可以组合或构造列表，但不能构造数组。 （数组由数组特定的函数处理。@xref{Arrays, , Arrays, elisp, The GNU Emacs Lisp Reference Manual}。）

@node cons
@section @code{cons}
@findex cons@r{, introduced}

@code{cons}函数用于构建列表；它是@code{car}和@code{cdr}的反函数。例如，@code{cons}可以用来从三元素列表@code{(fir oak maple)}中创建一个四元素列表：

@smallexample
(cons 'pine '(fir oak maple))
@end smallexample

@need 800
@noindent
在评估了这个列表之后，你将会看到：

@smallexample
(pine fir oak maple)
@end smallexample

@noindent
出现在回显区。@code{cons}导致创建一个新的列表，其中元素后面是原始列表的元素。

我们经常说@code{cons}将一个新元素放在列表的开头，或者附加或推送元素到列表中，但这种表达可能会误导，因为@code{cons}不会改变现有的列表，而是创建一个新列表。

与@code{car}和@code{cdr}一样，@code{cons}是非破坏性的。

@menu
* Build a list::
* length::                      如何找到列表的长度。
@end menu

@ifnottex
@node Build a list
@unnumberedsubsec 构建列表
@end ifnottex

@code{cons}必须有一个要附加的列表。@footnote{实际上，你可以将元素@code{cons}到原子上以生成一个点对。这里不讨论点对；参见@ref{Dotted Pair Notation, , Dotted Pair Notation, elisp, The GNU Emacs Lisp Reference Manual}。} 你不能从绝对的空白开始。如果你正在构建一个列表，你需要至少在开头提供一个空列表。以下是一系列的@code{cons}表达式，用于构建一系列花的列表。如果你在GNU Emacs中的Info中阅读这个，你可以按照通常的方式评估每个表达式；值将在这个文本中以@samp{@result{}}打印出来，你可以将其解读为“评估为”。

@smallexample
@group
(cons 'buttercup ())
     @result{} (buttercup)
@end group

@group
(cons 'daisy '(buttercup))
     @result{} (daisy buttercup)
@end group

@group
(cons 'violet '(daisy buttercup))
     @result{} (violet daisy buttercup)
@end group

@group
(cons 'rose '(violet daisy buttercup))
     @result{} (rose violet daisy buttercup)
@end group
@end smallexample

@noindent
在第一个例子中，空列表显示为@code{()}，并构建了一个由@code{buttercup}后面跟着空列表的列表。正如你所见，空列表在构建的列表中没有显示。因为空列表中没有任何内容，通常来说，空列表是不可见的。

在第二个例子中，@code{(cons 'daisy '(buttercup))}通过将@code{daisy}放在@code{buttercup}前面构建了一个新的两元素列表；第三个例子通过将@code{violet}放在@code{daisy}和@code{buttercup}前面构建了一个三元素列表。

@node length
@subsection 查找列表的长度：@code{length}
@findex length

你可以使用Lisp函数@code{length}来查找列表中有多少元素，例如以下示例：

@smallexample
@group
(length '(buttercup))
     @result{} 1
@end group

@group
(length '(daisy buttercup))
     @result{} 2
@end group

@group
(length (cons 'violet '(daisy buttercup)))
     @result{} 3
@end group
@end smallexample

@noindent
在第三个例子中，@code{cons}函数用于构建一个包含三个元素的列表，然后将其作为参数传递给@code{length}函数。

@need 1200
我们还可以使用@code{length}来计算空列表中的元素个数：

@smallexample
@group
(length ())
     @result{} 0
@end group
@end smallexample

@noindent
正如你所期望的那样，空列表中的元素个数为零。

一个有趣的实验是找出当你尝试找到根本没有列表的长度时会发生什么；也就是说，如果你尝试调用@code{length}而没有给它提供参数，甚至没有空列表：

@smallexample
(length )
@end smallexample

@need 800
@noindent
如果你评估这个表达式，你将看到错误消息：

@smallexample
Lisp error: (wrong-number-of-arguments length 0)
@end smallexample

@noindent
这意味着函数在期望某个其他数量的参数时（在本例中是一个参数），收到了错误数量的参数，即零。在这种情况下，期望一个参数，而参数是要测量其长度的列表。（注意，@emph{一个}列表是@emph{一个}参数，即使列表内有多个元素。）

错误消息中的@samp{length}是函数的名称。

@ignore
@code{length}仍然是一个子例程，但你需要使用C-h f来发现这一点。

在早期版本中：
这是用一种特殊的符号@samp{#<subr}写的，表示函数@code{length}是用C编写而不是用Emacs Lisp编写的原始函数之一。(@samp{subr}是“子例程”的缩写。) 更多关于子例程的信息，请参阅@ref{What Is a Function, , What Is a Function?, elisp, The GNU Emacs Lisp Reference Manual}。
@end ignore

@node nthcdr
@section @code{nthcdr}
@findex nthcdr

函数 @code{nthcdr} 与函数 @code{cdr} 相关联。它的作用是重复地取一个列表的 @sc{cdr}。

如果对列表 @code{(pine fir oak maple)} 进行 @sc{cdr} 操作，将得到列表 @code{(fir oak maple)}。如果在这个结果上再进行一次 @sc{cdr}，将得到列表 @code{(oak maple)}。当然，对原始列表反复 @sc{cdr} 只会得到原始的 @sc{cdr}，因为该函数不会改变列表。需要对 @sc{cdr} 进行评估，然后继续操作。最终，你将得到一个空列表，在这个例子中，它显示为 @code{nil} 而非 @code{()}。

@need 1200
为了复习，以下是一系列重复的 @sc{cdr} 操作，@samp{@result{}} 后的文本显示了返回的结果。

@smallexample
@group
(cdr '(pine fir oak maple))
     @result{} (fir oak maple)
@end group

@group
(cdr '(fir oak maple))
     @result{} (oak maple)
@end group

@group
(cdr '(oak maple))
     @result{} (maple)
@end group

@group
(cdr '(maple))
     @result{} nil
@end group

@group
(cdr 'nil)
     @result{} nil
@end group

@group
(cdr ())
     @result{} nil
@end group
@end smallexample

@need 1200
你也可以进行多次 @sc{cdr} 操作而不打印中间值，像这样：

@smallexample
@group
(cdr (cdr '(pine fir oak maple)))
     @result{} (oak maple)
@end group
@end smallexample

@noindent
在这个例子中，Lisp 解释器首先评估最内层的列表。最内层的列表被引用，因此它只是将列表传递给最内层的 @code{cdr}。这个 @code{cdr} 将由列表的第二个及之后的元素组成的列表传递给最外层的 @code{cdr}，产生一个由原始列表的第三个及之后的元素组成的列表。在这个例子中，重复调用 @code{cdr} 函数并返回一个由原始列表的前两个元素之外的元素组成的列表。

函数 @code{nthcdr} 的作用与重复调用 @code{cdr} 相同。在下面的例子中，参数 2 被传递给函数 @code{nthcdr}，连同列表一起传递，返回的值是没有前两个项的列表，这与在列表上连续调用两次 @code{cdr} 是一样的：

@smallexample
@group
(nthcdr 2 '(pine fir oak maple))
     @result{} (oak maple)
@end group
@end smallexample

@need 1200
使用原始的四个元素列表，我们可以看到当传递不同的数值参数给 @code{nthcdr} 时会发生什么，包括 0、1 和 5：

@smallexample
@group
;; @r{保留列表不变。}
(nthcdr 0 '(pine fir oak maple))
     @result{} (pine fir oak maple)
@end group

@group
;; @r{返回去掉第一个元素的列表副本。}
(nthcdr 1 '(pine fir oak maple))
     @result{} (fir oak maple)
@end group

@group
;; @r{返回去掉三个元素的列表副本。}
(nthcdr 3 '(pine fir oak maple))
     @result{} (maple)
@end group

@group
;; @r{返回去掉所有四个元素的列表副本。}
(nthcdr 4 '(pine fir oak maple))
     @result{} nil
@end group

@group
;; @r{返回去掉所有元素的列表副本。}
(nthcdr 5 '(pine fir oak maple))
     @result{} nil
@end group
@end smallexample

@node nth
@section @code{nth}
@findex nth

函数 @code{nthcdr} 重复获取列表的 @sc{cdr}。函数 @code{nth} 获取由 @code{nthcdr} 返回的结果的 @sc{car}。它返回列表的第 N 个元素。

@need 1500
因此，如果不是为了速度而在C中定义，@code{nth} 的定义将是：

@smallexample
@group
(defun nth (n list)
  "返回列表 LIST 的第 N 个元素。
N 从零开始计数。如果列表没有那么长，则返回 nil。"
  (car (nthcdr n list)))
@end group
@end smallexample

@noindent
(最初，@code{nth} 是在Emacs Lisp中在@file{subr.el}中定义的，但它的定义在1980年代被重写为C语言。)

@code{nth} 函数返回列表的单个元素。这可能非常方便。

请注意，元素从零开始编号，而不是从一开始。也就是说，列表的第一个元素，它的 @sc{car} 是零号元素。这种从零开始计数通常会让习惯于列表中第一个元素为编号一的人感到困扰。

@need 1250
例如：

@smallexample
@group
(nth 0 '("one" "two" "three"))
    @result{} "one"

(nth 1 '("one" "two" "three"))
    @result{} "two"
@end group
@end smallexample

值得一提的是，@code{nth}、@code{nthcdr} 和 @code{cdr} 都不会改变原始列表---这些函数是非破坏性的。这与 @code{setcar} 和 @code{setcdr} 函数形成鲜明对比。

@node setcar
@section @code{setcar}
@findex setcar

从它们的名字中，你可能已经猜到了，@code{setcar} 和 @code{setcdr} 函数用于将列表的 @sc{car} 或 @sc{cdr} 设置为新值。它们实际上会改变原始列表，与 @code{car} 和 @code{cdr} 不同，它们保持原始列表不变。了解这是如何工作的一种方法是进行实验。我们首先来看一下 @code{setcar} 函数。

@need 1200
首先，我们可以创建一个列表，然后使用 @code{setq} 特殊形式将变量的值设置为该列表。因为我们打算使用 @code{setcar} 来更改列表，所以这个 @code{setq} 不应该使用引用形式 @code{'(antelope giraffe lion tiger)}，因为那将产生一个程序的一部分的列表，如果我们尝试在运行时更改程序的一部分，可能会导致问题。通常来说，Emacs Lisp 程序的组件在程序运行时应该是常量（或不变的）。因此，我们使用 @code{list} 函数构造一个动物列表，如下所示：

@smallexample
(setq animals (list 'antelope 'giraffe 'lion 'tiger))
@end smallexample

@noindent
如果你在 GNU Emacs 中的 Info 中阅读这篇文章，你可以通过按 @kbd{C-x C-e} 将光标定位在表达式之后，以通常的方式评估这个表达式。（我在写这篇文章的时候就是这样做的。这是将解释器内置到计算环境中的优势之一。顺便说一句，当最终括号之后的行上没有任何内容，比如注释时，光标可以在下一行。因此，如果你的光标在下一行的第一列，你不需要移动它。事实上，Emacs 允许在最终括号之后有任意量的空白。）

@need 1200
当我们评估变量 @code{animals} 时，我们看到它绑定到列表 @code{(antelope giraffe lion tiger)}：

@smallexample
@group
animals
     @result{} (antelope giraffe lion tiger)
@end group
@end smallexample

@noindent
换句话说，变量 @code{animals} 指向列表 @code{(antelope giraffe lion tiger)}。

接下来，评估函数 @code{setcar}，同时传递给它两个参数，变量 @code{animals} 和引用的符号 @code{hippopotamus}；这是通过编写三个元素的列表 @code{(setcar animals 'hippopotamus)}，然后以通常的方式评估它来完成的：

@smallexample
(setcar animals 'hippopotamus)
@end smallexample

@need 1200
@noindent
评估完这个表达式后，再次评估变量 @code{animals}。你会看到动物列表已经改变了：

@smallexample
@group
animals
     @result{} (hippopotamus giraffe lion tiger)
@end group
@end smallexample

@noindent
列表的第一个元素 @code{antelope} 被 @code{hippopotamus} 替换。

所以我们可以看到，@code{setcar} 并没有像 @code{cons} 那样向列表中添加新元素；它替换了 @code{antelope} 为 @code{hippopotamus}；它@emph{改变了}列表。

@node setcdr
@section @code{setcdr}
@findex setcdr

@code{setcdr}函数类似于@code{setcar}函数，不同之处在于该函数替换列表的第二个及其后的元素，而不是第一个元素。

(要了解如何更改列表的最后一个元素，请查看@ref{kill-new function, , @code{kill-new} 函数}，该函数使用@code{nthcdr}和@code{setcdr}函数。)

@need 1200
为了了解它是如何工作的，请通过评估以下表达式将变量的值设置为一组驯养的动物：

@smallexample
(setq domesticated-animals (list 'horse 'cow 'sheep 'goat))
@end smallexample

@need 1200
@noindent
如果现在评估该列表，将返回列表@code{(horse cow sheep goat)}：

@smallexample
@group
domesticated-animals
     @result{} (horse cow sheep goat)
@end group
@end smallexample

@need 1200
接下来，通过使用两个参数评估@code{setcdr}，第一个参数是具有列表值的变量的名称，第二个参数是将设置为第一个列表的@sc{cdr}的列表；

@smallexample
(setcdr domesticated-animals '(cat dog))
@end smallexample

@noindent
如果评估此表达式，将在回显区域看到列表@code{(cat dog)}。这是该函数返回的值。我们感兴趣的结果是副作用，可以通过评估变量@code{domesticated-animals}来查看：

@smallexample
@group
domesticated-animals
     @result{} (horse cat dog)
@end group
@end smallexample

@noindent
确实，列表从@code{(horse cow sheep goat)}更改为@code{(horse cat dog)}。列表的@sc{cdr}从@code{(cow sheep goat)}更改为@code{(cat dog)}。

@node cons Exercise
@section 练习

通过评估多个表达式使用@code{cons}构建一个包含四只鸟的列表。了解当你使用@code{cons}将一个列表连接到自身时会发生什么。将四只鸟的列表的第一个元素替换为一条鱼。用其他鱼的列表替换该列表的其余部分。

@node Cutting & Storing Text
@chapter 剪切与存储文本
@cindex 剪切与存储文本
@cindex 存储与剪切文本
@cindex 删除文本
@cindex 剪切文本
@cindex 擦除文本
@cindex 删除文本

无论何时在GNU Emacs中使用@dfn{kill}命令剪切或剪贴文本，它都会被存储在一个列表中，您可以使用@dfn{yank}命令将其恢复。

（在Emacs中使用“kill”一词来表示那些特别@emph{不}破坏实体值的过程是一个不幸的历史偶然。一个更合适的词语应该是“剪切”，因为kill命令的作用是剪切文本并将其放入存储中，从中可以重新调用。我经常被诱惑着全局替换Emacs源代码中所有“kill”出现的地方为“clip”，并将所有“killed”的出现地方替换为“clipped”）。

@menu
* Storing Text::                   文本被存储在一个列表中。
* zap-to-char::               剪切文本直到某个字符。
* kill-region::               从区域中剪切文本。
* copy-region-as-kill::       复制文本的定义。
* Digression into C::               C编程语言宏的小注记。
* defvar::                    如何给变量一个初始值。
* cons & search-fwd Review::
* search Exercises::
@end menu

@ifnottex
@node Storing Text
@unnumberedsec 将文本存储在列表中
@end ifnottex

当文本从缓冲区中剪切出来时，它被存储在一个列表中。连续的文本片段被依次存储在列表中，因此列表可能看起来像这样：

@smallexample
("一段文本" "之前的片段")
@end smallexample

@need 1200
@noindent
函数@code{cons}可用于从文本片段（称为“原子”）和现有列表创建一个新列表，如下所示：

@smallexample
@group
(cons "另一段"
      '("一段文本" "之前的片段"))
@end group
@end smallexample

@need 1200
@noindent
如果您评估此表达式，一个包含三个元素的列表将显示在回显区：

@smallexample
("另一段" "一段文本" "之前的片段")
@end smallexample

使用@code{car}和@code{nthcdr}函数，您可以检索您想要的任何文本片段。例如，在以下代码中，@code{nthcdr 1 @dots{}}返回删除第一个项目的列表；而@code{car}返回该剩余部分的第一个元素---原始列表的第二个元素：

@smallexample
@group
(car (nthcdr 1 '("另一段"
                 "一段文本"
                 "之前的片段")))
     @result{} "一段文本"
@end group
@end smallexample

实际的Emacs函数当然比这更复杂。剪切和检索文本的代码必须被编写，以便Emacs可以弄清楚您想要列表中的哪个元素---第一个、第二个、第三个等。此外，当到达列表的末尾时，Emacs应该给您列表的第一个元素，而不是什么都不给您。

保存文本片段的列表称为@dfn{kill环}。本章首先描述了kill环，以及首先追踪@code{zap-to-char}函数的工作方式。此函数调用一个调用函数，该函数操纵kill环。因此，在到达山脚之前，我们要先爬过丘陵。

后续章节描述了从缓冲区剪切的文本如何被检索。@xref{Yanking, , 检索文本}。

@node zap-to-char
@section @code{zap-to-char}
@findex zap-to-char

让我们看一下交互式函数 @code{zap-to-char}。

@menu
* Complete zap-to-char::        完整的实现。
* zap-to-char interactive::     一个三部分的交互式表达式。
* zap-to-char body::            简要概述。
* search-forward::              如何搜索字符串。
* progn::                       特殊形式 @code{progn}。
* Summing up zap-to-char::      使用 @code{point} 和 @code{search-forward}。
@end menu

@ifnottex
@node Complete zap-to-char
@unnumberedsubsec 完整的 @code{zap-to-char} 实现
@end ifnottex

@code{zap-to-char} 函数删除光标位置（即 point）到下一个指定字符（包括该字符）之间的文本。@code{zap-to-char} 删除的文本被放入 kill ring，可以通过键入 @kbd{C-y}（@code{yank}）从 kill ring 中检索。如果给命令传递了一个参数，它将通过指定数量的出现次数删除文本。因此，如果光标位于本句的开头，字符为 @samp{s}，则将删除 @samp{Thus}。如果参数为二，则将删除 @samp{Thus, if the curs}，直到 @samp{cursor} 中的 @samp{s}。

如果未找到指定的字符，@code{zap-to-char} 将显示“Search failed”，告诉您输入的字符，并且不会删除任何文本。

为了确定要删除多少文本，@code{zap-to-char} 使用搜索函数。搜索在处理文本的代码中广泛使用，我们将重点关注搜索以及删除命令。

@ignore
@c GNU Emacs version 19
(defun zap-to-char (arg char)  ; version 19 implementation
  "Kill up to and including ARG'th occurrence of CHAR.
Goes backward if ARG is negative; error if CHAR not found."
  (interactive "*p\ncZap to char: ")
  (kill-region (point)
               (progn
                 (search-forward
                  (char-to-string char) nil nil arg)
                 (point))))
@end ignore

@need 1250
下面是版本 22 的函数实现的完整文本：

@c GNU Emacs 22
@smallexample
@group
(defun zap-to-char (arg char)
  "Kill up to and including ARG'th occurrence of CHAR.
Case is ignored if `case-fold-search' is non-nil in the current buffer.
Goes backward if ARG is negative; error if CHAR not found."
  (interactive "p\ncZap to char: ")
  (if (char-table-p translation-table-for-input)
      (setq char (or (aref translation-table-for-input char) char)))
  (kill-region (point) (progn
                         (search-forward (char-to-string char)
                                         nil nil arg)
                         (point))))
@end group
@end smallexample

文档非常详细。您需要了解“kill”这个术语的含义。

@cindex curved quotes
@cindex curly quotes
@code{zap-to-char} 版本 22 的文档字符串使用 ASCII grave accent 和撇号引用一个符号，因此它显示为 @t{`case-fold-search'}。这种引用风格受到上世纪 70 年代显示器的启发，在那里 grave accent 和撇号经常是镜像图像，适合用作引号。在大多数现代显示器上，这不再成立，当这两个 ASCII 字符出现在文档字符串或诊断消息格式中时，Emacs 通常将它们转换为 @dfn{弯引号}（左右单引号），因此上面引用的符号显示为 @t{‘case-fold-search’}。源代码字符串也可以直接使用弯引号。

@node zap-to-char interactive
@subsection @code{interactive} 表达式

@need 800
@code{zap-to-char} 命令中的交互式表达式如下：

@smallexample
(interactive "p\ncZap to char: ")
@end smallexample

引号内的部分，@code{"p\ncZap to char: "}，指定了两个不同的信息。首先，最简单的是 @samp{p}。这一部分与下一部分由换行符 @samp{\n} 分隔。@samp{p} 表示函数的第一个参数将传递一个 @dfn{processed prefix} 的值。前缀参数通过键入 @kbd{C-u} 和一个数字，或者 @kbd{M-} 和一个数字传递。如果在不带前缀的情况下交互调用该函数，则将 1 传递给此参数。

@code{"p\ncZap to char: "} 的第二部分是 @samp{cZap to char:@:  }。在这一部分中，小写的 @samp{c} 表示 @code{interactive} 期望一个提示，并且参数将是一个字符。提示跟在 @samp{c} 后面，是字符串 @samp{Zap to char:@: }（冒号后面有一个空格，使其看起来更好）。

所有这些都是为了准备 @code{zap-to-char} 的参数，以使它们具有正确的类型，并为用户提供提示。

在只读缓冲区中，@code{zap-to-char} 函数将文本复制到 kill ring，但不删除它。回显区显示一条消息，指示缓冲区是只读的。此外，终端可能会发出哔声或闪烁提醒。

@node zap-to-char body
@subsection @code{zap-to-char}函数的主体

@code{zap-to-char}函数的主体包含了用于删除（即移除）文本的代码，该文本位于光标当前位置到指定字符（包括该字符）的区域。

代码的第一部分如下：

@smallexample
(if (char-table-p translation-table-for-input)
    (setq char (or (aref translation-table-for-input char) char)))
(kill-region (point) (progn
                       (search-forward (char-to-string char) nil nil arg)
                       (point)))
@end smallexample

@noindent
@code{char-table-p}是一个前文未见的函数。它用于确定其参数是否为字符表。当是字符表时，它将传递给@code{zap-to-char}的字符设置为其中之一（如果该字符存在），否则设置为字符本身。（这对于非欧洲语言中的某些字符很重要。@code{aref}函数从数组中提取元素。它是一个特定于数组的函数，本文档不详细描述。@xref{Arrays, , Arrays, elisp, The GNU Emacs Lisp Reference Manual}。）

@noindent
@code{(point)}是光标的当前位置。

代码的下一部分是一个使用@code{progn}的表达式。@code{progn}的主体由对@code{search-forward}和@code{point}的调用组成。

在学习@code{progn}之前，了解一下@code{search-forward}会更容易理解，因此我们将先看看@code{search-forward}，然后再看@code{progn}。

@node search-forward
@subsection @code{search-forward}函数
@findex search-forward

@code{search-forward}函数用于在@code{zap-to-char}中定位要删除的字符。如果搜索成功，@code{search-forward}将光标立即置于目标字符串的最后一个字符之后。（在@code{zap-to-char}中，目标字符串只有一个字符长。@code{zap-to-char}使用@code{char-to-string}函数确保计算机将该字符视为字符串。）如果搜索是向后的，@code{search-forward}将光标放在目标的第一个字符之前。此外，@code{search-forward}返回@code{t}表示真（移动光标因此是一个副作用）。

@need 1250
在@code{zap-to-char}中，@code{search-forward}函数如下：

@smallexample
(search-forward (char-to-string char) nil nil arg)
@end smallexample

@code{search-forward}函数接受四个参数：

@enumerate
@item
第一个参数是目标，即要搜索的内容。这必须是一个字符串，例如@samp{"z"}。

正好传递给@code{zap-to-char}的参数是一个单个字符。由于计算机的构造方式，Lisp解释器可能会将单个字符视为与字符串不同。在计算机内部，单个字符具有与一个字符的字符串不同的电子格式。（计算机中通常可以用一个字节精确地记录一个单个字符；但字符串可能更长，计算机需要为此做好准备。）因此，@code{zap-to-char}函数接收的字符必须在计算机内部从一种格式转换为另一种格式；否则，@code{search-forward}函数将失败。使用@code{char-to-string}函数进行此转换。

@item
第二个参数限制了搜索的范围；它指定为缓冲区中的位置。在这种情况下，搜索可以到达缓冲区的末尾，因此未设置边界，第二个参数为@code{nil}。

@item
第三个参数告诉函数如果搜索失败应该做什么——它可以发出错误（并打印一条消息），或者返回@code{nil}。将@code{nil}作为第三个参数会导致函数在搜索失败时发出错误。

@item
@code{search-forward}的第四个参数是重复计数——要查找字符串的出现次数。此参数是可选的，如果函数在没有重复计数的情况下调用，则此参数将传递值1。如果此参数为负数，则搜索将向后进行。
@end enumerate

@need 800
在模板形式中，@code{search-forward}表达式如下：

@smallexample
@group
(search-forward "@var{target-string}"
                @var{limit-of-search}
                @var{what-to-do-if-search-fails}
                @var{repeat-count})
@end group
@end smallexample

接下来我们将看一下@code{progn}。

@node progn
@subsection @code{progn}特殊形式
@findex progn

@code{progn}是一种特殊形式，它导致按顺序评估其每个参数，然后返回最后一个参数的值。前面的表达式仅为它们执行的副作用而进行评估。它们产生的值被丢弃。

@need 800
@code{progn}表达式的模板非常简单：

@smallexample
@group
(progn
  @var{body}@dots{})
@end group
@end smallexample

在`zap-to-char`中，@code{progn}表达式必须执行两个操作：将点放置在准确的位置，并返回点的位置，以便@code{kill-region}知道要删除多远。

@code{progn}的第一个参数是@code{search-forward}。当@code{search-forward}找到字符串时，该函数将点立即置于目标字符串的最后一个字符之后。（在本例中，目标字符串只有一个字符长。）如果搜索是向后的，则@code{search-forward}将点置于目标的第一个字符之前。点的移动是一个副作用。

@code{progn}的第二个也是最后一个参数是表达式@code{(point)}。此表达式返回点的值，而在这种情况下，它将是由@code{search-forward}移动到的位置。（在源代码中，一行指示函数转到前一个字符（如果它是向前的）的代码在1999年被注释掉了；我不记得这个功能或错误是否曾经是分布源代码的一部分。）@code{point}的值由@code{progn}表达式返回，并作为@code{kill-region}的第二个参数传递。

@node Summing up zap-to-char
@subsection 总结@code{zap-to-char}

现在我们已经看到了@code{search-forward}和@code{progn}的工作原理，我们可以看到@code{zap-to-char}函数是如何整体工作的。

@code{kill-region}的第一个参数是在给定@code{zap-to-char}命令时光标的位置——即那个时刻的点的值。在@code{progn}内，搜索函数然后将点移动到刚刚删除的字符之后，并且@code{point}返回此位置的值。@code{kill-region}函数将这两个点的值组合在一起，第一个作为区域的起始，第二个作为区域的结束，然后删除该区域。

@code{progn}特殊形式是必需的，因为@code{kill-region}命令接受两个参数；如果@code{search-forward}和@code{point}表达式被顺序写为两个额外的参数，它将失败。@code{progn}表达式是@code{kill-region}的单个参数，并返回@code{kill-region}所需的唯一值作为其第二个参数。

@node kill-region
@section @code{kill-region}
@findex kill-region

@code{zap-to-char} 函数使用 @code{kill-region} 函数。这个函数从一个区域裁剪文本并将其复制到 kill ring 中，然后可以从中检索该文本。

@ignore
GNU Emacs 22:

(defun kill-region (beg end &optional yank-handler)
  "杀死（\"cut\"）点和标记之间的文本。
这会从缓冲区中删除文本并将其保存在 kill ring 中。
命令 \\[yank] 可以从中检索它。
\(如果你想要立即杀死然后粘贴，使用 \\[kill-ring-save]。)

如果你想将被杀死的区域追加到上次被杀死的文本中，
在 \\[kill-region] 之前使用 \\[append-next-kill]。

如果缓冲区是只读的，Emacs 会响铃并且不会删除文本，但仍会将文本放入 kill ring 中。
这意味着你可以使用删除命令从只读缓冲区复制文本。

这是程序用于杀死文本的原语（与删除不同）。
提供两个参数，指示要杀死的文本范围的字符位置。
调用此函数的任何命令都是“杀死命令”。
如果上一个命令也是杀死命令，
这次被杀死的文本将追加到上次被杀死的文本中，
形成 kill ring 中的一个条目。

在 Lisp 代码中，可选的第三个参数 YANK-HANDLER，如果非空，指定要设置在被杀死文本上的 yank-handler 文本属性。参见 `insert-for-yank'。"
  ;; 传递 point 先，然后是 mark，因为在调用 kill-append 时顺序很重要。
  (interactive (list (point) (mark)))
  (unless (and beg end)
    (error "当前未设置标记，因此没有区域"))
  (condition-case nil
      (let ((string (filter-buffer-substring beg end t)))
        (when string                        ;如果 BEG = END，则 STRING 为 nil
          ;; 以某种方式将该字符串添加到 kill ring 中。
          (if (eq last-command 'kill-region)
              (kill-append string (< end beg) yank-handler)
            (kill-new string nil yank-handler)))
        (when (or string (eq last-command 'kill-region))
          (setq this-command 'kill-region))
        nil)
    ((buffer-read-only text-read-only)
     ;; 上面的代码失败，因为缓冲区或区域中的某些字符是只读的。
     ;; 我们应该响铃，以防用户不知道这一点。
     ;; 但是无论如何，将区域的文本放入 kill ring 中都没有害处。
     (copy-region-as-kill beg end)
     ;; 现在设置 this-command，以便即使出现错误也会设置它。
     (setq this-command 'kill-region)
     ;; 如果 kill-read-only-ok 为真，则不会发生错误，而是发出消息。
     (if kill-read-only-ok
         (progn (message "只读文本已复制到 kill ring") nil)
       ;; 如果缓冲区是只读的，则发出错误。
       (barf-if-buffer-read-only)
       ;; 如果缓冲区不是只读的，那么文本是只读的。
       (signal 'text-read-only (list (current-buffer)))))))
@end ignore

该函数的 Emacs 22 版本使用了 @code{condition-case} 和 @code{copy-region-as-kill}，我们将对两者进行解释。@code{condition-case} 是一个重要的特殊形式。

实质上，@code{kill-region} 函数调用 @code{condition-case}，它接受三个参数。在这个函数中，第一个参数什么也不做。第二个参数包含当一切顺利时执行的代码。第三个参数包含在出现错误时调用的代码。

@menu
* Complete kill-region::        函数定义。
* condition-case::              处理问题。
* Lisp macro::
@end menu

@ifnottex
@node Complete kill-region
@unnumberedsubsec 完整的 @code{kill-region} 定义
@end ifnottex

@need 1200
我们将逐步讲解 @code{condition-case} 代码。首先，让我们看一下 @code{kill-region} 的定义，附带注释：

@c GNU Emacs 22:
@smallexample
@group
(defun kill-region (beg end)
  "Kill (\"cut\") text between point and mark.
This deletes the text from the buffer and saves it in the kill ring.
The command \\[yank] can retrieve it from there. @dots{} "
@end group

@group
  ;; @bullet{} 由于顺序很重要，首先传递 point。
  (interactive (list (point) (mark)))
  ;; @bullet{} 并告诉我们如果无法剪切文本要怎么办。
  ;; 'unless' 是没有 then 部分的 'if'。
  (unless (and beg end)
    (error "The mark is not set now, so there is no region"))
@end group

@group
  ;; @bullet{} 'condition-case' 接受三个参数。
  ;;    如果第一个参数是 nil，就像这里一样，
  ;;    错误信号的信息就不会被存储以供其他函数使用。
  (condition-case nil
@end group

@group
      ;; @bullet{} 'condition-case' 的第二个参数告诉 Lisp 解释器
      ;;    一切正常时要做什么。
@end group

@group
      ;;    它以一个 'let' 函数开始，提取字符串并测试它是否存在。
      ;;    如果存在（这是 'when' 检查的内容），它调用一个 'if' 函数，
      ;;    用于确定前一个命令是否是对 'kill-region' 的另一个调用；
      ;;    如果是，则新文本附加到先前的文本；如果不是，则调用
      ;;    另一个函数 'kill-new'。
@end group

@group
      ;;    'kill-append' 函数连接新字符串和旧字符串。
      ;;    'kill-new' 函数将文本插入到 kill 环中的新项目中。
@end group

@group
      ;;    'when' 是没有 else 部分的 'if'。
      ;;    第二个 'when' 再次检查当前字符串是否存在；
      ;;    此外，它还检查前一个命令是否是对 'kill-region' 的另一个调用。
      ;;    如果其中一个条件为真，则将当前命令设置为 'kill-region'。
@end group
@group
      (let ((string (filter-buffer-substring beg end t)))
        (when string                    ; 如果 BEG = END，则 STRING 为 nil
          ;; 将该字符串添加到 kill ring 中，以某种方式。
          (if (eq last-command 'kill-region)
@end group
@group
              ;;    @minus{} 'yank-handler' 是传递给 'kill-region' 的可选参数，
              ;;    告诉 'kill-append' 和 'kill-new' 函数如何处理添加到文本中的属性，
              ;;    例如 'bold' 或 'italics'。
              (kill-append string (< end beg) yank-handler)
            (kill-new string nil yank-handler)))
        (when (or string (eq last-command 'kill-region))
          (setq this-command 'kill-region))
        nil)
@end group

@group
    ;;  @bullet{} 'condition-case' 的第三个参数告诉解释器
    ;;    发生错误时要做什么。
@end group
@group
    ;;    第三个参数有一个条件部分和一个体部分。
    ;;    如果满足条件（在这种情况下，如果文本或缓冲区是只读的）
    ;;    那么就执行体部分。
@end group
@group
    ((buffer-read-only text-read-only) ;; 条件部分
     ;; @dots{} 体部分
     (copy-region-as-kill beg end)
@end group
@group
     ;;    接下来，同样作为体部分的一部分，设置 this-command，
     ;;    这样它将在错误中被设置。
     (setq this-command 'kill-region)
     ;;    最后，在体部分，如果可以在不发出错误的情况下将文本复制到 kill ring 中，则发送消息，否则不发送。
@end group
@group
     (if kill-read-only-ok
         (progn (message "Read only text copied to kill ring") nil)
       (barf-if-buffer-read-only)
       ;; 如果缓冲区不是只读的，则文本是只读的。
       (signal 'text-read-only (list (current-buffer)))))))
@end group
@end smallexample

@ignore
@c v 21
@smallexample
@group
(defun kill-region (beg end)
  "Kill between point and mark.
The text is deleted but saved in the kill ring."
  (interactive "r")
@end group

@group
  ;; 1. 'condition-case' 接受三个参数。
  ;;    如果第一个参数是 nil，就像这里一样，
  ;;    错误信号的信息就不会被存储以供其他函数使用。
  (condition-case nil
@end group

@group
      ;; 2. 'condition-case' 的第二个参数告诉 Lisp 解释器
      ;;    一切正常时要做什么。
@end group

@group
      ;;    'delete-and-extract-region' 函数通常执行工作。
      ;;    如果区域的开头和结尾都相同，则变量 'string' 将为空，或 nil。
      (let ((string (delete-and-extract-region beg end)))
@end group

@group
        ;; 'when' 是一个不能有 'else-part' 的 'if' 子句。
        ;; Emacs 通常将 'last-command' 的值设置为前一个命令。
@end group
@group
        ;; 'kill-append' 连接新字符串和旧字符串。
        ;; 'kill-new' 在 kill 环中的新项目中插入文本。
        (when string
          (if (eq last-command 'kill-region)
              ;; 如果为真，则在字符串之前添加字符串
              (kill-append string (< end beg))
            (kill-new string)))
        (setq this-command 'kill-region))
@end group

@group
    ;; 3. 'condition-case' 的第三个参数告诉解释器
    ;;    发生错误时要做什么。
@end group
@group
    ;;    第三个参数有一个条件部分和一个体部分。
    ;;    如果满足条件（在这种情况下，
    ;;             如果文本或缓冲区是只读的）
    ;;    那么就执行体部分。
@end group
@group
    ((buffer-read-only text-read-only) ;; 这是条件部分
     ;; 然后...
     (copy-region-as-kill beg end)
@end group
@group
     (if kill-read-only-ok            ;; 通常这个变量是 nil
         (message "Read only text copied to kill ring")
       ;; 否则，如果缓冲区是只读的，发出错误信号；
       (barf-if-buffer-read-only)
       ;; 并且，在任何情况下，都发出文本是只读的信号。
       (signal 'text-read-only (list (current-buffer)))))))
@end group
@end smallexample
@end ignore

@node condition-case
@subsection @code{condition-case}
@findex condition-case

正如我们之前所看到的（@pxref{Making Errors, , Generate an Error
Message}），当Emacs Lisp解释器在评估表达式时遇到问题时，它会为您提供帮助；在行话中，这被称为“发出错误信号”。通常，计算机会停止程序并显示一条消息。

然而，一些程序执行复杂的操作。它们在发生错误时不应该简单地停止。在@code{kill-region}函数中，最可能的错误是您尝试删除只读且无法删除的文本。因此，@code{kill-region}函数包含处理此情况的代码。这段代码构成了@code{kill-region}函数的主体，位于@code{condition-case}特殊形式中。

@need 800
@code{condition-case}的模板如下：

@smallexample
@group
(condition-case
  @var{var}
  @var{bodyform}
  @var{error-handler}@dots{})
@end group
@end smallexample

第二个参数，@var{bodyform}，很直观。@code{condition-case}特殊形式导致Lisp解释器评估@var{bodyform}中的代码。如果没有错误发生，特殊形式将返回代码的值并产生副作用（如果有的话）。

简而言之，@code{condition-case}表达式的@var{bodyform}部分决定一切正常时应该发生什么。

然而，如果发生错误，除了其他动作，生成错误信号的函数还将定义一个或多个错误条件名。

错误处理程序是@code{condition-case}的第三个参数。错误处理程序有两个部分，一个是@var{condition-name}，另一个是@var{body}。如果错误处理程序的@var{condition-name}部分与错误生成的条件名匹配，那么将运行错误处理程序的@var{body}部分。

正如您所期望的那样，错误处理程序的@var{condition-name}部分可以是单个条件名或条件名列表。

此外，完整的@code{condition-case}表达式可能包含多个错误处理程序。当发生错误时，将运行第一个适用的处理程序。

最后，@code{condition-case}表达式的第一个参数，@var{var}参数，有时绑定到包含有关错误的信息的变量。但是，如果该参数为@code{nil}，如在@code{kill-region}中的情况，该信息将被丢弃。

@need 1200
简而言之，在@code{kill-region}函数中，@code{condition-case}的代码如下：

@smallexample
@group
@var{如果没有错误，运行仅此代码}
    @var{但是，如果发生错误，运行另一段代码}。
@end group
@end smallexample

@ignore
2006年10月24日
在Emacs 22中，
copy-region-as-kill很短，12行，并使用
filter-buffer-substring，它更长，39行
其中包含delete-and-extract-region。
delete-and-extract-region是用C编写的。

见使用@code{defvar}初始化变量
这是第8054行
使用@code{defvar}初始化变量包括第8350行
@end ignore

@node Lisp macro
@subsection Lisp macro
@cindex Macro, lisp
@cindex Lisp macro

在期望一切顺利的情况下评估的@code{condition-case}表达式的一部分具有@code{when}。该代码使用@code{when}来确定@code{string}变量是否指向存在的文本。

@code{when}表达式只是程序员的便利。它是一个没有else子句可能性的@code{if}。在你的脑海中，你可以用@code{if}替换@code{when}并理解发生了什么。这就是Lisp解释器所做的。

从技术上讲，@code{when}是一个Lisp宏。Lisp宏使您能够定义新的控制结构和其他语言功能。它告诉解释器如何计算另一个Lisp表达式，该表达式将进而计算值。在这种情况下，另一个表达式是一个@code{if}表达式。

@code{kill-region}函数定义还有一个@code{unless}宏；它是@code{when}的反义词。@code{unless}宏是一个没有then子句的@code{if}。

有关Lisp宏的更多信息，请参阅@ref{Macros, , Macros, elisp, The GNU
Emacs Lisp Reference Manual}。C编程语言也提供宏。它们是不同的，但同样有用。

@ignore
我们将简要查看C中的宏
请参阅@ref{Digression into C}。
@end ignore

@need 1200
关于@code{when}宏，在@code{condition-case}表达式中，当字符串具有内容时，然后执行另一个条件表达式。这是一个带有then-part和else-part的@code{if}。

@smallexample
@group
(if (eq last-command 'kill-region)
    (kill-append string (< end beg) yank-handler)
  (kill-new string nil yank-handler))
@end group
@end smallexample

如果前一个命令是另一个对@code{kill-region}的调用，则评估then-part；否则，评估else-part。

@code{yank-handler}是传递给@code{kill-region}的可选参数，告诉@code{kill-append}和@code{kill-new}函数如何处理添加到文本中的属性，例如粗体或斜体。

@code{last-command}是Emacs附带的一个我们之前没有见过的变量。通常，每当执行函数时，Emacs都会将@code{last-command}的值设置为前一个命令。

@need 1200
在这个定义片段中，@code{if}表达式检查前一个命令是否为@code{kill-region}。如果是，

@smallexample
(kill-append string (< end beg) yank-handler)
@end smallexample

@noindent
将新剪贴文本的副本连接到刚刚剪贴的文本在kill ring中。

@node copy-region-as-kill
@section @code{copy-region-as-kill}
@findex copy-region-as-kill
@findex nthcdr

@code{copy-region-as-kill}函数将文本缓冲区中的一段文本复制并（通过@code{kill-append}或@code{kill-new}）保存在@code{kill-ring}中。

如果在执行@code{kill-region}命令之后立即调用@code{copy-region-as-kill}，Emacs将新复制的文本附加到先前复制的文本上。这意味着如果您粘贴文本，则会得到来自此次和上一次操作的所有文本。另一方面，如果在@code{copy-region-as-kill}之前执行了其他命令，则该函数将文本复制到kill环中的一个单独条目中。

@menu
* Complete copy-region-as-kill::  @code{copy-region-as-kill}函数的完整定义。
* copy-region-as-kill body::      @code{copy-region-as-kill}的主体部分。
@end menu

@ifnottex
@node Complete copy-region-as-kill
@unnumberedsubsec @code{copy-region-as-kill}函数的完整定义
@end ifnottex

@need 1200
以下是版本22的@code{copy-region-as-kill}函数的完整文本：

@smallexample
@group
(defun copy-region-as-kill (beg end)
  "将区域保存为已杀死，但不要杀死它。
在瞬时标记模式下，取消激活标记。
如果`interprogram-cut-function'非空，还为窗口系统剪切和粘贴保存文本。"
  (interactive "r")
@end group
@group
  (if (eq last-command 'kill-region)
      (kill-append (filter-buffer-substring beg end) (< end beg))
    (kill-new (filter-buffer-substring beg end)))
@end group
@group
  (if transient-mark-mode
      (setq deactivate-mark t))
  nil)
@end group
@end smallexample

@need 800
像往常一样，此函数可以分为其组成部分：

@smallexample
@group
(defun copy-region-as-kill (@var{argument-list})
  "@var{documentation}@dots{}"
  (interactive "r")
  @var{body}@dots{})
@end group
@end smallexample

参数是@code{beg}和@code{end}，函数以@code{"r"}交互，因此两个参数必须引用区域的起始和结束。如果您从文档开头阅读到这里，理解函数的这些部分几乎变得很常规。

文档有点令人困惑，除非您记得“kill”一词的意义与通常不同。瞬时标记和@code{interprogram-cut-function}的注释解释了某些副作用。

一旦设置了标记，缓冲区始终包含一个区域。如果愿意，可以使用瞬时标记模式临时突出显示区域。 （没有人希望一直突出显示区域，因此瞬时标记模式仅在适当的时候突出显示。许多人关闭瞬时标记模式，因此区域永远不会被突出显示。）

此外，窗口系统允许在不同程序之间复制、剪切和粘贴。例如，在X窗口系统中，@code{interprogram-cut-function}函数是@code{x-select-text}，它与窗口系统的Emacs kill环的等价物一起工作。

@code{copy-region-as-kill}函数的主体以一个@code{if}子句开始。该子句的作用是区分两种不同的情况：是否立即在先前的@code{kill-region}命令之后执行此命令。在第一种情况下，新区域将附加到先前复制的文本。否则，它将作为一个独立的文本片段插入到kill环的开头。

函数的最后两行阻止区域在瞬时标记模式打开时突出显示。

@node copy-region-as-kill body
@subsection @code{copy-region-as-kill}的主体

@code{copy-region-as-kill}函数的工作方式与@code{kill-region}函数类似。两者都被编写为使连续两次或更多次的杀死将它们的文本组合成单个条目。如果从kill环粘贴文本，则会得到一个整体。此外，从当前光标位置向前杀死的杀死将添加到先前复制的文本的末尾，而将文本向后复制的命令将其添加到先前复制的文本的开头。这样，文本中的单词保持正确的顺序。

与@code{kill-region}一样，@code{copy-region-as-kill}函数利用了@code{last-command}变量，该变量跟踪先前的Emacs命令。

@menu
* last-command & this-command::
* kill-append function::
* kill-new function::
@end menu

@ifnottex
@node last-command & this-command
@unnumberedsubsubsec @code{last-command}和@code{this-command}
@end ifnottex

通常情况下，每当执行函数时，Emacs将@code{this-command}的值设置为正在执行的函数（在本例中将是@code{copy-region-as-kill}）。同时，Emacs将@code{last-command}的值设置为@code{this-command}的先前值。

在@code{copy-region-as-kill}函数的主体的第一部分中，一个@code{if}表达式确定@code{last-command}的值是否为@code{kill-region}。如果是，@code{if}表达式的then-part将被评估；它使用@code{kill-append}函数将此次调用函数时复制的文本与kill环的第一个元素（@sc{car}）中已有的文本连接起来。另一方面，如果@code{last-command}的值不是@code{kill-region}，那么@code{copy-region-as-kill}函数将使用@code{kill-new}函数将一个新元素附加到kill环中。

@need 1250
@code{if}表达式如下所示；它使用@code{eq}：

@smallexample
@group
  (if (eq last-command 'kill-region)
      ;; @r{then-part}
      (kill-append  (filter-buffer-substring beg end) (< end beg))
    ;; @r{else-part}
    (kill-new  (filter-buffer-substring beg end)))
@end group
@end smallexample

@findex filter-buffer-substring
（@code{filter-buffer-substring}函数返回缓冲区的过滤子字符串，如果有的话。可选地——这里没有参数，因此也没有做任何事——该函数可以删除初始文本或返回不带其属性的文本；此函数是较早的@code{buffer-substring}函数的替代，该函数在实现文本属性之前出现。）

@findex eq @r{（用法示例）}
@noindent
@code{eq}函数测试其第一个参数是否与其第二个参数相同的Lisp对象。@code{eq}函数类似于@code{equal}函数，因为它用于测试相等性，但不同之处在于它确定两个表示实际上是计算机内部相同对象，只是具有不同的名称。@code{equal}确定两个表达式的结构和内容是否相同。

如果先前的命令是@code{kill-region}，则Emacs Lisp解释器调用@code{kill-append}函数。

@node kill-append function
@unnumberedsubsubsec @code{kill-append} 函数
@findex kill-append

@need 800
@code{kill-append} 函数的定义如下：

@c 在GNU Emacs 22中
@smallexample
@group
(defun kill-append (string before-p &optional yank-handler)
  "将STRING追加到kill环中最新的kill的末尾。
如果BEFORE-P非空，则将STRING插入到kill的开头。
@dots{} "
  (let* ((cur (car kill-ring)))
    (kill-new (if before-p (concat string cur) (concat cur string))
              (or (= (length cur) 0)
                  (equal yank-handler
                         (get-text-property 0 'yank-handler cur)))
              yank-handler)))
@end group
@end smallexample

@ignore
曾经的定义:
(defun kill-append (string before-p)
  "将STRING追加到kill环中最新的kill的末尾。
如果BEFORE-P非空，则将STRING插入到kill的开头。
如果`interprogram-cut-function'已设置，则将生成的kill传递给它。"
  (kill-new (if before-p
                (concat string (car kill-ring))
              (concat (car kill-ring) string))
            t))
@end ignore

@noindent
@code{kill-append} 函数非常直观。它使用了稍后我们将详细讨论的 @code{kill-new} 函数。

（此外，该函数提供了一个可选的参数叫做 @code{yank-handler}；当调用时，此参数告诉函数如何处理添加到文本的属性，比如粗体或斜体。）

@c !!! GNU Emacs 22版本中 kill-append 函数的bug？
它使用 @code{let*} 函数将kill环的第一个元素的值设置为 @code{cur}。（我不知道为什么函数不使用 @code{let} 替代；表达式中只设置了一个值。也许这是一个不会产生问题的bug？）

考虑到条件语句是 @code{kill-new} 的两个参数之一。它使用 @code{concat} 将新文本连接到kill环的 @sc{car}（第一个元素）。无论是插入还是追加文本，都取决于 @code{if} 表达式的结果：

@smallexample
@group
(if before-p                            ; @r{if-part}
    (concat string cur)                 ; @r{then-part}
  (concat cur string))                  ; @r{else-part}
@end group
@end smallexample

@noindent
如果要删除的区域位于上一次命令中删除的区域之前，那么它应该插入到之前保存的文本之前；反之，如果删除的文本跟随刚刚删除的文本，它应该追加到先前的文本之后。 @code{if} 表达式依赖于谓词 @code{before-p} 来决定新保存的文本是应该放在先前保存的文本之前还是之后。

符号 @code{before-p} 是 @code{kill-append} 函数的参数之一的名称。当评估 @code{kill-append} 函数时，它被绑定到通过评估实际参数返回的值。在这种情况下，这是表达式 @code{(< end beg)}。此表达式不直接确定此命令中删除的文本是在上次命令中删除的文本之前还是之后；它的作用是确定变量 @code{end} 的值是否小于变量 @code{beg} 的值。如果是，这意味着用户很可能朝着缓冲区的开头前进。此外，谓词表达式 @code{(< end beg)} 的评估结果将为真，文本将在先前文本之前插入。另一方面，如果变量 @code{end} 的值大于变量 @code{beg} 的值，则文本将在先前文本之后追加。

@need 800
当新保存的文本将被插入时，字符串与新文本将被连接到旧文本之前：

@smallexample
(concat string cur)
@end smallexample

@need 1200
@noindent
但如果文本将被追加，它将在旧文本之后连接：

@smallexample
(concat cur string))
@end smallexample

为了理解这是如何工作的，我们首先需要复习一下 @code{concat} 函数。@code{concat} 函数将两个文本字符串链接或合并在一起。结果是一个字符串。例如：

@smallexample
@group
(concat "abc" "def")
     @result{} "abcdef"
@end group

@group
(concat "new "
        (car '("first element" "second element")))
     @result{} "new first element"

(concat (car
        '("first element" "second element")) " modified")
     @result{} "first element modified"
@end group
@end smallexample

现在我们可以理解 @code{kill-append}：它修改了kill环的内容。kill环是一个列表，其中每个元素都是保存的文本。@code{kill-append} 函数使用 @code{kill-new} 函数，后者又使用 @code{setcar} 函数。

@node kill-new function
@unnumberedsubsubsec @code{kill-new} 函数
@findex kill-new

@need 1200
在版本22中，@code{kill-new} 函数的定义如下：

@smallexample
@group
(defun kill-new (string &optional replace yank-handler)
  "将STRING设为kill环中的最新kill。
将`kill-ring-yank-pointer'设为指向它。

如果`interprogram-cut-function'非nil，则将其应用于STRING。可选的第二个参数REPLACE非nil表示STRING将替换kill环的最前面，而不是被添加到列表中。
@dots{}"
@end group
@group
  (if (> (length string) 0)
      (if yank-handler
          (put-text-property 0 (length string)
                             'yank-handler yank-handler string))
    (if yank-handler
        (signal 'args-out-of-range
                (list string "yank-handler specified for empty string"))))
@end group
@group
  (if (fboundp 'menu-bar-update-yank-menu)
      (menu-bar-update-yank-menu string (and replace (car kill-ring))))
@end group
@group
  (if (and replace kill-ring)
      (setcar kill-ring string)
    (push string kill-ring)
    (if (> (length kill-ring) kill-ring-max)
        (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
@end group
@group
  (setq kill-ring-yank-pointer kill-ring)
  (if interprogram-cut-function
      (funcall interprogram-cut-function string (not replace))))
@end group
@end smallexample
@ignore
原先的定义：
(defun kill-new (string &optional replace)
  "将STRING设为kill环中的最新kill。
将kill-ring-yank指针设为指向它。
如果`interprogram-cut-function'非nil，则将其应用于STRING。
可选的第二个参数REPLACE非nil表示STRING将替换
kill环的最前面，而不是被添加到列表中。"
  (and (fboundp 'menu-bar-update-yank-menu)
       (menu-bar-update-yank-menu string (and replace (car kill-ring))))
  (if (and replace kill-ring)
      (setcar kill-ring string)
    (setq kill-ring (cons string kill-ring))
    (if (> (length kill-ring) kill-ring-max)
        (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
  (setq kill-ring-yank-pointer kill-ring)
  (if interprogram-cut-function
      (funcall interprogram-cut-function string (not replace))))
@end ignore

（注意，此函数不是交互式的。）

和往常一样，我们可以将这个函数分为几个部分来看。

函数定义有一个可选的@code{yank-handler}参数，当调用时告诉函数如何处理添加到文本中的属性，比如粗体或斜体。我们将跳过这一点。

@need 1200
文档的第一行有意义：

@smallexample
将STRING设为kill环中的最新kill。
@end smallexample

@noindent
让我们暂时跳过文档的其余部分。

@noindent
同样，让我们跳过初始的@code{if}表达式以及涉及@code{menu-bar-update-yank-menu}的那些行代码。我们将在下面解释它们。

@need 1200
关键的代码在这里：

@smallexample
@group
  (if (and replace kill-ring)
      ;; @r{然后}
      (setcar kill-ring string)
@end group
@group
    ;; @r{否则}
    (push string kill-ring)
@end group
@group
    (if (> (length kill-ring) kill-ring-max)
        ;; @r{避免kill环过长}
        (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
@end group
@group
  (setq kill-ring-yank-pointer kill-ring)
  (if interprogram-cut-function
      (funcall interprogram-cut-function string (not replace))))
@end group
@end smallexample

条件测试是 @w{@code{(and replace kill-ring)}}。当满足两个条件时，这将为真：kill环中有内容，并且@code{replace}变量为真。

@need 1250
当@code{kill-append}函数将@code{replace}设置为真时，且kill环中至少有一项时，将执行@code{setcar}表达式：

@smallexample
(setcar kill-ring string)
@end smallexample

@code{setcar}函数实际上将@code{kill-ring}列表的第一个元素更改为@code{string}的值。它替换第一个元素。

@need 1250
另一方面，如果kill环为空，或者replace为假，则执行条件的else部分：

@smallexample
(push string kill-ring)
@end smallexample

@noindent
@need 1250
@code{push}将其第一个参数推入第二个参数。它类似于较旧的

@smallexample
(setq kill-ring (cons string kill-ring))
@end smallexample

@noindent
@need 1250
或者较新的

@smallexample
(add-to-list kill-ring string)
@end smallexample

@noindent
当为假时，表达式首先通过将要被杀死的字符串作为新元素添加到旧kill环中构造了新版本的kill环（这就是@code{push}的作用）。然后它执行第二个@code{if}子句。这第二个@code{if}子句防止kill环变得过长。

让我们按顺序查看这两个表达式。

@code{push} else-part的行将新的kill环的值设置为将要被杀死的字符串添加到旧kill环中得到的值。

通过以下示例，我们可以看到它是如何工作的。

@need 800
首先，

@smallexample
(setq example-list '("here is a clause" "another clause"))
@end smallexample

@need 1200
@noindent
通过使用@kbd{C-x C-e}评估此表达式后，您可以评估@code{example-list}并查看其返回值：

@smallexample
@group
example-list
     @result{} ("here is a clause" "another clause")
@end group
@end smallexample

@need 1200
@noindent
现在，我们可以通过评估以下表达式将一个新元素添加到此列表中：
@findex push@r{, example}

@smallexample
(push "a third clause" example-list)
@end smallexample

@need 800
@noindent
当我们评估@code{example-list}时，我们发现其值为：

@smallexample
@group
example-list
     @result{} ("a third clause" "here is a clause" "another clause")
@end group
@end smallexample

@noindent
因此，通过@code{push}添加了第三个子句。

@need 1200
现在是@code{if}子句的第二部分。此表达式防止kill环变得过长。它看起来是这样的：

@smallexample
@group
(if (> (length kill-ring) kill-ring-max)
    (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil))
@end group
@end smallexample

代码检查kill环的长度是否大于允许的最大长度。这是@code{kill-ring-max}（默认为120）的值。如果kill环的长度太长，则此代码将最后一个元素设置为@code{nil}。它通过使用两个函数@code{nthcdr}和@code{setcdr}来实现。

我们之前看过@code{setcdr}（@pxref{setcdr, , @code{setcdr}}）。它设置列表的@sc{cdr}，就像@code{setcar}设置列表的@sc{car}一样。但是，在这种情况下，@code{setcdr}不会设置整个kill环的@sc{cdr}；@code{nthcdr}函数用于使其设置kill环的倒数第二个元素的@sc{cdr}——这意味着由于倒数第二个元素的@sc{cdr}是kill环的最后一个元素，它将设置kill环的最后一个元素。

@findex nthcdr@r{, example}
@code{nthcdr}函数通过重复获取列表的@sc{cdr}来工作——它获取@sc{cdr}的@sc{cdr}的@sc{cdr}等等。它这样做@var{N}次并返回结果。(@xref{nthcdr, , @code{nthcdr}}.)

@findex setcdr@r{, example}
因此，如果我们有一个应该是三个元素长的四个元素列表，我们可以将倒数第二个元素的@sc{cdr}设置为@code{nil}，从而缩短列表。（如果将最后一个元素设置为除@code{nil}之外的其他值，您可以这样做，那么您将不会缩短列表。@xref{setcdr, , @code{setcdr}}.）

通过依次评估以下三个表达式，您可以看到缩短的效果。首先将@code{trees}的值设置为@code{(maple oak pine birch)}，然后将其第二个@sc{cdr}的@sc{cdr}设置为@code{nil}，然后找到@code{trees}的值：

@smallexample
@group
(setq trees (list 'maple 'oak 'pine 'birch))
     @result{} (maple oak pine birch)
@end group

@group
(setcdr (nthcdr 2 trees) nil)
     @result{} nil

trees
     @result{} (maple oak pine)
@end group
@end smallexample

@noindent
(@code{setcdr}表达式返回的值为@code{nil}，因为它将@sc{cdr}设置为@code{nil}。)

重申一下，在@code{kill-new}中，@code{nthcdr}函数取kill环的最大允许大小减一的次数，@code{setcdr}函数将其@sc{cdr}设置为那个元素（这意味着由于倒数第二个元素的@sc{cdr}是kill环的最后一个元素，它将设置kill环的最后一个元素）。这样可以防止kill环变得过长。

@need 800
@code{kill-new}函数中倒数第二个表达式是

@smallexample
(setq kill-ring-yank-pointer kill-ring)
@end smallexample

@code{kill-ring-yank-pointer}是一个全局变量，被设置为@code{kill-ring}。

尽管@code{kill-ring-yank-pointer}被称为@samp{指针}，但它和kill环一样是一个变量。但是，为了帮助人们理解该变量的用法，选择了这个名称。

@need 1200
现在，回到函数体中的早期表达式：

@smallexample
@group
  (if (fboundp 'menu-bar-update-yank-menu)
       (menu-bar-update-yank-menu string (and replace (car kill-ring))))
@end group
@end smallexample

@noindent
它以一个@code{if}表达式开始

在这种情况下，该表达式首先测试@code{menu-bar-update-yank-menu}是否存在作为函数，并且如果存在，则调用它。@code{fboundp}函数返回true，如果它测试的符号具有非空的函数定义。如果符号的函数定义为空，我们将收到错误消息，就像我们故意创建错误一样（@pxref{Making Errors, , 生成错误消息}）。

@noindent
然后部分包含一个表达式，其第一个元素是@code{and}函数。

@findex and
特殊形式 @code{and} 对其每个参数进行求值，直到其中一个参数返回值为 @code{nil} 为止，此时 @code{and} 表达式返回 @code{nil}；然而，如果没有任何参数返回 @code{nil}，则返回最后一个参数的求值结果。 （由于这样的值不是 @code{nil}，在Emacs Lisp中被视为真值。）换句话说，只有当所有参数都为真时，@code{and} 表达式才返回真值。(@xref{Second Buffer Related Review}.)

该表达式确定了 @code{menu-bar-update-yank-menu} 的第二个参数是否为真。
@ignore
    ;; 如果我们应该扩展现有字符串，并且该字符串确实位于菜单的前面，则原地更新它。
@end ignore

@code{menu-bar-update-yank-menu} 是使得可以在菜单条的编辑项目的“选择和粘贴”菜单中使用的函数之一；使用鼠标，您可以查看已保存的各种文本片段，并选择一个片段进行粘贴。

@code{kill-new} 函数中的最后一个表达式将新复制的字符串添加到用于在窗口系统中运行的不同程序之间复制和粘贴的任何设施中。例如，在X Windowing系统中，@code{x-select-text} 函数将字符串存储在由X操作的内存中。您可以在另一个程序中粘贴该字符串，例如Xterm。

@need 1200
该表达式如下：

@smallexample
@group
  (if interprogram-cut-function
      (funcall interprogram-cut-function string (not replace))))
@end group
@end smallexample

如果存在 @code{interprogram-cut-function}，则Emacs执行 @code{funcall}，它又调用其第一个参数作为函数，并将其余参数传递给它。 （顺便说一下，就我所看到的，此 @code{if} 表达式可以被类似于函数第一部分的 @code{and} 表达式替代。）

我们不打算进一步讨论窗口系统和其他程序，只是注意到这是一种使GNU Emacs能够轻松而有效地与其他程序协同工作的机制。

这段代码用于将文本放入kill环中，可以是与现有元素连接，也可以是作为新元素。这引导我们进入了从缓冲区中删除文本的代码——yank命令。但在讨论yank命令之前，最好先了解计算机中列表是如何实现的。这将解释“指针”一词的使用。但在此之前，我们将离题讨论C。

@ignore
@c 这在Emacs 22中是真的吗？似乎不是

  （如果表达式 @w{@code{(< end beg))}} 为真，则 @code{kill-append} 将字符串前置到刚刚剪切的文本之前。有关详细讨论，请参阅 @ref{kill-append function, , The @code{kill-append} function}.）

如果然后将文本还原，即粘贴它，则可以同时获得两个文本片段。这样，如果您连续删除两个单词，然后将它们还原，您将以正确的顺序获得两个单词，一次性粘贴。（表达式 @w{@code{(< end beg))}} 确保顺序正确。）

另一方面，如果前一个命令不是 @code{kill-region}，那么将调用 @code{kill-new} 函数，该函数将文本添加到kill环中作为最新的项，并将 @code{kill-ring-yank-pointer} 变量设置为指向它。
@end ignore
@ignore

@c 显然，Emacs 22有所更改。zap-to-char命令不使用delete-and-extract-region函数

2006年10月26日，C离题现在可以了，但应该在copy-region-as-kill和filter-buffer-substring之后

2006年10月24日
在Emacs 22中，
copy-region-as-kill很短，12行，使用
filter-buffer-substring，它更长，有39行
并包含其中的delete-and-extract-region。
delete-and-extract-region是用C编写的。

参见使用 @code{defvar} 初始化变量
@end ignore

@node Digression into C
@section 进入C的插曲
@findex delete-and-extract-region
@cindex C，进入C的插曲
@cindex 进入C的插曲

@code{copy-region-as-kill} 函数（参见@pxref{copy-region-as-kill, , @code{copy-region-as-kill}}）使用了 @code{filter-buffer-substring} 函数，而该函数又使用了 @code{delete-and-extract-region} 函数。它会删除区域的内容，而且一旦删除就无法还原。

与这里讨论的其他代码不同，@code{delete-and-extract-region} 函数不是用Emacs Lisp编写的；它是用C编写的，是GNU Emacs系统的原语之一。由于它非常简单，我将简要离开Lisp并在这里描述它。

@need 1500
与许多其他Emacs原语一样，@code{delete-and-extract-region} 作为C宏的实例编写，宏是代码的模板。完整的宏如下：

@c 这是editfns.c中用于delete-and-extract-region的DEFUN的副本。
@smallexample
@group
DEFUN ("delete-and-extract-region", Fdelete_and_extract_region,
       Sdelete_and_extract_region, 2, 2, 0,
       doc: /* 删除START和END之间的文本并返回它。 */)
  (Lisp_Object start, Lisp_Object end)
@{
  validate_region (&start, &end);
  if (XFIXNUM (start) == XFIXNUM (end))
    return empty_unibyte_string;
  return del_range_1 (XFIXNUM (start), XFIXNUM (end), 1, 1);
@}
@end group
@end smallexample

在不深入宏编写过程的细节的情况下，让我指出该宏以单词 @code{DEFUN} 开头。选择单词 @code{DEFUN} 是因为该代码与Lisp中的 @code{defun} 具有相同的目的。（@code{DEFUN} C宏在@file{emacs/src/lisp.h}中定义。）

单词 @code{DEFUN} 后面跟着括号内的七个部分：

@itemize @bullet
@item
第一个部分是Lisp中给定的函数名称，@code{delete-and-extract-region}。

@item
第二部分是C中的函数名称，@code{Fdelete_and_extract_region}。按照惯例，它以 @samp{F} 开头。由于C中不使用连字符，而是使用下划线。

@item
第三部分是记录此函数信息以供内部使用的C常量结构的名称。它是C中函数的名称，但以 @samp{S} 开头而不是 @samp{F}。

@item
第四和第五部分指定函数可以有的参数的最小和最大数量。此函数要求精确地有2个参数。

@item
第六部分几乎与在Lisp中编写的函数中的 @code{interactive} 声明后面的参数相似：一个字母，然后是一个提示，也许还有一个数字。与Lisp不同的是，当使用零参数调用宏时。然后你写一个 @code{0}（它是一个空字符串），就像这个宏一样。

如果要指定参数，你会将它们放在引号之间。用于 @code{goto-char} 的C宏包括在此位置添加 @code{"NGoto char: "} 以指示该函数期望一个原始前缀，这种情况下是缓冲区中的数值位置，并提供提示。

@item
第七部分是文档字符串，就像Emacs Lisp中的函数的文档字符串一样。这是以C注释的形式编写的。（构建Emacs时，程序@command{lib-src/make-docfile}提取这些注释并用它们制作文档。）
@end itemize

@need 1200
在C宏中，接下来是形式参数，包括对象类型的说明，然后是宏的主体。对于 @code{delete-and-extract-region}，主体包括以下四行：

@smallexample
@group
validate_region (&start, &end);
if (XFIXNUM (start) == XFIXNUM (end))
  return empty_unibyte_string;
return del_range_1 (XFIXNUM (start), XFIXNUM (end), 1, 1);
@end group
@end smallexample

@code{validate_region} 函数检查作为区域开始和结束传递的值是否是正确的类型并且是否在范围内。如果开始和结束位置相同，则返回一个空字符串。

@code{del_range_1} 函数实际上删除文本。这是一个复杂的函数，我们不会深入研究。它更新缓冲区并执行其他操作。但是，值得注意的是传递给 @code{del_range_1} 的两个参数。这些是 @w{@code{XFIXNUM (start)}} 和 @w{@code{XFIXNUM (end)}}。

就C语言而言，@code{start} 和 @code{end} 是标记要删除的区域的开始和结束的两个不透明的值。更准确地说，需要更多专业知识才能理解，这两个值的类型是 @code{Lisp_Object}，它可能是C指针、C整数或C结构；C代码通常不应关心 @code{Lisp_Object} 的实现方式。

@samp{XFIXNUM} 是一个C宏，从较长的比特集中提取相关整数；类型比特被丢弃。

@need 800
@code{delete-and-extract-region} 中的命令如下：

@smallexample
del_range_1 (XFIXNUM (start), XFIXNUM (end), 1, 1);
@end smallexample

@noindent
它删除开始位置 @code{start} 和结束位置 @code{end} 之间的区域。

从编写Lisp的人的角度来看，Emacs非常简单；但是在底层隐藏着大量的复杂性，以使一切正常工作。

@node defvar
@section 使用 @code{defvar} 初始化变量
@findex defvar
@cindex 初始化变量
@cindex 变量初始化

@ignore
2006年10月24日
在Emacs 22中，
copy-region-as-kill 很短，有12行，使用了
filter-buffer-substring，它更长，有39行
并且其中包含了delete-and-extract-region。
delete-and-extract-region是用C语言编写的。

见 使用 @code{defvar} 初始化变量

@end ignore

@code{copy-region-as-kill} 函数是用Emacs Lisp编写的。其中的两个函数，@code{kill-append} 和 @code{kill-new}，复制缓冲区中的一段区域并将其保存在一个名为 @code{kill-ring} 的变量中。本节描述了如何使用 @code{defvar} 特殊形式创建和初始化 @code{kill-ring} 变量。

（再次注意，术语 @code{kill-ring} 是不准确的。从缓冲区中剪切出来的文本可以被还原；它不是一个尸体环，而是一个可以复活的文本环。）

在Emacs Lisp中，诸如 @code{kill-ring} 这样的变量是通过使用 @code{defvar} 特殊形式创建并赋予初始值的。其名称来自于“定义变量”。

@code{defvar} 特殊形式类似于 @code{setq}，因为它设置变量的值。但与 @code{setq} 不同的有两点：首先，它仅在变量尚未具有值时设置变量的值。如果变量已经有值，@code{defvar} 就不会覆盖现有值。其次，@code{defvar} 具有文档字符串。

（有一个相关的宏，@code{defcustom}，用于用户自定义的变量。它比 @code{defvar} 更强大。
（@xref{defcustom, , 使用 @code{defcustom} 设置变量}。）

@menu
* See variable current value::
* defvar and asterisk::
@end menu

@ifnottex
@node See variable current value
@unnumberedsubsec 查看变量的当前值
@end ifnottex

您可以使用 @code{describe-variable} 函数查看任何变量的当前值，通常通过键入 @kbd{C-h v} 调用。如果在提示时键入 @kbd{C-h v} 然后键入 @code{kill-ring}（然后按 @key{RET}），您将看到当前剪切环中的内容，这可能很多！相反，如果在本次Emacs会话中除了阅读本文档之外什么都没有做，那么可能什么都没有。此外，您将看到 @code{kill-ring} 的文档：

@smallexample
@group
文档：
已删除文本序列的列表。
由于剪切环应该与窗口系统提供的剪切和粘贴功能良好地交互，因此应使用此变量
@end group
@group
与`interprogram-cut-function'和
`interprogram-paste-function'良好交互。 函数`kill-new'，
`kill-append'和`current-kill'应实现此交互；
您可能希望使用它们而不是直接操作剪切环。
@end group
@end smallexample

@need 800
剪切环的定义如下：

@smallexample
@group
(defvar kill-ring nil
  "已删除文本序列的列表。
@dots{}")
@end group
@end smallexample

@noindent
在此变量定义中，变量被赋予初始值 @code{nil}，这是有道理的，因为如果您没有保存任何内容，那么在执行 @code{yank} 命令时您希望得到空白。文档字符串的写法与 @code{defun} 的文档字符串相同。与 @code{defun} 的文档字符串一样，文档的第一行应该是一个完整的句子，因为一些命令（如 @code{apropos}）仅打印文档的第一行。后续行不应缩进，否则在使用 @kbd{C-h v}（@code{describe-variable}）时会显得奇怪。

@node defvar and asterisk
@subsection @code{defvar} 和星号
@findex defvar @r{用于用户可定制的变量}
@findex defvar @r{带有星号}

过去，Emacs 在内部变量和用户可能更改的变量上都使用了 @code{defvar} 特殊形式。尽管您仍然可以使用 @code{defvar} 来定义用户可定制的变量，请改用 @code{defcustom}，因为它提供了进入定制命令的路径。
（@xref{defcustom, , 使用 @code{defcustom} 指定变量}。）

当使用 @code{defvar} 特殊形式指定变量时，您可以通过在其文档字符串的第一列键入星号（@samp{*}）来区分用户可能想更改的变量和其他变量。例如：

@smallexample
@group
(defvar shell-command-default-error-buffer nil
  "*'shell-command' @dots{}错误输出的缓冲区名称。
@dots{} ")
@end group
@end smallexample

@findex set-variable
@noindent
您可以（仍然可以）使用 @code{set-variable} 命令临时更改 @code{shell-command-default-error-buffer} 的值。但是，使用 @code{set-variable} 设置的选项仅在编辑会话期间设置。新值在会话之间不会保存。每次Emacs启动时，它都会读取原始值，除非您在 @file{.emacs} 文件中更改了该值，要么手动设置它，要么使用 @code{customize}。
@xref{Emacs Initialization, , 您的 @file{.emacs} 文件}。

对我来说，@code{set-variable} 命令的主要用途是建议我可能希望在 @file{.emacs} 文件中设置的变量。现在有700多个这样的变量，太多了，记不住。幸运的是，在调用 @code{M-x set-variable} 命令后，您可以按 @key{TAB} 键查看变量的列表。
（@xref{Examining, , 检查和设置变量, emacs, GNU Emacs手册}。）

@need 1250
@node cons & search-fwd Review
@section Review

这里是一些最近引入的函数的简要概述。

@table @code
@item car
@itemx cdr
@code{car} 返回列表的第一个元素；@code{cdr} 返回列表的第二个及后续元素。

@need 1250
例如：

@smallexample
@group
(car '(1 2 3 4 5 6 7))
     @result{} 1
(cdr '(1 2 3 4 5 6 7))
     @result{} (2 3 4 5 6 7)
@end group
@end smallexample

@item cons
@code{cons}通过将其第一个参数添加到其第二个参数前构造一个列表。

@need 1250
例如：

@smallexample
@group
(cons 1 '(2 3 4))
     @result{} (1 2 3 4)
@end group
@end smallexample

@item funcall
@code{funcall} 将其第一个参数作为函数求值，并将其余参数传递给其第一个参数。

@item nthcdr
返回在列表上对 @sc{cdr} 进行 @var{n} 次操作的结果。
@iftex
这是
@tex
$n^{th}$
@end tex
@code{cdr}。
@end iftex
可以看作是“剩下的剩下”。

@need 1250
例如：

@smallexample
@group
(nthcdr 3 '(1 2 3 4 5 6 7))
     @result{} (4 5 6 7)
@end group
@end smallexample

@item setcar
@itemx setcdr
@code{setcar} 改变列表的第一个元素；@code{setcdr} 改变列表的第二个及后续元素。

@need 1250
例如：

@smallexample
@group
(setq triple (list 1 2 3))

(setcar triple '37)

triple
     @result{} (37 2 3)

(setcdr triple '("foo" "bar"))

triple
     @result{} (37 "foo" "bar")
@end group
@end smallexample

@item progn
按顺序评估每个参数，然后返回最后一个的值。

@need 1250
例如：

@smallexample
@group
(progn 1 2 3 4)
     @result{} 4
@end group
@end smallexample

@item save-restriction
记录当前缓冲区中生效的任何缩小范围，并在评估参数后恢复该缩小。

@item search-forward
搜索字符串，如果找到，移动点。使用正则表达式时，请使用类似的 @code{re-search-forward}。(@xref{Regexp Search, , 正则表达式搜索}，了解正则表达式模式和搜索的解释。)

@need 1250
@noindent
@code{search-forward} 和 @code{re-search-forward} 需要四个参数：

@enumerate
@item
要搜索的字符串或正则表达式。

@item
可选地，搜索的限制。

@item
可选地，如果搜索失败，返回 @code{nil} 或错误消息。

@item
可选地，重复搜索的次数；如果为负数，则向后搜索。
@end enumerate

@item kill-region
@itemx delete-and-extract-region
@itemx copy-region-as-kill

@code{kill-region} 剪切点和标记之间的文本，并将该文本存储在kill ring中，因此您可以通过粘贴将其取回。

@code{copy-region-as-kill} 将点和标记之间的文本复制到kill ring中，可以通过粘贴获取。该函数不会从缓冲区中删除文本。

@end table

@code{delete-and-extract-region} 从缓冲区中移除点和标记之间的文本并将其丢弃。您无法再获取它。 (这不是一个交互式命令。)

@need 1500
@node search Exercises
@section 搜索练习

@itemize @bullet
@item
编写一个交互式函数，用于搜索字符串。如果搜索找到字符串，将光标放在字符串后面并显示消息：“找到了！”（请勿使用@code{search-forward}作为此函数的名称；如果这样做，将覆盖Emacs自带的@code{search-forward}版本。请使用诸如@code{test-search}的名称。）

@item
编写一个函数，在回显区域打印剪切环的第三个元素（如果存在）；如果剪切环不包含第三个元素，则打印相应的消息。
@end itemize

@node List Implementation
@chapter 如何实现列表
@cindex 计算机中的列表

在Lisp中，原子以一种直截了当的方式记录；如果在实践中实现不够直截了当，理论上仍然是直截了当的。例如，原子 @samp{rose} 被记录为四个连续的字母 @samp{r}、@samp{o}、@samp{s}、@samp{e}。然而，列表的存储方式不同。机制同样简单，但需要一些时间来适应这个概念。列表使用一系列指针对来维护。在这个系列中，每对中的第一个指针指向一个原子或另一个列表，而每对中的第二个指针指向下一对，或者指向表示列表结束的符号 @code{nil}。

指针本身就是指向所指对象的电子地址。因此，列表被保存为一系列电子地址。

@menu
* Lists diagrammed::
* Symbols as Chest::       探索一个强有力的隐喻。
* List Exercise::
@end menu

@ifnottex
@node Lists diagrammed
@unnumberedsec 列表示意图
@end ifnottex

例如，列表 @code{(rose violet buttercup)} 有三个元素，@samp{rose}、@samp{violet} 和 @samp{buttercup}。在计算机中，@samp{rose} 的电子地址记录在称为 @dfn{cons cell}（因为它实际上是函数 @code{cons} 创建的东西）的计算机内存段中。该 cons cell 还保存了指向第二个 cons cell 的地址，其 @sc{car} 是原子 @samp{violet}；而该地址（指示如何找到 @samp{violet} 的地址）与保存原子 @samp{buttercup} 的地址一起保存在第三个 cons cell 的地址中。

@need 1200
这听起来比实际上更复杂，但在图表中更容易理解：

@c 清除打印后期图形
@c !!! cons-cell-diagram #1
@ifnottex
@smallexample
@group
    ___ ___      ___ ___      ___ ___
   |___|___|--> |___|___|--> |___|___|--> nil
     |            |            |
     |            |            |
      --> rose     --> violet   --> buttercup
@end group
@end smallexample
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-1}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
    ___ ___      ___ ___      ___ ___
   |___|___|--> |___|___|--> |___|___|--> nil
     |            |            |
     |            |            |
      --> rose     --> violet   --> buttercup
@end group
@end smallexample
@end iftex
@end ifclear

@noindent
在图表中，每个框表示计算机内存中的一个字，通常以内存地址的形式保存一个Lisp对象。框，即地址，是成对出现的。每个箭头指向地址所指的内容，要么是一个原子，要么是另一对地址。第一个框是 @samp{rose} 的电子地址，箭头指向 @samp{rose}；第二个框是下一对框的地址，其第一部分是 @samp{violet} 的地址，第二部分是下一对的地址。最后一个框指向符号 @code{nil}，表示列表的结束。

@need 1200
当变量使用诸如 @code{setq} 这样的操作设置为列表时，它将存储在变量中的第一个框的地址。因此，表达式的求值

@smallexample
(setq bouquet '(rose violet buttercup))
@end smallexample

@need 1250
@noindent
会创建这样的情况：

@c cons-cell-diagram #2
@ifnottex
@smallexample
@group
bouquet
     |
     |     ___ ___      ___ ___      ___ ___
      --> |___|___|--> |___|___|--> |___|___|--> nil
            |            |            |
            |            |            |
             --> rose     --> violet   --> buttercup
@end group
@end smallexample
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-2}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
bouquet
     |
     |     ___ ___      ___ ___      ___ ___
      --> |___|___|--> |___|___|--> |___|___|--> nil
            |            |            |
            |            |            |
             --> rose     --> violet   --> buttercup
@end group
@end smallexample
@end iftex
@end ifclear

@noindent
在此示例中，符号 @code{bouquet} 持有第一对框的地址。

@need 1200
相同的列表可以用不同类型的框符号表示，如下所示：

@c cons-cell-diagram #2a
@ifnottex
@smallexample
@group
bouquet
 |
 |    --------------       ---------------       ----------------
 |   | car   | cdr  |     | car    | cdr  |     | car     | cdr  |
  -->| rose  |   o------->| violet |   o------->| butter- |  nil |
     |       |      |     |        |      |     | cup     |      |
      --------------       ---------------       ----------------
@end group
@end smallexample
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-2a}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
bouquet
 |
 |    --------------       ---------------       ----------------
 |   | car   | cdr  |     | car    | cdr  |     | car     | cdr  |
  -->| rose  |   o------->| violet |   o------->| butter- |  nil |
     |       |      |     |        |      |     | cup     |      |
      --------------       ---------------       ----------------
@end group
@end smallexample
@end iftex
@end ifclear

（符号由不仅仅是地址对组成，但符号的结构由地址组成。实际上，符号 @code{bouquet} 由一组地址框组成，其中一个是打印字 @samp{bouquet} 的地址，第二个是附加到符号的函数定义的地址（如果有的话），第三个是列表 @code{(rose violet buttercup)} 的地址的第一对地址框，依此类推。这里我们显示符号的第三个地址框指向列表的第一对地址框。）

如果将符号设置为列表的 @sc{cdr}，列表本身不会改变；符号只是具有列表中更远地址的地址。 （在行话中，@sc{car} 和 @sc{cdr} 是“非破坏性的”）因此，对以下表达式的求值

@smallexample
(setq flowers (cdr bouquet))
@end smallexample

@need 800
@noindent
会产生：

@c cons-cell-diagram #3
@ifnottex
@sp 1
@smallexample
@group
bouquet        flowers
  |              |
  |     ___ ___  |     ___ ___      ___ ___
   --> |   |   |  --> |   |   |    |   |   |
       |___|___|----> |___|___|--> |___|___|--> nil
         |              |            |
         |              |            |
          --> rose       --> violet   --> buttercup
@end group
@end smallexample
@sp 1
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-3}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@sp 1
@smallexample
@group
bouquet        flowers
  |              |
  |     ___ ___  |     ___ ___      ___ ___
   --> |   |   |  --> |   |   |    |   |   |
       |___|___|----> |___|___|--> |___|___|--> nil
         |              |            |
         |              |            |
          --> rose       --> violet   --> buttercup
@end group
@end smallexample
@sp 1
@end iftex
@end ifclear

@need 1200
@noindent
变量 @code{flowers} 的值是 @code{(violet buttercup)}，也就是说，符号 @code{flowers} 持有地址的对应的框，其中第一个框持有 @code{violet} 的地址，第二个框持有 @code{buttercup} 的地址。

@cindex 点对
@cindex cons cell
一对地址框称为 @dfn{cons cell} 或 @dfn{点对}。有关 cons cell 和点对的更多信息，请参见 @xref{Cons Cell Type, , Cons Cell and List Types, elisp, The GNU Emacs Lisp Reference Manual}，以及 @ref{Dotted Pair Notation, , Dotted Pair Notation, elisp, The GNU Emacs Lisp Reference Manual}。

@need 1200
函数 @code{cons} 将一个新的地址对添加到上面所示的地址系列的前面。例如，对以下表达式的求值

@smallexample
(setq bouquet (cons 'lily bouquet))
@end smallexample

@need 1500
@noindent
产生：

@c cons-cell-diagram #4
@ifnottex
@sp 1
@smallexample
@group
bouquet                       flowers
  |                             |
  |     ___ ___        ___ ___  |     ___ ___       ___ ___
   --> |   |   |      |   |   |  --> |   |   |     |   |   |
       |___|___|----> |___|___|----> |___|___|---->|___|___|--> nil
         |              |              |             |
         |              |              |             |
          --> lily      --> rose       --> violet    --> buttercup
@end group
@end smallexample
@sp 1
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-4}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@sp 1
@smallexample
@group
bouquet                       flowers
  |                             |
  |     ___ ___        ___ ___  |     ___ ___       ___ ___
   --> |   |   |      |   |   |  --> |   |   |     |   |   |
       |___|___|----> |___|___|----> |___|___|---->|___|___|--> nil
         |              |              |             |
         |              |              |             |
          --> lily      --> rose       --> violet    --> buttercup
@end group
@end smallexample
@sp 1
@end iftex
@end ifclear

@need 1200
@noindent
然而，这并不会改变符号 @code{flowers} 的值，可以通过求值以下表达式来查看：

@smallexample
(eq (cdr (cdr bouquet)) flowers)
@end smallexample

@noindent
这会返回 @code{t}，表示为真。

在被重新设置之前，@code{flowers} 仍然具有值 @code{(violet buttercup)}；也就是说，它持有第一个框的地址，该框的第一个地址是 @code{violet}。

总而言之，在Lisp中，要获得列表的 @sc{cdr}，只需获取系列中下一个 cons cell 的地址；要获取列表的 @sc{car}，只需获取列表的第一个元素的地址；要在列表前面添加新元素，只需在列表的前面添加一个新的 cons cell。就是这样！Lisp的底层结构非常简单！

而在一系列 cons 单元中，最后一个地址指向什么呢？它指向空列表，即 @code{nil} 的地址。

总之，当一个 Lisp 变量被设置为某个值时，它会被赋予指向该变量所引用的列表的地址。

@node Symbols as Chest
@section 符号作为抽屉式储物柜
@cindex 符号作为抽屉式储物柜
@cindex 抽屉式储物柜，作为符号的隐喻
@cindex 抽屉，抽屉式储物柜，作为符号的隐喻

在早期的一节中，我建议你将符号想象成一个抽屉式储物柜。一个抽屉放置函数定义，另一个抽屉放置值，依此类推。放在存放值的抽屉中的内容可以更改，而不影响放置函数定义的抽屉中的内容，反之亦然。

实际上，放在每个抽屉中的是值或函数定义的地址。就好像你在阁楼上发现了一只旧箱子，在其中一个抽屉里找到了一张地图，指引你找到埋藏的宝藏的地方。

（除了名称、符号定义和变量值之外，符号还有一个用于记录其他信息的@dfn{属性列表}抽屉。这里不讨论属性列表；请参阅@ref{Property Lists, , Property Lists, elisp，GNU Emacs Lisp参考手册}。）

@need 1500
这里是一个幻想的表示：

@c 抽屉式储物柜图表
@ifnottex
@sp 1
@smallexample
@group
            抽屉式储物柜            抽屉的内容

            __   o0O0o   __
          /                 \
         ---------------------
        |    符号名称的方向    |            [指向地图]
        |                     |             花束
        +---------------------+
        |    符号定义的方向    |
        |                     |             [无]
        +---------------------+
        |    变量值的方向      |            [指向地图]
        |                     |             (玫瑰 紫罗兰 毛茛)
        +---------------------+
        |    属性列表的方向    |             [这里不描述]
        |                     |
        +---------------------+
        |/                   \|
@end group
@end smallexample
@sp 1
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{drawers}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@sp 1
@smallexample
@group
            抽屉式储物柜            抽屉的内容

            __   o0O0o   __
          /                 \
         ---------------------
        |    符号名称的方向    |            [指向地图]
        |                     |             花束
        +---------------------+
        |    符号定义的方向    |
        |                     |             [无]
        +---------------------+
        |    变量值的方向      |            [指向地图]
        |                     |             (玫瑰 紫罗兰 毛茛)
        +---------------------+
        |    属性列表的方向    |             [这里不描述]
        |                     |
        +---------------------+
        |/                   \|
@end group
@end smallexample
@sp 1
@end iftex
@end ifclear

@node List Exercise
@section 练习

将@code{flowers}设置为@code{violet}和@code{buttercup}。在这个列表上再连接两朵花，并将这个新列表设置为@code{more-flowers}。将@code{flowers}的@sc{car}设置为一条鱼。现在，@code{more-flowers}列表包含什么？

@node Yanking
@chapter 插入文本
@findex 插入
@cindex 文本检索
@cindex 检索文本
@cindex 粘贴文本

在GNU Emacs中，每当你使用一个kill命令从缓冲区中剪切文本，你都可以使用yank命令将其还原。从缓冲区中剪切出的文本被放入kill环中，而yank命令则将kill环的相应内容插入到缓冲区中（不一定是原始缓冲区）。

一个简单的@kbd{C-y}（@code{yank}）命令将kill环中的第一个条目插入到当前缓冲区中。如果@kbd{C-y}命令后面紧跟着@kbd{M-y}，那么第一个元素将被第二个元素替换。随后的@kbd{M-y}命令将第二个元素替换为第三个、第四个或第五个元素，依此类推。当达到kill环中的最后一个元素时，它将被第一个元素替换，然后循环重复。（因此，kill环被称为“环”而不仅仅是一个“列表”。然而，实际保存文本的数据结构是一个列表。@xref{Kill Ring, , 处理Kill环}，了解如何将列表作为环处理的详细信息。）

@menu
* Kill Ring Overview::
* kill-ring-yank-pointer::      Kill环是一个列表。
* yank nthcdr Exercises::           @code{kill-ring-yank-pointer}变量。
@end menu

@node Kill Ring Overview
@section 剪切环概述
@cindex 剪切环概述

剪切环是一组文本字符串的列表。它的结构如下所示：

@smallexample
("一些文本" "不同的文本片段" "更多文本")
@end smallexample

如果这是我的剪切环的内容，并且我按下 @kbd{C-y} 键，那么包含字符串 @samp{一些文本} 的部分将被插入到我的光标所在位置。

@code{yank} 命令还用于通过复制来复制文本。复制的文本并未从缓冲区中删除，而是将其副本放入剪切环，并通过粘贴将其插入。

有三个函数用于从剪切环中恢复文本：@code{yank}，通常绑定到 @kbd{C-y}；@code{yank-pop}，通常绑定到 @kbd{M-y}；以及由这两个函数使用的 @code{rotate-yank-pointer}。

这些函数通过一个称为 @code{kill-ring-yank-pointer} 的变量引用剪切环。实际上，@code{yank} 和 @code{yank-pop} 函数的插入代码为：

@smallexample
(insert (car kill-ring-yank-pointer))
@end smallexample

@noindent
（好了，不再是这样了。在 GNU Emacs 22 中，该函数已被 @code{insert-for-yank} 替代，它会为每个 @code{yank-handler} 段重复调用 @code{insert-for-yank-1}。转而，@code{insert-for-yank-1} 根据 @code{yank-excluded-properties} 从插入的文本中去除文本属性。否则，它就像 @code{insert} 一样。我们将继续使用纯粹的 @code{insert}，因为它更容易理解。）

要开始理解 @code{yank} 和 @code{yank-pop} 如何工作，首先需要查看 @code{kill-ring-yank-pointer} 变量。

@node kill-ring-yank-pointer
@section 变量 @code{kill-ring-yank-pointer}

@code{kill-ring-yank-pointer} 是一个变量，就像 @code{kill-ring} 一样是一个变量。它通过绑定到它所指向的值来指向某个东西，就像任何其他 Lisp 变量一样。

@need 1000
因此，如果 kill 环的值为：

@smallexample
("一些文本" "另一段文本" "更多文本")
@end smallexample

@need 1250
@noindent
而 @code{kill-ring-yank-pointer} 指向第二个元素，那么 @code{kill-ring-yank-pointer} 的值就是：

@smallexample
("另一段文本" "更多文本")
@end smallexample

如前一章节所解释的（@pxref{List Implementation}），计算机并不保留被 @code{kill-ring} 和 @code{kill-ring-yank-pointer} 指向的文本的两个不同副本。"另一段文本"和"更多文本"这两个词不会被复制。相反，这两个 Lisp 变量指向相同的文本片段。以下是一个图示：

@c cons-cell-diagram #5
@ifnottex
@smallexample
@group
kill-ring     kill-ring-yank-pointer
    |               |
    |      ___ ___  |     ___ ___      ___ ___
     ---> |   |   |  --> |   |   |    |   |   |
          |___|___|----> |___|___|--> |___|___|--> nil
            |              |            |
            |              |            |
            |              |             --> "更多文本"
            |              |
            |               --> "另一段文本"
            |
             --> "一些文本"
@end group
@end smallexample
@sp 1
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-5}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
kill-ring     kill-ring-yank-pointer
    |               |
    |      ___ ___  |     ___ ___      ___ ___
     ---> |   |   |  --> |   |   |    |   |   |
          |___|___|----> |___|___|--> |___|___|--> nil
            |              |            |
            |              |            |
            |              |             --> "更多文本"
            |              |
            |               --> "另一段文本"
            |
             --> "一些文本"
@end group
@end smallexample
@sp 1
@end iftex
@end ifclear

变量 @code{kill-ring} 和变量 @code{kill-ring-yank-pointer} 都是指针。但是 kill 环本身通常被描述成它实际由什么组成。@code{kill-ring} 通常被视为保存最近从 Emacs 缓冲区中剪切的信息的完整数据结构。另一方面，@code{kill-ring-yank-pointer} 用于指示——即指向——kill 环的哪一部分将被插入。

@ignore
在 GNU Emacs 22 中，@code{kill-new} 函数调用：

@code{(setq kill-ring-yank-pointer kill-ring)}

(defun rotate-yank-pointer (arg)
  "旋转 kill 环的插入点。
带有参数时，向前旋转（如果是负数则向后旋转）那么多个插入点。"
  (interactive "p")
  (current-kill arg))

(defun current-kill (n &optional do-not-move)
  "将插入点旋转 N 个位置，然后返回该插入点的值。
如果 N 为零，`interprogram-paste-function' 被设置，并且调用它返回一个字符串，
则将该字符串添加到 kill 环的前面，并作为最新的插入点返回。
如果可选参数 DO-NOT-MOVE 非空，则不要实际移动插入点；只返回向前第 N 个插入点。"
  (let ((interprogram-paste (and (= n 0)
                                 interprogram-paste-function
                                 (funcall interprogram-paste-function))))
    (if interprogram-paste
        (progn
          ;; 在我们将新文本添加到 kill 环时禁用 interprogram cut 函数，
          ;; 以便 Emacs 不尝试拥有相同的文本选择。
          (let ((interprogram-cut-function nil))
            (kill-new interprogram-paste))
          interprogram-paste)
      (or kill-ring (error "Kill ring is empty"))
      (let ((ARGth-kill-element
             (nthcdr (mod (- n (length kill-ring-yank-pointer))
                          (length kill-ring))
                     kill-ring)))
        (or do-not-move
            (setq kill-ring-yank-pointer ARGth-kill-element))
        (car ARGth-kill-element)))))

@end ignore

@need 1500
@node yank nthcdr Exercises
@section 使用 @code{yank} 和 @code{nthcdr} 的练习

@itemize @bullet
@item
使用 @kbd{C-h v} (@code{describe-variable})，查看你的kill ring的值。向kill ring中添加几个项，再次查看其值。使用 @kbd{M-y} (@code{yank-pop})，在kill ring中循环移动。你的kill ring中有多少项？找到 @code{kill-ring-max} 的值。你的kill ring是满的吗，还是可以保存更多文本块？

@item
使用 @code{nthcdr} 和 @code{car}，构建一系列表达式，返回列表的第一、第二、第三和第四个元素。
@end itemize

@node Loops & Recursion
@chapter 循环和递归
@cindex 循环和递归
@cindex 递归和循环
@cindex 重复（循环）

Emacs Lisp 有两种主要的方式来使一个表达式或一系列表达式被重复地评估：一种使用 @code{while} 循环，另一种使用 @dfn{递归}。

重复可以是非常有价值的。例如，要前进四个句子，你只需要编写一个程序，该程序将前进一句，然后重复这个过程四次。由于计算机不会感到无聊或疲劳，这种重复的动作不会像对人类可能有害的过度或错误的重复那样产生不良影响。

大多数人使用 @code{while} 循环及其类似物来编写 Emacs Lisp 函数；但你也可以使用递归，它提供了一种非常强大的思考和解决问题的方式@footnote{你可以编写递归函数，让其在使用心智或计算资源时既节俭又浪费；实际上，人们发现易于使用——对心智资源节俭的方法——有时会使用相当多的计算资源。Emacs 设计用于运行在我们现在认为有限的机器上，其默认设置是保守的。你可能需要增加 @code{max-lisp-eval-depth} 的值。在我的 @file{.emacs} 文件中，我将其设置为默认值的30倍。}。

@menu
* while::                       导致代码段重复执行。
* dolist dotimes::
* Recursion::                   导致函数调用自身。
* Looping exercise::
@end menu

@node while
@section @code{while}
@cindex 循环
@findex while

特殊形式 @code{while} 用于测试通过评估其第一个参数返回的值是否为真或假。这类似于Lisp解释器对 @code{if} 的处理方式；然而，解释器接下来的操作有所不同。

在 @code{while} 表达式中，如果通过评估第一个参数返回的值为假，Lisp解释器将跳过表达式的其余部分（表达式的 @dfn{主体}）并不予以评估。然而，如果该值为真，则Lisp解释器将评估表达式的主体，然后再次测试 @code{while} 的第一个参数是真还是假。如果通过评估第一个参数返回的值再次为真，Lisp解释器将再次评估表达式的主体。

@need 1200
@code{while} 表达式的模板如下：

@smallexample
@group
(while @var{true-or-false-test}
  @var{body}@dots{})
@end group
@end smallexample

@menu
* Looping with while::          当测试返回 true 时重复执行。
* Loop Example::                  使用列表的 @code{while} 循环。
* print-elements-of-list::    使用 @code{while}、@code{car}、@code{cdr}。
* Incrementing Loop::                  带有递增计数器的循环。
* Incrementing Loop Details::
* Decrementing Loop::                  带有递减计数器的循环。
@end menu

@ifnottex
@node Looping with while
@unnumberedsubsec 使用 @code{while} 循环
@end ifnottex

只要 @code{while} 表达式的 true-or-false-test 在评估时返回真值，就会重复评估主体。这个过程称为循环，因为Lisp解释器一遍又一遍地重复相同的操作，就像一架飞机做环形飞行一样。当评估 true-or-false-test 的结果为假时，Lisp解释器将不再评估 @code{while} 的其余部分并退出循环。

显然，如果通过评估 @code{while} 的第一个参数返回的值始终为真，那么接下来的主体将一遍又一遍地被评估……而且永远都是如此。相反，如果返回的值从不为真，主体中的表达式将永远不会被评估。编写 @code{while} 循环的技巧在于选择一种机制，使得 true-or-false-test 仅在您希望后续表达式被评估的次数返回真，然后使测试返回假。

通过评估 @code{while} 的返回值是 true-or-false-test 的值。这样做的一个有趣的结果是，如果 @code{while} 循环评估成功且没有错误，它将始终返回 @code{nil} 或 false，无论它循环了1次还是100次，甚至一次都没有循环。成功评估的 @code{while} 表达式永远不返回真值！这意味着 @code{while} 总是被评估为其副作用，也就是评估循环体内表达式的后果。这是有道理的。人们追求的不仅仅是循环的行为，更是循环体内表达式反复评估时产生的后果。

@node Loop Example
@subsection 使用 @code{while} 循环和列表

控制 @code{while} 循环的常见方法是测试列表是否包含任何元素。如果包含元素，则循环将继续；但如果不包含元素，则循环结束。由于这是一种重要的技术，我们将创建一个简短的示例来说明它。

测试列表是否包含元素的一种简单方法是评估列表：如果没有元素，它是一个空列表，将返回空列表 @code{()}，这是 @code{nil} 或 false 的同义词。另一方面，具有元素的列表在评估时将返回这些元素。由于Emacs Lisp认为任何非 @code{nil} 的值都为真，因此返回元素的列表在 @code{while} 循环中将测试为真。

@need 1200
例如，您可以通过评估以下 @code{setq} 表达式将变量 @code{empty-list} 设置为 @code{nil}：

@smallexample
(setq empty-list ())
@end smallexample

@noindent
在评估了 @code{setq} 表达式之后，您可以以通常的方式评估变量 @code{empty-list}，即将光标放在符号后面，然后键入 @kbd{C-x C-e}；在您的回显区域中将显示 @code{nil}：

@smallexample
empty-list
@end smallexample

另一方面，如果将变量设置为具有元素的列表，则在评估变量时将显示该列表，如通过评估以下两个表达式所示：

@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))

animals
@end group
@end smallexample

因此，要创建一个 @code{while} 循环，测试列表 @code{animals} 中是否有任何项，循环的第一部分将被编写为：

@smallexample
@group
(while animals
       @dots{}
@end group
@end smallexample

@noindent
当 @code{while} 测试其第一个参数时，变量 @code{animals} 被评估。它返回一个列表。只要列表具有元素，@code{while} 将认为测试的结果为真；但当列表为空时，它将认为测试的结果为假。

为防止 @code{while} 循环无限运行，需要提供某种机制以最终清空列表。一个常用的技术是在 @code{while} 表达式的后续形式中之一将列表的值设置为列表的 @sc{cdr}。每次评估 @code{cdr} 函数时，列表都会变得更短，直到最终只剩下空列表。此时，@code{while} 循环的测试将返回假，@code{while} 的参数将不再被评估。

例如，将绑定到变量 @code{animals} 的动物列表可以通过以下表达式设置为原始列表的 @sc{cdr}：

@smallexample
(setq animals (cdr animals))
@end smallexample

@noindent
如果您已经评估了前面的表达式，然后评估此表达式，您将在回显区域中看到 @code{(giraffe lion tiger)}。如果再次评估表达式，将显示 @code{(lion tiger)}。如果再次评估它，@code{(tiger)} 将出现，然后是空列表，由 @code{nil} 表示。

使用 @code{cdr} 反复使真或假测试最终测试为假的 @code{while} 循环的模板如下：

@smallexample
@group
(while @var{test-whether-list-is-empty}
  @var{body}@dots{}
  @var{set-list-to-cdr-of-list})
@end group
@end smallexample

这个测试和使用 @code{cdr} 的功能可以放在一起，形成一个函数，该函数遍历列表并在各自的行上打印列表的每个元素。

@node print-elements-of-list
@subsection 示例：@code{print-elements-of-list} 函数
@findex print-elements-of-list

@code{print-elements-of-list} 函数演示了使用列表的 @code{while} 循环。

@cindex @file{*scratch*} 缓冲区
该函数需要多行输出。如果您正在使用最近版本的 GNU Emacs 阅读此文档，您可以像往常一样在 Info 中评估以下表达式。

如果您使用较早版本的 Emacs，则需要将必要的表达式复制到 @file{*scratch*} 缓冲区并在那里进行评估。这是因为早期版本的回显区只有一行。

您可以通过使用 @kbd{C-@key{SPC}}（@code{set-mark-command}）标记区域的开头，将光标移动到区域的末尾，然后使用 @kbd{M-w}（@code{kill-ring-save}，它调用 @code{copy-region-as-kill} 并提供视觉反馈）来复制区域。在 @file{*scratch*} 缓冲区中，您可以通过键入 @kbd{C-y}（@code{yank}）将表达式还原。

在将表达式复制到 @file{*scratch*} 缓冲区后，逐个评估每个表达式。确保通过键入 @kbd{C-u C-x C-e} 评估最后一个表达式 @code{(print-elements-of-list animals)}，即通过给 @code{eval-last-sexp} 提供参数。这将导致评估的结果在 @file{*scratch*} 缓冲区中打印，而不是在回显区中打印（否则您将在回显区中看到类似于这样的内容：@code{^Jgazelle^J^Jgiraffe^J^Jlion^J^Jtiger^Jnil}，其中每个 @samp{^J} 代表一个换行符）。

@need 1500
您可以直接在 Info 缓冲区中评估这些表达式，回显区将增大以显示结果。

@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))

(defun print-elements-of-list (list)
  "逐行打印 LIST 的每个元素。"
  (while list
    (print (car list))
    (setq list (cdr list))))

(print-elements-of-list animals)
@end group
@end smallexample

@need 1200
@noindent
当您按顺序评估这三个表达式时，将看到以下结果：

@smallexample
@group
gazelle

giraffe

lion

tiger
nil
@end group
@end smallexample

列表的每个元素都打印在自己的一行上（这是函数 @code{print} 的作用），然后打印函数的返回值。由于函数中的最后一个表达式是 @code{while} 循环，而且由于 @code{while} 循环总是返回 @code{nil}，因此在列表的最后一个元素后打印了一个 @code{nil}。

@node Incrementing Loop
@subsection 具有增量计数器的循环

循环如果没有在应该停止的时候停止，就毫无用处。除了使用列表控制循环外，另一种常见的停止循环的方式是将第一个参数写为一个测试，当正确的重复次数完成时返回false。这意味着循环必须有一个计数器，即一个表达式，用于计算循环重复的次数。

@ifnottex
@node Incrementing Loop Details
@unnumberedsubsec 增量循环的细节
@end ifnottex

具有增量计数器的循环的测试可以是诸如 @code{(< count desired-number)} 的表达式，如果 @code{count} 的值小于 @code{desired-number}，则返回 @code{t} 为true，如果 @code{count} 的值等于或大于 @code{desired-number}，则返回 @code{nil} 为false。增加计数的表达式可以是一个简单的 @code{setq}，例如 @code{(setq count (1+ count))}，其中 @code{1+} 是Emacs Lisp中的内置函数，将1添加到其参数。 (表达式 @w{@code{(1+ count)}} 的结果与 @w{@code{(+ count 1)}} 相同，但对于人类来说更容易阅读。)

@need 1250
由增量计数器控制的 @code{while} 循环的模板如下：

@smallexample
@group
@var{set-count-to-initial-value}
(while (< count desired-number)         ; @r{true-or-false-test}
  @var{body}@dots{}
  (setq count (1+ count)))              ; @r{incrementer}
@end group
@end smallexample

@noindent
请注意，您需要设置 @code{count} 的初始值；通常将其设置为1。

@menu
* Incrementing Example::        计算三角形中的鹅卵石。
* Inc Example parts::   函数定义的各个部分。
* Inc Example altogether::   将函数定义组合在一起。
@end menu

@node Incrementing Example
@unnumberedsubsubsec  具有增量计数器的示例

假设您正在沙滩上玩耍，决定做一个鹅卵石三角形，第一排放一个鹅卵石，第二排放两个，第三排放三个，依此类推，如下所示：

@sp 1
@c 鹅卵石图示
@ifnottex
@smallexample
@group
               *
              * *
             * * *
            * * * *
@end group
@end smallexample
@end ifnottex
@iftex
@smallexample
@group
               @bullet{}
              @bullet{} @bullet{}
             @bullet{} @bullet{} @bullet{}
            @bullet{} @bullet{} @bullet{} @bullet{}
@end group
@end smallexample
@end iftex
@sp 1

@noindent
(大约2500年前，毕达哥拉斯等人通过考虑这类问题发展了数论的开端。)

假设您想知道要制作一个有7排的三角形需要多少鹅卵石？

显然，您需要做的是将从1到7的数字相加。有两种方法可以做到这一点：从最小的数字开始，即1，按顺序相加列表中的数字1、2、3、4等；或者从最大的数字开始，按列表向下相加：7、6、5、4等。由于这两种机制都说明了编写 @code{while} 循环的常见方法，我们将创建两个示例，一个是递增计数，另一个是递减计数。在这个第一个示例中，我们将从1开始，然后添加2、3、4等。

如果您只是在一个短列表中相加一些数字，最简单的方法是一次将所有数字相加。但是，如果您不知道列表将有多少数字，或者如果您希望为一个非常长的列表做好准备，那么您需要设计加法，以便您重复一个简单的过程多次，而不是一次执行更复杂的过程。

例如，与其一次性将所有鹅卵石相加，不如将第一排的鹅卵石数，即1，加到第二排的鹅卵石数2中，然后将这两排的总数加到第三排的鹅卵石数3中。然后，将第四排的鹅卵石数4加到前三排的总数中，依此类推。

这个过程的关键特征是每个重复的动作都很简单。在这种情况下，在每一步中，我们只添加两个数字，即排中的鹅卵石数和已找到的总数。这个添加两个数字的过程一遍又一遍地重复，直到最后一排的鹅卵石被添加到所有前排的总数中。在更复杂的循环中，重复的动作可能不那么简单，但它将比一次性做所有事情更简单。

@node Inc Example parts
@unnumberedsubsubsec 函数定义的各部分

前面的分析为我们的函数定义提供了骨架：首先，我们需要一个变量，我们可以称之为 @code{total}，它将是函数返回的总的鹅卵石数量。这将是函数返回的值。

其次，我们知道函数将需要一个参数：这个参数将是三角形中的总行数。它可以被称为 @code{number-of-rows}。

最后，我们需要一个作为计数器的变量。我们可以称这个变量为 @code{counter}，但更好的名字是 @code{row-number}。这是因为在这个函数中，计数器的作用是计算行数，而程序应该尽可能易于理解。

当Lisp解释器首次开始评估函数中的表达式时，@code{total}的值应该设置为零，因为我们还没有向其中添加任何东西。然后，函数应该将第一行中的鹅卵石数量添加到总数中，然后将第二行的数量添加到总数中，然后将第三行的数量添加到总数中，依此类推，直到没有更多的行可以添加。

@code{total}和@code{row-number}都仅在函数内部使用，因此它们可以被声明为局部变量，并用@code{let}给予初始值。显然，@code{total}的初始值应为0。@code{row-number}的初始值应为1，因为我们从第一行开始。这意味着@code{let}语句将如下所示：

@smallexample
@group
  (let ((total 0)
        (row-number 1))
    @var{body}@dots{})
@end group
@end smallexample

在内部变量被声明并绑定到它们的初始值之后，我们可以开始@code{while}循环。作为测试的表达式应该在@code{row-number}小于或等于@code{number-of-rows}时返回true。如果表达式仅在行号小于三角形行数的情况下为true，最后一行将永远不会添加到总数中；因此行号必须小于或等于行数。

@need 1500
@findex <= @r{(小于或等于)}
Lisp提供了@code{<=}函数，如果其第一个参数的值小于或等于其第二个参数的值，则返回true，否则返回false。因此，@code{while}将评估为测试的表达式应如下所示：

@smallexample
(<= row-number number-of-rows)
@end smallexample

鹅卵石的总数量可以通过重复将一行中的鹅卵石数量添加到已找到的总数中来找到。由于一行中的鹅卵石数量等于行号，因此可以通过将行号添加到总数中来找到总数。

@smallexample
(setq total (+ total row-number))
@end smallexample

@noindent
这做的是将@code{total}的新值设置为将鹅卵石数量添加到先前总数的和。

在设置了@code{total}的值之后，需要建立下一次循环的条件，如果有的话。这是通过增加@code{row-number}变量的值来完成的，它充当计数器。在增加@code{row-number}变量之后，@code{while}循环开头的true-or-false测试会测试其值是否仍然小于或等于@code{number-of-rows}的值，如果是，将新值添加到先前循环的@code{total}中。

@need 1200
内置的Emacs Lisp函数@code{1+}将1添加到一个数字，因此可以使用以下表达式递增@code{row-number}变量：

@smallexample
(setq row-number (1+ row-number))
@end smallexample

@node Inc Example altogether
@unnumberedsubsubsec Putting the function definition together
@need 800

我们已经创建了函数定义的各个部分；现在需要将它们组合起来。

首先，@code{while} 表达式的内容：

@smallexample
@group
(while (<= 行号 总行数)   ; @r{真或假的测试}
  (setq 总和 (+ 总和 行号))
  (setq 行号 (1+ 行号)))    ; @r{增量器}
@end group
@end smallexample

连同 @code{let} 表达式的变量列表，这几乎完成了函数定义的主体。但是，还需要一个微妙的最后要素。

最后的一步是将变量 @code{总和} 单独放在 @code{while} 表达式之后的一行上。否则，整个函数返回的值将是在 @code{let} 主体中最后一个表达式的值，而这是由 @code{while} 评估得到的，其值始终为 @code{nil}。

这一点乍一看可能不明显。它几乎看起来好像增量表达式是整个函数的最后一个表达式。但是该表达式是 @code{while} 主体的一部分；它是以符号 @code{while} 开始的列表的最后一个元素。此外，整个 @code{while} 循环是 @code{let} 主体内的列表。

@need 1250

概述来说，函数将如下所示：

@smallexample
@group
(defun @var{函数名} (@var{参数列表})
  "@var{文档}@dots{}"
  (let (@var{变量列表})
    (while (@var{真或假的测试})
      @var{while的主体}@dots{} )
    @dots{} ))                    ; @r{这里需要最后的表达式。}
@end group
@end smallexample

评估 @code{let} 的结果将是由 @code{defun} 返回的结果，因为 @code{let} 不嵌套在任何包含列表中，除了整个 @code{defun}。然而，如果 @code{while} 是 @code{let} 表达式的最后一个元素，函数将始终返回 @code{nil}。这不是我们想要的！相反，我们想要的是变量 @code{总和} 的值。通过简单地将该符号作为以 @code{let} 开始的列表的最后一个元素放置在列表中，它将在之前的元素被评估之后被评估，这意味着在为总和赋予正确值之后才被评估。

通过将以 @code{let} 开始的列表打印在一行上，可能更容易看到这一点。这种格式使得显而易见，@var{变量列表} 和 @code{while} 表达式是以 @code{let} 开始的列表的第二和第三个元素，而 @code{总和} 是最后一个元素：

@smallexample
@group
(let (@var{变量列表}) (while (@var{真或假的测试}) @var{while的主体}@dots{} ) 总和)
@end group
@end smallexample

@need 1200

将所有内容放在一起，@code{triangle} 函数定义如下：

@smallexample
@group
(defun triangle (总行数)    ; @r{带有}
                                    ; @r{  增量计数器的版本。}
  "将三角形中的鹅卵石数量相加。
第一行有一个鹅卵石，第二行有两个鹅卵石，
第三行有三个鹅卵石，依此类推。
参数为总行数。"
@end group
@group
  (let ((总和 0)
        (行号 1))
    (while (<= 行号 总行数)
      (setq 总和 (+ 总和 行号))
      (setq 行号 (1+ 行号)))
    总和))
@end group
@end smallexample

@need 1200

安装 @code{triangle} 后，您可以尝试它。以下是两个示例：

@smallexample
@group
(triangle 4)

(triangle 7)
@end group
@end smallexample

@noindent
前四个数字的总和是10，前七个数字的总和是28。

@node Decrementing Loop
@subsection 带有递减计数器的循环

另一种常见的编写 @code{while} 循环的方式是编写测试，使其确定计数器是否大于零。只要计数器大于零，循环就会重复。但当计数器等于或小于零时，循环停止。为使此方法有效，计数器必须从大于零开始，然后通过一个可重复评估的形式逐渐减小。

测试将是诸如 @code{(> counter 0)} 的表达式，如果 @code{counter} 的值大于零，则返回 @code{t} 为 true，如果 @code{counter} 的值等于或小于零，则返回 @code{nil} 为 false。使数字逐渐减小的表达式可以是一个简单的 @code{setq}，例如 @code{(setq counter (1- counter))}，其中 @code{1-} 是 Emacs Lisp 中减去其参数的内置函数。

@need 1250
递减 @code{while} 循环的模板如下：

@smallexample
@group
(while (> counter 0)                    ; @r{真或假测试}
  @var{body}@dots{}
  (setq counter (1- counter)))          ; @r{递减器}
@end group
@end smallexample

@menu
* Decrementing Example::        海滩上更多的小石子。
* Dec Example parts::    函数定义的各个部分。
* Dec Example altogether::    将函数定义组合在一起。
@end menu

@node Decrementing Example
@unnumberedsubsubsec 带有递减计数器的示例

为了说明带有递减计数器的循环，我们将重写 @code{triangle} 函数，使计数器递减到零。

这是该函数早期版本的反转。在这种情况下，要找出构成 3 行三角形所需的小石子数量，将第三行的小石子数量（3）与前一行的数量（2）相加，然后将这两行的总和添加到它们之前的行，即第一行（1）。

同样，要找出具有 7 行的三角形中的小石子数量，将第七行的小石子数量（7）与前一行的数量（6）相加，然后将这两行的总和添加到它们之前的行，即第五行（5），依此类推。与前一个示例一样，每次添加仅涉及两个数字的相加，已经添加的行的总和以及正在添加到总和的行的小石子数量。这个加法的过程一遍又一遍地重复，直到没有更多的小石子可添加。

我们知道从哪里开始有多少小石子：最后一行中的小石子数量等于行数。如果三角形有七行，最后一行中的小石子数量为 7。同样，我们知道前一行中有多少小石子：它比该行中的数量少一个。

@node Dec Example parts
@unnumberedsubsubsec 函数定义的各部分

我们从三个变量开始：三角形中的总行数；每行中的小石子数；以及我们想要计算的小石子的总数。这些变量可以分别命名为 @code{number-of-rows}、@code{number-of-pebbles-in-row} 和 @code{total}。

@code{total} 和 @code{number-of-pebbles-in-row} 都仅在函数内部使用，并使用 @code{let} 进行声明。显然，@code{total} 的初始值应为零。然而，@code{number-of-pebbles-in-row} 的初始值应等于三角形中的行数，因为加法将从最长的行开始。

@need 1250
这意味着 @code{let} 表达式的开头将如下所示：

@smallexample
@group
(let ((total 0)
      (number-of-pebbles-in-row number-of-rows))
  @var{body}@dots{})
@end group
@end smallexample

小石子的总数可以通过重复将每行的小石子数加到已找到的总数中来找到，即通过反复评估以下表达式：

@smallexample
(setq total (+ total number-of-pebbles-in-row))
@end smallexample

@noindent
在将 @code{number-of-pebbles-in-row} 添加到 @code{total} 后，@code{number-of-pebbles-in-row} 应减一，因为下次循环重复时将添加前一行到总数中。

前一行中的小石子数比当前行中的小石子数少一个，因此可以使用内置的 Emacs Lisp 函数 @code{1-} 来计算前一行中的小石子数。可以使用以下表达式完成：

@smallexample
@group
(setq number-of-pebbles-in-row
      (1- number-of-pebbles-in-row))
@end group
@end smallexample

最后，我们知道 @code{while} 循环应在一行中没有小石子时停止重复添加。因此，@code{while} 循环的测试简单地是：

@smallexample
(while (> number-of-pebbles-in-row 0)
@end smallexample

@node Dec Example altogether
@unnumberedsubsubsec 将函数定义组合在一起

我们可以将这些表达式组合在一起以创建一个有效的函数定义。然而，在检查时，我们发现其中一个局部变量是不必要的！

@need 1250
函数定义如下：

@smallexample
@group
;;; @r{第一个减法版本。}
(defun triangle (number-of-rows)
  "将三角形中小石子的数量相加。"
  (let ((total 0)
        (number-of-pebbles-in-row number-of-rows))
    (while (> number-of-pebbles-in-row 0)
      (setq total (+ total number-of-pebbles-in-row))
      (setq number-of-pebbles-in-row
            (1- number-of-pebbles-in-row)))
    total))
@end group
@end smallexample

按照写法，这个函数是有效的。

然而，我们不需要 @code{number-of-pebbles-in-row}。

@cindex 参数作为局部变量
当评估 @code{triangle} 函数时，符号 @code{number-of-rows} 将绑定到一个数字，给它一个初始值。该数字可以在函数体内部像局部变量一样更改，而无需担心这样的更改会影响函数外部的变量值。这是 Lisp 的一个非常有用的特性；这意味着变量 @code{number-of-rows} 可以在函数中任何使用 @code{number-of-pebbles-in-row} 的地方使用。

@need 800
以下是稍微更清晰地编写的函数的第二个版本：

@smallexample
@group
(defun triangle (number)                ; @r{第二个版本。}
  "返回 1 到 NUMBER（包括）的数字的总和。"
  (let ((total 0))
    (while (> number 0)
      (setq total (+ total number))
      (setq number (1- number)))
    total))
@end group
@end smallexample

简而言之，一个正确编写的 @code{while} 循环将包含三个部分：

@enumerate
@item
一个测试，循环重复正确次数后将返回 false。

@item
一个表达式，其评估在重复评估后将返回所需值。

@item
一个表达式，用于更改传递给真假测试的值，以便在循环重复正确次数后测试返回 false。
@end enumerate

@node dolist dotimes
@section 节省时间：@code{dolist} 和 @code{dotimes}

除了 @code{while} 之外，@code{dolist} 和 @code{dotimes} 都提供了循环的功能。有时候，它们比等效的 @code{while} 循环更容易编写。两者都是Lisp宏。(@xref{宏, , 宏, elisp, GNU Emacs Lisp参考手册}.)

@code{dolist} 像一个 @code{while} 循环，不断地对列表进行 @sc{cdr} 操作：@code{dolist} 每次循环都会自动缩短列表---获取列表的 @sc{cdr}---并将每个缩短版本的列表的 @sc{car} 绑定到其第一个参数。

@code{dotimes} 循环指定的次数：您需要指定次数。

@menu
* dolist::
* dotimes::
@end menu

@node dolist
@unnumberedsubsec @code{dolist} 宏
@findex dolist

例如，假设您想反转一个列表，使得``first'' ``second'' ``third'' 变成 ``third'' ``second'' ``first''。

@need 1250
实际上，您可以使用 @code{reverse} 函数，如下所示：

@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))

(reverse animals)
@end group
@end smallexample

@need 800
@noindent
以下是使用 @code{while} 循环反转列表的方法：

@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))

(defun reverse-list-with-while (list)
  "使用while循环反转LIST的顺序。"
  (let (value)  ; 确保列表从空开始
    (while list
      (setq value (cons (car list) value))
      (setq list (cdr list)))
    value))

(reverse-list-with-while animals)
@end group
@end smallexample

@need 800
@noindent
以下是使用 @code{dolist} 宏的方法：

@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))

(defun reverse-list-with-dolist (list)
  "使用dolist宏反转LIST的顺序。"
  (let (value)  ; 确保列表从空开始
    (dolist (element list value)
      (setq value (cons element value)))))

(reverse-list-with-dolist animals)
@end group
@end smallexample

@need 1250
@noindent
在Info中，您可以将光标放在每个表达式的右括号后，然后键入 @kbd{C-x C-e}; 在每种情况下，您应该在回显区域看到

@smallexample
(tiger lion giraffe gazelle)
@end smallexample

@noindent
对于此示例，现有的 @code{reverse} 函数显然是最好的选择。
@code{while} 循环就像我们的第一个示例一样(@pxref{Loop Example, , 一个@code{while}循环和一个列表})。@code{while} 首先检查列表是否有元素；如果有，它通过将列表的第一个元素添加到现有列表（在循环的第一次迭代中是 @code{nil}）来构造一个新列表。由于第二个元素在第一个元素的前面添加，第三个元素在第二个元素的前面添加，因此列表被反转。

在使用 @code{while} 循环的表达式中，
@w{@code{(setq list (cdr list))}}
表达式缩短了列表，因此 @code{while} 循环最终停止。此外，它通过在每次循环重复时创建一个新的更短的列表，为 @code{cons} 表达式提供了一个新的第一个元素。

@code{dolist} 表达式的工作方式与 @code{while} 表达式非常相似，不同之处在于，@code{dolist} 宏执行了在编写 @code{while} 表达式时必须执行的一些工作。

像 @code{while} 循环一样，@code{dolist} 循环。不同之处在于，它每次循环都会自动缩短列表---它会对列表进行 @sc{cdr} 操作---并且会自动将每个较短版本的列表的 @sc{car} 绑定到其第一个参数。

在此示例中，较短版本的列表的 @sc{car} 由符号 @samp{element} 引用，列表本身称为 @samp{list}，返回的值称为 @samp{value}。@code{dolist} 表达式的其余部分是主体。

@code{dolist} 表达式将较短版本的列表的 @sc{car} 绑定到 @code{element}，然后评估表达式的主体；然后重复循环。结果在 @code{value} 中返回。

@node dotimes
@unnumberedsubsec @code{dotimes} 宏
@findex dotimes

@code{dotimes} 宏类似于 @code{dolist}，但它循环特定次数。

@code{dotimes} 的第一个参数在每次循环时被赋予数字 0、1、2 等等。你需要提供第二个参数的值，该值表示宏循环的次数。

@need 1250
例如，下面的代码将数字从 0 到 3（不包括 3）绑定到第一个参数 @var{number}，然后构建包含这三个数字的列表。（第一个数字是 0，第二个数字是 1，第三个数字是 2；总共有三个数字，以零为起始。）

@smallexample
@group
(let (value)      ; 否则 value 是一个未定义变量
  (dotimes (number 3)
    (setq value (cons number value)))
  value)

@result{} (2 1 0)
@end group
@end smallexample

@noindent
使用 @code{dotimes} 的方法是对某个表达式 @var{number} 进行操作，重复操作 @var{number} 次，然后返回结果，可以是列表或原子。

@need 1250
以下是一个使用 @code{dotimes} 的 @code{defun} 示例，用于计算三角形中鹅卵石的总数。

@smallexample
@group
(defun triangle-using-dotimes (number-of-rows)
  "使用 `dotimes'，计算三角形中鹅卵石的总数。"
(let ((total 0))  ; 否则 total 是一个未定义变量
  (dotimes (number number-of-rows)
    (setq total (+ total (1+ number))))
  total))

(triangle-using-dotimes 4)
@end group
@end smallexample

@node Recursion
@section 递归
@cindex 递归

一个递归函数包含代码，告诉Lisp解释器调用一个与自身完全相同但具有略有不同参数的程序。代码运行完全相同，因为它具有相同的名称。然而，即使程序具有相同的名称，它也不是相同的实体。它是不同的。在行话中，它是一个不同的“实例”。

最终，如果程序被正确编写，稍微不同的参数将与第一个参数足够不同，以至于最终的实例将停止。

@menu
* Building Robots::             相同的模型，不同的序列号...
* Recursive Definition Parts::         走到停下来...
* Recursion with list::         将列表用作判断是否递归的测试。
* Recursive triangle function::
* Recursion with cond::
* Recursive Patterns::               经常使用的模板。
* No Deferment::                  不要存储工作...
* No deferment solution::
@end menu

@node Building Robots
@subsection 构建机器人：扩展隐喻
@cindex 构建机器人
@cindex 机器人，构建

有时将运行的程序看作是执行任务的机器人是有帮助的。在执行其任务时，递归函数调用第二个机器人来帮助它。第二个机器人与第一个机器人在每个方面都是相同的，除了第二个机器人帮助第一个机器人并传递了不同于第一个机器人的参数。

在递归函数中，第二个机器人可能调用第三个；第三个可能调用第四个，依此类推。每个都是一个不同的实体；但都是克隆体。

由于每个机器人都有略有不同的指令——参数将从一个机器人到另一个机器人不同——最后一个机器人应该知道何时停止。

让我们扩展一下计算机程序是机器人的隐喻。

函数定义提供了一个机器人的蓝图。当您安装函数定义时，也就是当您评估@code{defun}宏时，您安装了构建机器人所需的设备。这就好像您在工厂中设置了一个装配线。具有相同名称的机器人是根据相同的蓝图构建的。因此，它们具有相同的型号，但不同的序列号。

我们经常说一个递归函数“调用自身”。我们的意思是递归函数中的指令导致Lisp解释器运行一个具有相同名称且执行与第一个相同的工作的不同函数，但具有不同参数。

参数从一个实例到下一个必须不同；否则，这个过程将永远不会停止。

@node Recursive Definition Parts
@subsection 递归定义的组成部分
@cindex 递归定义的部分
@cindex 递归定义的组成部分

一个递归函数通常包含一个条件表达式，该表达式有三个部分：

@enumerate
@item
一个判断函数是否再次调用的真假测试，这里称为@dfn{再次执行测试}。

@item
函数的名称。当调用此名称时，将创建一个函数的新实例，也可以看作是创建一个新的机器人，并告诉它要做什么。

@item
一个表达式，每次调用函数时都返回不同的值，这里称为@dfn{下一步表达式}。因此，传递给函数的新实例的参数（或参数）将与传递给上一个实例的参数不同。这导致条件表达式，即@dfn{再次执行测试}在正确的重复次数后返回false。
@end enumerate

递归函数可能比其他类型的函数简单得多。实际上，当人们首次开始使用它们时，它们经常看起来如此神秘简单，以至于难以理解。就像骑自行车一样，阅读递归函数定义需要一定的技巧，起初很难，但后来似乎很简单。

@need 1200
有几种常见的递归模式。一个非常简单的模式如下：

@smallexample
@group
(defun @var{name-of-recursive-function} (@var{argument-list})
  "@var{documentation}@dots{}"
  (if @var{do-again-test}
    @var{body}@dots{}
    (@var{name-of-recursive-function}
         @var{next-step-expression})))
@end group
@end smallexample

每次评估递归函数时，都会创建它的一个新实例，并告诉它要做什么。参数告诉实例要做什么。

参数被绑定到下一步表达式的值。每个实例以不同的下一步表达式的值运行。

下一步表达式中的值在再次执行测试中使用。

由下一步表达式返回的值被传递给函数的新实例，该实例评估它（或它的某些转化）以确定是否继续还是停止。下一步表达式被设计成当函数不再需要重复时再次执行测试返回false。

再次执行测试有时被称为@dfn{停止条件}，因为它在测试为false时停止重复。

@node Recursion with list
@subsection 列表递归

一个用@code{while}循环打印数字列表元素的例子可以用递归的方式重写。下面是代码，包括一个表达式，将变量@code{animals}的值设置为一个列表。

如果你在Emacs的Info中阅读此内容，你可以直接在Info中评估这个表达式。否则，你必须将示例复制到@file{*scratch*}缓冲区，并在那里逐个评估每个表达式。使用@kbd{C-u C-x C-e}来评估@code{(print-elements-recursively animals)}表达式，以便结果打印在缓冲区中；否则，Lisp解释器将尝试将结果压缩成回显区域的一行。

此外，在@code{print-elements-recursively}函数的最后一个闭合括号之后，在注释之前将光标放置在此处。否则，Lisp解释器将尝试评估注释。

@findex print-elements-recursively
@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))

(defun print-elements-recursively (list)
  "将LIST的每个元素单独打印到一行上。
使用递归。"
  (when list                            ; @r{do-again-test}
        (print (car list))              ; @r{body}
        (print-elements-recursively     ; @r{recursive call}
         (cdr list))))                  ; @r{next-step-expression}

(print-elements-recursively animals)
@end group
@end smallexample

@code{print-elements-recursively}函数首先测试列表中是否有内容；如果有，函数将打印列表的第一个元素，即列表的@sc{car}。然后，函数调用自身，但将自身作为参数传递，而不是整个列表，而是列表的第二个及后续元素，即列表的@sc{cdr}。

换句话说，如果列表不为空，函数调用另一个与初始代码相似但是不同执行线程的代码实例，其参数与第一个实例不同。

再换一种说法，如果列表不为空，第一个机器人组装第二个机器人并告诉它该做什么；第二个机器人是第一个机器人之外的另一个个体，但是是相同型号。

当进行第二次评估时，@code{when}表达式将被评估，如果为真，则打印作为其参数接收到的列表的第一个元素（这是原始列表的第二个元素）。然后，函数使用它调用的列表的@sc{cdr}调用自身，这是原始列表的@sc{cdr}的@sc{cdr}（第二次调用时）。

请注意，尽管我们说函数“调用自身”，但我们的意思是Lisp解释器将装配并指导程序的新实例。新实例是第一个的克隆，但是是独立的个体。

每次函数调用自身时，它都是在原始列表的较短版本上进行的。它创建一个在较短列表上运行的新实例。

最终，函数在空列表上调用自身。它创建一个参数为@code{nil}的新实例。条件表达式测试@code{list}的值。由于@code{list}的值是@code{nil}，@code{when}表达式测试为假，因此不会评估then部分。因此，整个函数返回@code{nil}。

@need 1200
当在@file{*scratch*}缓冲区中评估表达式@code{(print-elements-recursively animals)}时，你将看到以下结果：

@smallexample
@group
gazelle

giraffe

lion

tiger
nil
@end group
@end smallexample

@need 2000
@node Recursive triangle function
@subsection 使用递归替代计数器
@findex triangle-recursively

@need 1200
在前一节中描述的 @code{triangle} 函数也可以使用递归方式编写。它的代码如下：

@smallexample
@group
(defun triangle-recursively (number)
  "返回从1到NUMBER（包括NUMBER）的数字之和，使用递归。"
  (if (= number 1)                    ; @r{再做一次测试}
      1                               ; @r{然后部分}
    (+ number                         ; @r{否则部分}
       (triangle-recursively          ; @r{递归调用}
        (1- number)))))               ; @r{下一步表达式}

(triangle-recursively 7)
@end group
@end smallexample

@noindent
你可以通过评估这个函数来安装它，并通过评估 @code{(triangle-recursively 7)} 来尝试它。（记得把光标放在函数定义的最后一个括号之后，注释之前。）这个函数的值为28。

为了理解这个函数的工作原理，让我们考虑当函数的参数值为1、2、3或4时发生的各种情况。

@menu
* Recursive Example arg of 1 or 2::
* Recursive Example arg of 3 or 4::
@end menu

@ifnottex
@node Recursive Example arg of 1 or 2
@unnumberedsubsubsec 参数为1或2
@end ifnottex

首先，如果参数值为1会发生什么？

在文档字符串之后，函数有一个 @code{if} 表达式。它测试 @code{number} 的值是否等于1；如果是，Emacs 将评估 @code{if} 表达式的 then-部分，将1作为函数的值返回。（一个只有一行的三角形中有一个小石子。）

然而，假设参数值为2。在这种情况下，Emacs 将评估 @code{if} 表达式的 else-部分。

@need 1200
else-部分由一个加法、对 @code{triangle-recursively} 的递归调用和一个递减操作组成；它看起来像这样：

@smallexample
(+ number (triangle-recursively (1- number)))
@end smallexample

当Emacs评估这个表达式时，首先评估最内层的表达式；然后按顺序评估其他部分。以下是详细的步骤：

@table @i
@item 步骤1 @w{  } 评估最内层的表达式。

最内层的表达式是 @code{(1- number)}，因此Emacs将 @code{number} 的值从2递减到1。

@item 步骤2 @w{  } 评估 @code{triangle-recursively} 函数。

Lisp解释器创建了 @code{triangle-recursively} 的一个单独实例。这个函数包含在它自己的内部并不重要。Emacs将步骤1的结果作为这个 @code{triangle-recursively} 函数实例使用的参数传递。

在这种情况下，Emacs使用参数1评估 @code{triangle-recursively}。这意味着这次评估返回1。

@item 步骤3 @w{  } 评估 @code{number} 的值。

变量 @code{number} 是以 @code{+} 开头的列表的第二个元素；它的值为2。

@item 步骤4 @w{  } 评估 @code{+} 表达式。

@code{+} 表达式接收两个参数，第一个来自 @code{number} 的评估（步骤3），第二个来自 @code{triangle-recursively} 的评估（步骤2）。

加法的结果是2加1的和，返回数字3，这是正确的。一个有两行的三角形中有三颗小石子。
@end table

@node Recursive Example arg of 3 or 4
@unnumberedsubsubsec 参数为3或4的情况

假设调用 @code{triangle-recursively} 时参数为3。

@table @i
@item 步骤 1 @w{  } 评估再次执行测试。

首先评估 @code{if} 表达式。这是再次执行测试，并返回false，因此 @code{if} 表达式的else部分将被评估。（请注意，在此示例中，再次执行测试在测试false时导致函数调用自身，而不是在测试true时。）

@item 步骤 2 @w{  } 评估else部分的最内层表达式。

评估else部分的最内层表达式，将3减少到2。这是下一步表达式。

@item 步骤 3 @w{  } 评估 @code{triangle-recursively} 函数。

将数字2传递给 @code{triangle-recursively} 函数。

我们已经知道当Emacs使用参数2评估 @code{triangle-recursively} 时会发生什么。在经历了前面描述的一系列动作后，它将返回值3。因此，在这里也将发生这种情况。

@item 步骤 4 @w{  } 评估加法。

3将作为参数传递给加法，并将被添加到调用函数的数字中，该数字为3。
@end table

@noindent
函数整体返回的值将为6。

现在我们知道当 @code{triangle-recursively} 使用参数3调用时会发生什么，那么如果使用参数4调用它会发生什么就显而易见了：

@quotation
@need 800
在递归调用中，评估

@smallexample
(triangle-recursively (1- 4))
@end smallexample

@need 800
@noindent
将返回评估的值

@smallexample
(triangle-recursively 3)
@end smallexample

@noindent
这是6，此值将通过第三行的加法添加到4中。
@end quotation

@noindent
函数整体返回的值将为10。

每次评估 @code{triangle-recursively} 时，它都会评估它自己的版本---一个具有较小参数的不同实例，直到参数足够小以使其不再评估自身。

请注意，这种递归函数的特定设计要求推迟操作。

在 @code{(triangle-recursively 7)} 可以计算其答案之前，它必须调用 @code{(triangle-recursively 6)}；在 @code{(triangle-recursively 6)} 可以计算其答案之前，它必须调用 @code{(triangle-recursively 5)}；依此类推。也就是说，@code{(triangle-recursively 7)} 进行的计算必须推迟，直到 @code{(triangle-recursively 6)} 进行其计算为止；而 @code{(triangle-recursively 6)} 必须推迟，直到 @code{(triangle-recursively 5)} 完成为止；依此类推。

如果将 @code{triangle-recursively} 的每个实例都视为不同的机器人，第一个机器人必须等待第二个完成其工作，第二个必须等待第三个完成，依此类推。

有一种绕过这种等待的方法，我们将在 @ref{No Deferment, , 无推迟的递归} 中讨论。

@node Recursion with cond
@subsection 使用 @code{cond} 进行递归的例子
@findex cond

先前描述的 @code{triangle-recursively} 版本是用 @code{if} 特殊形式编写的。它也可以使用另一种特殊形式称为 @code{cond} 来编写。特殊形式 @code{cond} 的名称是单词 @samp{conditional} 的缩写。

尽管在 Emacs Lisp 源代码中并不像 @code{if} 那样经常使用 @code{cond} 特殊形式，但它被足够频繁地使用，以便解释它是有道理的。

@need 800
@code{cond} 表达式的模板如下：

@smallexample
@group
(cond
 @var{body}@dots{})
@end group
@end smallexample

@noindent
其中 @var{body} 是一系列列表。

@need 800
更详细地写出来，模板如下：

@smallexample
@group
(cond
 (@var{first-true-or-false-test} @var{first-consequent})
 (@var{second-true-or-false-test} @var{second-consequent})
 (@var{third-true-or-false-test} @var{third-consequent})
  @dots{})
@end group
@end smallexample

当 Lisp 解释器评估 @code{cond} 表达式时，它评估第一个元素（即第一个表达式中的 @sc{car} 或 true-or-false-test）。

如果 true-or-false-test 返回 @code{nil}，则跳过该表达式的其余部分，即 consequent，并评估下一个表达式的 true-or-false-test。当找到一个表达式，其 true-or-false-test 返回非 @code{nil} 的值时，将评估该表达式的 consequent。consequent 可以是一个或多个表达式。如果 consequent 包含多个表达式，则按顺序评估这些表达式，并返回最后一个的值。如果表达式没有 consequent，则返回 true-or-false-test 的值。

如果没有一个 true-or-false-test 测试为真，@code{cond} 表达式返回 @code{nil}。

@need 1250
使用 @code{cond} 编写的 @code{triangle} 函数如下：

@smallexample
@group
(defun triangle-using-cond (number)
  (cond ((<= number 0) 0)
        ((= number 1) 1)
        ((> number 1)
         (+ number (triangle-using-cond (1- number))))))
@end group
@end smallexample

@noindent
在这个例子中，如果数字小于等于 0，则 @code{cond} 返回 0；如果数字为 1，则返回 1；如果数字大于 1，则评估 @code{(+
number (triangle-using-cond (1- number)))}。

@node Recursive Patterns
@subsection 递归模式
@cindex 递归模式

以下是三种常见的递归模式，每一种都涉及到列表。递归不一定需要涉及列表，但Lisp是为列表设计的，这展示了其原始功能的一种感觉。

@menu
* Every::
* Accumulate::
* Keep::
@end menu

@node Every
@unnumberedsubsubsec 递归模式：@emph{每个元素}
@cindex 每个元素，递归模式类型
@cindex 递归模式 - 每个元素

在@code{every}递归模式中，对列表的每个元素执行一个操作。

@need 1500
基本模式如下：

@itemize @bullet
@item
如果列表为空，则返回@code{nil}。
@item
否则，对列表的开头（列表的@sc{car}）执行操作
    @itemize @minus
    @item
    通过对列表的其余部分（@sc{cdr}）进行函数的递归调用，
    @item
    并且可以选择地将执行操作的元素与对其余部分进行递归调用的结果使用@code{cons}结合。
    @end itemize
@end itemize

@need 1500
以下是一个例子：

@smallexample
@group
(defun square-each (numbers-list)
  "递归地计算NUMBERS LIST中的每个数字的平方。"
  (if (not numbers-list)                ; do-again-test
      nil
    (cons
     (* (car numbers-list) (car numbers-list))
     (square-each (cdr numbers-list))))) ; next-step-expression
@end group

@group
(square-each '(1 2 3))
    @result{} (1 4 9)
@end group
@end smallexample

@need 1200
@noindent
如果@code{numbers-list}为空，则不执行任何操作。但如果它包含内容，则构造一个列表，其中包含第一个数字的平方与递归调用的结果的结合。

（该示例完全遵循该模式：如果数字列表为空，则返回@code{nil}。在实践中，您会编写条件语句，以便在数字列表不为空时执行操作。）

@code{print-elements-recursively}函数（@pxref{Recursion with list, , Recursion with a List}）是@code{every}模式的另一个示例，不同之处在于，我们不使用@code{cons}将结果组合在一起，而是逐个打印输出的每个元素。

@need 1250
@code{print-elements-recursively}函数如下：

@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))
@end group

@group
(defun print-elements-recursively (list)
  "逐行打印LIST中的每个元素。使用递归。"
  (when list                            ; @r{do-again-test}
        (print (car list))              ; @r{body}
        (print-elements-recursively     ; @r{recursive call}
         (cdr list))))                  ; @r{next-step-expression}

(print-elements-recursively animals)
@end group
@end smallexample

@need 1500
@code{print-elements-recursively}的模式如下：

@itemize @bullet
@item
当列表为空时，不执行任何操作。
@item
但是当列表至少有一个元素时，
    @itemize @minus
    @item
    对列表的开头（列表的@sc{car}）执行操作，
    @item
    并对列表的其余部分（@sc{cdr}）进行递归调用。
    @end itemize
@end itemize

@node Accumulate
@unnumberedsubsubsec 递归模式：@emph{累积}
@cindex 累积，一种递归模式
@cindex 递归模式 - 累积

另一种递归模式称为@code{累积}模式。在@code{累积}递归模式中，对列表的每个元素执行一个操作，并将该操作的结果与对其他元素执行的操作的结果累积在一起。

这与使用@code{cons}的@code{每个}模式非常相似，只是不使用@code{cons}，而是使用其他某个组合器。

@need 1500
该模式如下：

@itemize @bullet
@item
如果列表为空，则返回零或其他常数。
@item
否则，对列表的开头（列表的@sc{car}）进行操作，
    @itemize @minus
    @item
    将该操作的元素与
    @item
    通过对列表的其余部分（@sc{cdr}）进行递归调用的函数进行组合，使用@code{+}或其他组合函数。
    @end itemize
@end itemize

@need 1500
以下是一个示例：

@smallexample
@group
(defun add-elements (numbers-list)
  "将NUMBERS-LIST的元素相加。"
  (if (not numbers-list)
      0
    (+ (car numbers-list) (add-elements (cdr numbers-list)))))
@end group

@group
(add-elements '(1 2 3 4))
    @result{} 10
@end group
@end smallexample

@xref{Files List, , 制作文件列表}，以获取累积模式的示例。

@node Keep
@unnumberedsubsubsec 递归模式：@emph{保留}
@cindex 保留，一种递归模式
@cindex 递归模式 - 保留

第三种递归模式称为@code{保留}模式。
在@code{保留}递归模式中，测试列表的每个元素；
只有在元素满足条件时，对该元素进行操作并仅保留结果。

同样，这与@code{每个}模式非常相似，只是除非元素满足条件，否则将跳过该元素。

@need 1500
该模式有三个部分：

@itemize @bullet
@item
如果列表为空，则返回@code{nil}。
@item
否则，如果列表的开头（列表的@sc{car}）通过
        一个测试
    @itemize @minus
    @item
    对该元素进行操作并使用@code{cons}与
    @item
    通过对列表的其余部分（@sc{cdr}）进行递归调用的函数进行组合。
    @end itemize
@item
否则，如果列表的开头（列表的@sc{car}）未通过
测试
    @itemize @minus
    @item
    跳过该元素，
    @item
    并以对列表的其余部分（@sc{cdr}）进行递归调用的方式进行递归调用。
    @end itemize
@end itemize

@need 1500
以下是一个使用@code{cond}的示例：

@smallexample
@group
(defun keep-three-letter-words (word-list)
  "保留WORD-LIST中的三个字母的单词。"
  (cond
   ;; 第一个再次测试：停止条件
   ((not word-list) nil)

   ;; 第二个再次测试：何时操作
   ((eq 3 (length (symbol-name (car word-list))))
    ;; 将已操作的元素与对较短列表进行递归调用的结果组合
    (cons (car word-list) (keep-three-letter-words (cdr word-list))))

   ;; 第三个再次测试：何时跳过元素；
   ;;   以下一步表达式对较短列表进行递归调用
   (t (keep-three-letter-words (cdr word-list)))))
@end group

@group
(keep-three-letter-words '(one two three four five six))
    @result{} (one two six)
@end group
@end smallexample

毫无疑问，您无需使用@code{nil}作为停止测试的条件；当然，您可以组合这些模式。

@node No Deferment
@subsection 无推迟的递归
@cindex 递归中的推迟
@cindex 无推迟的递归

让我们再次考虑一下@code{triangle-recursively}函数的运行情况。我们会发现中间计算被推迟，直到所有计算都可以完成。

@need 800
以下是函数定义：

@smallexample
@group
(defun triangle-recursively (number)
  "返回从1加到NUMBER（包括）的数字的和。
使用递归。"
  (if (= number 1)                    ; @r{do-again-test}
      1                               ; @r{then-part}
    (+ number                         ; @r{else-part}
       (triangle-recursively          ; @r{recursive call}
        (1- number)))))               ; @r{next-step-expression}
@end group
@end smallexample

当我们使用参数7调用此函数时会发生什么？

第一次调用@code{triangle-recursively}函数会将数字7与第二个
@code{triangle-recursively}实例的返回值相加，该实例已被传递了一个
参数为6。也就是说，第一次计算是：

@smallexample
(+ 7 (triangle-recursively 6))
@end smallexample

@noindent
第一次调用@code{triangle-recursively}---你可以把它想象成一个小机器人---无法完成它的工作。它必须将@code{(triangle-recursively 6)}的计算委托给程序的第二个实例，即第二个机器人。这第二个个体与第一个完全不同；它是，按行话来说，一个“不同的实例”。“换句话说，它是一个不同的机器人。它与第一个相同；它递归地计算三角形数；但它有一个不同的序列号。

那么@code{(triangle-recursively 6)}返回什么呢？它返回数字6加上评估带有参数5的
@code{triangle-recursively}的返回值。使用机器人的隐喻，它要求另一个机器人帮助它。

@need 800
现在总数是：

@smallexample
(+ 7 6 (triangle-recursively 5))
@end smallexample

@need 800
接下来会发生什么？

@smallexample
(+ 7 6 5 (triangle-recursively 4))
@end smallexample

每次调用@code{triangle-recursively}，除了最后一次外，它都会创建程序的另一个实例---另一个机器人---并要求它进行计算。

@need 800
最终，完整的加法被设置并执行：

@smallexample
(+ 7 6 5 4 3 2 1)
@end smallexample

这个函数的设计推迟了第一步的计算，直到第二步可以完成，然后推迟到第三步可以完成，依此类推。每个推迟都意味着计算机必须记住正在等待什么。在这个例子中，当步骤很少时，这不是问题。但当步骤更多时，这可能会成为问题。

@node No deferment solution
@subsection 无推迟解决方案
@cindex 无推迟解决方案
@cindex 无推迟的解决方案

解决推迟操作的问题的方法是以不推迟操作的方式编写代码@footnote{术语@dfn{尾递归}用来描述这种使用常量空间的过程。}。这需要编写一个不同的模式，通常涉及编写两个函数定义，一个初始化函数和一个辅助函数。

初始化函数设置任务；辅助函数执行工作。

@need 1200
以下是两个求和的函数定义。它们非常简单，我发现它们很难理解。

@smallexample
@group
(defun triangle-initialization (number)
  "返回从1加到NUMBER（包括）的数字的和。
这是使用递归的两个函数对的初始化组件。"
  (triangle-recursive-helper 0 0 number))
@end group
@end smallexample

@smallexample
@group
(defun triangle-recursive-helper (sum counter number)
  "使用COUNTER返回SUM，通过NUMBER（包括）。
这是使用递归的两个函数对的辅助组件。"
  (if (> counter number)
      sum
    (triangle-recursive-helper (+ sum counter)  ; @r{sum}
                               (1+ counter)     ; @r{counter}
                               number)))        ; @r{number}
@end group
@end smallexample

@need 1250
通过评估这两个函数定义来安装它们，然后使用2行调用@code{triangle-initialization}：

@smallexample
@group
(triangle-initialization 2)
    @result{} 3
@end group
@end smallexample

初始化函数使用三个参数调用辅助函数的第一个实例：零，零，以及三角形中的行数。

传递给辅助函数的前两个参数是初始化值。这些值在@code{triangle-recursive-helper}调用新实例时会更改。@footnote{术语有点混乱：@code{triangle-recursive-helper}在递归的过程中使用迭代的方式，因为计算机只需记录三个值@code{sum}、@code{counter}和@code{number}；而该过程在递归的过程中使用递归的方式，因为函数调用了自身。另一方面，@code{triangle-recursively}使用的过程和过程都被称为递归。在这两种情况下，“递归”这个词在两个上下文中有不同的含义。}

让我们看看当我们有一个只有一行的三角形时会发生什么。（这个三角形将有一个小石子！）

@need 1200
@code{triangle-initialization}将使用参数@w{@code{0 0 1}}调用它的辅助函数。该函数将运行条件测试，即@code{(> counter number)}：

@smallexample
(> 0 1)
@end smallexample

@need 1200
@noindent
并发现结果为假，因此它将调用@code{if}子句的else部分：

@smallexample
@group
    (triangle-recursive-helper
     (+ sum counter)  ; @r{sum加counter} @result{} @r{sum}
     (1+ counter)     ; @r{增加counter} @result{} @r{counter}
     number)          ; @r{number保持不变}
@end group
@end smallexample

@need 800
@noindent
这将首先计算：

@smallexample
@group
(triangle-recursive-helper (+ 0 0)  ; @r{sum}
                           (1+ 0)   ; @r{counter}
                           1)       ; @r{number}
@exdent 即：

(triangle-recursive-helper 0 1 1)
@end group
@end smallexample

再次，@code{(> counter number)}将为假，因此Lisp解释器将评估@code{triangle-recursive-helper}，创建一个新实例并传递新参数。

@need 800
这个新实例将是：

@smallexample
@group
    (triangle-recursive-helper
     (+ sum counter)  ; @r{sum加counter} @result{} @r{sum}
     (1+ counter)     ; @r{增加counter} @result{} @r{counter}
     number)          ; @r{number保持不变}

@exdent 即：

(triangle-recursive-helper 1 2 1)
@end group
@end smallexample

在这种情况下，@code{(> counter number)}测试将为真！因此，该实例将返回@code{sum}的值，该值将是1，符合预期。

现在，让我们将@code{triangle-initialization}的参数设置为2，以查看具有两行的三角形中有多少个小石子。

该函数调用@code{(triangle-recursive-helper 0 0 2)}。

@need 800
分阶段，被调用的实例将是：

@smallexample
@group
                          @r{sum counter number}
(triangle-recursive-helper 0    1       2)

(triangle-recursive-helper 1    2       2)

(triangle-recursive-helper 3    3       2)
@end group
@end smallexample

当调用最后一个实例时，@code{(> counter number)}测试将为真，因此该实例将返回@code{sum}的值，该值将是3。

这种模式在编写可能使用计算机中的许多资源的函数时很有帮助。

@need 1500
@node Looping exercise
@section 循环练习

@itemize @bullet
@item
编写一个类似于 @code{triangle} 的函数，其中每一行的值是该行号的平方。使用 @code{while} 循环。

@item
编写一个类似于 @code{triangle} 的函数，但是它将值相乘而不是相加。

@item
递归地重写这两个函数。使用 @code{cond} 重写这些函数。

@c 在标题中的逗号会导致 Info 交叉引用问题
@item
为 Texinfo 模式编写一个函数，在段落开头为每个段落中的 @samp{@@dfn} 创建一个索引条目。
（在 Texinfo 文件中，@samp{@@dfn} 标记一个定义。本书是用 Texinfo 编写的。）

你将需要用到前两章中的许多函数，@ref{Cutting & Storing Text, , 剪切与存储文本} 和 @ref{Yanking, , Yanking Text Back} 中有它们的描述。如果使用 @code{forward-paragraph} 将索引条目放在段落开头，您将需要使用 @w{@kbd{C-h f}}（@code{describe-function}）查找如何使命令向后执行。

更多信息，请参见
@ifinfo
@ref{Indicating, , Indicating Definitions, texinfo}。
@end ifinfo
@ifhtml
@ref{Indicating, , Indicating, texinfo, Texinfo Manual}，其中会跳转到当前目录中的 Texinfo 手册。或者，如果您在互联网上，参见
@uref{https://www.gnu.org/software/texinfo/manual/texinfo/}
@end ifhtml
@iftex
``Indicating Definitions, Commands, etc.''@: in @cite{Texinfo, The GNU
Documentation Format}。
@end iftex
@end itemize

@node Regexp Search
@chapter 正则表达式搜索
@cindex 搜索，演示
@cindex 正则表达式搜索
@cindex 模式，搜索
@cindex 通过句子和段落进行移动
@cindex 通过句子进行移动
@cindex 通过段落进行移动

正则表达式搜索在GNU Emacs中被广泛使用。两个函数，@code{forward-sentence}和@code{forward-paragraph}，很好地说明了这些搜索的用法。它们使用正则表达式来确定点应该移动到哪里。短语“正则表达式”通常写作“regexp”。

正则表达式搜索在@ref{Regexp Search, , Regular Expression Search, emacs, The GNU Emacs Manual}中有详细描述，以及在@ref{Regular Expressions, , , elisp, The GNU Emacs Lisp Reference Manual}中也有描述。在撰写本章时，我假定您至少对它们有一些了解。需要记住的主要观点是正则表达式允许您搜索模式以及字符字面上的字符串。例如，@code{forward-sentence}函数中的代码搜索可能标记句子结束的字符模式，并将点移动到该位置。

在查看@code{forward-sentence}函数的代码之前，值得考虑一下标记句子结束的模式是什么。该模式将在下一节中讨论；随后是正则表达式搜索函数@code{re-search-forward}的描述。@code{forward-sentence}函数在其后的部分中描述。最后，本章的最后一节描述了@code{forward-paragraph}函数。@code{forward-paragraph}是一个复杂的函数，引入了一些新功能。

@menu
* sentence-end::                @code{sentence-end}的正则表达式。
* re-search-forward::           与@code{search-forward}非常相似。
* forward-sentence::            正则表达式搜索的简单示例。
* forward-paragraph::           一个相对复杂的示例。
* Regexp Review::
* re-search Exercises::
@end menu

@node sentence-end
@section 关于 @code{sentence-end} 的正则表达式
@findex sentence-end

符号 @code{sentence-end} 被绑定到标记句子结束的模式。这个正则表达式应该是什么呢？

显然，句子可以以句点、问号或感叹号结束。实际上，在英语中，只有以这三个字符之一结尾的从句才应被视为句子的结束。这意味着模式应包括字符集：

@smallexample
[.?!]
@end smallexample

然而，我们不希望 @code{forward-sentence} 只是简单地跳到句点、问号或感叹号，因为这样的字符可能在句子中间使用。例如，句点在缩写后使用。因此，需要其他信息。

按照约定，你在每个句子后面键入两个空格，但在句子中间的句点、问号或感叹号后只键入一个空格。因此，句点、问号或感叹号后跟两个空格是句子结束的良好指示器。然而，在文件中，这两个空格可能被制表符或行尾替代。这意味着正则表达式应包括这三个项作为备选项。

@need 800
这组备选项将如下所示：

@smallexample
@group
\\($\\| \\|  \\)
       ^   ^^
      TAB  SPC
@end group
@end smallexample

@noindent
这里，@samp{$} 表示行尾，我标出了制表符和两个空格在表达式中的位置。两者都是通过将实际字符放入表达式中插入的。

在括号和竖线前需要两个反斜杠，@samp{\\}：第一个反斜杠引用 Emacs 中的后续反斜杠；第二个指示后面的字符（括号或竖线）是特殊的。

@need 1000
另外，句子后面可能跟着一个或多个回车，就像这样：

@smallexample
@group
[
]*
@end group
@end smallexample

@noindent
与制表符和空格一样，通过将其直接插入正则表达式，回车就会插入其中。星号表示 @key{RET} 重复零次或多次。

但句子结尾不仅仅包括句点、问号或感叹号后跟适当的空格：可能有一个闭合引号或某种括号在空格之前。事实上，可能有一个以上这样的引号或括号在空格之前。这需要一个如下所示的表达式：

@smallexample
[]\"')@}]*
@end smallexample

在这个表达式中，第一个 @samp{]} 是表达式中的第一个字符；第二个字符是 @samp{"}，它前面有一个 @samp{\}，告诉 Emacs @samp{"} 不是特殊字符。最后三个字符是 @samp{'}, @samp{)} 和 @samp{@}}。

所有这些都暗示了匹配句子结尾的正则表达式模式，确实，如果我们评估 @code{sentence-end}，我们会发现它返回以下值：

@smallexample
@group
sentence-end
     @result{} "[.?!][]\"')@}]*\\($\\|     \\|  \\)[
]*"
@end group
@end smallexample

@noindent
（好吧，在 GNU Emacs 22 中不是这样；这是因为为了使过程更简单并处理更多的字形和语言而做的努力。当 @code{sentence-end} 的值为 @code{nil} 时，使用函数 @code{sentence-end} 定义的值。 （这是 Emacs Lisp 中值和函数之间差异的使用示例。）该函数返回由变量 @code{sentence-end-base}、@code{sentence-end-double-space}、@code{sentence-end-without-period} 和 @code{sentence-end-without-space} 构造的值。关键变量是 @code{sentence-end-base}；它的全局值类似于上述描述的值，但还包含两个额外的引号。这些引号的弯曲程度不同。当 @code{sentence-end-without-period} 变量为真时，告诉 Emacs 句子可以在没有句点的情况下结束，例如泰语文本。）

@ignore
@noindent
（注意，在这里 @key{TAB}、两个空格和 @key{RET} 在模式中都是以字面形式显示的。）

这个正则表达式可以这样解读：

@table @code
@item [.?!]
模式的第一部分是三个字符，一个句点、一个问号和一个感叹号，都在方括号内。模式必须以这些字符中的一个开始。

@item []\"')@}]*
模式的第二部分是闭合括号和引号组成的组，可以出现零次或多次。这些可以跟在句点、问号或感叹号后。在正则表达式中，反斜杠 @samp{\} 后面跟着双引号 @samp{"} 表示字符串引号字符类。通常，双引号是该类中唯一的字符。星号 @samp{*} 表示前面组（由方括号 @samp{[]} 包围的组）中的项可以重复零次或多次。

@item \\($\\|   \\|  \\)
模式的第三部分是下列情况之一：行尾、两个空格或一个制表符。双反斜杠用于防止 Emacs 将括号和竖线读取为搜索模式的一部分；括号用于标记组，竖线用于表示它们两侧的模式是备选项。美元符号用于表示行尾，两个空格和制表符分别插入以指示它们的存在。

@item [@key{RET}]*
最后，模式的最后部分表示行尾或句点、问号或感叹号后的空格后可能跟随零个或多个回车，但不一定。在模式中，回车作为实际回车插入，但这里显示为 @key{RET}。
@end table
@end ignore

@node re-search-forward
@section @code{re-search-forward} 函数
@findex re-search-forward

@code{re-search-forward} 函数与 @code{search-forward} 函数非常相似。(@xref{search-forward, , @code{search-forward} 函数}.)

@code{re-search-forward} 用于搜索正则表达式。如果搜索成功，它将把光标立即放在目标的最后一个字符之后。如果是反向搜索，它将把光标放在目标的第一个字符之前。您可以告诉 @code{re-search-forward} 在搜索成功时返回 @code{t}。 (移动光标因此是一个副作用。)

与 @code{search-forward} 一样，@code{re-search-forward} 函数接受四个参数：

@enumerate
@item
第一个参数是要搜索的正则表达式。正则表达式将是双引号之间的字符串。

@item
可选的第二个参数限制函数搜索的范围；它是一个界限，指定为缓冲区中的位置。

@item
可选的第三个参数指定函数对失败的响应方式：当搜索失败时，第三个参数为 @code{nil} 会导致函数发出错误信号（并打印一条消息）；任何其他值会导致在搜索失败时返回 @code{nil}，在搜索成功时返回 @code{t}。

@item
可选的第四个参数是重复计数。负重复计数会导致 @code{re-search-forward} 进行向后搜索。
@end enumerate

@need 800
@code{re-search-forward} 的模板如下：

@smallexample
@group
(re-search-forward "@var{正则表达式}"
                @var{搜索限制}
                @var{失败时的操作}
                @var{重复计数})
@end group
@end smallexample

第二、第三和第四个参数是可选的。但是，如果您想向最后两个参数之一或两者都传递一个值，您还必须向所有前面的参数传递一个值。否则，Lisp 解释器将混淆您正在传递值的参数。

@need 1200
在 @code{forward-sentence} 函数中，正则表达式将是变量 @code{sentence-end} 的值。简单形式如下：

@smallexample
@group
"[.?!][]\"')@}]*\\($\\|  \\|  \\)[
]*"
@end group
@end smallexample

@noindent
搜索的限制将是段落的末尾（因为句子不能超过段落）。如果搜索失败，函数将返回 @code{nil}；而重复计数将由 @code{forward-sentence} 函数的参数提供。

@node forward-sentence
@section @code{forward-sentence}
@findex forward-sentence

将光标向前移动到下一个句子末尾的命令是如何在Emacs Lisp中使用正则表达式搜索的一个直观例子。实际上，该函数看起来比实际复杂得多；这是因为该函数旨在向前和向后移动；而且，可选地，可以跨越多个句子。该函数通常绑定到键命令@kbd{M-e}。

@menu
* Complete forward-sentence::
* fwd-sentence while loops::    两个 @code{while} 循环。
* fwd-sentence re-search::      正则表达式搜索。
@end menu

@ifnottex
@node Complete forward-sentence
@unnumberedsubsec 完整的 @code{forward-sentence} 函数定义
@end ifnottex

@need 1250
以下是@code{forward-sentence}的代码：

@c 在 GNU Emacs 22 中
@smallexample
@group
(defun forward-sentence (&optional arg)
  "向前移动到下一个句子末尾。带有参数时重复。带有负数参数时，反复向后移动到句子开头。

变量 `sentence-end' 是一个正则表达式，用于匹配句子的末尾。此外，每个段落边界也会终止句子。"
@end group
@group
  (interactive "p")
  (or arg (setq arg 1))
  (let ((opoint (point))
        (sentence-end (sentence-end)))
    (while (< arg 0)
      (let ((pos (point))
            (par-beg (save-excursion (start-of-paragraph-text) (point))))
       (if (and (re-search-backward sentence-end par-beg t)
                (or (< (match-end 0) pos)
                    (re-search-backward sentence-end par-beg t)))
           (goto-char (match-end 0))
         (goto-char par-beg)))
      (setq arg (1+ arg)))
@end group
@group
    (while (> arg 0)
      (let ((par-end (save-excursion (end-of-paragraph-text) (point))))
       (if (re-search-forward sentence-end par-end t)
           (skip-chars-backward " \t\n")
         (goto-char par-end)))
      (setq arg (1- arg)))
    (constrain-to-field nil opoint t)))
@end group
@end smallexample

@ignore
GNU Emacs 21
@smallexample
@group
(defun forward-sentence (&optional arg)
  "向前移动到下一个句子末尾。带有参数时重复。带有负数参数时，反复向后移动到句子开头。句子的末尾由 `sentence-end' 的值标识，被视为正则表达式。此外，每个段落边界也会终止句子。"
@end group
@group
  (interactive "p")
  (or arg (setq arg 1))
  (while (< arg 0)
    (let ((par-beg
           (save-excursion (start-of-paragraph-text) (point))))
      (if (re-search-backward
           (concat sentence-end "[^ \t\n]") par-beg t)
          (goto-char (1- (match-end 0)))
        (goto-char par-beg)))
    (setq arg (1+ arg)))
  (while (> arg 0)
    (let ((par-end
           (save-excursion (end-of-paragraph-text) (point))))
      (if (re-search-forward sentence-end par-end t)
          (skip-chars-backward " \t\n")
        (goto-char par-end)))
    (setq arg (1- arg))))
@end group
@end smallexample
@end ignore

这个函数乍一看似乎很长，最好先看它的骨架，然后再看它的实现。看骨架的方法是查看从最左列开始的表达式：

@smallexample
@group
(defun forward-sentence (&optional arg)
  "@var{documentation}@dots{}"
  (interactive "p")
  (or arg (setq arg 1))
  (let ((opoint (point)) (sentence-end (sentence-end)))
    (while (< arg 0)
      (let ((pos (point))
            (par-beg (save-excursion (start-of-paragraph-text) (point))))
       @var{向后移动时 while 循环的其余部分的主体}
    (while (> arg 0)
      (let ((par-end (save-excursion (end-of-paragraph-text) (point))))
       @var{向前移动时 while 循环的其余部分的主体}
    @var{处理表单和等价物的表达式}
@end group
@end smallexample

这看起来简单得多！函数定义由文档、一个@code{interactive}表达式、一个@code{or}表达式、一个@code{let}表达式和@code{while}循环组成。

让我们逐个查看这些部分。

我们注意到文档写得很详细且易懂。

函数有一个@code{interactive "p"}声明。这意味着处理过的前缀参数（如果有）将作为函数的参数传递。 （这将是一个数字。）如果函数未以参数形式调用（它是可选的），则参数@code{arg}将绑定为1。

当以非交互方式调用@code{forward-sentence}且没有参数时，@code{arg}绑定为@code{nil}。@code{or}表达式处理这一点。它的作用是仅在@code{arg}绑定到一个值时保持@code{arg}的值不变；或者在@code{arg}绑定到@code{nil}时将@code{arg}的值设置为1。

接下来是一个@code{let}。它指定了两个局部变量@code{opoint}和@code{sentence-end}的值。从搜索之前的点的局部值用于@code{constrain-to-field}函数，该函数处理表单和等价物。@code{sentence-end}变量由@code{sentence-end}函数设置。

@node fwd-sentence while loops
@unnumberedsubsec The @code{while} loops

接下来是两个@code{while}循环。第一个@code{while}具有一个真假测试，如果@code{forward-sentence}的前缀参数是负数，则测试为真。这是用于向后移动的情况。该循环的主体类似于第二个@code{while}子句的主体，但不完全相同。我们将跳过这个@code{while}循环，专注于第二个@code{while}循环。

@need 1500
第二个@code{while}循环是用于向前移动点的。它的框架如下：

@smallexample
@group
(while (> arg 0)            ; @r{真假测试}
  (let @var{varlist}
    (if (@var{真假测试})
        @var{then-part}
      @var{else-part}
  (setq arg (1- arg))))     ; @code{while} @r{循环递减器}
@end group
@end smallexample

该@code{while}循环是递减型的。(@xref{Decrementing Loop, , A Loop with a Decrementing Counter}.) 它有一个真假测试，只要计数器（在这种情况下是变量@code{arg}）大于零，测试就为真；并且有一个递减器，每次循环重复时从计数器的值中减去1。

如果没有给@code{forward-sentence}提供前缀参数，这是该命令最常用的方式，那么这个@code{while}循环将运行一次，因为@code{arg}的值将为1。

@code{while}循环的主体包含一个@code{let}表达式，该表达式创建和绑定一个局部变量，并且其主体是一个@code{if}表达式。

@need 1250
@code{while}循环的主体如下：

@smallexample
@group
(let ((par-end
       (save-excursion (end-of-paragraph-text) (point))))
  (if (re-search-forward sentence-end par-end t)
      (skip-chars-backward " \t\n")
    (goto-char par-end)))
@end group
@end smallexample

@code{let}表达式创建并绑定局部变量@code{par-end}。正如我们将看到的，此局部变量旨在为正则表达式搜索提供一个边界或限制。如果搜索未能在段落中找到适当的句子结束，它将在达到段落末尾时停止。

但首先，让我们查看@code{par-end}如何绑定到段落末尾的值。发生的是@code{let}将@code{par-end}的值设置为Lisp解释器评估表达式时返回的值

@smallexample
@group
(save-excursion (end-of-paragraph-text) (point))
@end group
@end smallexample

@noindent
在此表达式中，@code{(end-of-paragraph-text)}将point移动到段落末尾，@code{(point)}返回point的值，然后@code{save-excursion}将point恢复到其原始位置。因此，@code{let}将@code{par-end}绑定到由@code{save-excursion}表达式返回的值，即段落末尾的位置。 (@code{end-of-paragraph-text}函数使用@code{forward-paragraph}，我们将很快讨论。)

@need 1200
接下来，Emacs评估@code{let}的主体，这是一个@code{if}表达式，如下所示：

@smallexample
@group
(if (re-search-forward sentence-end par-end t) ; @r{if部分}
    (skip-chars-backward " \t\n")              ; @r{then部分}
  (goto-char par-end)))                        ; @r{else部分}
@end group
@end smallexample

@code{if}测试其第一个参数是否为真，如果是，则评估其then部分；否则，Emacs Lisp解释器将评估else部分。@code{if}表达式的真假测试是正则表达式搜索。

可能看起来奇怪的是，在这里埋藏看起来像是@code{forward-sentence}函数的实际工作，但这是Lisp中执行此类操作的常见方式。

@node fwd-sentence re-search
@unnumberedsubsec 正则表达式搜索

函数 @code{re-search-forward} 用于搜索句子的结尾，即由 @code{sentence-end} 正则表达式定义的模式。如果找到模式——也就是找到了句子的结尾——那么 @code{re-search-forward} 函数会执行两个操作：

@enumerate
@item
@code{re-search-forward} 函数执行一个副作用，即将点移动到找到的出现的结尾。

@item
@code{re-search-forward} 函数返回 true 的值。这是由 @code{if} 接收的值，并表示搜索成功。
@end enumerate

@noindent
副作用，即点的移动，在 @code{if} 函数接收到搜索成功的返回值之前完成。

当 @code{if} 函数从成功调用 @code{re-search-forward} 接收到 true 的值时，@code{if} 会评估 then 部分，即表达式 @code{(skip-chars-backward " \t\n")}。这个表达式向后移动任何空格、制表符或回车，直到找到一个打印字符，然后将点留在字符之后。由于点已经被移动到标记句子结尾的模式的末尾，这个操作将点留在句子的结束字符后，通常是一个句点。

另一方面，如果 @code{re-search-forward} 函数未能找到标记句子结束的模式，则该函数返回 false。然后 false 导致 @code{if} 评估其第三个参数，即 @code{(goto-char par-end)}：将点移动到段落的末尾。

（如果文本处于表单或等效状态，且点可能无法完全移动，则会调用 @code{constrain-to-field} 函数。）

正则表达式搜索非常有用，而由 @code{re-search-forward} 展示的模式，其中搜索是 @code{if} 表达式的测试，非常方便。你会经常看到或编写包含这个模式的代码。

@node forward-paragraph
@section @code{forward-paragraph}：一个丰富的功能集合
@findex forward-paragraph

@ignore
@c 在 GNU Emacs 22 中
(defun forward-paragraph (&optional arg)
  "向前移动至段落末尾。
带有参数 ARG 时，执行 ARG 次；
负参数 ARG = -N 表示向后移动 N 段落。

`paragraph-start' 匹配的行要么分隔段落
（如果 `paragraph-separate' 也匹配它），要么是段落的第一行。
段落末尾是前一行的结束不属于同一段落的行，或缓冲区的结束。
返回剩余要移动的段落数量。"
  (interactive "p")
  (or arg (setq arg 1))
  (let* ((opoint (point))
         (fill-prefix-regexp
          (and fill-prefix (not (equal fill-prefix ""))
               (not paragraph-ignore-fill-prefix)
               (regexp-quote fill-prefix)))
         ;; 如果在 paragraph-start 和 paragraph-sep 的开头有 ^，则移除它们。
         ;; 这些正则表达式不应该是锚定的，因为我们从左边距开始查找它们。
         ;; 这允许段落命令在缩进的文本中正常工作。
         ;; 此 hack 将无法找到问题案例，例如 "whatever\\|^something"。
         (parstart (if (and (not (equal "" paragraph-start))
                            (equal ?^ (aref paragraph-start 0)))
                       (substring paragraph-start 1)
                     paragraph-start))
         (parsep (if (and (not (equal "" paragraph-separate))
                          (equal ?^ (aref paragraph-separate 0)))
                     (substring paragraph-separate 1)
                   paragraph-separate))
         (parsep
          (if fill-prefix-regexp
              (concat parsep "\\|"
                      fill-prefix-regexp "[ \t]*$")
            parsep))
         ;; 用于搜索的变量。
         (sp-parstart (concat "^[ \t]*\\(?:" parstart "\\|" parsep "\\)"))
         start found-start)
    (while (and (< arg 0) (not (bobp)))
      (if (and (not (looking-at parsep))
               (re-search-backward "^\n" (max (1- (point)) (point-min)) t)
               (looking-at parsep))
          (setq arg (1+ arg))
        (setq start (point))
        ;; 向后移动超过分隔段落的行。
        (forward-char -1) (beginning-of-line)
        (while (and (not (bobp))
                    (progn (move-to-left-margin)
                           (looking-at parsep)))
          (forward-line -1))
        (if (bobp)
            nil
          (setq arg (1+ arg))
          ;; 移动至前一行的结束（非分隔）。
          (end-of-line)
          ;; 向后搜索以找到开始或分隔段落的行。
          (if (if fill-prefix-regexp
                  ;; 存在填充前缀；它覆盖了 parstart。
                  (let (multiple-lines)
                    (while (and (progn (beginning-of-line) (not (bobp)))
                                (progn (move-to-left-margin)
                                       (not (looking-at parsep)))
                                (looking-at fill-prefix-regexp))
                      (unless (= (point) start)
                        (setq multiple-lines t))
                      (forward-line -1))
                    (move-to-left-margin)
                    ;; 这段已删除的代码导致长悬挂缩进行无法与后续行一起填充。
                    ;; ;; 不要向后移动一个段落之前的行，除非它不以 fill-prefix 开头，
                    ;; ;; 并且那是我们移动的唯一行。
                    ;; (and (not (looking-at fill-prefix-regexp))
                    ;;      multiple-lines
                    ;;      (forward-line 1))
                    (not (bobp)))
                (while (and (re-search-backward sp-parstart nil 1)
                            (setq found-start t)
                            ;; 找到一个候选项，但需要检查它是否是真正的 parstart。
                            (progn (setq start (point))
                                   (move-to-left-margin)
                                   (not (looking-at parsep)))
                            (not (and (looking-at parstart)
                                      (or (not use-hard-newlines)
                                          (bobp)
                                          (get-text-property
                                           (1- start) 'hard)))))
                  (setq found-start nil)
                  (goto-char start))
                found-start)
              ;; 找到一个。
              (progn
                ;; 向前移动超过分隔符。
                ;; 我们知道这不可能达到我们开始的地方，
                ;; 因为我们知道我们向后移动超过了非分隔符。
                (while (and (not (eobp))
                            (progn (move-to-left-margin)
                                   (looking-at parsep)))
                  (forward-line 1))
                ;; 如果段落前一行只是边距，后退到那里。
                (end-of-line 0)
                (if (> (current-column) (current-left-margin))
                    (forward-char 1)
                  (skip-chars-backward " \t")
                  (if (not (bolp))
                      (forward-line 1))))
            ;; 没有启动器或分隔符行 => 使用缓冲区开头。
            (goto-char (point-min))))))

    (while (and (> arg 0) (not (eobp)))
      ;; 向前移动超过分隔符行...
      (while (and (not (eobp))
                  (progn (move-to-left-margin) (not (eobp)))
                  (looking-at parsep))
        (forward-line 1))
      (unless (eobp) (setq arg (1- arg)))
      ;; ... 还有一行。
      (forward-line 1)
      (if fill-prefix-regexp
          ;; 存在填充前缀；它覆盖了 parstart。
          (while (and (not (eobp))
                      (progn (move-to-left-margin) (not (eobp)))
                      (not (looking-at parsep))
                      (looking-at fill-prefix-regexp))
            (forward-line 1))
        (while (and (re-search-forward sp-parstart nil 1)
                    (progn (setq start (match-beginning 0))
                           (goto-char start)
                           (not (eobp)))
                    (progn (move-to-left-margin)
                           (not (looking-at parsep)))
                    (or (not (looking-at parstart))
                        (and use-hard-newlines
                             (not (get-text-property (1- start) 'hard)))))
          (forward-char 1))
        (if (< (point) (point-max))
            (goto-char start))))
    (constrain-to-field nil opoint t)
    ;; 返回无法完成的步骤数。
    arg))
@end ignore

@code{forward-paragraph} 函数将点（point）向前移动到段落末尾。通常绑定到 @kbd{M-@}}，并且使用一些重要的函数，包括@code{let*}、@code{match-beginning} 和 @code{looking-at}。

@code{forward-paragraph} 的函数定义比 @code{forward-sentence} 的函数定义长得多，因为它处理一个段落，其中每一行可能以填充前缀开始。

填充前缀由一串在每一行开头重复的字符组成。例如，在 Lisp 代码中，通常使用 @samp{;;; } 开始段落长注释的每一行。在文本模式中，四个空格组成了另一种常见的填充前缀，创建一个缩进的段落。（有关填充前缀的更多信息，请参阅 @xref{Fill Prefix, , ,emacs, The GNU Emacs Manual}。）

存在填充前缀意味着除了能够找到以最左列开始的段落的末尾之外，@code{forward-paragraph} 函数还必须能够找到在缓冲区中所有或许多行都以填充前缀开头的段落的末尾。

此外，有时忽略存在的填充前缀是切实可行的，特别是在空白行分隔段落时。这是一个额外的复杂性。

@menu
* forward-paragraph in brief::  函数定义的关键部分。
* fwd-para let::                @code{let*} 表达式。
* fwd-para while::              前进运动的 @code{while} 循环。
@end menu

@ifnottex
@node forward-paragraph in brief
@unnumberedsubsec Shortened @code{forward-paragraph} function definition
@end ifnottex

与其打印整个 @code{forward-paragraph} 函数，我们只打印其中的部分。如果毫无准备地阅读，这个函数可能令人生畏！

@need 800
简而言之，该函数的轮廓如下：

@smallexample
@group
(defun forward-paragraph (&optional arg)
  "@var{文档}@dots{}"
  (interactive "p")
  (or arg (setq arg 1))
  (let*
      @var{变量列表}
    (while (and (< arg 0) (not (bobp)))     ; @r{向后移动的代码}
      @dots{}
    (while (and (> arg 0) (not (eobp)))     ; @r{向前移动的代码}
      @dots{}
@end group
@end smallexample

函数的前部分很常规：函数的参数列表包含一个可选参数。文档随后。

在 @code{interactive} 声明中的小写 @samp{p} 表示处理后的前缀参数（如果有）将传递给函数。这将是一个数字，是光标将移动的段落数的重复计数。下一行的 @code{or} 表达式处理了未向函数传递参数的常见情况，即如果函数是从其他代码中调用而不是交互式调用时发生的情况。此情况在之前已经描述过。(@xref{forward-sentence, The @code{forward-sentence} function}.) 现在我们到达了这个函数的熟悉部分的末尾。

@node fwd-para let
@unnumberedsubsec The @code{let*} expression

@findex let*
@code{forward-paragraph} 函数的下一行开始了一个 @code{let*} 表达式 (@pxref{let* introduced,,@code{let*} introduced})，在其中 Emacs 绑定了七个变量：@code{opoint}、@code{fill-prefix-regexp}、@code{parstart}、@code{parsep}、@code{sp-parstart}、@code{start} 和 @code{found-start}。

变量 @code{parsep} 出现两次，首先是为了去除 @samp{^} 的实例，其次是为了处理填充前缀。

变量 @code{opoint} 只是 @code{point} 的值。正如你可以猜到的，它在一个 @code{constrain-to-field} 表达式中使用，就像在 @code{forward-sentence} 中一样。

变量 @code{fill-prefix-regexp} 被设置为通过评估以下列表返回的值：

@smallexample
@group
(and fill-prefix
     (not (equal fill-prefix ""))
     (not paragraph-ignore-fill-prefix)
     (regexp-quote fill-prefix))
@end group
@end smallexample

@noindent
这是一个表达式，其第一个元素是 @code{and} 特殊形式。

正如我们之前学到的(@pxref{kill-new function, , @code{kill-new} 函数})，@code{and} 特殊形式评估其每个参数，直到其中一个参数返回 @code{nil} 的值，此时 @code{and} 表达式返回 @code{nil}；然而，如果没有任何参数返回 @code{nil} 的值，则评估最后一个参数产生的值将被返回。 (由于这样的值不是 @code{nil}，在 Lisp 中被视为真值。) 换句话说，只有当 @code{and} 表达式的所有参数都为真时，它才返回真值。

在这种情况下，只有当以下四个表达式在评估时产生真值（即非 @code{nil} 值）时，变量 @code{fill-prefix-regexp} 才绑定到非 @code{nil} 值；否则，@code{fill-prefix-regexp} 被绑定到 @code{nil}。

@table @code
@item fill-prefix
评估此变量时，返回填充前缀的值（如果有的话）。如果没有填充前缀，则此变量返回 @code{nil}。

@item (not (equal fill-prefix ""))
此表达式检查现有填充前缀是否为空字符串，即不包含任何字符的字符串。空字符串不是有用的填充前缀。

@item (not paragraph-ignore-fill-prefix)
如果变量 @code{paragraph-ignore-fill-prefix} 被设置为真值，如 @code{t}，则此表达式返回 @code{nil}。

@item (regexp-quote fill-prefix)
这是 @code{and} 特殊形式的最后一个参数。如果 @code{and} 的所有参数都为真，则通过评估此表达式产生的值将被 @code{and} 表达式返回，并绑定到变量 @code{fill-prefix-regexp}，
@end table

@findex regexp-quote
@noindent
成功评估此 @code{and} 表达式的结果是，@code{fill-prefix-regexp} 将绑定到由 @code{regexp-quote} 函数修改的 @code{fill-prefix} 的值。 @code{regexp-quote} 做的是读取一个字符串并返回一个正则表达式，该正则表达式将精确匹配该字符串且不匹配其他任何内容。这意味着如果存在填充前缀，@code{fill-prefix-regexp} 将被设置为一个精确匹配填充前缀的值。否则，该变量将被设置为 @code{nil}。

@code{let*} 表达式中的下两个局部变量旨在从 @code{parstart} 和 @code{parsep} 中删除 @samp{^} 的实例。接下来的表达式再次设置 @code{parsep}。这是为了处理填充前缀。

这是定义调用 @code{let*} 而不是 @code{let} 的设置。 @code{if} 表达式的真假测试取决于变量 @code{fill-prefix-regexp} 是否评估为 @code{nil} 或其他值。

如果 @code{fill-prefix-regexp} 没有值，Emacs 评估 @code{if} 表达式的 else-部分，并将 @code{parsep} 绑定到其局部值。 (@code{parsep} 是一个匹配段落之间分隔符的正则表达式。)

但是，如果 @code{fill-prefix-regexp} 有值，Emacs 将评估 @code{if} 表达式的 then-部分，并将 @code{parsep} 绑定到一个正则表达式，该正则表达式包含 @code{fill-prefix-regexp} 作为模式的一部分。

具体而言，@code{parsep} 被设置为段落分隔正则表达式的原始值，后面跟着一个可选的空白到行尾的替代表达式，由 @w{@code{"[ \t]*$"}} 定义。) @samp{\\|} 定义了正则表达式的这一部分作为 @code{parsep} 的替代项。

根据代码中的注释，接下来的局部变量，@code{sp-parstart}，用于搜索，然后最后两个，@code{start} 和 @code{found-start}，被设置为 @code{nil}。

现在我们进入了 @code{let*} 的主体。 @code{let*} 的主体的第一部分处理函数被给予负参数且因此向后移动的情况。我们将跳过这一部分。

@node fwd-para while
@unnumberedsubsec 前进动作 @code{while} 循环

@code{let*} 的第二部分处理前进动作。它是一个 @code{while} 循环，只要 @code{arg} 的值大于零就重复执行。在函数的最常见用法中，参数的值为 1，因此 @code{while} 循环的主体只被评估一次，光标向前移动一个段落。

@ignore
(while (and (> arg 0) (not (eobp)))

  ;; 向前移动过分隔行…
  (while (and (not (eobp))
              (progn (move-to-left-margin) (not (eobp)))
              (looking-at parsep))
    (forward-line 1))
  (unless (eobp) (setq arg (1- arg)))
  ;; …再多移动一行。
  (forward-line 1)

  (if fill-prefix-regexp
      ;; 存在填充前缀；它覆盖了 parstart；
      (while (and (not (eobp))
                  (progn (move-to-left-margin) (not (eobp)))
                  (not (looking-at parsep))
                  (looking-at fill-prefix-regexp))
        (forward-line 1))

    (while (and (re-search-forward sp-parstart nil 1)
                (progn (setq start (match-beginning 0))
                       (goto-char start)
                       (not (eobp)))
                (progn (move-to-left-margin)
                       (not (looking-at parsep)))
                (or (not (looking-at parstart))
                    (and use-hard-newlines
                         (not (get-text-property (1- start) 'hard)))))
      (forward-char 1))

    (if (< (point) (point-max))
        (goto-char start))))
@end ignore

这部分处理三种情况：当光标在段落之间时，当存在填充前缀时，当不存在填充前缀时。

@need 800
@code{while} 循环如下：

@smallexample
@group
;; @r{向前移动且不在缓冲区末尾}
(while (and (> arg 0) (not (eobp)))

  ;; @r{在段落之间}
  ;; 向前移动过分隔行…
  (while (and (not (eobp))
              (progn (move-to-left-margin) (not (eobp)))
              (looking-at parsep))
    (forward-line 1))
  ;;  @r{这减少了循环计数}
  (unless (eobp) (setq arg (1- arg)))
  ;; …再多移动一行。
  (forward-line 1)
@end group

@group
  (if fill-prefix-regexp
      ;; 存在填充前缀；它覆盖了 parstart；
      ;; 我们逐行向前移动
      (while (and (not (eobp))
                  (progn (move-to-left-margin) (not (eobp)))
                  (not (looking-at parsep))
                  (looking-at fill-prefix-regexp))
        (forward-line 1))
@end group

@group
    ;; 不存在填充前缀；
    ;; 我们逐字符向前移动
    (while (and (re-search-forward sp-parstart nil 1)
                (progn (setq start (match-beginning 0))
                       (goto-char start)
                       (not (eobp)))
                (progn (move-to-left-margin)
                       (not (looking-at parsep)))
                (or (not (looking-at parstart))
                    (and use-hard-newlines
                         (not (get-text-property (1- start) 'hard)))))
      (forward-char 1))
@end group

@group
    ;; 如果没有填充前缀且不在末尾，
    ;;     则转到在正则表达式搜索 sp-parstart 中找到的内容
    (if (< (point) (point-max))
        (goto-char start))))
@end group
@end smallexample

@findex eobp
我们可以看到这是一个递减计数器的 @code{while} 循环，使用表达式 @code{(setq arg (1- arg))} 作为递减器。该表达式并不远离 @code{while}，但被隐藏在另一个 Lisp 宏中，即 @code{unless} 宏。除非我们在缓冲区末尾——这是 @code{eobp} 函数确定的；它是 @samp{End Of Buffer P} 的缩写——否则我们会将 @code{arg} 的值减小一。

（如果我们在缓冲区末尾，我们无法再向前移动，由于测试是与 @code{(not (eobp))} 的 @code{and}，下一个循环的表达式将测试为假，因为 @code{not} 函数的作用与您期望的完全相同；它是 @code{null} 的另一个名称，当其参数为假时返回真。）

有趣的是，循环计数器在我们离开段落之间之前并未递减，除非我们到达缓冲区的末尾或停止看到段落分隔符的本地值。

这第二个 @code{while} 也有一个 @code{(move-to-left-margin)} 表达式。该函数是不言自明的。它在一个 @code{progn} 表达式中，并且不是其主体的最后一个元素，因此它仅被调用以产生其移动到当前行左边缘的副作用。

@findex looking-at
@code{looking-at} 函数同样不言自明；如果点之后的文本与其参数给定的正则表达式匹配，则返回真。

在理解的过程中，循环体的其余部分起初看起来可能有些困难，但随着理解，它会变得合理。

@need 800
首先考虑如果存在填充前缀时会发生什么：

@smallexample
@group
  (if fill-prefix-regexp
      ;; 存在填充前缀；它覆盖了 parstart；
      ;; 我们逐行向前移动
      (while (and (not (eobp))
                  (progn (move-to-left-margin) (not (eobp)))
                  (not (looking-at parsep))
                  (looking-at fill-prefix-regexp))
        (forward-line 1))
@end group
@end smallexample

@noindent
这个表达式会使点逐行向前移动，只要四个条件都为真：

@enumerate
@item
点不在缓冲区末尾。

@item
我们可以移动到文本的左边缘且不在缓冲区末尾。

@item
点之后的文本不分隔段落。

@item
点之后的模式是填充前缀正则表达式。
@end enumerate

最后一个条件可能令人困惑，直到您记住点在 @code{forward-paragraph} 函数中早期被移动到行的开头。这意味着如果文本有填充前缀，@code{looking-at} 函数将会看到它。

@need 1250
考虑当没有填充前缀时会发生什么。

@smallexample
@group
    (while (and (re-search-forward sp-parstart nil 1)
                (progn (setq start (match-beginning 0))
                       (goto-char start)
                       (not (eobp)))
                (progn (move-to-left-margin)
                       (not (looking-at parsep)))
                (or (not (looking-at parstart))
                    (and use-hard-newlines
                         (not (get-text-property (1- start) 'hard)))))
      (forward-char 1))
@end group
@end smallexample

@noindent
这个 @code{while} 循环让我们向前搜索 @code{sp-parstart}，它是可能的空白字符与段落或段落分隔符的本地值的组合。 （后两者都在以 @code{\(?:} 开头的表达式中，以便它们不被 @code{match-beginning} 函数引用。）

@need 800
这两个表达式，

@smallexample
@group
(setq start (match-beginning 0))
(goto-char start)
@end group
@end smallexample

@noindent
意味着转到由正则表达式搜索匹配的文本的开头。

@code{(match-beginning 0)} 表达式是新的。它返回一个指定由最近的搜索匹配的文本的开头位置的数字。

@findex match-beginning
当给定参数 0 时，@code{match-beginning} 返回最近搜索匹配的文本的开头位置。在这种情况下，最近的搜索寻找 @code{sp-parstart}。@code{(match-beginning 0)} 表达式返回该模式的开头位置，而不是该模式的结束位置。

（顺便说一下，当作为参数传递一个正数时，@code{match-beginning} 函数返回最后一次搜索中括号表达式的位置，除非该括号表达式以 @code{\(?:} 开头。我不知道为什么这里出现 @code{\(?:}，因为参数是 0。）

@need 1250
当没有填充前缀时的最后一个表达式是

@smallexample
@group
(if (< (point) (point-max))
    (goto-char start))))
@end group
@end smallexample

@noindent
这表示如果没有填充前缀且不在末尾，点应该移动到由正则表达式搜索 @code{sp-parstart} 找到的内容的开头。

@code{forward-paragraph} 函数的完整定义不仅包括前进的代码，还包括后退的代码。

如果您在 GNU Emacs 中阅读此内容并想查看整个函数，请键入 @kbd{C-h f}（@code{describe-function}）和函数的名称。这会给您函数文档和包含函数源代码的库的名称。将点放在库的名称上，然后按 @key{RET} 键；您将直接转到源代码。（确保安装了源代码！没有源代码，您就像闭着眼睛开车的人一样！）

@node Regexp Review
@section 复习

以下是一些最近引入的函数的简要概述。

@table @code
@item while
重复评估表达式体的主体，只要体的第一个元素测试为真。然后返回@code{nil}。（仅为了其副作用而评估表达式。）

@need 1250
例如：

@smallexample
@group
(let ((foo 2))
  (while (> foo 0)
    (insert (format "foo is %d.\n" foo))
    (setq foo (1- foo))))

     @result{}      foo is 2.
             foo is 1.
             nil
@end group
@end smallexample

@noindent
（@code{insert}函数在光标处插入其参数；@code{format}函数根据其参数的方式返回一个字符串，就像@code{message}格式化其参数一样；@code{\n}产生一个新行。）

@item re-search-forward
搜索模式，如果找到模式，则将光标移动到其后。

@noindent
与@code{search-forward}相似，接受四个参数：

@enumerate
@item
一个正则表达式，指定要搜索的模式。（记得在这个参数周围加上引号！）

@item
可选的搜索限制。

@item
可选的，如果搜索失败，返回@code{nil}或错误消息。

@item
可选的，重复搜索的次数；如果为负数，则进行反向搜索。
@end enumerate

@item let*
在本地将一些变量绑定到特定值，然后评估其余参数，返回最后一个的值。在绑定本地变量时，使用先前绑定的变量的本地值（如果有）。

@need 1250
例如：

@smallexample
@group
(let* ((foo 7)
       (bar (* 3 foo)))
  (message "`bar' is %d." bar))
     @result{} ‘bar’ is 21.
@end group
@end smallexample

@item match-beginning
返回由上一次正则表达式搜索找到的文本的起始位置。

@item looking-at
如果光标后的文本与参数匹配（应为正则表达式），则返回@code{t}为真。

@item eobp
如果光标位于缓冲区的可访问部分的末尾，则返回@code{t}为真。如果缓冲区没有缩小，则可访问部分的末尾是缓冲区的末尾；如果缓冲区已经缩小，则可访问部分的末尾是缩小部分的末尾。
@end table

@need 1500
@node re-search Exercises
@section 使用@code{re-search-forward}的练习

@itemize @bullet
@item
编写一个函数来搜索与正则表达式匹配的两个或更多空白行。

@item
编写一个函数来搜索重复的单词，例如“the the”。有关如何编写匹配由两个相同部分组成的字符串的正则表达式（regexp）的信息，请参阅@xref{Regexps, , Syntax of Regular Expressions, emacs, The GNU Emacs Manual}。您可以设计几个正则表达式；有些比其他的好。我使用的函数在附录中有描述，以及几个正则表达式。@xref{the-the, , @code{the-the} Duplicated Words Function}。
@end itemize

@node Counting Words
@chapter 通过重复和正则表达式进行统计
@cindex 通过重复统计单词
@cindex 通过正则表达式统计单词

重复和正则表达式搜索是在编写Emacs Lisp代码时经常使用的强大工具。本章通过使用 @code{while} 循环和递归构建单词计数命令来说明正则表达式搜索的使用。

@menu
* Why Count Words::
* @value{COUNT-WORDS}::          使用正则表达式，但遇到问题。
* recursive-count-words::       从区域中没有单词的情况开始。
* Counting Exercise::
@end menu

@ifnottex
@node Why Count Words
@unnumberedsec 统计单词
@end ifnottex

标准的Emacs发行版包含用于计算区域内行数和单词数的函数。

某些类型的写作要求你统计单词数。因此，如果你写一篇文章，你可能被限制在800个单词；如果你写一本小说，你可能自律地每天写1000个单词。这似乎有些奇怪，但很长一段时间，Emacs缺乏一个统计单词数的命令。也许人们主要使用Emacs编写代码或一些不需要统计单词数的文档；或者他们局限于使用操作系统的单词计数命令 @code{wc}。另外，人们可能按照出版商的习惯，通过将文档中的字符数除以五来计算单词数。

有许多实现统计单词数的方法。以下是一些例子，您可能希望与标准Emacs命令 @code{count-words-region} 进行比较。

@node @value{COUNT-WORDS}
@section 函数 @code{@value{COUNT-WORDS}}
@findex @value{COUNT-WORDS}

一个单词计数命令可以在行、段落、区域或缓冲区中计算单词数。这个命令应该覆盖什么范围？你可以设计命令来计算整个缓冲区中的单词数。然而，Emacs 传统鼓励灵活性——你可能只想计算一个部分中的单词，而不是整个缓冲区。因此，更有意义的是设计命令来计算区域中的单词数。一旦你有一个计算区域中单词数的命令，如果愿意，可以通过使用@w{@kbd{C-x h}}（@code{mark-whole-buffer}）标记整个缓冲区来计算单词数。

显然，计算单词是一个重复的动作：从区域的开头开始，计算第一个单词，然后是第二个单词，依此类推，直到达到区域的末尾。这意味着单词计数理想情况下适合使用递归或@code{while}循环。

@menu
* Design @value{COUNT-WORDS}::  使用@code{while}循环进行定义。
* Whitespace Bug::  @code{@value{COUNT-WORDS}}中的空白符号错误。
@end menu

@ifnottex
@node Design @value{COUNT-WORDS}
@unnumberedsubsec 设计 @code{@value{COUNT-WORDS}}
@end ifnottex

首先，我们将使用@code{while}循环实现单词计数命令，然后再使用递归。当然，该命令将是交互式的。

@need 800
交互式函数定义的模板如下：

@smallexample
@group
(defun @var{name-of-function} (@var{argument-list})
  "@var{documentation}@dots{}"
  (@var{interactive-expression}@dots{})
  @var{body}@dots{})
@end group
@end smallexample

我们需要填写这些位置。

函数的名称应该是不言自明且容易记忆的。@code{count-words-region}是显而易见的选择。由于该名称已用于标准的Emacs命令以计算单词数，我们将为我们的实现命名为@code{@value{COUNT-WORDS}}。

该函数计算区域中的单词数。这意味着参数列表必须包含绑定到区域的两个位置的符号，即起始和结束。这两个位置可以分别称为@samp{beginning}和@samp{end}。文档的第一行应该是一个简单的句子，因为这是由@code{apropos}等命令打印的所有文档。交互表达式将采用形式@samp{(interactive "r")}，因为这将导致Emacs将区域的起始和结束传递给函数的参数列表。所有这些都是例行公事。

函数的主体需要编写三个任务：首先，设置@code{while}循环可以计算单词的条件；其次，运行@code{while}循环；最后，向用户发送消息。

当用户调用@code{@value{COUNT-WORDS}}时，点可能位于区域的开头或末尾。然而，计数过程必须从区域的开头开始。这意味着如果点尚未在那里，我们将希望将点放在那里。执行@code{(goto-char beginning)}可以确保这一点。当函数完成其工作时，当然我们希望将点返回到其预期的位置。因此，主体必须包含在@code{save-excursion}表达式中。

函数主体的核心部分包含一个@code{while}循环，其中一个表达式按单词向前跳转点，另一个表达式计算这些跳转。@code{while}循环的真假测试应该在点应该向前跳转时返回true，在点在区域末尾时返回false。

我们可以使用@code{(forward-word 1)}作为将点逐个单词向前移动的表达式，但如果使用正则表达式搜索，可以更容易地看到Emacs将其识别为“单词”的内容。

一个正则表达式搜索找到其正在搜索的模式后，将点留在匹配的最后一个字符之后。这意味着一系列成功的单词搜索将点逐个单词向前移动。

实际上，我们希望正则表达式搜索跳过单词之间的空白符和标点符号，以及单词本身。一个拒绝跳过单词之间空白符的正则表达式搜索永远不会跳过一个以上的单词！这意味着正则表达式应包括单词之后（如果有的话）的空白符和标点符号，以及单词本身。 （一个单词可能结束于缓冲区，而没有任何后续空白符或标点符号，因此该正则表达式的这一部分必须是可选的。）

因此，我们希望正则表达式的模式是定义一个或多个单词成分字符，后面跟着可选的一个或多个不是单词成分字符的字符。这个正则表达式的模式如下：

@smallexample
\w+\W*
@end smallexample

@noindent
缓冲区的语法表决定了哪些字符是单词成分字符，哪些不是。有关语法的更多信息，请参见@pxref{Syntax Tables, , Syntax Tables, elisp, The GNU Emacs Lisp Reference Manual}。

@need 800
搜索表达式看起来像这样：

@smallexample
(re-search-forward "\\w+\\W*")
@end smallexample

@noindent
（请注意，斜杠前面有@samp{w}和@samp{W}。单个斜杠对Emacs Lisp解释器有特殊含义。它表示以下字符的解释方式与通常不同。例如，两个字符@samp{\n}代表@samp{newline}，而不是反斜杠后跟@samp{n}。两个连续的斜杠表示一个普通的、非特殊的反斜杠，因此Emacs Lisp解释器最终会看到一个后面跟着一个字母的单个反斜杠。因此，它发现这个字母是特殊的。）

我们需要一个计数器来计算有多少个单词；这个变量必须首先设置为0，然后在Emacs循环@code{while}中的每一次都递增。递增表达式很简单：

@smallexample
(setq count (1+ count))
@end smallexample

最后，我们想告诉用户区域中有多少个单词。@code{message}函数适用于向用户呈现这种类型的信息。消息必须以这样的方式构造，以便不管区域中有多少个单词，它都能正确阅读：我们不想说“区域中有1个单词”。单数和复数之间的冲突是不合语法的。我们可以通过使用条件表达式来解决此问题，该表达式根据区域中的单词数评估不同的消息。有三种可能性：区域中没有单词，区域中有一个单词，以及区域中有多个单词。这意味着@code{cond}特殊形式是适当的。

@need 1500
所有这些导致以下函数定义：

@smallexample
@group
;;; @r{第一个版本；存在错误！}
(defun @value{COUNT-WORDS} (beginning end)
  "打印区域中的单词数。
单词被定义为至少一个单词成分字符，后跟至少一个不是单词成分字符的字符。
缓冲区的语法表决定了这些字符是什么。"
  (interactive "r")
  (message "正在计算区域中的单词数... ")
@end group

@group
;;; @r{1. 设置适当的条件。}
  (save-excursion
    (goto-char beginning)
    (let ((count 0))
@end group

@group
;;; @r{2. 运行} while @r{循环。}
      (while (< (point) end)
        (re-search-forward "\\w+\\W*")
        (setq count (1+ count)))
@end group

@group
;;; @r{3. 向用户发送消息。}
      (cond ((zerop count)
             (message
              "区域中没有单词。"))
            ((= 1 count)
             (message
              "区域中有1个单词。"))
            (t
             (message
              "区域中有%d个单词。" count))))))
@end group
@end smallexample

@noindent
按照目前的编写方式，该函数能够工作，但在某些情况下不完全正确。

@node Whitespace Bug
@subsection @code{@value{COUNT-WORDS}} 中的空白字符错误

在前面的章节中描述的 @code{@value{COUNT-WORDS}} 命令有两个错误，或者更确切地说，有一个带有两个表现形式的错误。首先，如果你标记一个仅包含中间某些文本的空白区域，@code{@value{COUNT-WORDS}} 命令会告诉你该区域包含一个单词！其次，如果你标记一个仅包含位于缓冲区末尾或缩小缓冲区的可访问部分的空白字符的区域，该命令会显示一个错误消息，看起来像这样：

@smallexample
搜索失败："\\w+\\W*"
@end smallexample

如果你是在GNU Emacs的Info中阅读本文，你可以自行测试这些错误。

首先，按照通常的方式评估该函数以安装它。
@ifinfo
这是定义的一个副本。将光标放在括号结束后，然后键入 @kbd{C-x C-e} 以安装它。

@smallexample
@group
;; @r{第一个版本; 存在错误!}
(defun @value{COUNT-WORDS} (beginning end)
  "打印区域内的单词数。
单词定义为至少一个单词构成字符，后面跟着至少一个不是单词构成字符的字符。缓冲区的语法表确定这些字符。"
@end group
@group
  (interactive "r")
  (message "正在计算区域内的单词数 ... ")
@end group

@group
;;; @r{1. 设置适当的条件。}
  (save-excursion
    (goto-char beginning)
    (let ((count 0))
@end group

@group
;;; @r{2. 运行} while @r{循环。}
      (while (< (point) end)
        (re-search-forward "\\w+\\W*")
        (setq count (1+ count)))
@end group

@group
;;; @r{3. 向用户发送消息。}
      (cond ((zerop count)
             (message "该区域不包含任何单词。"))
            ((= 1 count) (message "该区域包含1个单词。"))
            (t (message "该区域包含%d个单词。" count))))))
@end group
@end smallexample
@end ifinfo

@need 1000
如果愿意，也可以通过评估以下绑定来安装此键绑定：

@smallexample
(global-set-key "\C-c=" '@value{COUNT-WORDS})
@end smallexample

进行第一个测试，将标记和点设置到以下行的开始和结束，然后键入 @kbd{C-c =}（或如果未绑定 @kbd{C-c =}，则为 @kbd{M-x @value{COUNT-WORDS}}）：

@smallexample
    一个  两个  三
@end smallexample

@noindent
Emacs 将告诉你，该区域有三个单词，这是正确的。

重复测试，但将标记放在该行的开头，并将点放在单词 @samp{一个} 之前。再次输入命令 @kbd{C-c =}（或 @kbd{M-x @value{COUNT-WORDS}}）。Emacs 应该告诉你该区域没有单词，因为它仅由该行开头的空白字符组成。但是，Emacs却告诉你该区域有一个单词！

对于第三个测试，将示例行复制到 @file{*scratch*} 缓冲区的末尾，然后在该行的末尾输入多个空格。将标记放在单词 @samp{三} 之后，将点放在行末。 （行末将是缓冲区的末尾。）像之前一样，输入 @kbd{C-c =}（或 @kbd{M-x @value{COUNT-WORDS}}）。再次，Emacs 应该告诉你该区域没有单词，因为它仅由该行末尾的空白字符组成。但是，相反，Emacs 显示一个错误消息，其中显示 @samp{Search failed}。

这两个错误源于同一个问题。

考虑错误的第一个表现形式，在该表现形式中，该命令告诉你该行开头的空白字符包含一个单词。发生的情况是：@code{M-x @value{COUNT-WORDS}} 命令将点移动到区域的开头。@code{while} 测试点的值是否小于 @code{end} 的值，它是的。因此，正则表达式搜索寻找并找到第一个单词。它将点放在单词之后。 @code{count} 设置为一。@code{while} 循环重复; 但是这次点的值大于 @code{end} 的值，循环退出；函数显示一条消息，其中包含区域中的单词数为一。简而言之，尽管标记区域外的单词，但正则表达式搜索却寻找并找到了该单词。

在错误的第二个表现形式中，该区域是位于缓冲区末尾的空白字符。Emacs 显示 @samp{Search failed}。发生的情况是，在 @code{while} 循环中的真假测试中，测试为真，因此执行搜索表达式。但由于缓冲区中没有更多的单词，搜索失败。

在错误的两个表现形式中，搜索都会扩展或尝试扩展到区域之外。

解决方案是限制搜索到该区域，这是一个相当简单的操作，但正如你可能期望的那样，它并不像你想象的那么简单。

正如我们所见，@code{re-search-forward} 函数将搜索模式作为其第一个参数。但除了这第一个，强制性的参数外，它还接受三个可选参数。可选的第二个参数限制了搜索。可选的第三个参数，如果是 @code{t}，则使函数在搜索失败时返回 @code{nil} 而不是引发错误。可选的第四个参数是重复计数。（在Emacs中，可以通过键入 @kbd{C-h f}，函数的名称，然后 @key{RET} 来查看函数的文档。）

在 @code{@value{COUNT-WORDS}} 的定义中，区域末尾的值由传递给函数的变量 @code{end} 持有。因此，我们可以将 @code{end} 添加为正则表达式搜索表达式的参数：

@smallexample
(re-search-forward "\\w+\\W*" end)
@end smallexample

然而，如果你只对 @code{@value{COUNT-WORDS}} 定义进行这个更改，然后在一段空白区域上测试新版本的定义，你将收到一条错误消息，其中显示 @samp{Search failed}。

发生的情况是：搜索限制为该区域，因为在该区域中没有单词构成字符，所以搜索失败，正如你所期望的那样。由于失败，我们收到了一条错误消息。但在这种情况下，我们不希望收到错误消息；我们希望收到消息“该区域不包含任何单词”。

解决此问题的方法是向 @code{re-search-forward} 提供第三个参数 @code{t}，这将导致函数在搜索失败时返回 @code{nil} 而不是引发错误。

然而，如果你进行此更改并尝试运行它，你将看到消息“计算区域内的单词数 ...”，等等，你将继续看到该消息...，直到你键入 @kbd{C-g}（@code{keyboard-quit}）。

发生的情况是：搜索限制为该区域，与之前一样失败，因为该区域中没有单词构成字符，正如预期的那样。因此，@code{re-search-forward} 表达式返回 @code{nil}。它仅仅返回 @code{nil}。特别地，如果找到了搜索目标，它不会移动点，这是它的副作用之一。在 @code{re-search-forward} 表达式返回 @code{nil} 后，@code{while} 循环中的下一个表达式将被评估。该表达式递增计数。然后循环重复。由于 @code{re-search-forward} 表达式没有移动点，所以 @code{while} 循环的真假测试测试为真，因为点的值仍然小于 @code{end} 的值。...循环重复...

@code{@value{COUNT-WORDS}} 定义需要进行另一个修改，以使 @code{while} 循环的真假测试在搜索失败时测试为假。换句话说，在增加单词计数变量之前，必须同时满足两个条件：点必须仍然在区域内，并且搜索表达式必须找到一个要计数的单词。

由于第一个条件和第二个条件必须一起为真，所以这两个表达式，区域测试和搜索表达式，可以用 @code{and} 特殊形式连接，并嵌入到 @code{while} 循环中作为真假测试，如下所示：

@smallexample
(and (< (point) end) (re-search-forward "\\w+\\W*" end t))
@end smallexample

@c 在打印的章节标题中的冒号会导致Info交叉引用问题
@c 在Info交叉引用中也存在问题
@iftex
@noindent
（有关 @code{and} 的信息，请参见 @ref{kill-new function, , The @code{kill-new} function}。）
@end iftex
@ifinfo
@noindent
（关于 @code{and} 的信息，请参见 @ref{kill-new function, , The @code{kill-new} function}。）
@end ifinfo

@code{re-search-forward} 表达式在搜索成功时返回 @code{t}，并作为副作用移动点。因此，随着找到单词，点通过区域移动。当搜索表达式未能找到另一个单词，或当点达到区域的末尾时，真假测试失败，@code{while} 循环退出，@code{@value{COUNT-WORDS}} 函数显示其消息之一。

在加入这些最终更改后，@code{@value{COUNT-WORDS}} 就没有错误了（或者至少，我没有找到错误！）。以下是它的最终版本：

@smallexample
@group
;;; @r{最终版本：} @code{while}
(defun @value{COUNT-WORDS} (beginning end)
  "打印区域内的单词数。"
  (interactive "r")
  (message "计算区域内的单词数 ... ")
@end group

@group
;;; @r{1. 设置适当的条件。}
  (save-excursion
    (let ((count 0))
      (goto-char beginning)
@end group

@group
;;; @r{2. 运行} while @r{循环。}
      (while (and (< (point) end)
                  (re-search-forward "\\w+\\W*" end t))
        (setq count (1+ count)))
@end group

@group
;;; @r{3. 向用户发送消息。}
      (cond ((zerop count)
             (message
              "该区域不包含任何单词。"))
            ((= 1 count)
             (message
              "该区域包含一个单词。"))
            (t
             (message
              "该区域包含 %d 个单词。" count))))))
@end group
@end smallexample

@node recursive-count-words
@section 递归计算单词数
@cindex 递归计算单词数
@cindex 递归单词计数
@cindex 单词，递归计数

你可以编写递归方式和使用 @code{while} 循环的函数来计算单词数。让我们看看如何实现。

首先，我们需要认识到 @code{@value{COUNT-WORDS}} 函数有三个任务：它设置适当的条件来进行计数；它计算区域内的单词数；并向用户发送一条消息，告诉有多少个单词。

如果我们写一个单一的递归函数来执行所有这些任务，我们将为每个递归调用都收到一条消息。如果区域包含13个单词，我们将接收到十三条消息，依次排列。我们不想要这样！相反，我们必须编写两个函数来完成工作，其中一个（递归函数）将在另一个内部使用。一个函数将设置条件并显示消息；另一个将返回单词数。

让我们从引起消息显示的函数开始。我们可以继续称之为 @code{@value{COUNT-WORDS}}。

这是用户将调用的函数。它将是交互式的。实际上，它将类似于我们先前版本的这个函数，只是它将调用 @code{recursive-count-words} 来确定区域中有多少个单词。

@need 1250
我们可以基于先前的版本轻松构造这个函数的模板：

@smallexample
@group
;; @r{递归版本；使用正则表达式搜索}
(defun @value{COUNT-WORDS} (beginning end)
  "@var{documentation}@dots{}"
  (@var{interactive-expression}@dots{})
@end group
@group

;;; @r{1. 设置适当的条件。}
  (@var{explanatory message})
  (@var{set-up functions}@dots{}
@end group
@group

;;; @r{2. 计算单词数。}
    @var{recursive call}
@end group
@group

;;; @r{3. 向用户发送消息。}
    @var{message providing word count}))
@end group
@end smallexample

定义看起来很简单，只是要注意递归调用返回的计数如何传递给显示单词计数的消息。经过一点思考，我们可以利用 @code{let} 表达式来实现：我们可以在 @code{let} 表达式的 varlist 中将一个变量绑定到区域内的单词数，由递归调用返回；然后 @code{cond} 表达式可以使用绑定来向用户显示该值。

通常，人们将 @code{let} 表达式内的绑定视为函数的主要工作的某种次要部分。但在这种情况下，您可能认为函数的主要工作，即计算单词数，是在 @code{let} 表达式内完成的。

@need 1250
使用 @code{let}，函数定义如下：

@smallexample
@group
(defun @value{COUNT-WORDS} (beginning end)
  "打印区域内的单词数。"
  (interactive "r")
@end group

@group
;;; @r{1. 设置适当的条件。}
  (message "正在计算区域内的单词数... ")
  (save-excursion
    (goto-char beginning)
@end group

@group
;;; @r{2. 计算单词数。}
    (let ((count (recursive-count-words end)))
@end group

@group
;;; @r{3. 向用户发送消息。}
      (cond ((zerop count)
             (message
              "该区域没有任何单词。"))
            ((= 1 count)
             (message
              "该区域有1个单词。"))
            (t
             (message
              "该区域有 %d 个单词。" count))))))
@end group
@end smallexample

接下来，我们需要编写递归计数函数。

递归函数至少有三个部分：再次执行测试，下一步表达式和递归调用。

再次执行测试确定函数是否将再次调用。由于我们在区域中计算单词数并可以使用一个每个单词都向前移动指针的函数，再次执行测试可以检查点是否仍然在区域内。再次执行测试应该找到点的值，并确定点是在区域结束的值之前，与之相等还是之后。我们可以使用 @code{point} 函数来定位点。显然，必须将区域结束的值作为参数传递给递归计数函数。

此外，再次执行测试还应该测试搜索是否找到了单词。如果没有找到，函数不应再次调用自身。

下一步表达式更改一个值，以便当递归函数应该停止调用自身时，它停止。更准确地说，下一步表达式更改一个值，以便在正确的时间，再次执行测试停止递归函数再次调用自身。在这种情况下，下一步表达式可以是将点按单词向前移动的表达式。

递归函数的第三部分是递归调用。

还需要一个执行函数工作的部分，一个执行计数的重要部分！

@need 1250
但是，我们已经有了递归计数函数的大纲：

@smallexample
@group
(defun recursive-count-words (region-end)
  "@var{documentation}@dots{}"
   @var{do-again-test}
   @var{next-step-expression}
   @var{recursive call})
@end group
@end smallexample

现在我们需要填充这些槽。让我们从最简单的情况开始：如果点在区域结束的位置或之后，那么区域中不能有任何单词，因此函数应返回零。同样，如果搜索失败，就没有单词可计数，因此函数应返回零。

另一方面，如果点在区域内且搜索成功，则函数应再次调用自身。

@need 800
因此，再次执行测试应如下所示：

@smallexample
@group
(and (< (point) region-end)
     (re-search-forward "\\w+\\W*" region-end t))
@end group
@end smallexample

请注意，搜索表达式是再次执行测试的一部分——如果其搜索成功，则函数返回 @code{t}，如果失败，则返回 @code{nil}。(@xref{Whitespace Bug, , @code{@value{COUNT-WORDS}} 中的空白字符错误}，了解 @code{re-search-forward} 的工作原理的解释。)

再次执行测试是 @code{if} 子句的真值测试。显然，如果再次执行测试成功，则 @code{if} 子句的 then-部分应该再次调用函数；但如果失败，则 else-部分应该返回零，因为要么点在区域外，要么搜索失败，因为找不到单词。

但在考虑递归调用之前，我们需要考虑下一步表达式。这是什么？有趣的是，它就是do-again-test的搜索部分。

除了为do-again-test返回@code{t}或@code{nil}外，@code{re-search-forward}在成功搜索时会作为副作用移动点。这是改变点值的操作，使得递归函数停止调用自身，当点通过区域完成移动。因此，@code{re-search-forward}表达式就是next-step-expression。

@need 1200
概述来看，@code{recursive-count-words}函数的主体如下：

@smallexample
@group
(if @var{do-again-test-and-next-step-combined}
    ;; @r{then}
    @var{recursive-call-returning-count}
  ;; @r{else}
  @var{return-zero})
@end group
@end smallexample

如何融入计数机制？

如果你不习惯编写递归函数，这样的问题可能会让人头疼。但应该以系统的方式来解决。

我们知道计数机制应该以某种方式与递归调用关联起来。确实，由于next-step-expression通过一个单词将点向前移动，并且由于每个单词都会进行递归调用，计数机制必须是一个表达式，该表达式将一个添加到由@code{recursive-count-words}调用返回的值。

@need 800
考虑几种情况：

@itemize @bullet
@item
如果区域中有两个单词，则函数应该返回一个值，该值是在计算第一个单词时添加到该值的值，再加上计算区域中剩余单词时返回的数字，这在这种情况下为一。

@item
如果区域中只有一个单词，则函数应该返回一个值，该值是在计算该单词时添加到该值的值，再加上计算区域中剩余单词时返回的数字，这在这种情况下为零。

@item
如果区域中没有单词，则函数应该返回零。
@end itemize

从草图中我们可以看到，@code{if}的else部分对于没有单词的情况返回零。这意味着@code{if}的then部分必须返回一个值，该值是通过递归调用的返回值添加一的结果。

@need 1200
表达式将如下所示，其中@code{1+}是一个将一个添加到其参数的函数。

@smallexample
(1+ (recursive-count-words region-end))
@end smallexample

@need 1200
整个@code{recursive-count-words}函数将如下所示：

@smallexample
@group
(defun recursive-count-words (region-end)
  "@var{documentation}@dots{}"

;;; @r{1. do-again-test}
  (if (and (< (point) region-end)
           (re-search-forward "\\w+\\W*" region-end t))
@end group

@group
;;; @r{2. then-part: the recursive call}
      (1+ (recursive-count-words region-end))

;;; @r{3. else-part}
    0))
@end group
@end smallexample

@need 1250
让我们看看这是如何工作的：

如果区域中没有单词，则@code{if}表达式的else部分被求值，因此函数返回零。

如果区域中有一个单词，则点的值小于@code{region-end}的值，并且搜索成功。在这种情况下，@code{if}表达式的true-or-false-test为true，将求值@code{if}表达式的then部分。计数表达式将被求值。该表达式返回一个值（这将是整个函数返回的值），即加一到递归调用返回的值。

同时，next-step-expression导致点跳过区域中的第一个（在这种情况下是唯一的）单词。这意味着当@code{(recursive-count-words region-end)}第二次求值时，由于递归调用的结果，点的值将等于或大于region end的值。因此，这次，@code{recursive-count-words}将返回零。零将添加到一，原始的@code{recursive-count-words}的求值将返回一加零，即一，这是正确的数量。

显然，如果区域中有两个单词，则第一次调用@code{recursive-count-words}将返回一个添加到调用@code{recursive-count-words}的区域剩余单词的值，即它添加到一，产生两个，这是正确的数量。

同样地，如果区域中有三个单词，则第一次调用@code{recursive-count-words}将返回一个添加到调用@code{recursive-count-words}的区域剩余两个单词的值，依此类推。

@need 1250
@noindent
具有完整文档的两个函数如下：

@need 1250
@noindent
递归函数：

@findex recursive-count-words
@smallexample
@group
(defun recursive-count-words (region-end)
  "在点和REGION-END之间的单词数。"
@end group

@group
;;; @r{1. do-again-test}
  (if (and (< (point) region-end)
           (re-search-forward "\\w+\\W*" region-end t))
@end group

@group
;;; @r{2. then-part: the recursive call}
      (1+ (recursive-count-words region-end))

;;; @r{3. else-part}
    0))
@end group
@end smallexample

@need 800
@noindent
包装器：

@smallexample
@group
;;; @r{递归版本}
(defun @value{COUNT-WORDS} (beginning end)
  "打印区域中的单词数。"
@end group

@group
单词被定义为至少一个单词构成字符，后面跟着至少一个不是单词构成字符的字符。缓冲区的语法表决定了这些字符是哪些。"
@end group
@group
  (interactive "r")
  (message "正在计算区域中的单词数...")
  (save-excursion
    (goto-char beginning)
    (let ((count (recursive-count-words end)))
@end group
@group
      (cond ((zerop count)
             (message
              "该区域没有任何单词。"))
@end group
@group
            ((= 1 count)
             (message "该区域有1个单词。"))
            (t
             (message
              "该区域有%d个单词。" count))))))
@end group
@end smallexample

@node Counting Exercise
@section 练习：计算标点符号

使用 @code{while} 循环，编写一个函数来计算区域内标点符号的数量---句号、逗号、分号、冒号、感叹号和问号。然后使用递归方式完成相同的任务。

@node Words in a defun
@chapter 在 @code{defun} 中计算单词数
@cindex 在 @code{defun} 中计算单词数
@cindex 在 @code{defun} 中的单词计数

我们下一个项目是计算函数定义中的单词数。显然，这可以通过一些 @code{@value{COUNT-WORDS}} 的变体来完成。参见 @xref{Counting Words, ,通过重复和正则表达式计数}。如果我们只想计算一个定义中的单词数，那么可以使用 @kbd{C-M-h} (@code{mark-defun}) 命令标记定义，然后调用 @code{@value{COUNT-WORDS}}。

然而，我更有雄心壮志：我想要计算 Emacs 源代码中每个定义中的单词和符号的数量，然后打印一个图表，显示每个长度的函数有多少个：包含 40 到 49 个单词或符号的有多少个函数，包含 50 到 59 个单词或符号的有多少个，依此类推。我常常好奇一个典型函数有多长，这将给出答案。

@menu
* Divide and Conquer::
* Words and Symbols::           应该计数什么？
* Syntax::                  什么构成一个单词或符号？
* count-words-in-defun:: 与 @code{@value{COUNT-WORDS}} 非常相似。
* Several defuns::           计算文件中的多个定义。
* Find a File::              想要查看一个文件吗？
* lengths-list-file::     许多定义长度的列表。
* Several files::              在不同文件中计数定义。
* Several files recursively::      递归在不同文件中计数。
* Prepare the data::              为在图表中显示准备数据。
@end menu

@ifnottex
@node Divide and Conquer
@unnumberedsec 分而治之
@end ifnottex

用一句话描述，直方图项目是艰巨的；但是，将其分解为许多小步骤，我们可以一次解决一个，项目就变得不那么可怕了。让我们考虑这些步骤应该是什么：

@itemize @bullet
@item
首先，编写一个函数来计算一个定义中的单词数。这包括处理符号以及单词的问题。

@item
其次，编写一个函数来列出文件中每个函数中的单词数。这个函数可以使用 @code{count-words-in-defun} 函数。

@item
第三，编写一个函数来列出每个文件中每个函数中的单词数。这涉及到自动找到不同文件，切换到它们，并计算其中定义的单词数。

@item
第四，编写一个函数将我们在第三步中创建的数字列表转换为适合打印为图表的形式。

@item
第五，编写一个函数将结果打印为图表。
@end itemize

这是一个相当庞大的项目！但是，如果我们慢慢来，它并不难。

@node Words and Symbols
@section 如何计数？
@cindex defun 中的单词和符号

当我们首次考虑如何计算函数定义中的单词时，第一个问题是（或者应该是）我们要计数什么？当我们谈到与 Lisp 函数定义相关的“单词”时，实际上在很大程度上我们是在谈论符号。例如，下面的 @code{multiply-by-seven} 函数包含五个符号：@code{defun}、@code{multiply-by-seven}、@code{number}、@code{*} 和 @code{7}。此外，在文档字符串中，它包含四个单词：@samp{Multiply}、@samp{NUMBER}、@samp{by} 和 @samp{seven}。符号 @samp{number} 被重复使用，因此定义包含总共十个单词和符号。

@smallexample
@group
(defun multiply-by-seven (number)
  "Multiply NUMBER by seven."
  (* 7 number))
@end group
@end smallexample

@noindent
然而，如果我们使用 @kbd{C-M-h}（@code{mark-defun}）标记 @code{multiply-by-seven} 定义，然后调用 @code{@value{COUNT-WORDS}}，我们会发现 @code{@value{COUNT-WORDS}} 声称该定义有十一个单词，而不是十个！有些地方出错了！

问题有两个方面：@code{@value{COUNT-WORDS}} 不将 @samp{*} 视为一个单词，而将单个符号 @code{multiply-by-seven} 视为包含三个单词。连字符被视为单词间的空格而不是单词内的连接符：@samp{multiply-by-seven} 被计算为如果它被写成 @samp{multiply by seven}。

混淆的原因在于 @code{@value{COUNT-WORDS}} 定义中的正则表达式搜索，该搜索按单词向前移动点。在 @code{@value{COUNT-WORDS}} 的典型版本中，正则表达式为：

@smallexample
"\\w+\\W*"
@end smallexample

@noindent
该正则表达式是一个模式，定义了一个或多个单词构成字符，后面可能跟着一个或多个不是单词构成字符的字符。关于“单词构成字符”是什么，这就引出了语法问题，值得单独讨论一节。

@node Syntax
@section 何为单词或符号的组成部分？
@cindex 语法类别和表

Emacs将不同的字符视为属于不同的@dfn{语法类别}。例如，正则表达式@samp{\\w+}是一个模式，指定一个或多个@emph{单词组成}字符。单词组成字符属于一个语法类别。其他语法类别包括标点字符类，如句点和逗号，以及空白字符类，如空格和制表符。（更多信息，请参阅@pxref{Syntax Tables, , Syntax Tables, elisp, The GNU Emacs Lisp Reference Manual}。）

语法表指定哪些字符属于哪些类别。通常，连字符不被指定为单词组成字符。相反，它被指定为符号名称中的字符类，但不是单词。这意味着@code{@value{COUNT-WORDS}}函数以与单词间空格相同的方式处理它，这就是为什么@code{@value{COUNT-WORDS}}将@samp{multiply-by-seven}计为三个单词的原因。

有两种方法可以使Emacs将@samp{multiply-by-seven}计为一个符号：修改语法表或修改正则表达式。

我们可以通过修改Emacs为每种模式保留的语法表来重新定义连字符为单词组成字符。这个动作将满足我们的目的，除了连字符仅仅是符号中最常见的不是单词组成字符的字符；还有其他字符。

或者，我们可以重新定义@code{@value{COUNT-WORDS}}定义中使用的正则表达式，以包括符号。这个过程具有清晰的优点，但任务有点棘手。

@need 1200
第一部分相当简单：模式必须匹配至少一个是单词或符号组成字符的字符。因此：

@smallexample
"\\(\\w\\|\\s_\\)+"
@end smallexample

@noindent
@samp{\\(}是包含@samp{\\w}和@samp{\\s_}作为选择项的分组结构的第一部分，由@samp{\\|}分隔。@samp{\\w}匹配任何单词组成字符，而@samp{\\s_}匹配任何是符号名称但不是单词组成字符的字符。组后面的@samp{+}表示单词或符号组成字符必须至少匹配一次。

然而，正则表达式的第二部分设计更难。我们希望第一部分后面可以选择跟随零个或多个不是单词或符号组成字符的字符。起初，我认为可以用以下方式定义这个：

@smallexample
"\\(\\W\\|\\S_\\)*"
@end smallexample

@noindent
大写的@samp{W}和@samp{S}匹配@emph{不是}单词或符号组成字符的字符。不幸的是，这个表达式匹配任何不是单词组成字符或符号组成字符的字符。这匹配任何字符！

我然后注意到我的测试区域中的每个单词或符号后面都跟着空白（空格、制表符或换行符）。所以我尝试在匹配一个或多个单词或符号组成字符的模式之后放置一个匹配一个或多个空格的模式。这也失败了。单词和符号通常由空白分隔，但在实际代码中，括号可能跟随符号，标点可能跟随单词。因此最后，我设计了一个模式，其中单词或符号组成字符后面可以选择跟随不是空白字符的字符，然后可以选择跟随空白字符。

@need 800
以下是完整的正则表达式：

@smallexample
"\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"
@end smallexample

@node count-words-in-defun
@section @code{count-words-in-defun} 函数
@cindex 在 @code{defun} 中计算单词数

我们已经看到有几种编写 @code{count-words-region} 函数的方法。为了编写 @code{count-words-in-defun}，我们只需调整其中一种版本即可。

使用 @code{while} 循环的版本很容易理解，因此我将对其进行调整。由于 @code{count-words-in-defun} 将成为一个更复杂的程序的一部分，它不需要是交互式的，也不需要显示消息，只需返回计数即可。这些考虑稍微简化了定义。

另一方面，@code{count-words-in-defun} 将在包含函数定义的缓冲区中使用。因此，合理的要求是，该函数确定在调用时点是否位于函数定义内，并且如果是，则返回该定义的计数。这增加了定义的复杂性，但省去了需要将参数传递给函数的需要。

@need 1250
这些考虑引导我们准备以下模板：

@smallexample
@group
(defun count-words-in-defun ()
  "@var{documentation}@dots{}"
  (@var{set up}@dots{}
     (@var{while loop}@dots{})
   @var{return count})
@end group
@end smallexample

@noindent
像往常一样，我们的任务是填写这些槽。

首先，设置。

我们假设该函数将在包含函数定义的缓冲区中调用。点要么在函数定义内，要么不在。为了使 @code{count-words-in-defun} 起作用，点必须移动到定义的开头，一个计数器必须从零开始，而计数循环必须在点达到定义的末尾时停止。

@code{beginning-of-defun} 函数向后搜索开头为 @samp{(}（例如在行首）的分隔符，并将点移动到该位置，否则移到搜索的限制位置。在实践中，这意味着 @code{beginning-of-defun} 将点移到封闭或前置函数定义的开头，或者移到缓冲区的开头。我们可以使用 @code{beginning-of-defun} 将点放置在我们想要开始的位置。

@code{while} 循环需要一个计数器来跟踪要计数的单词或符号。可以使用 @code{let} 表达式创建一个用于此目的的局部变量，并将其绑定到零的初始值。

@code{end-of-defun} 函数与 @code{beginning-of-defun} 类似，除了它将点移动到定义的末尾。@code{end-of-defun} 可以作为确定定义末尾位置的表达式的一部分使用。

@code{count-words-in-defun} 的设置迅速形成：首先将点移动到定义的开头，然后创建一个本地变量以保存计数，最后记录定义的末尾位置，以便 @code{while} 循环知道何时停止循环。

@need 1250
代码如下：

@smallexample
@group
(beginning-of-defun)
(let ((count 0)
      (end (save-excursion (end-of-defun) (point))))
@end group
@end smallexample

@noindent
代码很简单。唯一的小复杂性可能涉及到 @code{end}：它被绑定到通过 @code{save-excursion} 表达式返回的点的位置，该表达式在 @code{end-of-defun} 暂时将其移动到定义的末尾后返回其值。

@code{count-words-in-defun} 的第二部分，在设置之后，是 @code{while} 循环。

该循环必须包含一个表达式，该表达式按单词和符号前进并且另一个表达式用于计数跳跃。@code{while} 循环的真假测试应该在点应该前进时为真，而在点位于定义末尾时为假。我们已经重新定义了这个正则表达式，所以循环很简单：

@smallexample
@group
(while (and (< (point) end)
            (re-search-forward
             "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*" end t))
  (setq count (1+ count)))
@end group
@end smallexample

该函数定义的第三部分返回单词和符号的计数。这一部分是 @code{let} 表达式体内的最后一个表达式，可以非常简单地是局部变量 @code{count}，在评估时返回计数。

@need 1250
将这些部分组合起来，@code{count-words-in-defun} 的定义如下：

@findex count-words-in-defun
@smallexample
@group
(defun count-words-in-defun ()
  "返回 defun 中的单词和符号数。"
  (beginning-of-defun)
  (let ((count 0)
        (end (save-excursion (end-of-defun) (point))))
@end group
@group
    (while
        (and (< (point) end)
             (re-search-forward
              "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"
              end t))
      (setq count (1+ count)))
    count))
@end group
@end smallexample

如何测试这个函数？虽然函数不是交互式的，但很容易在其周围添加包装器使其变为交互式；我们可以使用几乎与递归版本的 @code{@value{COUNT-WORDS}} 相同的代码：

@smallexample
@group
;;; @r{交互版本。}
(defun count-words-defun ()
  "函数定义中的单词和符号数。"
  (interactive)
  (message
   "正在计算函数定义中的单词和符号数... ")
@end group
@group
  (let ((count (count-words-in-defun)))
    (cond
     ((zerop count)
      (message
       "该定义没有任何单词或符号。"))
@end group
@group
     ((= 1 count)
      (message
       "该定义有 1 个单词或符号。"))
     (t
      (message
       "该定义有 %d 个单词或符号。" count)))))
@end group
@end smallexample

@need 800
@noindent
让我们重新使用 @kbd{C-c =} 作为一个方便的键绑定：

@smallexample
(global-set-key "\C-c=" 'count-words-defun)
@end smallexample

现在我们可以尝试 @code{count-words-defun}：安装 @code{count-words-in-defun} 和 @code{count-words-defun}，并设置键绑定。然后将以下内容复制到 Emacs Lisp 缓冲区（例如，@file{*scratch*}），将光标放在定义内，并使用 @kbd{C-c =} 命令。

@smallexample
@group
(defun multiply-by-seven (number)
  "将 NUMBER 乘以七。"
  (* 7 number))
     @result{} 10
@end group
@end smallexample

@noindent
成功！该定义有 10 个单词和符号。

下一个问题是计算单个文件中多个定义中的单词和符号数。

@node Several defuns
@section 统计文件中的多个 @code{defun}

一个文件，比如 @file{simple.el}，可能包含一百个或更多的函数定义。我们的长期目标是收集许多文件的统计信息，但作为第一步，我们的即时目标是在一个文件中收集统计信息。

信息将是一系列数字，每个数字代表一个函数定义的长度。我们可以将这些数字存储在一个列表中。

我们知道我们将要将关于一个文件的信息与许多其他文件的信息结合起来；这意味着在一个文件中计算定义长度的函数只需要返回长度列表，而不需要也不应该显示任何消息。

字数统计命令包含一个表达式，用于逐个单词向前跳转，以及另一个表达式，用于计算跳转的次数。用于返回定义长度的函数可以被设计成以相同的方式工作，其中一个表达式用于逐个定义向前跳转，另一个表达式用于构造长度列表。

问题的陈述使编写函数定义变得非常基础。显然，我们将从文件的开头开始计数，因此第一个命令将是 @code{(goto-char (point-min))}。接下来，我们启动 @code{while} 循环；循环的真假测试可以是对下一个函数定义进行正则表达式搜索---只要搜索成功，点就向前移动，然后评估循环体。循环体需要一个表达式，用于构造长度列表。列表构造命令 @code{cons} 可以用来创建列表。就是这样简单。

@need 800
以下是这段代码片段的样子：

@smallexample
@group
(goto-char (point-min))
(while (re-search-forward "^(defun" nil t)
  (setq lengths-list
        (cons (count-words-in-defun) lengths-list)))
@end group
@end smallexample

我们遗漏的是找到包含函数定义的文件的机制。

在以前的例子中，我们要么使用当前文件，Info 文件，要么在其他缓冲区之间切换，比如 @file{*scratch*} 缓冲区。

找到文件是我们尚未讨论的一个新过程。

@node Find a File
@section 查找文件
@cindex 查找文件

在Emacs中查找文件，您可以使用@kbd{C-x C-f}（@code{find-file}）命令。这个命令几乎完全符合长度问题，但还需要稍作调整。

@need 1200
让我们看一下@code{find-file}的源代码：

@smallexample
@group
(defun find-file (filename)
  "编辑文件 FILENAME。
切换到访问文件 FILENAME 的缓冲区，如果不存在则创建一个。"
  (interactive "FFind file: ")
  (switch-to-buffer (find-file-noselect filename)))
@end group
@end smallexample

@noindent
（@code{find-file}函数定义的最新版本允许您指定可选的通配符以访问多个文件；这使得定义更加复杂，我们在这里不讨论，因为这与问题无关。您可以使用@kbd{M-.}（@code{xref-find-definitions}）或@kbd{C-h f}（@code{describe-function}）查看其源代码。）

@ignore
在Emacs 22
(defun find-file (filename &optional wildcards)
  "编辑文件 FILENAME。
切换到访问文件 FILENAME 的缓冲区，如果不存在则创建一个。
在交互模式下，如果只是按 @key{RET} 键，它会默认到当前目录，但可以通过迷你缓冲区历史记录访问文件名：输入 M-n 将其拉入迷你缓冲区。

在交互模式下，或者在Lisp调用中WILDCARDS为非nil时，展开通配符（如果有的话）并访问多个文件。您可以通过将`find-file-wildcards'设置为nil来禁止通配符展开。

要访问文件而不进行任何类型的转换并且不自动选择主模式，请使用 \\[find-file-literally]。"
  (interactive (find-file-read-args "Find file: " nil))
  (let ((value (find-file-noselect filename nil nil wildcards)))
    (if (listp value)
        (mapcar 'switch-to-buffer (nreverse value))
      (switch-to-buffer value))))
@end ignore

我展示的定义具有简短但完整的文档和交互规范，在您以交互方式使用命令时会提示您输入文件名。定义的主体包含两个函数，@code{find-file-noselect} 和 @code{switch-to-buffer}。

根据@kbd{C-h f}（@code{describe-function}命令）显示的文档，@code{find-file-noselect}函数将指定的文件读入缓冲区并返回该缓冲区。（其最新版本还包括一个可选的@var{wildcards}参数，以及另一个以文本方式读取文件和另一个以抑制警告消息的参数。这些可选参数与问题无关。）

然而，@code{find-file-noselect}函数不会选择放置文件的缓冲区。Emacs不会切换其注意力（或者如果您正在使用@code{find-file-noselect}，那么是您的注意力）到选定的缓冲区。这就是@code{switch-to-buffer}的作用：它切换Emacs关注的缓冲区；并且将窗口中显示的缓冲区切换到新的缓冲区。我们已经在其他地方讨论了缓冲区切换。 （@xref{Switching Buffers}。）

在这个直方图项目中，我们不需要在屏幕上显示每个文件，因为程序确定其中每个定义的长度。我们可以使用@code{set-buffer}而不是@code{switch-to-buffer}，后者会将屏幕上的缓冲区重新显示。因此，我们不必调用@code{find-file}来执行这项任务，而是必须编写我们自己的表达式。

任务很简单：使用@code{find-file-noselect}和@code{set-buffer}。

@node lengths-list-file
@section @code{lengths-list-file} 详解

@code{lengths-list-file} 函数的核心是一个包含 @code{while} 循环的结构，其中包含一个函数来逐个 defun 地将 point 前进，以及一个函数来计算每个 defun 中的单词和符号数。这个核心必须被包裹在执行各种其他任务的函数中，包括查找文件并确保 point 位于文件的开头。该函数定义如下：
@findex lengths-list-file

@smallexample
@group
(defun lengths-list-file (filename)
  "返回 FILE 中定义长度的列表。
返回的列表是数字的列表。
每个数字是一个函数定义中的单词或符号的数量。"
@end group
@group
  (message "正在处理 `%s' ... " filename)
  (save-excursion
    (let ((buffer (find-file-noselect filename))
          (lengths-list))
      (set-buffer buffer)
      (setq buffer-read-only t)
      (widen)
      (goto-char (point-min))
      (while (re-search-forward "^(defun" nil t)
        (setq lengths-list
              (cons (count-words-in-defun) lengths-list)))
      (kill-buffer buffer)
      lengths-list)))
@end group
@end smallexample

@noindent
该函数接受一个参数，即它将操作的文件的名称。它有四行文档，但没有交互规范。由于人们担心如果他们看不到任何操作就会认为计算机出了问题，函数体的第一行是一个消息。

接下来的一行包含一个 @code{save-excursion}，在函数完成时将 Emacs 的注意力返回到当前缓冲区。这对于嵌套在假设 point 被恢复到原始缓冲区的另一个函数中的情况是有用的。

在 @code{let} 表达式的变量列表中，Emacs 找到文件并将局部变量 @code{buffer} 绑定到包含文件的缓冲区。同时，Emacs 创建了 @code{lengths-list} 作为局部变量。

接下来，Emacs 将注意力切换到缓冲区。

在接下来的一行中，Emacs 将缓冲区设置为只读。理想情况下，这一行是不必要的。在计算函数定义中的单词和符号数的函数中，缓冲区不应该发生更改。此外，即使更改了缓冲区，它也不会被保存。这一行完全是对极度谨慎的后果。对谨慎的原因是，这个函数及其调用的函数处理 Emacs 的源代码，并且如果它们被意外修改，则会很不方便。不用说，在一个实验出现问题并开始修改我的 Emacs 源文件之前，我并没有意识到需要这一行 @dots{}

接下来是调用扩展缓冲区的函数，如果它被缩小了的话。通常情况下，这个函数是不需要的 - Emacs 如果还没有存在缓冲区，就会创建一个新的；但是如果已经存在了一个访问文件的缓冲区，Emacs 就返回那个缓冲区。在这种情况下，缓冲区可能被缩小，必须被扩展。如果我们想要完全用户友好，我们会安排保存约束和 point 的位置，但我们不会这样做。

@code{(goto-char (point-min))} 表达式将 point 移动到缓冲区的开头。

然后是一个 @code{while} 循环，在循环中执行函数的工作。在循环中，Emacs 确定每个定义的长度并构造包含该信息的长度列表。

在处理完缓冲区后，Emacs 将其关闭。这是为了在 Emacs 中保存空间。我使用的 GNU Emacs 19 版本包含了 300 多个感兴趣的源文件；GNU Emacs 22 包含了一千多个源文件。另一个函数将应用 @code{lengths-list-file} 到每个文件。

最后，在 @code{let} 表达式中的最后一个表达式是 @code{lengths-list} 变量；其值作为整个函数的值返回。

你可以通过通常的方式安装这个函数并尝试它。然后，将光标放在以下表达式之后，键入 @kbd{C-x C-e} (@code{eval-last-sexp}).

@c !!! 22.1.1 lisp 源文件的位置在这里
@smallexample
(lengths-list-file
 "/usr/local/share/emacs/22.1/lisp/emacs-lisp/debug.el")
@end smallexample

@noindent
你可能需要更改文件的路径名；这里的路径是适用于 GNU Emacs 版本 22.1 的。要更改表达式，将其复制到 @file{*scratch*} 缓冲区并进行编辑。

@need 1200
@noindent
此外，为了看到列表的完整长度，而不是截断版本，你可能需要评估以下内容：
@c 我们不想插入，所以不要提及零前缀参数。

@smallexample
(custom-set-variables '(eval-expression-print-length nil))
@end smallexample

@noindent
(@xref{defcustom, , 使用 @code{defcustom} 指定变量}。
然后评估 @code{lengths-list-file} 表达式。)

@need 1200
@file{debug.el} 的长度列表在 GNU Emacs 22 中不到一秒钟就产生了，看起来像这样：

@smallexample
(83 113 105 144 289 22 30 97 48 89 25 52 52 88 28 29 77 49 43 290 232 587)
@end smallexample

@need 1500
(在我的旧机器上，版本 19 的 @file{debug.el} 长度列表花费了七秒钟并且看起来像这样：

@smallexample
(75 41 80 62 20 45 44 68 45 12 34 235)
@end smallexample

@noindent
新版本的 @file{debug.el} 包含比早期版本更多的 defuns；而我的新机器比旧机器要快得多。)
请注意，文件中的最后一个定义的长度在列表中是最先的。

@node Several files
@section 统计不同文件中 @code{defuns} 的词数

在前一节中，我们创建了一个函数，该函数返回文件中每个定义的长度的列表。现在，我们想要定义一个函数，返回一个包含多个文件中定义长度的主列表。

处理文件列表中的每个文件是一个重复的操作，因此我们可以使用 @code{while} 循环或递归。

@menu
* lengths-list-many-files::     返回 @code{defuns} 长度的列表。
* append::                      将一个列表附加到另一个列表。
@end menu

@ifnottex
@node lengths-list-many-files
@unnumberedsubsec 确定 @code{defuns} 的长度
@end ifnottex

使用 @code{while} 循环的设计是常规的。传递给函数的参数是一个文件列表。正如我们之前看到的 (@pxref{Loop Example})，可以编写一个 @code{while} 循环，使得在列表包含元素的情况下计算循环体，但在列表为空时退出循环。为了使此设计工作，循环体必须包含一个表达式，该表达式在每次计算循环体时缩短列表，以便最终列表为空。通常的技术是在每次计算循环体时将列表的值设置为列表的 @sc{cdr} 的值。

@need 800
模板如下：

@smallexample
@group
(while @var{测试列表是否为空}
  @var{循环体}@dots{}
  @var{设置列表为列表的cdr})
@end group
@end smallexample

此外，我们要记住，@code{while} 循环返回 @code{nil}（真假测试的计算结果），而不是循环体内任何评估的结果。（循环体内的评估是为了它们的副作用。）然而，设置长度列表的表达式是循环体的一部分，这是我们希望整个函数返回的值。为了实现这一点，我们将 @code{while} 循环封装在一个 @code{let} 表达式内，并安排 @code{let} 表达式的最后一个元素包含长度列表的值。(@xref{Incrementing Example, , 带有增量计数器的循环示例}。)

@findex lengths-list-many-files
@need 1250
这些考虑直接引导我们到函数本身：

@smallexample
@group
;;; @r{使用 @code{while} 循环。}
(defun lengths-list-many-files (list-of-files)
  "返回 LIST-OF-FILES 中 @code{defuns} 的长度列表。"
@end group
@group
  (let (lengths-list)

;;; @r{真假测试}
    (while list-of-files
      (setq lengths-list
            (append
             lengths-list

;;; @r{生成长度列表。}
             (lengths-list-file
              (expand-file-name (car list-of-files)))))
@end group

@group
;;; @r{使文件列表变短。}
      (setq list-of-files (cdr list-of-files)))

;;; @r{返回长度列表的最终值。}
    lengths-list))
@end group
@end smallexample

@code{expand-file-name} 是一个内置函数，将文件名转换为绝对路径形式。该函数使用调用函数所在目录的名称。

@c !!! 22.1.1 lisp 源代码位置在这里
@need 1500
因此，如果在 Emacs 访问 @file{/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/} 目录时，对 @code{debug.el} 调用 @code{expand-file-name}，

@smallexample
debug.el
@end smallexample

@need 800
@noindent
变成了

@c !!! 22.1.1 lisp 源代码位置在这里
@smallexample
/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/debug.el
@end smallexample

该函数定义的另一个新元素是尚未学习的 @code{append} 函数，它值得有一个专门的小节。

@node append
@subsection @code{append} 函数

@need 800
@code{append} 函数将一个列表附加到另一个列表。因此，

@smallexample
(append '(1 2 3 4) '(5 6 7 8))
@end smallexample

@need 800
@noindent
产生了列表

@smallexample
(1 2 3 4 5 6 7 8)
@end smallexample

这正是我们希望将 @code{lengths-list-file} 生成的两个长度列表附加到一起的方式。与 @code{cons} 的结果形成对比，

@smallexample
(cons '(1 2 3 4) '(5 6 7 8))
@end smallexample

@need 1250
@noindent
它构造一个新列表，其中 @code{cons} 的第一个参数成为新列表的第一个元素：

@smallexample
((1 2 3 4) 5 6 7 8)
@end smallexample

@node Several files recursively
@section 递归计算不同文件中的单词数

除了使用 @code{while} 循环外，你还可以通过递归来处理文件列表中的每个文件。一个递归版本的 @code{lengths-list-many-files} 很短而简单。

递归函数具有通常的部分：再次执行测试、下一步表达式和递归调用。再次执行测试确定函数是否应该再次调用自身，如果 @code{list-of-files} 包含任何剩余元素，它将调用自身；下一步表达式将 @code{list-of-files} 重置为其自身的 @sc{cdr}，所以最终列表将为空；递归调用在较短的列表上调用自身。整个函数比这个描述还要短！
@findex recursive-lengths-list-many-files

@smallexample
@group
(defun recursive-lengths-list-many-files (list-of-files)
  "返回 LIST-OF-FILES 中每个 defun 的长度列表。"
  (if list-of-files                     ; @r{再次执行测试}
      (append
       (lengths-list-file
        (expand-file-name (car list-of-files)))
       (recursive-lengths-list-many-files
        (cdr list-of-files)))))
@end group
@end smallexample

@noindent
简而言之，该函数返回第一个 @code{list-of-files} 的长度列表，附加到对其余 @code{list-of-files} 调用自身的结果上。

这里是对 @code{recursive-lengths-list-many-files} 的测试，以及在每个文件上分别运行 @code{lengths-list-file} 的结果。

如果需要，安装 @code{recursive-lengths-list-many-files} 和 @code{lengths-list-file}，然后评估以下表达式。您可能需要更改文件的路径；这些路径在此 Info 文件和 Emacs 源代码位于其习惯位置时有效。要更改表达式，将其复制到 @file{*scratch*} 缓冲区，编辑它们，然后评估它们。

结果在 @samp{@result{}} 之后显示。（这些结果是针对 Emacs 版本 22.1.1 的文件；来自其他版本的 Emacs 的文件可能会产生不同的结果。）

@c !!! 22.1.1 lisp 源代码路径在此
@smallexample
@group
(cd "/usr/local/share/emacs/22.1.1/")

(lengths-list-file "./lisp/macros.el")
     @result{} (283 263 480 90)
@end group

@group
(lengths-list-file "./lisp/mail/mailalias.el")
     @result{} (38 32 29 95 178 180 321 218 324)
@end group

@group
(lengths-list-file "./lisp/hex-util.el")
     @result{} (82 71)
@end group

@group
  (recursive-lengths-list-many-files
   '("./lisp/macros.el"
     "./lisp/mail/mailalias.el"
     "./lisp/hex-util.el"))
       @result{} (283 263 480 90 38 32 29 95 178 180 321 218 324 82 71)
@end group
@end smallexample

@code{recursive-lengths-list-many-files} 函数产生了我们想要的输出。

下一步是准备列表中的数据以在图表中显示。

@node Prepare the data
@section 为在图表中显示准备数据

函数 @code{recursive-lengths-list-many-files} 返回一个数字列表。每个数字记录一个函数定义的长度。我们现在需要将这些数据转换为适合生成图表的数字列表。新列表将显示有多少个函数定义包含少于10个单词和符号，有多少个包含10到19个单词和符号，有多少个包含20到29个单词和符号，以此类推。

简而言之，我们需要遍历由 @code{recursive-lengths-list-many-files} 函数生成的长度列表，并统计每个长度范围内的 defuns 的数量，并生成一个包含这些数字的列表。

@menu
* Data for Display in Detail::
* Sorting::                     列表排序。
* Files List::                  制作文件列表。
* Counting function definitions::
@end menu

@ifnottex
@node Data for Display in Detail
@unnumberedsubsec 详细显示的数据
@end ifnottex

基于我们之前所做的工作，我们可以预见编写一个函数不会太难，该函数 @sc{cdr}s 下长度列表，查看每个元素，确定它属于哪个长度范围，并增加该范围的计数器。

然而，在开始编写这样一个函数之前，我们应该考虑先对长度列表进行排序的优势，以便数字按从小到大的顺序排列。首先，排序将使在每个范围内计数数字变得更容易，因为两个相邻的数字要么在相同的长度范围内，要么在相邻的范围内。其次，通过检查已排序的列表，我们可以发现最高和最低的数字，从而确定我们将需要的最大和最小长度范围。

@node Sorting
@subsection 列表排序
@findex sort

Emacs 包含一个用于排序列表的函数，称为（你可能猜到的）@code{sort}。@code{sort} 函数接受两个参数，要排序的列表和一个断言，该断言确定两个列表元素中的第一个是否小于第二个。

正如我们之前所见（@pxref{Wrong Type of Argument, , 使用错误类型的对象作为参数}），断言是确定某个属性是真还是假的函数。@code{sort} 函数将根据断言使用的任何属性重新排序列表；这意味着 @code{sort} 可以根据非数值标准对非数值列表进行排序---例如，它可以对列表进行字母排序。

@need 1250
在对数值列表进行排序时，使用函数 @code{<}。例如，

@smallexample
(sort '(4 8 21 17 33 7 21 7) '<)
@end smallexample

@need 800
@noindent
产生以下结果：

@smallexample
(4 7 7 8 17 21 21 33)
@end smallexample

@noindent
（请注意，在此示例中，两个参数都引用了，以便在传递给 @code{sort} 之前不对符号进行求值。）

对由 @code{recursive-lengths-list-many-files} 函数返回的列表进行排序很简单；它使用 @code{<} 函数：

@smallexample
@group
(sort
 (recursive-lengths-list-many-files
  '("./lisp/macros.el"
    "./lisp/mailalias.el"
    "./lisp/hex-util.el"))
 '<)
@end group
@end smallexample

@need 800
@noindent
产生以下结果：

@smallexample
(29 32 38 71 82 90 95 178 180 218 263 283 321 324 480)
@end smallexample

@noindent
（请注意，在此示例中，@code{sort} 的第一个参数未引用，因为必须评估表达式以产生传递给 @code{sort} 的列表。）

@node Files List
@subsection 创建文件列表

函数 @code{recursive-lengths-list-many-files} 需要一个文件列表作为其参数。在我们的测试示例中，我们手工构建了这样一个列表；但是 Emacs Lisp 源代码目录太大，我们无法手动创建。相反，我们将编写一个函数来为我们完成这个任务。在这个函数中，我们将同时使用 @code{while} 循环和递归调用。

@findex directory-files
在旧版本的 GNU Emacs 中，我们无需编写这样的函数，因为它们将所有的 @samp{.el} 文件放在一个目录中。相反，我们可以使用 @code{directory-files} 函数，该函数列出了匹配指定模式的文件的名称，该模式在单个目录中。

然而，最近的 Emacs 版本将 Emacs Lisp 文件放在顶层 @file{lisp} 目录的子目录中。这种重新排列方便了导航。例如，所有与邮件相关的文件都在名为 @file{mail} 的 @file{lisp} 子目录中。但与此同时，这种排列方式迫使我们创建一个能够进入子目录的文件列表函数。

@findex files-in-below-directory
我们可以使用熟悉的函数，如 @code{car}、@code{nthcdr} 和 @code{substring}，以及一个名为 @code{directory-files-and-attributes} 的现有函数来创建这个函数。这个后者不仅列出目录中所有文件的名称，包括子目录的名称，还列出它们的属性。

重新表述我们的目标：创建一个函数，使我们能够将文件名作为一个列表传递给 @code{recursive-lengths-list-many-files}，该列表看起来像这样（但元素更多）：

@smallexample
@group
("./lisp/macros.el"
 "./lisp/mail/rmail.el"
 "./lisp/hex-util.el")
@end group
@end smallexample

@code{directory-files-and-attributes} 函数返回一个列表的列表。主列表中的每个列表都包含13个元素。列表的第一个元素是包含文件的名称的字符串，在 GNU/Linux 中，它可能是一个 @dfn{目录文件}，也就是说，具有目录的特殊属性的文件。列表的第二个元素是目录的 @code{t}，符号链接的字符串（字符串是链接到的名称），或 @code{nil}。

例如，@file{lisp/} 目录中的第一个 @samp{.el} 文件是 @file{abbrev.el}。它的名称是 @file{/usr/local/share/emacs/22.1.1/lisp/abbrev.el}，它既不是目录也不是符号链接。

@need 1000
以下是 @code{directory-files-and-attributes} 如何列出该文件及其属性的方式：

@smallexample
@group
("abbrev.el"
nil
1
1000
100
@end group
@group
(20615 27034 579989 697000)
(17905 55681 0 0)
(20615 26327 734791 805000)@footnote{如果 @code{current-time-list} 是 @code{nil}，则三个时间戳分别为 @code{(1351051674579989697 . 1000000000)}，@code{(1173477761000000000 . 1000000000)} 和 @code{(1351050967734791805 . 1000000000)}。}
13188
"-rw-r--r--"
@end group
@group
t
2971624
773)
@end group
@end smallexample

@need 1200
另一方面，@file{mail/} 是 @file{lisp/} 目录中的一个子目录。其列表的开头看起来像这样：

@smallexample
@group
("mail"
t
@dots{}
)
@end group
@end smallexample

（要了解不同属性，请查看 @code{file-attributes} 的文档。请注意，@code{file-attributes} 函数不会列出文件名，因此它的第一个元素是 @code{directory-files-and-attributes} 的第二个元素。）

我们希望我们的新函数 @code{files-in-below-directory} 能够列出它被告知检查的目录以及该目录下的任何子目录中的 @samp{.el} 文件。

这为我们提供了构建 @code{files-in-below-directory} 的线索：在目录内，该函数应该将 @samp{.el} 文件名添加到列表中；而如果在目录内，该函数遇到子目录，它应该进入该子目录并重复其操作。

然而，我们应该注意到每个目录都包含一个指向自身的名称，称为 @file{.}（“点”），以及一个指向其父目录的名称，称为 @file{..}（“点 点”）。 （在 @file{/}，即根目录中，@file{..} 指向它自己，因为 @file{/} 没有父目录。）显然，我们不希望我们的 @code{files-in-below-directory} 函数进入这些目录，因为它们始终直接或间接地导致当前目录。

因此，我们的 @code{files-in-below-directory} 函数必须执行几个任务：

@itemize @bullet
@item
检查是否正在查看以 @samp{.el} 结尾的文件名；如果是，则将其名称添加到列表中。

@item
检查是否正在查看是目录的名称；如果是，

@itemize @minus
@item
检查是否正在查看 @file{.} 或 @file{..}；如果是，则跳过。

@item
否则，进入该目录并重复过程。
@end itemize
@end itemize

让我们编写一个函数定义来执行这些任务。我们将使用一个 @code{while} 循环来在目录中从一个文件名移动到另一个文件名，检查需要执行的操作；我们将使用递归调用来在每个子目录上重复这些操作。递归模式是 Accumulate（@pxref{Accumulate}），使用 @code{append} 作为组合器。

@ignore
(directory-files "/usr/local/src/emacs/lisp/" t "\\.el$")
(shell-command "find /usr/local/src/emacs/lisp/ -name '*.el'")

(directory-files "/usr/local/share/emacs/22.1.1/lisp/" t "\\.el$")
(shell-command "find /usr/local/share/emacs/22.1.1/lisp/ -name '*.el'")
@end ignore

@c  /usr/local/share/emacs/22.1.1/lisp/

@need 800
以下是该函数：

@smallexample
@group
(defun files-in-below-directory (directory)
  "列出 DIRECTORY 及其子目录中的 .el 文件。"
  ;; 尽管该函数将被非交互地使用，
  ;; 但如果我们将其设置为交互式，测试将更容易。
  ;; 目录的名称将类似于
  ;; "/usr/local/share/emacs/22.1.1/lisp/"
  (interactive "DDirectory name: ")
@end group
@group
  (let (el-files-list
        (current-directory-list
         (directory-files-and-attributes directory t)))
    ;; 当我们在当前目录中时
    (while current-directory-list
@end group
@group
      (cond
       ;; 检查文件名是否以 '.el' 结尾
       ;; 如果是，则将其名称添加到列表中。
       ((equal ".el" (substring (car (car current-directory-list)) -3))
        (setq el-files-list
              (cons (car (car current-directory-list)) el-files-list)))
@end group
@group
       ;; 检查文件名是否是目录的名称
       ((eq t (car (cdr (car current-directory-list))))
        ;; 决定是跳过还是递归
        (if
            (equal "."
                   (substring (car (car current-directory-list)) -1))
            ;; 然后什么都不做，因为文件名是
            ;;   当前目录或父目录的名称，"." 或 ".."
            ()
@end group
@group
          ;; 否则，进入该目录并重复过程
          (setq el-files-list
                (append
                 (files-in-below-directory
                  (car (car current-directory-list)))
                 el-files-list)))))
      ;; 移动到列表中的下一个文件名；这也
      ;; 缩短列表，因此 while 循环最终会结束
      (setq current-directory-list (cdr current-directory-list)))
    ;; 返回文件名
    el-files-list))
@end group
@end smallexample

@c (files-in-below-directory "/usr/local/src/emacs/lisp/")
@c (files-in-below-directory "/usr/local/share/emacs/22.1.1/lisp/")

@code{files-in-below-directory} @code{directory-files} 函数接受一个参数，即目录的名称。

@need 1250
因此，在我的系统上，

@c (length (files-in-below-directory "/usr/local/src/emacs/lisp/"))

@c !!! 22.1.1 lisp 源代码的位置在这里
@smallexample
@group
(length
 (files-in-below-directory "/usr/local/share/emacs/22.1.1/lisp/"))
@end group
@end smallexample

@noindent
告诉我，在我的 Lisp 源代码目录及其子目录中有 1031 个 @samp{.el} 文件。

@code{files-in-below-directory} 以字母顺序的逆序返回一个列表。将列表按字母顺序排序的表达式如下：

@smallexample
@group
(sort
 (files-in-below-directory "/usr/local/share/emacs/22.1.1/lisp/")
 'string-lessp)
@end group
@end smallexample

@ignore
(defun test ()
  "测试查找所有排序的 elisp defuns 的长度所需的时间。"
  (insert "\n" (current-time-string) "\n")
  (sit-for 0)
  (sort
   (recursive-lengths-list-many-files
    (files-in-below-directory "/usr/local/src/emacs/lisp/"))
   '<)
  (insert (current-time-string)))
@end ignore

@node Counting function definitions
@subsection 统计函数定义数量

我们的即时目标是生成一个列表，告诉我们有多少个函数定义包含少于10个字和符号，有多少包含10到19个字和符号，有多少包含20到29个字和符号，依此类推。

有了一个排序过的数字列表，这很容易实现：统计列表中有多少元素小于10，然后在移过刚刚计数的数字后，统计列表中有多少元素小于20，然后在移过刚刚计数的数字后，统计列表中有多少元素小于30，依此类推。每个数字，10、20、30、40以及类似的，都比该范围的顶部大1。我们可以称这个数字列表为@code{top-of-ranges}列表。

@need 1200
如果愿意，我们可以自动生成这个列表，但手动编写列表更简单。下面是一个例子：
@vindex top-of-ranges

@smallexample
@group
(defvar top-of-ranges
 '(10  20  30  40  50
   60  70  80  90 100
  110 120 130 140 150
  160 170 180 190 200
  210 220 230 240 250
  260 270 280 290 300)
 "指定 `defuns-per-range' 的范围的列表。")
@end group
@end smallexample

要更改范围，我们编辑此列表。

接下来，我们需要编写一个函数，该函数创建包含在每个范围内的定义数量列表。显然，此函数必须将@code{sorted-lengths}和@code{top-of-ranges}列表作为参数。

@code{defuns-per-range} 函数必须反复执行两件事：它必须计算在当前顶部范围值指定的范围内的定义数量；并且在计算当前范围内的定义数量后，它必须转移到@code{top-of-ranges}列表中的下一个更高的值。由于每个动作都是重复的，我们可以使用@code{while}循环完成这项工作。一个循环计算当前范围内的定义数量，另一个循环依次选择@code{top-of-ranges}中的每个顶部范围值。

@need 1250
@code{sorted-lengths} 列表的每个条目都会计数多次，这意味着@code{sorted-lengths}列表的循环将在@code{top-of-ranges}列表的循环内部，就像小齿轮在大齿轮内部一样。

内部循环计算范围内的定义数量。它是我们之前见过的简单计数循环的类型。(@xref{Incrementing Loop, , 具有增量计数器的循环}.) 循环的真假测试测试@code{sorted-lengths} 列表中的值是否小于范围顶部的当前值。如果是，则函数增加计数器并测试@code{sorted-lengths}列表的下一个值。

@need 1250
内部循环如下：

@smallexample
@group
(while @var{length-element-smaller-than-top-of-range}
  (setq number-within-range (1+ number-within-range))
  (setq sorted-lengths (cdr sorted-lengths)))
@end group
@end smallexample

外部循环必须从@code{top-of-ranges}列表的最小值开始，然后依次设置为每个后续更高的值。可以使用如下循环实现：

@smallexample
@group
(while top-of-ranges
  @var{body-of-loop}@dots{}
  (setq top-of-ranges (cdr top-of-ranges)))
@end group
@end smallexample

@need 1200
组合在一起，两个循环如下：

@smallexample
@group
(while top-of-ranges

  ;; @r{计算当前范围内的元素数量。}
  (while @var{length-element-smaller-than-top-of-range}
    (setq number-within-range (1+ number-within-range))
    (setq sorted-lengths (cdr sorted-lengths)))

  ;; @r{移到下一个范围。}
  (setq top-of-ranges (cdr top-of-ranges)))
@end group
@end smallexample

此外，在外部循环的每一次迭代中，Emacs应该记录该范围内的定义数量（@code{number-within-range}的值）到一个列表中。我们可以使用@code{cons}来完成这个目的。(@xref{cons, , @code{cons}}.)

@code{cons}函数运行正常，但它构造的列表将以最大范围的定义数量开头，并以最小范围的定义数量结尾。这是因为@code{cons}将新元素附加到列表的开头，而由于两个循环从较低端开始遍历长度的列表，因此@code{defuns-per-range-list}将以最大的数字开始。但我们希望以最小值优先打印我们的图形，然后再打印较大的值。解决方案是颠倒@code{defuns-per-range-list}的顺序。我们可以使用@code{nreverse}函数实现这一点，该函数颠倒列表的顺序。
@findex nreverse

@need 800
例如，

@smallexample
(nreverse '(1 2 3 4))
@end smallexample

@need 800
@noindent
产生：

@smallexample
(4 3 2 1)
@end smallexample

请注意，@code{nreverse}函数是破坏性的---也就是说，它改变了其应用的列表；这与@code{car}和@code{cdr}函数不同，它们是非破坏性的。在这种情况下，我们不需要原始的@code{defuns-per-range-list}，因此它被销毁并不重要。(@code{reverse}函数提供列表的反向副本，保留原始列表不变。) 
@findex reverse

@need 1250
全部组合在一起，@code{defuns-per-range}如下：

@smallexample
@group
(defun defuns-per-range (sorted-lengths top-of-ranges)
  "在每个TOP-OF-RANGES范围内，对SORTED-LENGTHS进行函数定义。"
  (let ((top-of-range (car top-of-ranges))
        (number-within-range 0)
        defuns-per-range-list)
@end group

@group
    ;; @r{外部循环。}
    (while top-of-ranges
@end group

@group
      ;; @r{内部循环。}
      (while (and
              ;; @r{需要用于数字测试的数字。}
              (car sorted-lengths)
              (< (car sorted-lengths) top-of-range))
@end group

@group
        ;; @r{计算当前范围内的定义数量。}
        (setq number-within-range (1+ number-within-range))
        (setq sorted-lengths (cdr sorted-lengths)))

      ;; @r{退出内部循环但仍保持在外部循环中。}
@end group

@group
      (setq defuns-per-range-list
            (cons number-within-range defuns-per-range-list))
      (setq number-within-range 0)      ; @r{将计数器重置为零。}
@end group

@group
      ;; @r{移至下一个范围。}
      (setq top-of-ranges (cdr top-of-ranges))
      ;; @r{指定下一个范围的顶部值。}
      (setq top-of-range (car top-of-ranges)))
@end group

@group
    ;; @r{退出外部循环并计算大于}
    ;; @r{最大顶部范围值的函数数量。}
    (setq defuns-per-range-list
          (cons
           (length sorted-lengths)
           defuns-per-range-list))
@end group

@group
    ;; @r{返回每个范围内定义数量的列表，}
    ;; @r{从最小到最大。}
    (nreverse defuns-per-range-list)))
@end group
@end smallexample

@need 1200
@noindent
该函数很直观，除了一个微妙的特征。内部循环的真假测试看起来像这样：

@smallexample
@group
(and (car sorted-lengths)
     (< (car sorted-lengths) top-of-range))
@end group
@end smallexample

@need 800
@noindent
而不是像这样：

@smallexample
(< (car sorted-lengths) top-of-range)
@end smallexample

该测试的目的是确定@code{sorted-lengths}列表中的第一个项是否小于范围顶部的值。

简单版本的测试很好，除非@code{sorted-lengths}列表有一个@code{nil}值。在这种情况下，@code{(car sorted-lengths)} 表达式函数返回@code{nil}。@code{<}函数无法将数字与@code{nil}（一个空列表）进行比较，因此Emacs会发出错误并阻止函数继续执行。

当计数器达到列表末尾时，@code{sorted-lengths}列表始终变为@code{nil}。这意味着任何尝试使用简单版本测试的@code{defuns-per-range}函数都将失败。

我们通过使用@code{(car sorted-lengths)} 表达式与@code{and} 表达式结合来解决问题。@code{(car sorted-lengths)} 表达式只要列表中至少有一个数字，就会返回非@code{nil}值，但如果列表为空，则返回@code{nil}。@code{and} 表达式首先评估@code{(car sorted-lengths)} 表达式，如果它是@code{nil}，则@emph{不}评估@code{<} 表达式，直接返回false。但如果@code{(car sorted-lengths)} 表达式返回非@code{nil}值，则@code{and} 表达式评估@code{<} 表达式，并将该值作为@code{and} 表达式的值返回。

@c 在打印的章节标题中的冒号会导致Info交叉引用问题
这样，我们避免了错误。
@iftex
@noindent
(有关@code{and}的信息，请参阅
@ref{kill-new function, , @code{kill-new}函数}.)
@end iftex
@ifinfo
@noindent
(有关@code{and}的信息，请参阅@code{kill-new}函数
@xref{kill-new function, , @code{kill-new}函数}.)
@end ifinfo

以下是对@code{defuns-per-range}函数的简短测试。首先，评估将（缩短的）@code{top-of-ranges} 列表绑定到值列表的表达式，然后评估绑定@code{sorted-lengths} 列表的表达式，最后评估@code{defuns-per-range}函数。

@smallexample
@group
;; @r{(比我们稍后将使用的列表更短.)}
(setq top-of-ranges
 '(110 120 130 140 150
   160 170 180 190 200))

(setq sorted-lengths
      '(85 86 110 116 122 129 154 176 179 200 265 300 300))

(defuns-per-range sorted-lengths top-of-ranges)
@end group
@end smallexample

@need 800
@noindent
返回的列表如下：

@smallexample
(2 2 2 0 0 1 0 2 0 0 4)
@end smallexample

@noindent
确实，@code{sorted-lengths}列表中有两个小于110的元素，两个元素介于 110 和 119 之间，两个元素介于 120 和 129 之间，依此类推。有四个值等于或大于 200 的元素。

@c The next step is to turn this numbers' list into a graph.
@node Readying a Graph
@chapter 准备图表
@cindex 准备图表
@cindex 图表原型
@cindex 原型图表
@cindex 图表主体

我们的目标是构建一个图表，显示Emacs Lisp源代码中各个长度的函数定义数量。

实际上，如果你要创建一个图表，你可能会使用诸如@code{gnuplot}等程序来完成这项工作。
（@code{gnuplot}已经很好地集成到GNU Emacs中。）但在这种情况下，我们将从头开始创建一个图表，
在这个过程中，我们将重新熟悉之前学到的一些知识，并学到更多。

在这一章中，我们将首先编写一个简单的图表打印函数。这个初步定义将是一个@dfn{原型}，
一个迅速编写的函数，使我们能够侦察这个未知的制图领域。我们将发现是否存在困难，或者它们只是虚构。
在侦察完地形后，我们将更加自信，并增强该函数以自动标记坐标轴。

@menu
* Columns of a graph::
* graph-body-print::            如何打印图表的主体。
* recursive-graph-body-print::
* Printed Axes::
* Line Graph Exercise::
@end menu

@ifnottex
@node Columns of a graph
@unnumberedsec 打印图表的列
@end ifnottex

由于Emacs被设计为灵活且适用于各种终端，包括字符终端，图表需要由打字机符号之一制作。
星号就可以；随着图表打印函数的改进，我们可以选择使用用户选项来指定符号。

我们可以将这个函数称为@code{graph-body-print}；它将以@code{numbers-list}作为其唯一参数。
在这个阶段，我们不会为图表标记，而只会打印其主体。

@code{graph-body-print}函数为@code{numbers-list}中的每个元素插入一个垂直的星号列。
每行的高度由@code{numbers-list}的该元素的值确定。

插入列是一种重复性的操作；这意味着可以使用@code{while}循环或递归来编写此函数。

我们的第一个挑战是发现如何打印星号列。通常，在Emacs中，我们通过逐行输入以水平方式将字符打印到屏幕上。
我们有两条路可以走：编写我们自己的列插入函数或发现Emacs中是否存在这样一个函数。

为了查看Emacs中是否存在这样的函数，我们可以使用@kbd{M-x apropos}命令。此命令类似于@kbd{C-h a}（@code{command-apropos}）命令，
但后者仅找到命令函数。@kbd{M-x apropos}命令列出与正则表达式匹配的所有符号，包括不是交互式的函数。
@findex apropos

我们要寻找的是某个打印或插入列的命令。很可能，该函数的名称将包含“print”或“insert”或“column”这个词。
因此，我们可以简单地输入@kbd{M-x apropos @key{RET} print\|insert\|column @key{RET}}并查看结果。
在我的系统上，这个命令曾经花费了相当长的时间，然后产生了一个包含79个函数和变量的列表。现在它几乎不花费任何时间，
并生成包含211个函数和变量的列表。在列表中扫描，唯一看起来可能完成这项工作的函数是@code{insert-rectangle}。

@need 1200
事实上，这正是我们想要的函数；其文档如下：

@smallexample
@group
insert-rectangle:
在点的上左角插入RECTANGLE的文本。
RECTANGLE的第一行插入在点处，
其第二行插入在点的下面的垂直位置，依此类推。
RECTANGLE应该是一个字符串列表。
此命令执行后，标记位于左上角，
点位于右下角。
@end group
@end smallexample

我们可以进行一次快速测试，确保它能够按照我们的期望工作。

在将光标放在@code{insert-rectangle}表达式之后，键入@kbd{C-u C-x C-e}（@code{eval-last-sexp}），
以下是在点和下面插入了字符串@samp{"first"}、@samp{"second"}和@samp{"third"}的函数结果。
此外，该函数返回@code{nil}。

@smallexample
@group
(insert-rectangle '("first" "second" "third"))first
                                              second
                                              thirdnil
@end group
@end smallexample

@noindent
当然，我们不会将@code{insert-rectangle}表达式本身的文本插入我们正在创建图表的缓冲区，
而是将从我们的程序中调用该函数。但是，我们必须确保点在缓冲区中@code{insert-rectangle}函数将插入其列的位置。

如果您在Info中阅读此内容，您可以通过切换到另一个缓冲区，例如@file{*scratch*}缓冲区，
将点放在缓冲区的某个位置，键入@kbd{M-:}，在提示符处键入@code{insert-rectangle}表达式，
然后键入@key{RET}。这会导致Emacs在小缓冲区中评估表达式，但将点的值用作@file{*scratch*}缓冲区中点的位置的值。
（@kbd{M-:}是@code{eval-expression}的键绑定。此外，由于表达式在小缓冲区中评估，因此@code{nil}不会出现在@file{*scratch*}缓冲区中，
因为表达式在小缓冲区中评估。）

当我们这样做时，我们发现点最终位于最后插入行的末尾——也就是说，此函数将点作为副作用移动了。
如果我们在此位置重复命令，将点放在此位置，下一个插入将在上一个插入的下方和右侧。
我们不想要这个！如果我们要制作一个条形图，那么列需要相互并列。

因此，我们发现列插入@code{while}循环的每个周期必须将点重新定位到我们想要的位置，
并且该位置将位于列的顶部而不是底部。此外，我们记得当打印图表时，我们不希望所有列的高度都相同。
这意味着每个列的顶部可能与前一个列的顶部高度不同。我们不能简单地将点重新定位到相同的行，而是可能移到右边……。

我们计划使用星号制作条形图的列。列中的星号数量是由@code{numbers-list}的当前元素指定的数量。
我们需要构建一个合适长度的星号列表，以便每次调用@code{insert-rectangle}时都会插入正确的位置。

如果此列表仅包含所需数量的星号，则必须为图的打印正确位置将点移动到图的基础上方的正确行。
这可能会很困难。

另一方面，如果我们可以找到一种方法，将@code{insert-rectangle}传递一个每次都是相同长度的列表，
那么我们就可以每次都将点放在相同的行上，但对于每个新列都将其右移一列。如果这样做，那么传递给@code{insert-rectangle}的列表中的一些条目必须是空白，而不是星号。
例如，如果图的最大高度为5，但列的高度为3，则@code{insert-rectangle}需要一个参数，如下所示：

@smallexample
(" " " " "*" "*" "*")
@end smallexample

最后的提议并不那么困难，只要我们能确定列高度。我们有两种方法来指定列高度：我们可以任意规定它将是多少，这对于该高度的图表是可以的；
或者我们可以搜索数字列表，将其最大高度用作图的最大高度。如果后者的操作很困难，那么前者的过程将是最简单的，
但是Emacs内置了一个确定其参数的最大值的函数。我们可以使用该函数。该函数称为@code{max}，它返回其参数的最大值，这些参数必须是数字。例如，

@smallexample
(max  3 4 6 5 7 3)
@end smallexample

@noindent
返回7。（相应的函数称为@code{min}，返回其参数的最小值。）
@findex max
@findex min

但我们不能简单地在@code{numbers-list}上调用@code{max}函数；@code{max}函数期望数字作为其参数，而不是数字列表。
因此，以下表达式，

@smallexample
(max  '(3 4 6 5 7 3))
@end smallexample

@need 800
@noindent
产生以下错误消息：

@smallexample
Wrong type of argument:  number-or-marker-p, (3 4 6 5 7 3)
@end smallexample

@findex apply
我们需要一个函数，将参数列表传递给函数。这个函数是@code{apply}。该函数将其第一个参数（函数）应用于其余的参数，
其中最后一个参数可以是一个列表。

@need 1250
例如，

@smallexample
(apply 'max 3 4 7 3 '(4 8 5))
@end smallexample

@noindent
返回8。

（顺便说一下，如果没有像这样的书，我不知道您将如何了解此函数。通过猜测其名称的一部分，然后使用@code{apropos}，
可以发现其他函数，如@code{search-forward}或@code{insert-rectangle}。尽管它在隐喻上的基础很清晰——将其第一个参数应用于其余部分——但我怀疑初学者在使用@code{apropos}或其他工具时是否会想到使用这个特定的词。当然，我可能是错的；毕竟，首次命名该函数的人必须发明它。）

@code{apply}的第二个和后续的参数是可选的，因此我们可以使用@code{apply}来调用一个函数并将其列表元素传递给它，
就像这样，它也返回8：

@smallexample
(apply 'max '(4 8 5))
@end smallexample

我们将使用@code{apply}的这种方式。@code{recursive-lengths-list-many-files}函数返回一个数字列表，
我们可以将@code{max}应用于它（我们也可以将@code{max}应用于排序后的数字列表；列表是否排序都无关紧要）。

@need 800
因此，找到图的最大高度的操作是这样的：

@smallexample
(setq max-graph-height (apply 'max numbers-list))
@end smallexample

现在我们可以回到创建图表列的问题。告诉了图的最大高度和列中星号的数量后，
函数应返回@code{insert-rectangle}命令插入的列表。

每一列由星号或空格组成。由于函数传递了列的高度和列中星号的数量，因此可以通过从列的高度中减去星号的数量来找到空格的数量。给定空格的数量和星号的数量，可以使用两个 @code{while} 循环构造列表：

@smallexample
@group
;;; @r{第一个版本。}
(defun column-of-graph (max-graph-height actual-height)
  "返回一个图表列的字符串列表。"
  (let ((insert-list nil)
        (number-of-top-blanks
         (- max-graph-height actual-height)))
@end group

@group
    ;; @r{填充星号。}
    (while (> actual-height 0)
      (setq insert-list (cons "*" insert-list))
      (setq actual-height (1- actual-height)))
@end group

@group
    ;; @r{填充空格。}
    (while (> number-of-top-blanks 0)
      (setq insert-list (cons " " insert-list))
      (setq number-of-top-blanks
            (1- number-of-top-blanks)))
@end group

@group
    ;; @r{返回整个列表。}
    insert-list))
@end group
@end smallexample

如果安装了此函数，然后评估以下表达式，您将看到它按预期返回列表：

@smallexample
(column-of-graph 5 3)
@end smallexample

@need 800
@noindent
返回

@smallexample
(" " " " "*" "*" "*")
@end smallexample

如上所写，@code{column-of-graph} 包含一个主要缺陷：用于空白和列中标记条目的符号是硬编码的，分别是空格和星号。这对于原型来说是可以的，但您或其他用户可能希望使用其他符号。例如，在测试图函数时，您可能想要使用句点代替空格，以确保每次调用 @code{insert-rectangle} 函数时点被正确重新定位；或者您可能想要用 @samp{+} 符号或其他符号替换星号。您甚至可能希望创建一个宽度超过一个显示列的图表列。程序应该更加灵活。为了实现这一点，我们可以用两个变量 @code{graph-blank} 和 @code{graph-symbol} 替换空白和星号，并分别定义这两个变量。

此外，文档写得不好。这些考虑因素引导我们到函数的第二个版本：

@smallexample
@group
(defvar graph-symbol "*"
  "用于图表的符号字符串，通常是星号。")
@end group

@group
(defvar graph-blank " "
  "用于图表的空白字符串，通常是空格。
graph-blank 的宽度必须与 graph-symbol 相同。")
@end group
@end smallexample

@noindent
（有关 @code{defvar} 的解释，请参见 @ref{defvar, , 用 @code{defvar} 初始化变量}。）

@smallexample
@group
;;; @r{第二个版本。}
(defun column-of-graph (max-graph-height actual-height)
  "返回 MAX-GRAPH-HEIGHT 个字符串；ACTUAL-HEIGHT 是图表符号。

@end group
@group
图表符号是列表末尾的连续条目。
列表将作为图表的一列插入。
这些字符串要么是 graph-blank，要么是 graph-symbol。"
@end group

@group
  (let ((insert-list nil)
        (number-of-top-blanks
         (- max-graph-height actual-height)))
@end group

@group
    ;; @r{填充 @code{graph-symbols}。}
    (while (> actual-height 0)
      (setq insert-list (cons graph-symbol insert-list))
      (setq actual-height (1- actual-height)))
@end group

@group
    ;; @r{填充 @code{graph-blanks}。}
    (while (> number-of-top-blanks 0)
      (setq insert-list (cons graph-blank insert-list))
      (setq number-of-top-blanks
            (1- number-of-top-blanks)))

    ;; @r{返回整个列表。}
    insert-list))
@end group
@end smallexample

如果我们愿意，我们可以再次重写 @code{column-of-graph}，以提供线图和条形图的可选支持。这不难做到。想象一下线图不过是每个条的顶部以下部分为空格的条形图。为了构建线图的列，该函数首先构建一个比值短一的空格列表，然后使用 @code{cons} 将图符附加到列表；然后再次使用 @code{cons} 将顶部空格附加到列表。

容易看出如何编写这样的函数，但由于我们不需要它，我们将不予实现。但是这项工作是可以完成的，如果完成了，将使用 @code{column-of-graph} 完成。更重要的是，几乎不需要在任何其他地方进行更改。如果我们有兴趣进行增强，这是个简单的任务。

现在，最后，我们来到我们的第一个实际图表打印函数。这将打印图表的主体，而不是垂直和水平轴的标签，因此我们可以称其为 @code{graph-body-print}。

@node graph-body-print
@section 函数 @code{graph-body-print}
@findex graph-body-print

在前一节的准备工作完成后，@code{graph-body-print} 函数就很简单了。该函数将按列打印星号和空格，使用数字列表中的元素来指定每列中星号的数量。这是一个重复的操作，这意味着我们可以使用递减的 @code{while} 循环或递归函数来完成这项工作。在本节中，我们将使用 @code{while} 循环来编写定义。

@code{column-of-graph} 函数需要图表的高度作为参数，因此我们应该确定并记录它作为一个局部变量。

这导致了以下 @code{while} 循环版本的函数模板：

@smallexample
@group
(defun graph-body-print (numbers-list)
  "@var{文档}@dots{}"
  (let ((height  @dots{}
         @dots{}))
@end group

@group
    (while numbers-list
      @var{插入列并重新定位点}
      (setq numbers-list (cdr numbers-list)))))
@end group
@end smallexample

@noindent
我们需要填写模板的空白部分。

显然，我们可以使用表达式 @code{(apply 'max numbers-list)} 来确定图表的高度。

@code{while} 循环将逐个元素循环遍历 @code{numbers-list}。由于它被 @code{(setq numbers-list (cdr numbers-list))} 表达式缩短，列表的每个实例的 @sc{car} 是传递给 @code{column-of-graph} 的参数值。

在 @code{while} 循环的每个循环中，@code{insert-rectangle} 函数插入由 @code{column-of-graph} 返回的列表。由于 @code{insert-rectangle} 函数将点移动到插入的矩形的右下角，我们需要保存矩形插入时点的位置，在插入矩形后返回到该位置，然后水平移动到下一个调用 @code{insert-rectangle} 的位置。

如果插入的列只有一个字符宽，就像使用单个空格和星号时一样，重新定位命令就是简单的 @code{(forward-char 1)}；然而，列的宽度可能大于一个字符。这意味着重新定位命令应该写为 @code{(forward-char symbol-width)}。@code{symbol-width} 本身是一个 @code{graph-blank} 的长度，可以使用表达式 @code{(length graph-blank)} 找到。将 @code{symbol-width} 变量绑定到图列的宽度值的最佳位置是在 @code{let} 表达式的 varlist 中。

这些考虑导致了以下函数定义：

@smallexample
@group
(defun graph-body-print (numbers-list)
  "打印 NUMBERS-LIST 的条形图。
numbers-list 由 Y 轴的值组成。"

  (let ((height (apply 'max numbers-list))
        (symbol-width (length graph-blank))
        from-position)
@end group

@group
    (while numbers-list
      (setq from-position (point))
      (insert-rectangle
       (column-of-graph height (car numbers-list)))
      (goto-char from-position)
      (forward-char symbol-width)
@end group
@group
      ;; @r{逐列绘制图形。}
      (sit-for 0)
      (setq numbers-list (cdr numbers-list)))
@end group
@group
    ;; @r{为 X 轴标签定位点。}
    (forward-line height)
    (insert "\n")
))
@end group
@end smallexample

@noindent
这个函数中唯一意外的表达式是 @w{@code{(sit-for 0)}} 表达式在 @code{while} 循环中。这个表达式使得图形打印操作比没有它更有趣。该表达式导致 Emacs 在零时间内“坐下”或什么都不做，然后重新绘制屏幕。放在这里，它导致 Emacs 逐列重新绘制屏幕。如果没有它，Emacs 将在函数退出时才重新绘制屏幕。

我们可以使用一组短数字列表测试 @code{graph-body-print}。

@enumerate
@item
安装 @code{graph-symbol}、@code{graph-blank}、
@code{column-of-graph}，它们在
@iftex
@ref{Readying a Graph, , Readying a Graph},
@end iftex
@ifnottex
@ref{Columns of a graph},
@end ifnottex
以及 @code{graph-body-print}。

@need 800
@item
复制以下表达式：

@smallexample
(graph-body-print '(1 2 3 4 6 4 3 5 7 6 5 2 3))
@end smallexample

@item
切换到 @file{*scratch*} 缓冲区，并将光标放在要开始绘制图表的位置。

@item
输入 @kbd{M-:} (@code{eval-expression}).

@item
使用 @kbd{C-y} (@code{yank}) 将 @code{graph-body-print} 表达式粘贴到迷你缓冲区中。

@item
按 @key{RET} 以评估 @code{graph-body-print} 表达式。
@end enumerate

@need 800
Emacs 将打印一个类似于以下的图形：

@smallexample
@group
                    *
                *   **
                *  ****
               *** ****
              ********* *
             ************
            *************
@end group
@end smallexample

@node recursive-graph-body-print
@section 函数 @code{recursive-graph-body-print}
@findex recursive-graph-body-print

函数 @code{graph-body-print} 也可以使用递归的方式来实现。递归解决方案分为两部分：一个外部包装器，它使用 @code{let} 表达式确定一些变量的值，这些变量只需找到一次，例如图形的最大高度；以及一个内部函数，该函数被递归调用以打印图形。

@need 1250
外部包装器比较简单：

@smallexample
@group
(defun recursive-graph-body-print (numbers-list)
  "打印 NUMBERS-LIST 的条形图。"
  (let ((height (apply 'max numbers-list))
        (symbol-width (length graph-blank))
        from-position)
    (recursive-graph-body-print-internal
     numbers-list
     height
     symbol-width)))
@end group
@end smallexample

递归函数稍微复杂一些。它分为四个部分：再次执行测试、打印代码、递归调用和下一步表达式。再次执行测试是一个 @code{when} 表达式，用于确定 @code{numbers-list} 是否包含任何剩余元素；如果包含，则该函数使用打印代码打印图的一列，并再次调用自身。函数再次调用自身的依据是下一步表达式产生的值，该值导致调用作用在 @code{numbers-list} 的较短版本上。

@smallexample
@group
(defun recursive-graph-body-print-internal
  (numbers-list height symbol-width)
  "打印条形图，在 recursive-graph-body-print 函数中使用。"
@end group

@group
  (when numbers-list
        (setq from-position (point))
        (insert-rectangle
         (column-of-graph height (car numbers-list)))
@end group
@group
        (goto-char from-position)
        (forward-char symbol-width)
        (sit-for 0)     ; @r{逐列绘制图形。}
        (recursive-graph-body-print-internal
         (cdr numbers-list) height symbol-width)))
@end group
@end smallexample

@need 1250
安装完成后，可以测试此表达式；以下是一个示例：

@smallexample
(recursive-graph-body-print '(3 2 5 6 7 5 3 4 6 4 3 2 1))
@end smallexample

@need 800
这是 @code{recursive-graph-body-print} 生成的结果：

@smallexample
@group
                *
               **   *
              ****  *
              **** ***
            * *********
            ************
            *************
@end group
@end smallexample

这两个函数之一，@code{graph-body-print} 或 @code{recursive-graph-body-print}，都可以创建图形的主体。

@node Printed Axes
@section 打印坐标轴的必要性

图表需要有打印的坐标轴，这样你就能更好地定位自己在图中的位置。对于一个一次性的项目，手工使用Emacs的Picture mode绘制坐标轴可能是合理的；但是，一个图形绘制函数可能会被多次使用。

因此，我已经对基本的@code{print-graph-body}函数进行了增强，使其能够自动打印水平和垂直坐标轴的标签。由于标签打印函数并不包含太多新材料，我把它们的描述放在了附录中。@xref{Full Graph, , 带有标记坐标轴的图表}。

@node Line Graph Exercise
@section 练习

编写一个线图版本的图形打印函数。

@node Emacs Initialization
@chapter 你的 @file{.emacs} 文件
@cindex @file{.emacs} 文件
@cindex 定制你的 @file{.emacs} 文件
@cindex 初始化文件

``你不一定要喜欢Emacs才能喜欢它''---这个看似矛盾的说法是GNU Emacs的秘密。默认的、开箱即用的Emacs是一个通用工具。大多数人使用它来进行定制，以适应自己的需求。

GNU Emacs主要由Emacs Lisp编写；这意味着通过编写Emacs Lisp表达式，你可以改变或扩展Emacs的功能。

@menu
* Default Configuration::
* Site-wide Init::              你可以编写站点级别的初始化文件。
* defcustom::                   Emacs会为你生成代码。
* Beginning init File::         如何编写 @file{.emacs} 初始化文件。
* Text and Auto-fill::          自动换行。
* Mail Aliases::                使用电子邮件地址的缩写。
* Indent Tabs Mode::            在@TeX{}中不使用制表符。
* Key Bindings::                创建一些个人的键绑定。
* Keymaps::                     更多关于键绑定的信息。
* Loading Files::               自动加载文件（即，评估文件）。
* Autoload::                    使函数可用。
* Simple Extension::            定义一个函数；将其绑定到一个键上。
* X11 Colors::                  X中的颜色。
* Miscellaneous::
* Mode Line::                   如何定制你的模式行。
@end menu

@ifnottex
@node Default Configuration
@unnumberedsec Emacs的默认配置
@end ifnottex

有些人欣赏Emacs的默认配置。毕竟，当你编辑C文件时，Emacs会启动C模式，编辑Fortran文件时会启动Fortran模式，而编辑未装饰的文件时会启动Fundamental模式。如果你不知道谁将使用Emacs，这一切都是有道理的。谁知道一个人希望用未装饰的文件做什么？对于这样的文件，Fundamental模式是正确的默认选择，就像编辑C代码时C模式是正确的默认选择一样。（足够多的编程语言有语法使它们能够共享或几乎共享功能，因此C模式现在由CC模式提供，即C集合。）

但当你知道将要使用Emacs的是谁---就是你自己---那么定制Emacs就是有意义的。

例如，当我编辑一个除了没有区别的文件时，我很少想要Fundamental模式；我想要Text模式。这就是为什么我定制Emacs的原因：使其适合我。

你可以通过编写或调整 @file{~/.emacs} 文件来定制和扩展Emacs。这是你的个人初始化文件；其中的内容，用Emacs Lisp编写，告诉Emacs应该做什么。@footnote{你还可以将 @file{.el} 添加到 @file{~/.emacs} 并称之为 @file{~/.emacs.el} 文件。过去，你不能输入名称 @file{~/.emacs.el} 需要的额外按键，但现在你可以。新的格式符合Emacs Lisp文件命名规范；旧的格式节省了打字。}

一个 @file{~/.emacs} 文件包含Emacs Lisp代码。你可以自己编写这些代码；或者你可以使用Emacs的 @code{customize} 功能为你编写代码。你可以在你的 @file{.emacs} 文件中结合自己的表达式和自动生成的定制表达式。

（我个人更喜欢编写自己的表达式，除非是那些，特别是字体之类，我发现使用 @code{customize} 命令更容易操作。我将这两种方法结合在一起。）

本章的大部分内容是关于自己编写表达式的。它描述了一个简单的 @file{.emacs} 文件；有关更多信息，请参见 @ref{Init File, , The Init File, emacs, The GNU Emacs Manual} 和 @ref{Init File, , The Init File, elisp, The GNU Emacs Lisp Reference Manual}。

@node Site-wide Init
@section 站点范围初始化文件

@cindex @file{default.el} 初始化文件
@cindex @file{site-init.el} 初始化文件
@cindex @file{site-load.el} 初始化文件
除了个人初始化文件外，Emacs 还会自动加载各种站点范围的初始化文件，如果这些文件存在的话。这些文件与你的 @file{.emacs} 文件具有相同的形式，但会被所有用户加载。

有两个站点范围的初始化文件，@file{site-load.el} 和 @file{site-init.el}，它们会在 Emacs 启动时被加载，然后如果创建了 Emacs 的已转储版本，它们会被转储。（已转储的 Emacs 拥有更快的加载速度。然而，一旦文件被加载并转储，对它的更改不会导致 Emacs 的变化，除非你自己加载它或重新转储 Emacs。@xref{Building Emacs, , Building Emacs, elisp, The GNU Emacs Lisp Reference Manual}，以及 @file{INSTALL} 文件。）

另外，还有三个站点范围的初始化文件，每次启动 Emacs 时都会自动加载，如果它们存在的话。这些文件分别是 @file{site-start.el}，它在你的 @file{.emacs} 文件之前加载，以及 @file{default.el} 和终端类型文件，它们在你的 @file{.emacs} 文件之后加载。

在你的 @file{.emacs} 文件中的设置和定义会覆盖 @file{site-start.el} 文件中的冲突设置和定义（如果存在的话）。但是，在 @file{default.el} 或终端类型文件中的设置和定义会覆盖你的 @file{.emacs} 文件中的设置和定义。（你可以通过将 @code{term-file-prefix} 设置为 @code{nil} 来阻止终端类型文件的干扰。@xref{Simple Extension, , 一个简单的扩展}。）

@c 重写以避免 hbox 溢出。
分发中附带的 @file{INSTALL} 文件包含了对 @file{site-init.el} 和 @file{site-load.el} 文件的描述。

@file{loadup.el}、@file{startup.el} 和 @file{loaddefs.el} 文件控制加载过程。这些文件位于 Emacs 分发包的 @file{lisp} 目录中，值得一读。

@file{loaddefs.el} 文件包含了许多关于要放入你自己的 @file{.emacs} 文件或站点范围初始化文件的建议。

@node defcustom
@section 使用 @code{defcustom} 指定变量
@findex defcustom

您可以使用 @code{defcustom} 指定变量，以便您和其他人可以使用 Emacs 的 @code{customize} 功能来设置它们的值。 （您不能使用 @code{customize} 来编写函数定义；但是您可以在您的 @file{.emacs} 文件中编写 @code{defuns}。实际上，您可以在您的 @file{.emacs} 文件中写任何 Lisp 表达式。）

@code{customize} 功能依赖于 @code{defcustom} 宏。虽然您可以使用 @code{defvar} 或 @code{setq} 来定义用户设置的变量，但是 @code{defcustom} 宏是专门设计用于此任务的。

您可以使用对 @code{defvar} 的了解来编写 @code{defcustom} 的前三个参数。@code{defcustom} 的第一个参数是变量的名称。第二个参数是变量的初始值，如果有的话；并且仅当值尚未设置时才设置。第三个参数是文档。

@code{defcustom} 的第四个及以后的参数指定类型和选项；这在 @code{defvar} 中没有。 （这些参数是可选的。）

每个参数都由一个关键字和一个值组成。每个关键字以冒号字符 @samp{:} 开头。

@need 1250
例如，可定制的用户选项变量 @code{text-mode-hook} 如下所示：

@smallexample
@group
(defcustom text-mode-hook nil
  "Normal hook run when entering Text mode and many related modes."
  :type 'hook
  :options '(turn-on-auto-fill flyspell-mode)
  :group 'wp)
@end group
@end smallexample

@noindent
变量的名称是 @code{text-mode-hook}；它没有默认值；其文档字符串告诉您其功能。

@code{:type} 关键字告诉 Emacs 应该将 @code{text-mode-hook} 设置为哪种数据类型，并且如何在自定义缓冲区中显示值。

@code{:options} 关键字指定变量的建议值列表。通常，@code{:options} 适用于钩子。列表只是一个建议；它不是排他的；设置变量的人可以将其设置为其他值；@code{:options} 关键字后面显示的列表旨在为用户提供方便的选择。

最后，@code{:group} 关键字告诉 Emacs 自定义命令该变量位于哪个组中。这告诉它在哪里找到它。

@code{defcustom} 宏识别超过十几个关键字。有关更多信息，请参见 @ref{Customization, , Writing Customization Definitions, elisp, The GNU Emacs Lisp Reference Manual}。

以 @code{text-mode-hook} 为例。

有两种方法可以定制此变量。您可以使用定制命令，输入：

@need 800
@smallexample
M-x customize
@end smallexample

@noindent
然后找到文本文件编辑组的名称为“Text”。进入该组。 Text Mode Hook 是第一个成员。您可以单击其各种选项，如 @code{turn-on-auto-fill}，以设置值。单击按钮

@smallexample
Save for Future Sessions
@end smallexample

@noindent
Emacs 将在您的 @file{.emacs} 文件中写入一个表达式。它看起来像这样：

@smallexample
@group
(custom-set-variables
  ;; custom-set-variables was added by Custom.
  ;; If you edit it by hand, you could mess it up, so be careful.
  ;; Your init file should contain only one such instance.
  ;; If there is more than one, they won't work right.
 '(text-mode-hook '(turn-on-auto-fill text-mode-hook-identify)))
@end group
@end smallexample

@noindent
（@code{text-mode-hook-identify} 函数告诉 @code{toggle-text-mode-auto-fill} 哪些缓冲区处于文本模式。它会自动启动。）

与 @code{setq} 不同，@code{custom-set-variables} 函数的工作方式有些不同。虽然我从未学习过其中的区别，但我手动修改 @file{.emacs} 文件中的 @code{custom-set-variables} 表达式：我以我认为合理的方式进行更改，并且没有遇到任何问题。其他人喜欢使用定制命令，让 Emacs 为他们完成工作。

另一个 @code{custom-set-@dots{}} 函数是 @code{custom-set-faces}。该函数设置各种字体样式。随着时间的推移，我已经设置了相当多的样式。有时候，我使用 @code{customize} 重新设置它们；其他时候，我只是编辑 @file{.emacs} 文件中的 @code{custom-set-faces} 表达式本身。

第二种自定义 @code{text-mode-hook} 的方法是在 @file{.emacs} 文件中使用与 @code{custom-set-@dots{}} 函数无关的代码自己设置它。

@need 800
当您这样做，并稍后使用 @code{customize} 时，您会看到一个消息，上面写着

@smallexample
在 Customize 之外更改；在这里操作可能不可靠。
@end smallexample

@need 800
这只是一个警告。如果您单击按钮

@smallexample
Save for Future Sessions
@end smallexample

@noindent
Emacs 将在您的 @file{.emacs} 文件末尾附近写入一个 @code{custom-set-@dots{}} 表达式，该表达式将在您手写的表达式之后进行评估。因此，它将覆盖您手写的表达式。不会有任何问题。但是，请务必记住哪个表达式是活动的；如果您忘记了，可能会使自己困惑。

只要记得值是在哪里设置的，就不会有问题。无论如何，这些值总是在您的初始化文件中设置的，通常称为 @file{.emacs}。

我个人几乎不使用 @code{customize}。大多数情况下，我自己编写表达式。

@findex defsubst
@findex defconst
顺便说一下，为了更完整地了解定义：@code{defsubst} 定义内联函数。语法与 @code{defun} 相同。@code{defconst} 将符号定义为常量。意图是既不应该由程序也不应该由用户更改由 @code{defconst} 设置的值。 （您可以更改它；设置的值是一个变量；但请不要这样做。）

@node Beginning init File
@section 开始一个 @file{.emacs} 文件
@cindex @file{.emacs} 文件，开始

当你启动Emacs时，它会加载你的 @file{.emacs} 文件，除非你在命令行上使用 @samp{-q} 参数告诉它不要加载。（@code{emacs -q} 命令会给你一个原始、未配置的Emacs。）

一个 @file{.emacs} 文件包含Lisp表达式。通常，这些仅仅是设置值的表达式；有时它们是函数定义。

@xref{Init File, , 初始化文件 @file{~/.emacs}, emacs, GNU Emacs手册}，提供了对初始化文件的简短描述。

本章节涉及相同的主题，但是是从一个完整且长时间使用的 @file{.emacs} 文件中提取的片段，这是我的文件。

文件的第一部分包含注释：提醒给我自己的。当然，现在我记得这些事情，但当我开始时，我不记得。

@need 1200
@smallexample
@group
;;;; Bob的 .emacs 文件
; Robert J. Chassell
; 1985年9月26日
@end group
@end smallexample

@noindent
看那个日期！我很久以前就开始了这个文件。从那时起，我一直在添加内容。

@smallexample
@group
; 该文件中的每个部分都由以四个分号开头的一行引入；
; 每个条目都由以三个分号开头的一行引入。
@end group
@end smallexample

@noindent
这描述了Emacs Lisp中注释的通常约定。在分号后面的行上的所有内容都是注释。两个、三个和四个分号用作子部分和部分的标记。（@xref{Comments, ,, elisp, GNU Emacs Lisp参考手册}，了解更多关于注释的信息。）

@smallexample
@group
;;;; 帮助键
; 控制键-h是帮助键；
; 在输入控制键-h后，输入一个字母表示你想要帮助的主题。
; 要了解帮助设施的说明，
; 连续输入两次控制键-h。
@end group
@end smallexample

@noindent
只需记住：输入 @kbd{C-h} 两次来获取帮助。

@smallexample
@group
; 要了解任何模式，输入控制键-h m
; 在该模式中。例如，要了解
; 关于邮件模式的信息，进入邮件模式然后输入
; 控制键-h m。
@end group
@end smallexample

@noindent
我称之为``模式帮助''，非常有帮助。通常，它告诉你所有你需要知道的。

当然，你不需要在你的 @file{.emacs} 文件中包含这些注释。我在我的文件中包含它们是因为我老是忘记模式帮助或注释的约定——但我能记得在这里查看以提醒自己。

@node Text and Auto-fill
@section 文本和自动填充模式

现在我们来讨论打开文本模式和自动填充模式的部分。

@smallexample
@group
;;; 文本模式和自动填充模式
;; 下面两行将Emacs置于文本模式和自动填充模式，适用于希望开始写散文而非代码的作者。
(setq-default major-mode 'text-mode)
(add-hook 'text-mode-hook 'turn-on-auto-fill)
@end group
@end smallexample

这是这个 @file{.emacs} 文件的第一部分，不仅提醒了健忘的人类！

括号中的两行中的第一行告诉Emacs在找到文件时打开文本模式，@emph{除非}该文件应该进入其他模式，比如C模式。

@cindex 缓冲区特定的本地变量列表
@cindex 本地变量列表，缓冲区特定的
@cindex 自动模式选择
@cindex 模式选择，自动
当Emacs读取一个文件时，它查看文件名的扩展名，如果有的话（扩展名是 @samp{.} 后面的部分）。如果文件以 @samp{.c} 或 @samp{.h} 结尾，那么Emacs将打开C模式。此外，Emacs查看文件的第一非空行；如果该行说 @w{@samp{-*- C -*-}}，Emacs将打开C模式。Emacs拥有一个自动使用的扩展名和规范列表。此外，Emacs在文件的最后一页附近查找每个缓冲区的本地变量列表，如果有的话。

@ifinfo
@xref{Choosing Modes, , How Major Modes are Chosen, emacs, The GNU
Emacs Manual}.

@xref{File Variables, , Local Variables in Files, emacs, The GNU Emacs
Manual}.
@end ifinfo
@iftex
请参阅 @cite{GNU Emacs Manual} 中的 ``How Major Modes are Chosen'' 和 ``Local Variables in Files'' 部分。
@end iftex

现在，回到 @file{.emacs} 文件。

@need 800
这里是上一行；它是如何工作的？

@cindex 打开文本模式
@smallexample
(setq major-mode 'text-mode)
@end smallexample

@noindent
这一行是一个简短但完整的Emacs Lisp表达式。

我们已经熟悉了 @code{setq}。它将变量 @code{major-mode} 设置为后续的值，即 @code{text-mode}。在 @code{text-mode} 之前的单引号告诉Emacs直接处理 @code{text-mode} 符号，而不是处理它可能代表的任何东西。参见 @xref{set & setq, , Setting the Value of a Variable}，了解 @code{setq} 的工作原理。主要的观点是，在你的 @file{.emacs} 文件中设置值的过程与在Emacs的其他任何地方使用的过程没有区别。

@need 800
这是下一行：

@cindex 打开自动填充模式
@findex add-hook
@smallexample
(add-hook 'text-mode-hook 'turn-on-auto-fill)
@end smallexample

@noindent
在这一行中，@code{add-hook} 命令将 @code{turn-on-auto-fill} 添加到变量中。

@code{turn-on-auto-fill} 是一个程序的名称，猜对了！它打开自动填充模式。

每次Emacs打开文本模式时，Emacs都会运行挂钩到文本模式的命令。因此，每次Emacs打开文本模式时，Emacs也会打开自动填充模式。

简而言之，第一行使Emacs在编辑文件时进入文本模式，除非文件名扩展名、第一非空行或本地变量告诉Emacs使用其他模式。

文本模式在其他操作中将语法表设置为方便写作者使用。在文本模式中，Emacs将撇号视为单词的一部分，如字母一样；但Emacs不将句点或空格视为单词的一部分。因此，@kbd{M-f} 可以将光标移到 @samp{it's} 上。另一方面，在C模式中，@kbd{M-f} 在 @samp{it's} 的 @samp{t} 后停止。

第二行使Emacs在打开文本模式时打开自动填充模式。在自动填充模式中，Emacs会自动断开太宽的行，并将行的过宽部分移到下一行。Emacs在单词之间断开行，而不是在它们内部。

当关闭自动填充模式时，行将根据您输入它们而继续向右延伸。根据您设置的 @code{truncate-lines} 的值，您输入的单词可能会从屏幕右侧消失，或者以一种相当丑陋和不可读的方式显示在屏幕上，作为续行。

@need 1250
此外，在我的 @file{.emacs} 文件的这一部分中，我告诉Emacs填充命令在冒号后插入两个空格：

@smallexample
(setq colon-double-space t)
@end smallexample

@node Mail Aliases
@section 邮件别名

以下是一个启用邮件别名的 @code{setq}，以及更多的提醒。

@smallexample
@group
;;; 消息模式
; 进入消息模式，输入 'C-x m'
; 进入 RMAIL（阅读邮件），
; 输入 'M-x rmail'
(setq mail-aliases t)
@end group
@end smallexample

@cindex 邮件别名
@noindent
这个 @code{setq} 将变量 @code{mail-aliases} 的值设置为 @code{t}。由于 @code{t} 表示真，这一行实际上是说：“是的，使用邮件别名。”

邮件别名是方便的短名称，用于表示长电子邮件地址或电子邮件地址列表。保存别名的文件是 @file{~/.mailrc}。你可以这样写一个别名：

@smallexample
alias geo george@@foobar.wiz.edu
@end smallexample

@noindent
当你给George写一封邮件时，请将地址写为 @samp{geo}；邮件客户端将自动将 @samp{geo} 展开为完整的地址。

@node Indent Tabs Mode
@section 缩进选项
@cindex 防止制表符
@findex indent-tabs-mode

默认情况下，Emacs在格式化区域时会用制表符替代多个空格。（例如，您可能会一次性缩进多行文本，使用 @code{indent-region} 命令。）在终端或普通打印中，制表符看起来很好，但在使用 @TeX{} 或 Texinfo 时会产生糟糕的缩进输出，因为 @TeX{} 忽略制表符。

@need 1250
以下是关闭缩进选项的方法：

@smallexample
@group
;;; 防止多余的制表符
(setq-default indent-tabs-mode nil)
@end group
@end smallexample

请注意，此行使用的是 @code{setq-default}，而不是我们之前见过的 @code{setq}；@code{setq-default} 仅在变量在没有本地值的缓冲区中才设置值。

@ifinfo
@xref{Just Spaces, , Tabs vs.@: Spaces, emacs, The GNU Emacs Manual}.

@xref{File Variables, , Local Variables in Files, emacs, The GNU Emacs
Manual}.
@end ifinfo
@iftex
请参阅 @cite{The GNU Emacs Manual} 中的“Tabs vs.@: Spaces”和“文件中的局部变量”部分。
@end iftex

@need 1700
@node Key Bindings
@section 一些按键绑定

现在来看一些个人按键绑定：

@smallexample
@group
;;; 比较窗口
(global-set-key "\C-cw" 'compare-windows)
@end group
@end smallexample

@findex compare-windows
@code{compare-windows} 是一个巧妙的命令，用于比较当前窗口中的文本与下一个窗口中的文本。它通过从每个窗口的光标位置开始，在每个窗口中移动文本，直到找到不匹配的部分。我经常使用这个命令。

这也展示了如何在所有模式中全局设置按键。

@cindex 全局设置按键
@cindex 全局按键设置
@cindex 按键全局设置
@findex global-set-key
该命令是 @code{global-set-key}。它后面跟着按键绑定。在 @file{.emacs} 文件中，按键绑定的写法如下：@code{\C-c} 代表 Control-C，意味着同时按下 Control 键和 @kbd{c} 键。@code{w} 代表按下 @kbd{w} 键。按键绑定用双引号括起来。在文档中，你应该这样写：@w{@kbd{C-c w}}。（如果你要绑定一个 @key{META} 键，例如 @kbd{M-c}，而不是 @key{CTRL} 键，你应该在 @file{.emacs} 文件中写成 @w{@code{\M-c}}。详见 @xref{Init Rebinding, , 重新绑定按键在你的初始化文件中, emacs, GNU Emacs 手册}，获取详细信息。）

由这些按键调用的命令是 @code{compare-windows}。注意，@code{compare-windows} 前面有一个单引号；否则，Emacs 将首先尝试评估符号以确定其值。

这三个元素，双引号、@samp{C} 前面的反斜杠，以及单引号，是我经常忘记的按键绑定的必要部分。幸运的是，我已经记住了应该查看我的现有 @file{.emacs} 文件，并适应其中的内容。

至于按键绑定本身：@kbd{C-c w}。这将前缀键 @kbd{C-c} 与一个单字符 @kbd{w} 结合在一起。这组按键，@kbd{C-c} 后跟一个单字符，严格保留供个人使用。 （我称这些为 @dfn{个人} 按键，因为这些是我自己使用的。）你应该始终能够创建这样的按键绑定，而不会覆盖其他人的按键绑定。如果你曾经编写过 Emacs 的扩展，请避免为公共使用占用这些按键。请创建一个类似 @kbd{C-c C-w} 的按键。否则，我们将用完个人按键。

@need 1250
这里是另一个按键绑定，附有注释：

@smallexample
@group
;;; 为 'occur' 绑定按键
; 我经常使用 occur，所以让我们绑定一个按键：
(global-set-key "\C-co" 'occur)
@end group
@end smallexample

@findex occur
@code{occur} 命令显示当前缓冲区中与正则表达式匹配的所有行。当区域处于活动状态时，@code{occur} 限制匹配于该区域。否则，它使用整个缓冲区。匹配的行显示在一个名为 @file{*Occur*} 的缓冲区中。该缓冲区作为跳转到匹配行的菜单。

@findex global-unset-key
@cindex 解除按键绑定
@cindex 按键解绑定
@need 1250
以下是如何解绑按键，使其无效：

@smallexample
@group
;;; 解绑 'C-x f'
(global-unset-key "\C-xf")
@end group
@end smallexample

这解绑的原因是：我发现我在意图输入 @kbd{C-x C-f} 时无意中键入了 @w{@kbd{C-x f}}。与其找到一个文件，我无意中设置了填充文本的宽度，几乎总是设置成我不想要的宽度。由于我几乎从不重新设置默认宽度，我简单地解绑了该按键。

@findex list-buffers@r{，重新绑定}
@findex buffer-menu@r{，绑定到按键}
@need 1250
以下是如何重新绑定现有按键：

@smallexample
@group
;;; 为 'buffer-menu' 重新绑定 'C-x C-b'
(global-set-key "\C-x\C-b" 'buffer-menu)
@end group
@end smallexample

默认情况下，@kbd{C-x C-b} 运行 @code{list-buffers} 命令。该命令在 @emph{另一个} 窗口中列出你的缓冲区。由于我几乎总是想在那个窗口中执行某些操作，我更喜欢 @code{buffer-menu} 命令，它不仅列出缓冲区，还将光标移到该窗口。

@node Keymaps
@section 键位映射
@cindex 键位映射
@cindex 重新绑定键位

Emacs 使用 @dfn{键位映射} 记录哪些键调用哪些命令。当你使用 @code{global-set-key} 在 Emacs 的所有部分为单个命令设置键绑定时，你正在指定键绑定在 @code{current-global-map} 中。

特定模式，如 C 模式或文本模式，有它们自己的键位映射；模式特定的键位映射会覆盖所有缓冲区共享的全局映射。

@code{global-set-key} 函数绑定或重新绑定全局键位映射。例如，下面将键 @kbd{C-x C-b} 绑定到函数 @code{buffer-menu}：

@smallexample
(global-set-key "\C-x\C-b" 'buffer-menu)
@end smallexample

模式特定的键位映射使用 @code{define-key} 函数进行绑定，该函数接受特定的键位映射作为参数，以及键和命令。例如，我的 @file{.emacs} 文件包含以下表达式，将命令 @code{texinfo-insert-@@group} 绑定到键 @kbd{C-c C-c g}：

@smallexample
@group
(define-key texinfo-mode-map "\C-c\C-cg" 'texinfo-insert-@@group)
@end group
@end smallexample

@noindent
@code{texinfo-insert-@@group} 函数本身是对 Texinfo 模式的一个小扩展，它在 Texinfo 文件中插入 @samp{@@group}。我经常使用这个命令，而且更喜欢输入三个按键 @kbd{C-c C-c g}，而不是六个按键 @kbd{@@ g r o u p}。
（@samp{@@group} 及其匹配的 @samp{@@end group} 是一对命令，将所有包含的文本保持在一页上；本书中的许多多行示例都被 @samp{@@group @dots{} @@end group} 包围。）

@need 1250
以下是 @code{texinfo-insert-@@group} 函数的定义：

@smallexample
@group
(defun texinfo-insert-@@group ()
  "在 Texinfo 缓冲区中插入字符串 @@group。"
  (interactive)
  (beginning-of-line)
  (insert "@@group\n"))
@end group
@end smallexample

（当然，我本可以使用 Abbrev 模式来节省输入，而不是编写一个插入单词的函数；但我更喜欢与其他 Texinfo 模式键绑定一致的按键。）

在 @file{loaddefs.el} 以及各种模式库如 @file{cc-mode.el} 和 @file{lisp-mode.el} 中，你会看到许多 @code{define-key} 表达式。

@xref{键绑定, , 定制键绑定, emacs, GNU Emacs 手册}，以及 @ref{键位映射, , 键位映射, elisp, GNU Emacs Lisp 参考手册}，获取更多关于键位映射的信息。

@node Loading Files
@section 载入文件
@cindex 载入文件
@c findex 载入

GNU Emacs 社区的许多成员都编写了对 Emacs 的扩展。随着时间的推移，这些扩展通常会被包含在新的发行版中。例如，日历和日记包现在是标准的 GNU Emacs 的一部分，就像 Calc 一样。

您可以使用 @code{load} 命令来评估一个完整的文件，从而将文件中的所有函数和变量安装到 Emacs 中。例如：

@c (auto-compression-mode t)

@smallexample
(load "~/emacs/slowsplit")
@end smallexample

这将评估（即加载）@file{slowsplit.el}文件，或者如果存在的话，加载@file{emacs}子目录中更快的、字节编译的@file{slowsplit.elc}文件。该文件包含了 John Robinson 在 1989 年编写的函数 @code{split-window-quietly}。

@code{split-window-quietly} 函数以最小的重绘方式分割窗口。我在 1989 年安装它，因为它在我当时使用的速度为 1200 波特的终端上运行良好。如今，我只偶尔遇到这样的慢速连接，但我继续使用该函数，因为我喜欢它将缓冲区的下半部分留在新窗口的下半部分，而将上半部分留在上面的窗口中。

@need 1250
要替换默认的 @code{split-window-vertically} 的键绑定，您还必须取消该键的绑定，并将键绑定到 @code{split-window-quietly}，如下所示：

@smallexample
@group
(global-unset-key "\C-x2")
(global-set-key "\C-x2" 'split-window-quietly)
@end group
@end smallexample

@vindex load-path
如果您像我一样加载了许多扩展，那么您可以将该扩展文件所在的确切位置指定为 Emacs 的 @code{load-path} 的一部分，而不是像上面那样。然后，当 Emacs 加载文件时，它将在其默认目录列表以及该目录中搜索。 （默认列表在构建 Emacs 时在 @file{paths.h} 中指定。）

@need 1250
以下命令将您的 @file{~/emacs} 目录添加到现有的加载路径中：

@smallexample
@group
;;; Emacs 加载路径
(setq load-path (cons "~/emacs" load-path))
@end group
@end smallexample

顺便说一下，@code{load-library} 是 @code{load} 函数的交互式接口。完整的函数如下：

@findex load-library
@smallexample
@group
(defun load-library (library)
  "加载名为 LIBRARY 的 Emacs Lisp 库。
这是对函数 `load' 的接口。在 `load-path' 中搜索 LIBRARY，既包括 `load-suffixes'，也包括（以及 `load-file-rep-suffixes'）。

有关更多详细信息，请参见 Info 节点 `(emacs)Lisp Libraries'。
有关 `load-file' 对 `load' 的另一种接口，请参见 `Lisp Libraries' 节点中的信息。"
  (interactive
   (list (completing-read "加载库: "
                          (apply-partially 'locate-file-completion-table
                                           load-path
                                           (get-load-suffixes)))))
  (load library))
@end group
@end smallexample

函数的名称 @code{load-library} 来自于“library”作为“file”的传统同义词的使用。该命令的源代码位于 @file{files.el} 库中。

另一个执行略有不同任务的交互式命令是 @code{load-file}。有关 @code{load-library} 与该命令之间区别的信息，请参阅 `Lisp Libraries, , Libraries of Lisp Code for Emacs, emacs, The GNU Emacs Manual`。

@node Autoload
@section 自动加载
@findex 自动加载

与通过加载包含函数的文件或评估函数定义来安装函数不同，您可以使函数可用，但实际上只有在首次调用时才安装它。这称为@dfn{自动加载}。

当执行一个自动加载的函数时，Emacs会自动评估包含定义的文件，然后调用该函数。

Emacs使用自动加载的函数启动更快，因为它们的库不会立即加载；但是当您首次使用这样的函数时，需要等待片刻，因为其包含文件正在评估中。

很少使用的函数经常被自动加载。@file{loaddefs.el}库包含数千个自动加载的函数，从@code{5x5}到@code{zone}。当然，您可能会经常使用一个罕见的函数。当您这样做时，应该在@file{.emacs}文件中使用@code{load}表达式加载该函数的文件。

在我的@file{.emacs}文件中，我加载了14个包含函数的库，否则这些函数将被自动加载。（实际上，最好在我的dumped Emacs中包含这些文件，但我忘了。有关dumping的更多信息，请参阅@xref{Building Emacs, , Building Emacs, elisp, The GNU Emacs Lisp Reference Manual}和@file{INSTALL}文件。）

您可能还希望在@file{.emacs}文件中包含自动加载的表达式。@code{autoload}是一个内置函数，最多接受五个参数，最后三个是可选的。第一个参数是要自动加载的函数的名称；第二个是要加载的文件的名称。第三个参数是函数的文档，第四个告诉函数是否可以通过交互调用。第五个参数告诉对象的类型——@code{autoload}可以处理键位图或宏以及函数（默认是函数）。

@need 800
这是一个典型的例子：

@smallexample
@group
(autoload 'html-helper-mode
  "html-helper-mode" "Edit HTML documents" t)
@end group
@end smallexample

@noindent
（@code{html-helper-mode}是@code{html-mode}的一个较旧的替代品，它是分发的标准部分。）

@noindent
此表达式自动加载了@code{html-helper-mode}函数。它从@file{html-helper-mode.el}文件（或其字节编译版本@file{html-helper-mode.elc}，如果存在的话）中获取。该文件必须位于由@code{load-path}指定的目录中。文档说明这是一种帮助您编辑用HyperText Markup Language编写的文档的模式。您可以通过键入@kbd{M-x html-helper-mode}以交互方式调用此模式。（需要在自动加载表达式中重复函数的常规文档，因为常规函数尚未加载，所以其文档尚不可用。）

@xref{Autoload, , Autoload, elisp, The GNU Emacs Lisp Reference Manual}，了解更多信息。

@node Simple Extension
@section 一个简单的扩展：@code{line-to-top-of-window}
@findex line-to-top-of-window
@cindex 在 @file{.emacs} 文件中的简单扩展

下面是一个简单的Emacs扩展，将光标所在行移动到窗口顶部。我经常使用它，以便更容易阅读文本。

你可以将以下代码放入一个单独的文件中，然后从你的 @file{.emacs} 文件中加载它，或者直接包含在 @file{.emacs} 文件中。

@need 1250
下面是定义：

@smallexample
@group
;;; 将行移到窗口顶部；
;;; 替代三个按键序列 C-u 0 C-l
(defun line-to-top-of-window ()
  "将光标所在行移动到窗口顶部。"
  (interactive)
  (recenter 0))
@end group
@end smallexample

@need 1250
现在是按键绑定。

函数键以及鼠标按钮事件和非@sc{ascii}字符用方括号括起，不加引号。

我将 @code{line-to-top-of-window} 绑定到我的 @key{F6} 函数键上，如下所示：

@smallexample
(global-set-key [f6] 'line-to-top-of-window)
@end smallexample

有关更多信息，请参阅 @ref{Init Rebinding, , 在你的初始化文件中重新绑定键, emacs, GNU Emacs手册}。

@cindex 在两个版本的Emacs之间选择
@cindex Emacs版本，选择
@cindex 选择Emacs版本
如果你运行两个GNU Emacs版本，比如版本27和28，并使用一个 @file{.emacs} 文件，你可以使用以下条件选择要评估的代码：

@smallexample
@group
(cond
 ((= 27 emacs-major-version)
  ;; 评估版本27的代码
  ( @dots{} ))
 ((= 28 emacs-major-version)
  ;; 评估版本28的代码
  ( @dots{} )))
@end group
@end smallexample

例如，最近的版本默认闪烁光标。我不喜欢这种闪烁，以及其他一些功能，因此我将以下内容放在我的 @file{.emacs} 文件中@footnote{当我启动不加载我的 @file{.emacs} 文件或任何站点文件的Emacs实例时，我还会关闭闪烁：

@smallexample
emacs -q --no-site-file -eval '(blink-cursor-mode nil)'

@exdent 或者现在，使用一组更复杂的选项，

emacs -Q -D
@end smallexample
}：

@smallexample
@group
(when (>= emacs-major-version 21)
  (blink-cursor-mode 0)
  ;; 在缓冲区末尾按 'C-n'（next-line）时插入换行符
  (setq next-line-add-newlines t)
@end group
@group
  ;; 打开图像查看
  (auto-image-file-mode t)
@end group
@group
  ;; 打开菜单栏（此栏具有文本）
  ;; （使用数值参数打开）
  (menu-bar-mode 1)
@end group
@group
  ;; 关闭工具栏（此栏具有图标）
  ;; （使用数值参数打开）
  (tool-bar-mode nil)
@end group
@group
  ;; 关闭工具栏的工具提示模式
  ;; （此模式导致图标解释弹出）
  ;; （使用数值参数打开）
  (tooltip-mode nil)
  ;; 如果启用工具提示，使提示迅速显示
  (setq tooltip-delay 0.1)  ; 默认为0.7秒
   )
@end group
@end smallexample

@node X11 Colors
@section X11 颜色

在使用 MIT X 窗口系统的 Emacs 中，您可以指定颜色。

我不喜欢默认的颜色，因此我设置了自己的颜色。

@need 1250
以下是我在 @file{.emacs} 文件中设置值的表达式：

@smallexample
@group
;; 设置光标颜色
(set-cursor-color "white")

;; 设置鼠标颜色
(set-mouse-color "white")

;; 设置前景和背景颜色
(set-foreground-color "white")
(set-background-color "darkblue")
@end group

@group
;;; 为 isearch 和 drag 设置高亮颜色
(set-face-foreground 'highlight "white")
(set-face-background 'highlight "blue")
@end group

@group
(set-face-foreground 'region "cyan")
(set-face-background 'region "blue")
@end group

@group
(set-face-foreground 'secondary-selection "skyblue")
(set-face-background 'secondary-selection "darkblue")
@end group

@group
;; 设置日历高亮颜色
(with-eval-after-load 'calendar
  (set-face-foreground 'diary   "skyblue")
  (set-face-background 'holiday "slate blue")
  (set-face-foreground 'holiday "white"))
@end group
@end smallexample

各种蓝色调缓解了我的眼睛，并防止我看到屏幕闪烁。

或者，我也可以在各种 X 初始化文件中设置我的规格。例如，我可以在 @file{~/.Xresources} 文件中设置前景、背景、光标和指针（即鼠标）颜色，如下所示：

@smallexample
@group
Emacs*foreground:   white
Emacs*background:   darkblue
Emacs*cursorColor:  white
Emacs*pointerColor: white
@end group
@end smallexample

无论如何，由于它不是 Emacs 的一部分，我在 @file{~/.xinitrc} 文件中设置了我的 X 窗口的根颜色，如下所示@footnote{我还运行更现代的窗口管理器，如 Enlightenment、Gnome 或 KDE；在这些情况下，我通常指定图像而不是纯色。}：

@smallexample
xsetroot -solid Navy -fg white &
@end smallexample

@need 1700
@node Miscellaneous
@section Emacs @file{.emacs} 文件的其他设置

@need 1250
以下是一些杂项设置：
@sp 1

@itemize @minus
@item
设置鼠标指针的形状和颜色：

@smallexample
@group
; 鼠标指针形状在 '/usr/include/X11/cursorfont.h' 中定义；
; 例如，'target' 鼠标指针是编号 128；
; 'top_left_arrow' 鼠标指针是编号 132。
@end group

@group
(let ((mpointer (x-get-resource "*mpointer"
                                "*emacs*mpointer")))
  ;; 如果你没有设置鼠标指针
  ;; 则设置它，否则保持原样:
  (if (eq mpointer nil)
      (setq mpointer "132")) ; top_left_arrow
@end group
@group
  (setq x-pointer-shape (string-to-number mpointer))
  (set-mouse-color "white"))
@end group
@end smallexample

@item
或者你可以在一个关联列表中设置各种特性的值，如下所示：

@smallexample
@group
(setq-default
 default-frame-alist
 '((cursor-color . "white")
   (mouse-color . "white")
   (foreground-color . "white")
   (background-color . "DodgerBlue4")
   ;; (cursor-type . bar)
   (cursor-type . box)
@end group
@group
   (tool-bar-lines . 0)
   (menu-bar-lines . 1)
   (width . 80)
   (height . 58)
   (font .
         "-Misc-Fixed-Medium-R-Normal--20-200-75-75-C-100-ISO8859-1")
   ))
@end group
@end smallexample

@item
将 @kbd{@key{CTRL}-h} 转换为 @key{DEL}，将 @key{DEL} 转换为 @kbd{@key{CTRL}-h}。@*
(一些较旧的键盘可能需要这样做，尽管我最近没有遇到这个问题。)

@smallexample
@group
;; 将 'C-h' 转换为 <DEL>。
; (keyboard-translate ?\C-h ?\C-?)

;; 将 <DEL> 转换为 'C-h'。
(keyboard-translate ?\C-? ?\C-h)
@end group
@end smallexample

@item 关闭光标的闪烁！

@smallexample
@group
(if (fboundp 'blink-cursor-mode)
    (blink-cursor-mode -1))
@end group
@end smallexample

@noindent
或者使用命令 @code{emacs -nbc} 启动 GNU Emacs。

@need 1250
@item 使用 @command{grep}@*
@samp{-i}@w{  }   忽略大小写@*
@samp{-n}@w{  }   在输出中添加每行的行号@*
@samp{-H}@w{  }   为每个匹配项打印文件名@*
@samp{-e}@w{  }   保护以连字符字符 @samp{-} 开头的模式

@smallexample
(setq grep-command "grep -i -nH -e ")
@end smallexample

@item 查找已存在的缓冲区，即使它有不同的名称@*
这可以避免符号链接的问题。

@smallexample
(setq find-file-existing-other-name t)
@end smallexample

@item 设置语言环境和默认输入法

@smallexample
@group
(set-language-environment "latin-1")
;; 记住你可以使用 @code{toggle-input-method'} (@kbd{C-\}) 命令启用或禁用多语言文本输入
(setq default-input-method "latin-1-prefix")
@end group
@end smallexample

如果你想用中文 GB 字符写作，请设置如下：

@smallexample
@group
(set-language-environment "Chinese-GB")
(setq default-input-method "chinese-tonepy")
@end group
@end smallexample
@end itemize

@subsubheading 修复不愉快的键绑定
@cindex 键绑定，修复
@cindex 绑定，键，修复不愉快的

一些系统将键绑定得不太舒服。有时，例如，@key{CTRL} 键出现在一个尴尬的位置，而不是在键盘的最左侧。

通常情况下，当人们修复这些类型的键绑定时，他们不会更改他们的 @file{~/.emacs} 文件。相反，他们会在启动脚本中使用 @code{loadkeys} 或 @code{install-keymap} 命令在控制台上绑定正确的键，并在他们的 @file{.xinitrc} 或 @file{.Xsession} 文件中包含 @code{xmodmap} 命令以供 X 窗口系统使用。

@need 1250
@noindent
对于启动脚本：

@smallexample
@group
loadkeys /usr/share/keymaps/i386/qwerty/emacs2.kmap.gz
@exdent 或
install-keymap emacs2
@end group
@end smallexample

@need 1250
@noindent
对于 @file{.xinitrc} 或 @file{.Xsession} 文件，当 @key{Caps Lock} 键位于键盘的最左侧时：

@smallexample
@group
# 将标有 'Caps Lock' 的键绑定为 'Control'
# (这样破碎的用户界面表明键盘制造商认为计算机是来自1885年的打字机。)

xmodmap -e "clear Lock"
xmodmap -e "add Control = Caps_Lock"
@end group
@end smallexample

@need 1250
@noindent
在 @file{.xinitrc} 或 @file{.Xsession} 文件中，将 @key{ALT} 键转换为 @key{META} 键：

@smallexample
@group
# 一些设计不当的键盘有一个标有 ALT 的键而没有 Meta
xmodmap -e "keysym Alt_L = Meta_L Alt_L"
@end group
@end smallexample

@need 1700
@node Mode Line
@section 修改后的模式行
@vindex mode-line-format
@cindex 模式行格式

最后，有一个我真的很喜欢的功能：修改后的模式行。

当我通过网络工作时，我会忘记我使用的是哪台机器。而且，我往往会迷失在当前位置、光标所在行等信息中。

因此，我将我的模式行重置为以下样式：

@smallexample
-:-- foo.texi   rattlesnake:/home/bob/  行 1  (Texinfo 填充) 顶部
@end smallexample

我正在访问一个名为@file{foo.texi}的文件，位于我的机器@file{rattlesnake}上，位于@file{/home/bob}缓冲区。我在第1行，在Texinfo模式下，并且位于缓冲区的顶部。

@need 1200
我的@file{.emacs}文件有一个如下的部分：

@smallexample
@group
;; 设置一个模式行，告诉我所在的机器、目录和所在的行，以及其他通常的信息。
(setq-default mode-line-format
 (quote
  (#("-" 0 1
     (help-echo
      "mouse-1: 选择窗口, mouse-2: 删除其他..."))
   mode-line-mule-info
   mode-line-modified
   mode-line-frame-identification
   "    "
@end group
@group
   mode-line-buffer-identification
   "    "
   (:eval (substring
           (system-name) 0 (string-match "\\..+" (system-name))))
   ":"
   default-directory
   #(" " 0 1
     (help-echo
      "mouse-1: 选择窗口, mouse-2: 删除其他..."))
   (line-number-mode " 行 %l ")
   global-mode-string
@end group
@group
   #("   %[(" 0 6
     (help-echo
      "mouse-1: 选择窗口, mouse-2: 删除其他..."))
   (:eval (format-time-string "%F"))
   mode-line-process
   minor-mode-alist
   #("%n" 0 2 (help-echo "mouse-2: 扩大" local-map (keymap ...)))
   ")%] "
   (-3 . "%P")
   ;;   "-%-"
   )))
@end group
@end smallexample

@noindent
在这里，我重新定义了默认的模式行。列表中的大多数部分来自原始模式行；但我做了一些更改。我设置了@emph{默认}的模式行格式，以允许各种模式（如Info）覆盖它。

列表中的许多元素都是不言自明的：
@code{mode-line-modified}是一个变量，表示缓冲区是否被修改，@code{mode-name}表示模式的名称等等。但是，格式看起来很复杂，是因为我们还没有讨论的两个特性。

@cindex 在模式行示例中的属性
模式行中的第一个字符串是一个破折号，@samp{-}。在过去，它将简单地指定为@code{"-"}。但现在，Emacs可以为字符串添加属性，如高亮或者在本例中，一个帮助功能。如果将鼠标光标放在连字符上，将显示一些帮助信息（默认情况下，您必须等待七分之一秒才能看到信息。您可以通过更改@code{tooltip-delay}的值来更改该时间。）

@need 1000
新字符串格式具有特殊的语法：

@smallexample
#("-" 0 1 (help-echo "mouse-1: 选择窗口, ..."))
@end smallexample

@noindent
@code{#(}开始一个列表。列表的第一个元素是字符串本身，只有一个@samp{-}。第二个和第三个元素指定第四个元素适用的范围。范围从字符之后开始，所以零表示范围从第一个字符之前开始；1表示范围在第一个字符之后结束。第三个元素是范围的属性。它包含一个属性列表，一个属性名称，在本例中是@samp{help-echo}，后跟一个值，在本例中是一个字符串。新字符串格式的第二、第三和第四个元素可以重复。

@xref{Text Properties, , 文本属性, elisp, GNU Emacs Lisp参考手册}，并参见@ref{Mode Line Format, , 模式行格式, elisp, GNU Emacs Lisp参考手册}，获取更多信息。

@code{mode-line-buffer-identification}
显示当前缓冲区的名称。它是一个以@code{(#("%12b" 0 4 @dots{}}开头的列表。
@code{#(}开始列表。

@samp{"%12b"}显示当前缓冲区的名称，使用我们熟悉的@code{buffer-name}函数；@samp{12}指定将显示的最大字符数。当名称字符较少时，将添加空格以填充到这个数字。 （缓冲区名称可以并且通常应该比12个字符长；在典型的80列宽窗口中，此长度效果很好。）

@code{:eval}表示评估以下表达式，并将结果用作要显示的字符串。在这种情况下，该表达式显示完整系统名称的第一个组成部分。第一个组成部分的末尾是@samp{.}（句点），因此我使用@code{string-match}函数告诉我第一个组成部分的长度。从第零个字符到该长度的子字符串是机器的名称。

@need 1250
这是表达式：

@smallexample
@group
(:eval (substring
        (system-name) 0 (string-match "\\..+" (system-name))))
@end group
@end smallexample

@samp{%[}和@samp{%]}使每个递归编辑级别都出现一对方括号。 @samp{%n}在缩小效果生效时说“Narrow”。“%P”告诉您在窗口底部之上的缓冲区百分比，或者是“Top”、“Bottom”或“All”（小写的@samp{p}告诉您在窗口顶部之上的百分比）。 @samp{%-}插入足够的破折号以填满整行。

记住，你不一定非要喜欢Emacs才能使用它---你自己的Emacs可以有不同的颜色、不同的命令和不同的键盘快捷键，与默认的Emacs不同。

另一方面，如果您想要启动一个纯粹的开箱即用的Emacs，没有定制，请键入：

@smallexample
emacs -q
@end smallexample

@noindent
这将启动一个不加载您的@file{~/.emacs}初始化文件的Emacs。一个纯粹的、默认的Emacs。没有更多。

@node Debugging
@chapter 调试
@cindex 调试

GNU Emacs有两个调试器，@code{debug} 和 @code{edebug}。第一个内置于Emacs的内部，随时可用；第二个需要在使用之前对函数进行仪表化。

这两个调试器在 @ref{Debugging, , 调试Lisp程序, elisp, GNU Emacs Lisp参考手册} 中都有详细描述。在本章中，我将分别演示这两种调试器的简短示例。

@menu
* debug::                       如何使用内置调试器。
* debug-on-entry::              在调用函数时开始调试。
* debug-on-quit::               在按下 @kbd{C-g} 时开始调试。
* edebug::                      如何使用Edebug，一个源代码级调试器。
* Debugging Exercises::
@end menu

@node debug
@section @code{debug}
@findex debug

假设你已经编写了一个函数定义，该函数旨在返回给定数字范围内数字的总和。 (这是先前讨论的 @code{triangle} 函数。@xref{Decrementing Example, , 具有递减计数器的示例} 进行讨论。)

然而，你的函数定义中存在一个错误。你误将 @samp{1=} 写成了 @samp{1-}。以下是有问题的定义：

@findex triangle-bugged
@smallexample
@group
(defun triangle-bugged (number)
  "返回1到NUMBER（含）的数字之和。"
  (let ((total 0))
    (while (> number 0)
      (setq total (+ total number))
      (setq number (1= number)))      ; @r{这里有错误。}
    total))
@end group
@end smallexample

如果你在Info中阅读这个，可以以正常方式评估这个定义。你将在回显区域看到 @code{triangle-bugged}。

@need 1250
现在用参数4评估 @code{triangle-bugged} 函数：

@smallexample
(triangle-bugged 4)
@end smallexample

@noindent
这将创建并进入一个 @file{*Backtrace*} 缓冲区，显示：

@noindent
@smallexample
@group
---------- 缓冲区: *Backtrace* ----------
Debugger entered--Lisp error: (void-function 1=)
  (1= number)
  (setq number (1= number))
  (while (> number 0) (setq total (+ total number))
        (setq number (1= number)))
  (let ((total 0)) (while (> number 0) (setq total ...)
    (setq number ...)) total)
  triangle-bugged(4)
@end group
@group
  eval((triangle-bugged 4) nil)
  eval-expression((triangle-bugged 4) nil nil 127)
  funcall-interactively(eval-expression (triangle-bugged 4) nil nil 127)
  call-interactively(eval-expression nil nil)
  command-execute(eval-expression)
---------- 缓冲区: *Backtrace* ----------
@end group
@end smallexample

@noindent
（我稍微重新格式化了这个示例；调试器不会折叠长行。通常情况下，你可以在 @file{*Backtrace*} 缓冲区中键入 @kbd{q} 退出调试器。）

在实践中，对于这么简单的错误，Lisp错误行会告诉你正确的信息来修正定义。函数 @code{1=} 是无效的。

然而，假设你不太确定发生了什么？你可以阅读完整的回溯信息。

Emacs会自动启动调试器并将你放在 @file{*Backtrace*} 缓冲区中。你也可以按照下面的描述手动启动调试器。

从下到上阅读 @file{*Backtrace*} 缓冲区；它告诉你导致错误的Emacs操作。Emacs进行了对 @kbd{C-x C-e}（@code{eval-last-sexp}）的交互调用，这导致了对 @code{triangle-bugged} 表达式的评估。每一行以上告诉你Lisp解释器接下来评估了什么。

@need 1250
从缓冲区底部开始数第三行是

@smallexample
(setq number (1= number))
@end smallexample

@noindent
Emacs试图评估这个表达式；为了这样做，它试图评估缓冲区从上到下显示的内部表达式：

@smallexample
(1= number)
@end smallexample

@need 1250
@noindent
这就是错误发生的地方；正如最上面的行所说：

@smallexample
Debugger entered--Lisp error: (void-function 1=)
@end smallexample

@noindent
你可以纠正错误，重新评估函数定义，然后再次运行你的测试。

@node debug-on-entry
@section @code{debug-on-entry}
@findex debug-on-entry

当你的函数发生错误时，Emacs会自动启动调试器。

顺便提一下，你可以手动启动调试器，适用于所有版本的Emacs；其中的优势是，即使你的代码没有错误，调试器也会运行。有时候你的代码是没有bug的！

你可以通过调用 @code{debug-on-entry} 在调用函数时手动进入调试器。

@need 1250
@noindent
输入以下命令：

@smallexample
M-x debug-on-entry @key{RET} triangle-bugged @key{RET}
@end smallexample

@need 1250
@noindent
然后，评估以下表达式：

@smallexample
(triangle-bugged 5)
@end smallexample

@noindent
所有版本的Emacs都会创建一个 @file{*Backtrace*} 缓冲区，并告诉你它正在开始评估 @code{triangle-bugged} 函数：

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--entering a function:
* triangle-bugged(5)
  eval((triangle-bugged 5) nil)
@end group
@group
  eval-expression((triangle-bugged 5) nil nil 127)
  funcall-interactively(eval-expression (triangle-bugged 5) nil nil 127)
  call-interactively(eval-expression nil nil)
  command-execute(eval-expression)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

在 @file{*Backtrace*} 缓冲区中，输入 @kbd{d}。Emacs将评估 @code{triangle-bugged} 函数中的第一个表达式；缓冲区将如下所示：

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--beginning evaluation of function call form:
* (let ((total 0)) (while (> number 0) (setq total ...)
        (setq number ...)) total)
* triangle-bugged(5)
  eval((triangle-bugged 5))
@end group
@group
  eval((triangle-bugged 5) nil)
  eval-expression((triangle-bugged 5) nil nil 127)
  funcall-interactively(eval-expression (triangle-bugged 5) nil nil 127)
  call-interactively(eval-expression nil nil)
  command-execute(eval-expression)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@noindent
现在，再次输入 @kbd{d}，慢慢输入八次。每次输入 @kbd{d}，Emacs将评估函数定义中的另一个表达式。

@need 1750
最终，缓冲区将如下所示：

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--beginning evaluation of function call form:
* (setq number (1= number))
* (while (> number 0) (setq total (+ total number))
        (setq number (1= number)))
@group
@end group
* (let ((total 0)) (while (> number 0) (setq total ...)
        (setq number ...)) total)
* triangle-bugged(5)
  eval((triangle-bugged 5) nil)
@group
@end group
  eval-expression((triangle-bugged 5) nil)
  funcall-interactively((triangle-bugged 5) nil)
  call-interactively((triangle-bugged 5) nil)
  command-execute((triangle-bugged 5))
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@need 1500
@noindent
最后，在再次输入 @kbd{d} 两次后，Emacs将达到错误点，并且 @file{*Backtrace*} 缓冲区的前两行将如下所示：

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function 1=)
* (1= number)
@dots{}
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

通过输入 @kbd{d}，你能够逐步执行函数。

你可以通过在 @file{*Backtrace*} 缓冲区中输入 @kbd{q} 来退出；这将退出跟踪，但不会取消 @code{debug-on-entry}。

@findex cancel-debug-on-entry
要取消 @code{debug-on-entry} 的效果，调用 @code{cancel-debug-on-entry} 和函数的名称，如下：

@smallexample
M-x cancel-debug-on-entry @key{RET} triangle-bugged @key{RET}
@end smallexample

@noindent
(如果你在Info中阅读此内容，请现在取消 @code{debug-on-entry}。)

@node debug-on-quit
@section @code{debug-on-quit}和@code{(debug)}

除了设置@code{debug-on-error}或调用@code{debug-on-entry}之外，还有两种启动@code{debug}的方法。

@findex debug-on-quit
通过将变量@code{debug-on-quit}设置为@code{t}，你可以在键入@kbd{C-g}（@code{keyboard-quit}）时随时启动@code{debug}。这对于调试无限循环非常有用。

@need 1500
@cindex 在代码中使用@code{(debug)}
或者，你可以在代码中插入一行，如下所示，以在想要启动调试器的地方开始@code{(debug)}：

@smallexample
@group
(defun triangle-bugged (number)
  "返回从1累加到NUMBER的数字的总和。"
  (let ((total 0))
    (while (> number 0)
      (setq total (+ total number))
      (debug)                         ; @r{启动调试器。}
      (setq number (1- number)))      ; @r{错误出现在这里。}
    total))
@end group
@end smallexample

@code{debug}函数的详细信息在@ref{Debugger, ,Lisp 调试器, elisp, GNU Emacs Lisp参考手册}中有描述。

@node edebug
@section @code{edebug} 源码级调试器
@cindex 源码级调试器
@findex edebug

Edebug 是一个源码级调试器。Edebug 通常显示你正在调试的代码的源码，左边有一个箭头，指示你当前执行的是哪一行。

你可以逐行地走过函数的执行，或者快速运行直到达到一个@dfn{断点}，在那里停止执行。

有关 Edebug 的详细信息，请参阅@ref{Edebug, , , elisp, GNU Emacs Lisp 参考手册}。

@need 1250
下面是一个有bug的 @code{triangle-recursively} 函数定义。参见@xref{Recursive triangle function, , 替代计数的递归}进行查看。

@smallexample
@group
(defun triangle-recursively-bugged (number)
  "返回1到NUMBER（包括）之间数字的和，使用递归。"
  (if (= number 1)
      1
    (+ number
       (triangle-recursively-bugged
        (1= number)))))               ; @r{这里有错误。}
@end group
@end smallexample

@noindent
通常，你会通过将光标定位在函数的闭括号之后，然后输入 @kbd{C-x C-e}（@code{eval-last-sexp}），或者将光标定位在定义内部，然后输入 @kbd{C-M-x}（@code{eval-defun}）来安装这个定义。 （默认情况下，@code{eval-defun} 命令仅在 Emacs Lisp 模式或 Lisp 交互模式下工作。）

@need 1500
然而，为了准备这个函数定义以供 Edebug 使用，你必须首先使用不同的命令进行@dfn{仪器化}。你可以将光标定位在定义内部或之后，然后输入

@smallexample
M-x edebug-defun @key{RET}
@end smallexample

@noindent
这将导致 Emacs 在需要时自动加载 Edebug（如果尚未加载），并正确地仪器化该函数。

在仪器化函数之后，将光标放在以下表达式之后，然后输入 @kbd{C-x C-e}（@code{eval-last-sexp}）：

@smallexample
(triangle-recursively-bugged 3)
@end smallexample

@noindent
你将跳转回 @code{triangle-recursively-bugged} 的源码，光标定位在函数的 @code{if} 行的开头。此外，你将在该行的左侧看到一个箭头。箭头标记了函数执行的行。在下面的示例中，我们使用@samp{=>}显示箭头；在窗口系统中，你可能会在窗口边缘看到箭头作为一个实心三角形。

@smallexample
=>@point{}(if (= number 1)
@end smallexample

@noindent
@iftex
在示例中，点的位置显示为星号，例如，@samp{@point{}}（在 Info 中，它显示为 @samp{-!-}）。
@end iftex
@ifnottex
在示例中，点的位置显示为 @samp{@point{}}（在印刷书籍中，它显示为一个五角星）。
@end ifnottex

如果现在按下 @key{SPC} 键，点将移动到下一个要执行的表达式；该行将如下所示：

@smallexample
=>(if @point{}(= number 1)
@end smallexample

@noindent
随着你继续按下 @key{SPC}，点将从一个表达式移动到另一个表达式。与此同时，每当一个表达式返回一个值时，该值将显示在回显区域。例如，当你将点移到 @code{number} 后面时，你将看到以下内容：

@smallexample
Result: 3 (#o3, #x3, ?\C-c)
@end smallexample

@noindent
这意味着 @code{number} 的值是3，即八进制三，十六进制三，和 ASCII 控制字符C（字母表的第三个字母，如果你需要知道这些信息）。

你可以继续移动代码，直到到达包含错误的行。在评估之前，该行看起来像这样：

@smallexample
=>        @point{}(1= number)))))               ; @r{这里有错误。}
@end smallexample

@need 1250
@noindent
当你再次按下 @key{SPC} 时，将会产生一个错误消息，说：

@smallexample
Symbol's function definition is void:@: 1=
@end smallexample

@noindent
这就是bug。

按下 @kbd{q} 退出 Edebug。

要从函数定义中删除仪器化，只需使用不对其进行仪器化的命令重新评估它。例如，你可以将光标放在定义的闭括号之后，然后输入 @kbd{C-x C-e}。

Edebug 不仅仅能够与你一起逐步执行函数。你可以设置它，让它自己快速执行，只在错误或指定的停止点停下；你可以让它显示各种表达式的变化值；你可以了解一个函数被调用了多少次，等等。

有关 Edebug 的详细信息，请参阅@ref{Edebug, , , elisp, GNU Emacs Lisp 参考手册}。

@need 1500
@node Debugging Exercises
@section 调试练习

@itemize @bullet
@item
安装 @code{@value{COUNT-WORDS}} 函数，然后在调用它时使其进入内置调试器。在包含两个单词的区域上运行该命令。你将需要按下 @kbd{d} 键很多次。在你的系统上，命令完成后是否有一个叫做 hook 的钩子？（有关 hooks 的信息，请参见 @ref{Command Overview, , Command Loop Overview, elisp, The GNU Emacs Lisp Reference Manual}。）

@item
将 @code{@value{COUNT-WORDS}} 复制到 @file{*scratch*} 缓冲区中，为 Edebug 工具为该函数设置断点，并步进执行。该函数不一定要有 bug，尽管你可以引入一个如果愿意的话。如果函数没有 bug，步进执行将顺利完成。

@item
在运行 Edebug 时，按下 @kbd{?} 键以查看所有 Edebug 命令的列表。（@code{global-edebug-prefix} 通常是 @kbd{C-x X}，即按下 @kbd{@key{CTRL}-x} 后再按一个大写的 @kbd{X}；在 Edebug 调试缓冲区之外使用此前缀执行命令。）

@item
在 Edebug 调试缓冲区中，使用 @kbd{p} 命令（@code{edebug-bounce-point}）查看 @code{@value{COUNT-WORDS}} 在区域中的工作位置。

@item
将光标移动到函数内部的某个位置，然后键入 @kbd{h} 命令（@code{edebug-goto-here}）跳转到该位置。

@item
使用 @kbd{t} 命令（@code{edebug-trace-mode}）使 Edebug 自动步进执行函数；使用大写的 @kbd{T} 来使用 @code{edebug-Trace-fast-mode}。

@item
设置一个断点，然后在 Trace 模式下运行 Edebug，直到达到停止点。
@end itemize

@node Conclusion
@chapter 结论

我们现在已经到达了这个介绍的结尾。您现在已经学到足够的关于在Emacs Lisp中编程的知识，足以设置值、为自己和朋友编写简单的@file{.emacs}文件，以及编写对Emacs进行简单定制和扩展的代码。

这是一个停下来的地方。或者，如果您愿意，现在可以继续前进，自己深入学习。

您已经学到了一些编程的基础知识。但仅仅是一些。有许多容易使用的括号和铰链，我们尚未涉及。

您现在可以追踪GNU Emacs的源代码以及
@ifnotinfo
@cite{The GNU Emacs Lisp Reference Manual}。
@end ifnotinfo
@ifinfo
@ref{Top, , The GNU Emacs Lisp Reference Manual, elisp, The GNU
Emacs Lisp Reference Manual}.
@end ifinfo

Emacs Lisp的源代码是一场冒险。当您阅读源代码并遇到一个陌生的函数或表达式时，您需要弄清楚或找出它的作用。

前往参考手册。它是对Emacs Lisp进行了详尽、完整且相当易读的描述。它不仅是为专家编写的，还为像您一样有一定基础的人编写的。（@cite{参考手册}与标准GNU Emacs发行版一起提供。与本介绍一样，它作为一个Texinfo源文件，因此您可以在计算机上阅读它，并作为排版的印刷书籍阅读。）

查看GNU Emacs的其他内置帮助：所有函数和变量的内置文档，以及
@code{xref-find-definitions}，该程序可以带您转到源代码。

这里是我探索源代码的一个示例。由于其名称，@file{simple.el}是我很久以前首先查看的文件。恰好@file{simple.el}中的一些函数很复杂，或者至少乍一看很复杂。例如，@code{open-line}函数看起来很复杂。

您可能想像这个函数的作用，就像我们之前使用@code{forward-sentence}函数一样慢慢地走一遍。(@xref{forward-sentence, The
@code{forward-sentence} function}.) 或者您可能想跳过该函数，查看另一个函数，比如@code{split-line}。您不需要阅读所有函数。根据
@code{count-words-in-defun}，@code{split-line}函数包含102个单词和符号。

即使很短，@code{split-line}包含我们尚未学习的表达式：@code{skip-chars-forward}，@code{indent-to}，@code{current-column}和@code{insert-and-inherit}。

考虑@code{skip-chars-forward}函数。
在GNU Emacs中，您可以通过键入@kbd{C-h f}（@code{describe-function}）和函数的名称来查找有关@code{skip-chars-forward}的更多信息。这将显示函数文档。

您可能能够猜到一个命名得当的函数（例如@code{indent-to}）的作用；或者您也可以查找它。顺便说一下，@code{describe-function}函数本身位于@file{help.el}中；它是那些很长但可以解读的函数之一。您可以使用@kbd{C-h f}命令查找@code{describe-function}！

在这种情况下，由于代码是Lisp，@file{*Help*}缓冲区包含包含函数源代码的库的名称。您可以将光标放在库的名称上，按下@key{RET}键，在这种情况下它绑定到@code{help-follow}，直接转到源代码，方式类似于@kbd{M-.}（@code{xref-find-definitions}）。

@code{describe-function}的定义说明了如何定制@code{interactive}表达式，而不使用标准字符代码；它还展示了如何创建临时缓冲区。

（@code{indent-to}函数是用C而不是Emacs Lisp编写的；它是一个内置函数。@code{help-follow}会将您带到它的源代码，就像@code{xref-find-definitions}一样，当正确设置时。）

您可以使用@code{xref-find-definitions}查看函数的源代码，它绑定到@kbd{M-.}。最后，您可以查看Reference Manual中关于该函数的内容，方法是在Info中访问手册，然后键入@kbd{i}（@code{Info-index}）和函数的名称，或者在印刷副本的索引中查找该函数。

同样，您可以找出@code{insert-and-inherit}的含义。

其他有趣的源文件包括@file{paragraphs.el}、@file{loaddefs.el}和@file{loadup.el}。@file{paragraphs.el}文件包含简短、易于理解的函数以及较长的函数。@file{loaddefs.el}文件包含许多标准的自动加载和许多按键映射。我从未完全查看过它；只是查看了部分。@file{loadup.el}是加载Emacs标准部分的文件；它告诉您关于Emacs构建方式的很多信息。
(@xref{Building Emacs, , Building Emacs, elisp, The GNU Emacs Lisp
Reference Manual}，了解更多有关构建的信息。)

正如我所说，您已经学到了一些基础知识；但是，非常重要的是，我们几乎没有涉及编程的重要方面；我对如何排序信息一无所知，除了使用预定义的@code{sort}函数之外；我对如何存储信息一无所知，除了使用变量和列表之外；我对如何编写编写程序的程序一无所知。这是另一种、不同类型的书籍、不同类型的学习的主题。

您所做的是学到了足够在GNU Emacs中进行实际工作的知识。您所做的是开始。这是一个开始的结束。

@c ================ Appendix ================

@node the-the
@appendix The @code{the-the} 函数
@findex the-the
@cindex 重复单词函数
@cindex 单词, 重复

有时在写文本时，你会重复单词，就像本句子开头的 "you you" 一样。我发现最常见的情况是重复 "the"，因此，我称检测重复单词的函数为 @code{the-the}。

@need 1250
作为第一步，你可以使用以下正则表达式搜索重复项：

@smallexample
\\(\\w+[ \t\n]+\\)\\1
@end smallexample

@noindent
这个正则表达式匹配一个或多个单词成分字符，后面跟着一个或多个空格、制表符或换行符。然而，它不能检测不同行上的重复单词，因为第一个单词的结束，即行尾，与第二个单词的结束，即空格，不同。 （有关正则表达式的更多信息，请参见 @ref{Regexp Search, , 正则表达式搜索}，以及 @ref{Regexps, , 正则表达式语法, emacs, GNU Emacs 手册} 和 @ref{Regular Expressions, , 正则表达式, elisp, GNU Emacs Lisp 参考手册}。）

你可能尝试仅搜索重复的单词成分字符，但这不起作用，因为该模式检测到类似 "with the" 中的 "th" 的两个重复。

另一个可能的正则表达式搜索单词成分字符后跟非单词成分字符的模式，再次，这不是有用的。

这是我使用的模式。它不是完美的，但足够好。 @w{@samp{\\b}} 匹配空字符串，只要它位于单词的开头或结尾； @w{@samp{[^@@ \n\t]+}} 匹配一个或多个字符，这

@node Kill Ring
@appendix 处理 Kill Ring
@cindex Kill ring 处理
@cindex 处理 kill ring
@cindex Ring，生成类似列表的

Kill ring 是一个列表，通过 @code{current-kill} 函数的作用被转化为一个环。@code{yank} 和 @code{yank-pop} 命令使用 @code{current-kill} 函数。

本附录描述了 @code{current-kill} 函数以及 @code{yank} 和 @code{yank-pop} 命令，但首先，让我们了解一下 kill ring 的工作原理。

@menu
* What the Kill Ring Does::
* current-kill::
* yank::                        粘贴剪贴板元素的副本。
* yank-pop::                    插入指向的元素。
* ring file::
@end menu

@ifnottex
@node What the Kill Ring Does
@unnumberedsec Kill Ring 的作用
@end ifnottex

@need 1250
Kill ring 的默认最大长度是六十个元素；这个数字对于解释来说太大了。相反，将其设置为四。请执行以下操作：

@smallexample
@group
(setq old-kill-ring-max kill-ring-max)
(setq kill-ring-max 4)
@end group
@end smallexample

@noindent
然后，请将以下缩进的示例中的每行复制到 kill ring 中。您可以使用 @kbd{C-k} 杀死每行，或者用 @kbd{M-w} 标记并复制。

@noindent
（在只读缓冲区中，如 @file{*info*} 缓冲区中，杀死命令 @kbd{C-k}（@code{kill-line}）不会删除文本，只会将其复制到 kill ring 中。然而，您的机器可能会响铃。或者，为了保持安静，您可以使用 @kbd{M-w}（@code{kill-ring-save}）命令复制每行的区域。您必须为该命令标记每一行，但无论将点放在哪一端都没有关系。）

@need 1250
@noindent
请按顺序调用这些调用，以使五个元素尝试填充 kill ring：

@smallexample
@group
first some text
second piece of text
third line
fourth line of text
fifth bit of text
@end group
@end smallexample

@need 1250
@noindent
然后通过评估以下表达式找到 @code{kill-ring} 的值：

@smallexample
kill-ring
@end smallexample

@need 800
@noindent
它是：

@smallexample
@group
("fifth bit of text" "fourth line of text"
"third line" "second piece of text")
@end group
@end smallexample

@noindent
第一个元素，@samp{first some text}，被删除。

@need 1250
要恢复 kill ring 长度的旧值，请执行：

@smallexample
(setq kill-ring-max old-kill-ring-max)
@end smallexample

@node current-kill
@appendixsec The @code{current-kill} 函数
@findex current-kill

@code{current-kill} 函数改变 kill 环中由 @code{kill-ring-yank-pointer} 指向的元素。
（同时，@code{kill-new} 函数将 @code{kill-ring-yank-pointer} 设置为指向 kill 环的最新元素。
@code{kill-new} 函数直接或间接地被 @code{kill-append}、@code{copy-region-as-kill}、
@code{kill-ring-save}、@code{kill-line} 和 @code{kill-region} 使用。）

@menu
* Code for current-kill::
* Understanding current-kill::
@end menu

@ifnottex
@node Code for current-kill
@unnumberedsubsec @code{current-kill} 的代码
@end ifnottex

@need 1500
@code{current-kill} 函数被 @code{yank} 和 @code{yank-pop} 使用。下面是 @code{current-kill} 的代码：

@smallexample
@group
(defun current-kill (n &optional do-not-move)
  "将插入点在 kill 环中旋转 N 个位置，然后返回该 kill。
如果 N 为零，并且 `interprogram-paste-function' 设置为返回字符串或字符串列表的函数，
并且该函数不返回 nil，则将该字符串（或列表）添加到 kill 环的最前面，并将该字符串
（或列表的第一个字符串）作为最新的 kill 返回。

如果 N 不为零，并且 `yank-pop-change-selection' 为非 nil，则使用
`interprogram-cut-function' 将新的插入点处的 kill 转移到窗口系统的选择中。

如果可选参数 DO-NOT-MOVE 为非 nil，则实际上不移动插入点；只是返回第 N 个 kill。"

  (let ((interprogram-paste (and (= n 0)
                                 interprogram-paste-function
                                 (funcall interprogram-paste-function))))
@end group
@group
    (if interprogram-paste
        (progn
          ;; 在将新文本添加到 kill 环时禁用 interprogram cut 函数，
          ;; 以便 Emacs 不尝试拥有相同的文本选择。
          (let ((interprogram-cut-function nil))
            (if (listp interprogram-paste)
              (mapc 'kill-new (nreverse interprogram-paste))
              (kill-new interprogram-paste)))
          (car kill-ring))
@end group
@group
      (or kill-ring (error "Kill 环为空"))
      (let ((ARGth-kill-element
             (nthcdr (mod (- n (length kill-ring-yank-pointer))
                          (length kill-ring))
                     kill-ring)))
        (unless do-not-move
          (setq kill-ring-yank-pointer ARGth-kill-element)
          (when (and yank-pop-change-selection
                     (> n 0)
                     interprogram-cut-function)
            (funcall interprogram-cut-function (car ARGth-kill-element))))
        (car ARGth-kill-element)))))
@end group
@end smallexample

还要记住，@code{kill-new} 函数将 @code{kill-ring-yank-pointer} 设置为 kill 环的最新元素，
这意味着所有调用它的函数都间接地设置了该值：@code{kill-append}、@code{copy-region-as-kill}、
@code{kill-ring-save}、@code{kill-line} 和 @code{kill-region}。

@need 1500
下面是 @code{kill-new} 中的一行，详见 @ref{kill-new function, , @code{kill-new} 函数}。

@smallexample
(setq kill-ring-yank-pointer kill-ring)
@end smallexample

@ifnottex
@node Understanding current-kill
@unnumberedsubsec 在大纲中理解 @code{current-kill}
@end ifnottex

@code{current-kill} 函数看起来复杂，但通常情况下，通过逐步分解可以理解它。
首先以骨架形式查看：

@smallexample
@group
(defun current-kill (n &optional do-not-move)
  "将插入点在 kill 环中旋转 N 个位置，然后返回该 kill。"
  (let @var{varlist}
    @var{body}@dots{})
@end group
@end smallexample

此函数接受两个参数，其中一个是可选的。它有一个文档字符串。它 @emph{不}是交互式的。

@menu
* Body of current-kill::
* Digression concerning error:: 如何误导人类，但不是计算机。
* Determining the Element::
@end menu

@ifnottex
@node Body of current-kill
@unnumberedsubsubsec @code{current-kill} 函数体
@end ifnottex

函数定义体是一个 @code{let} 表达式，它本身有一个体和一个 @var{varlist}。

@code{let} 表达式声明了一个仅在此函数范围内可用的变量。这个变量称为 @code{interprogram-paste}，用于复制到另一个程序，而不是在此 GNU Emacs 实例内进行复制。大多数窗口系统提供了跨程序粘贴的功能。遗憾的是，这个功能通常只提供最后一个元素。尽管 Emacs 几十年来一直提供了许多可能性的环形，但大多数窗口系统尚未采用。

@code{if} 表达式有两个部分，一个是如果存在 @code{interprogram-paste}，另一个是如果不存在。

@need 2000
让我们考虑 @code{current-kill} 函数的 else-部分。（then-部分使用我们已经描述的 @code{kill-new} 函数。@xref{kill-new function, , @code{kill-new} 函数}）。

@smallexample
@group
(or kill-ring (error "Kill ring is empty"))
(let ((ARGth-kill-element
       (nthcdr (mod (- n (length kill-ring-yank-pointer))
                    (length kill-ring))
               kill-ring)))
  (or do-not-move
      (setq kill-ring-yank-pointer ARGth-kill-element))
  (car ARGth-kill-element))
@end group
@end smallexample

@noindent
代码首先检查 kill 环是否有内容；否则，它会发出一个错误。

@need 1000
请注意，@code{or} 表达式与使用 @code{if} 测试长度非常相似：

@findex zerop
@findex error
@smallexample
@group
(if (zerop (length kill-ring))          ; @r{if-部分}
    (error "Kill ring is empty"))       ; @r{then-部分}
  ;; 没有 else-部分
@end group
@end smallexample

@noindent
如果 kill 环中没有任何内容，它的长度必须为零，并向用户发送错误消息：@samp{Kill ring is empty}。@code{current-kill} 函数使用一个更简单的 @code{or} 表达式。但是，一个 @code{if} 表达式提醒我们发生了什么。

此 @code{if} 表达式使用函数 @code{zerop}，如果它测试的值为零，则返回 true。当 @code{zerop} 测试为 true 时，@code{if} 的 then-部分将被评估。then-部分是以函数 @code{error} 开头的列表，它是一种类似于 @code{message} 函数的函数
(@pxref{message, , The @code{message} Function})，因为它在回显区域打印一行消息。然而，除了打印消息之外，@code{error} 还会停止它嵌套在其中的函数的评估。这意味着如果 kill 环的长度为零，则函数的其余部分将不会被评估。

然后，@code{current-kill} 函数选择要返回的元素。选择取决于 @code{current-kill} 旋转的位置以及 @code{kill-ring-yank-pointer} 指向的位置。

接下来，如果可选的 @code{do-not-move} 参数为 true，或者当前值 @code{kill-ring-yank-pointer} 被设置为指向列表。最后，另一个表达式返回列表的第一个元素，即使 @code{do-not-move} 参数为 true。

@ifnottex
@node Digression concerning error
@unnumberedsubsubsec 有关术语“error”的离题讨论
@end ifnottex

在我看来，将“error”作为 @code{error} 函数的名称，至少对人类来说，有点误导。一个更好的术语应该是“cancel”（取消）。严格来说，当然，你不能指向，更不用说旋转指向一个长度为零的列表，因此从计算机的角度来看，“error”一词是正确的。但是人类期望尝试这种事情，即使只是为了找出 kill 环是满的还是空的。这是一种探索的行为。

从人类的角度来看，探索和发现的行为不一定是错误的，因此不应该被标记为错误，即使在计算机的深处。事实上，Emacs 中的代码暗示了一个以探索环境为美德的人类正在犯错误。这是不好的。即使计算机采取与错误相同的步骤，诸如“cancel”这样的术语会有一个更清晰的内涵。

@ifnottex
@node Determining the Element
@unnumberedsubsubsec 确定元素
@end ifnottex

在 @code{if} 表达式的 else 部分中，除了执行其他动作外，当 kill 环中有内容且 @code{do-not-move} 的值为 @code{nil} 时，@code{if} 表达式的 else 部分会将 @code{kill-ring-yank-pointer} 的值设置为 @code{ARGth-kill-element}。

@need 800
代码如下：

@smallexample
@group
(nthcdr (mod (- n (length kill-ring-yank-pointer))
             (length kill-ring))
        kill-ring)))
@end group
@end smallexample

这需要一些解释。除非不打算移动指针，@code{current-kill} 函数会改变 @code{kill-ring-yank-pointer} 指向的位置。
这就是 @w{@code{(setq kill-ring-yank-pointer ARGth-kill-element))}} 表达式的作用。
显然，@code{ARGth-kill-element} 被设置为与 kill 环的某个 @sc{cdr} 相等，使用了在前面一节中描述的 @code{nthcdr} 函数。
(@xref{copy-region-as-kill}。) 它是如何实现的呢？

正如我们之前所看到的 (@pxref{nthcdr})，@code{nthcdr} 函数通过反复取列表的 @sc{cdr} 来工作---它取 @sc{cdr} 的 @sc{cdr} 的 @sc{cdr} @dots{}

@need 800
以下两个表达式产生相同的结果：

@smallexample
@group
(setq kill-ring-yank-pointer (cdr kill-ring))

(setq kill-ring-yank-pointer (nthcdr 1 kill-ring))
@end group
@end smallexample

然而，@code{nthcdr} 表达式更加复杂。它使用 @code{mod} 函数来确定要选择哪个 @sc{cdr}。

(记得先看内部函数；事实上，我们将不得不深入了解 @code{mod}。)

@code{mod} 函数返回其第一个参数对第二个参数取模的值；换句话说，它返回第一个参数除以第二个参数后的余数。返回值与第二个参数具有相同的符号。

@need 800
因此，

@smallexample
@group
(mod 12 4)
  @result{} 0  ;; @r{因为没有余数}
(mod 13 4)
  @result{} 1
@end group
@end smallexample

@need 1250
在这种情况下，第一个参数通常小于第二个参数。这没问题。

@smallexample
@group
(mod 0 4)
  @result{} 0
(mod 1 4)
  @result{} 1
@end group
@end smallexample

我们可以猜测 @code{-} 函数的作用。它类似于 @code{+}，但是执行减法而不是加法；@code{-} 函数从其第一个参数中减去第二个参数。此外，我们已经知道 @code{length} 函数的作用 (@pxref{length})。它返回列表的长度。

而 @code{n} 是 @code{current-kill} 函数的必需参数的名称。

@need 1250
因此，当 @code{nthcdr} 的第一个参数为零时，@code{nthcdr} 表达式返回整个列表，如下所示：

@smallexample
@group
;; kill-ring-yank-pointer 和 kill-ring 的长度均为四
;; 而 (mod (- 0 4) 4) 的结果为 0
(nthcdr (mod (- 0 4) 4)
        '("fourth line of text"
          "third line"
          "second piece of text"
          "first some text"))
@end group
@end smallexample

@need 1250
当 @code{current-kill} 函数的第一个参数为一时，@code{nthcdr} 表达式返回不包含其第一个元素的列表。

@smallexample
@group
(nthcdr (mod (- 1 4) 4)
        '("fourth line of text"
          "third line"
          "second piece of text"
          "first some text"))
@end group
@end smallexample

@cindex @samp{全局变量} 定义
@cindex @samp{变量, 全局}，定义
顺便说一下，@code{kill-ring} 和 @code{kill-ring-yank-pointer} 都是 @dfn{全局变量}。这意味着 Emacs Lisp 中的任何表达式都可以访问它们。它们不像由 @code{let} 定义的局部变量或参数列表中指定的符号那样。局部变量只能在定义它们的 @code{let} 内部或在参数列表中指定它们的函数内访问（以及由它们调用的表达式内访问）。

@c texi2dvi 在 section 的名称在 ifnottex 中时会失败...
@ifnottex
(@xref{Prevent confusion, , @code{let} 避免混淆}, 和
@end ifnottex
@iftex
(@xref{Permanent Installation, , @code{let} Prevents Confusion}, 和
@end iftex
@ref{defun, , The @code{defun} Macro}.)

@node yank
@appendixsec @code{yank}
@findex yank

在学习了@code{current-kill}之后，@code{yank}函数的代码几乎变得很简单。

@code{yank}函数不直接使用@code{kill-ring-yank-pointer}变量。它调用@code{insert-for-yank}，而@code{insert-for-yank}又调用@code{current-kill}，后者设置了@code{kill-ring-yank-pointer}变量。

@need 1250
代码如下：

@c 在GNU Emacs 22中
@smallexample
@group
(defun yank (&optional arg)
  "重新插入（\"粘贴\"）最近一次删除的文本段。
更准确地说，重新插入最近一次删除或粘贴的文本段。将光标放在末尾，并在开头设置标记。
使用 \\[universal-argument] 作为参数时，效果相同，但将光标放在开头（标记放在末尾）。
带有参数N时，重新插入第N个最近删除的文本段。

当此命令将删除的文本插入缓冲区时，将遵循`yank-excluded-properties'和`yank-handler'，如`insert-for-yank-1'的文档字符串所述，请参见。

还可以参考命令`yank-pop'（\\[yank-pop]）."
@end group
@group
  (interactive "*P")
  (setq yank-window-start (window-start))
  ;; 如果没有完全执行，使last-command指示随后的命令。
  (setq this-command t)
  (push-mark (point))
@end group
@group
  (insert-for-yank (current-kill (cond
                                  ((listp arg) 0)
                                  ((eq arg '-) -2)
                                  (t (1- arg)))))
  (if (consp arg)
      ;; 这类似于exchange-point-and-mark，但不激活标记。
      ;; 尽管命令循环会因为插入文本而取消激活标记，但避免激活更清晰。
      (goto-char (prog1 (mark t)
                   (set-marker (mark-marker) (point) (current-buffer)))))
@end group
@group
  ;; 如果完全执行，使this-command指示。
  (if (eq this-command t)
      (setq this-command 'yank))
  nil)
@end group
@end smallexample

关键表达式是@code{insert-for-yank}，它插入由@code{current-kill}返回的字符串，但从中删除了一些文本属性。

然而，在到达该表达式之前，函数将@code{yank-window-start}的值设置为@code{(window-start)}表达式返回的位置，即显示当前开始的位置。@code{yank}函数还设置了@code{this-command}并推送了标记。

在它插入适当的元素之后，如果可选参数是@sc{cons}而不是数字或为空，它将光标放在插入的文本的开头，并在其末尾设置标记。

（@code{prog1}函数类似于@code{progn}，但返回其第一个参数的值，而不是其最后一个参数的值。其第一个参数被强制为整数返回缓冲区的标记。可以通过将光标置于此缓冲区中的这些函数上，然后键入@kbd{C-h f}（@code{describe-function}）并随后键入@kbd{RET}来查看这些函数的文档；默认为函数。）

函数成功时的最后部分说明了要做什么。

@node yank-pop
@appendixsec @code{yank-pop}
@findex yank-pop

在理解了 @code{yank} 和 @code{current-kill} 之后，你就知道如何处理 @code{yank-pop} 函数了。为了节省空间，下面是省略了文档的函数定义：

@c GNU Emacs 22
@smallexample
@group
(defun yank-pop (&optional arg)
  "@dots{}"
  (interactive "*p")
  (if (not (eq last-command 'yank))
      (error "上一个命令不是 yank"))
@end group
@group
  (setq this-command 'yank)
  (unless arg (setq arg 1))
  (let ((inhibit-read-only t)
        (before (< (point) (mark t))))
@end group
@group
    (if before
        (funcall (or yank-undo-function 'delete-region) (point) (mark t))
      (funcall (or yank-undo-function 'delete-region) (mark t) (point)))
    (setq yank-undo-function nil)
@end group
@group
    (set-marker (mark-marker) (point) (current-buffer))
    (insert-for-yank (current-kill arg))
    ;; 如果可能，将窗口的起始位置设置回 yank 命令之前的位置。
    (set-window-start (selected-window) yank-window-start t)
@end group
@group
    (if before
        ;; 这类似于 exchange-point-and-mark，
        ;; 但不激活标记。
        ;; 即使命令循环会因为我们插入文本而取消激活标记，
        ;; 这样做更干净，因为我们避免了激活。
        (goto-char (prog1 (mark t)
                     (set-marker (mark-marker)
                                 (point)
                                 (current-buffer))))))
  nil)
@end group
@end smallexample

这个函数是交互式的，带有一个小的 @samp{p}，因此前缀参数会被处理并传递给函数。该命令只能在先前的 yank 后使用；否则会发送错误消息。此检查使用变量 @code{last-command}，该变量由 @code{yank} 设置，并在其他地方进行了讨论。(@xref{copy-region-as-kill}。)

@code{let} 子句将变量 @code{before} 设置为 true 或 false，具体取决于 point 是否在 mark 之前，然后删除 point 和 mark 之间的区域。这是由前一个 yank 命令刚插入的区域，也就是将被替换的文本。

@code{funcall} 将其第一个参数作为函数调用，并将其余参数传递给它。第一个参数是 @code{or} 表达式返回的内容。其余两个参数是由前一个 @code{yank} 命令设置的 point 和 mark 的位置。

还有更多内容，但这是最难的部分。

@node ring file
@appendixsec The @file{ring.el} File
@cindex @file{ring.el} file

有趣的是，GNU Emacs 拥有一个名为 @file{ring.el} 的文件，它提供了我们刚刚讨论的许多功能。但诸如 @code{kill-ring-yank-pointer} 等功能并未使用该库，可能是因为它们是较早编写的。

@node Full Graph
@appendix 带有标记轴的图表

印刷的坐标轴有助于理解图表，它们传达了比例尺。在之前的章节中（@pxref{Readying a Graph, ,准备图表}），我们编写了打印图表主体的代码。在这里，我们编写打印和标记垂直和水平轴的代码，以及图表主体本身。

@menu
* Labeled Example::
* print-graph Varlist::         @code{let} 表达式在 @code{print-graph} 中的使用。
* print-Y-axis::                打印垂直轴的标签。
* print-X-axis::                打印水平标签。
* Print Whole Graph::           用于打印完整图表的函数。
@end menu

@ifnottex
@node Labeled Example
@unnumberedsec 带标签示例图表
@end ifnottex

由于插入会填充到点的右侧和下方的缓冲区，新的图表打印函数应该首先打印Y或垂直轴，然后是图表的主体，最后是X或水平轴。这个顺序为我们规定了函数的内容：

@enumerate
@item
设置代码。

@item
打印Y轴。

@item
打印图表主体。

@item
打印X轴。
@end enumerate

@need 800
这是一个完成的图表应该看起来的示例：

@smallexample
@group
    10 -
                  *
                  *  *
                  *  **
                  *  ***
     5 -      *   *******
            * *** *******
            *************
          ***************
     1 - ****************
         |   |    |    |
         1   5   10   15
@end group
@end smallexample

@noindent
在这个图表中，垂直轴和水平轴都用数字标记。然而，在一些图表中，水平轴表示时间，最好用月份标记，就像这样：

@smallexample
@group
     5 -      *
            * ** *
            *******
          ********** **
     1 - **************
         |    ^      |
         一月  六月   一月
@end group
@end smallexample

事实上，经过一点思考，我们可以轻松想出各种垂直和水平标记方案。我们的任务可能变得复杂。但是复杂性会导致混淆。与其允许这种情况发生，不如为我们的第一次尝试选择一个简单的标记方案，以后再进行修改或替换。

@need 1200
这些考虑建议了@code{print-graph}函数的以下大纲：

@smallexample
@group
(defun print-graph (numbers-list)
  "@var{文档}@dots{}"
  (let ((height  @dots{}
        @dots{}))
@end group
@group
    (print-Y-axis height @dots{} )
    (graph-body-print numbers-list)
    (print-X-axis @dots{} )))
@end group
@end smallexample

我们可以逐步处理@code{print-graph}函数定义的每个部分。

@node print-graph Varlist
@appendixsec 打印图形的 @code{print-graph} Varlist
@cindex @code{print-graph} 变量列表

在编写 @code{print-graph} 函数时，第一项任务是在 @code{let} 表达式中写入 varlist。（我们暂时不考虑将函数设计成交互式的，也不考虑文档字符串的内容。）

Varlist 应该设置几个值。显然，垂直轴标签的顶部必须至少与图形的高度相同，这意味着我们必须在这里获取此信息。请注意，@code{print-graph-body} 函数也需要此信息。在两个不同的地方计算图形的高度是没有必要的，因此我们应该修改 @code{print-graph-body} 的定义，以利用这个计算。

同样，打印 X 轴标签的函数和 @code{print-graph-body} 函数都需要获取每个符号的宽度值。我们可以在这里执行计算，并更改前一章中定义的 @code{print-graph-body} 的方式。

水平轴标签的长度必须至少与图形的长度相同。然而，此信息仅在打印水平轴的函数中使用，因此不需要在这里进行计算。

这些思考直接引导我们到 @code{print-graph} 的 @code{let} 中的以下形式的 varlist：

@smallexample
@group
(let ((height (apply 'max numbers-list)) ; @r{第一版。}
      (symbol-width (length graph-blank)))
@end group
@end smallexample

@noindent
正如我们将看到的，这个表达式并不完全正确。

@need 2000
@node print-Y-axis
@appendixsec @code{print-Y-axis} 函数
@cindex 垂直轴打印
@cindex Y 轴打印
@cindex 垂直轴打印
@cindex 打印垂直轴

@code{print-Y-axis} 函数的任务是打印垂直轴的标签，其外观如下：

@smallexample
@group
    10 -




     5 -



     1 -
@end group
@end smallexample

@noindent
函数应该接收图形的高度，然后构建并插入相应的数字和标记。

@menu
* print-Y-axis in Detail::
* Height of label::             Y 轴的高度应该是多少？
* Compute a Remainder::         如何计算除法的余数。
* Y Axis Element::              构建 Y 轴线。
* Y-axis-column::               生成 Y 轴标签的列表。
* print-Y-axis Penultimate::    不太终极的版本。
@end menu

@ifnottex
@node print-Y-axis in Detail
@unnumberedsubsec @code{print-Y-axis} 函数详解
@end ifnottex

很容易在图中看到 Y 轴标签应该是什么样子；但用文字表达，然后编写一个函数定义来完成这项工作是另一回事。说“我们希望每五行有一个数字和一个刻度”并不完全准确：在 @samp{1} 和 @samp{5} 之间只有三条线（2、3和4行），但在 @samp{5} 和 @samp{10} 之间有四条线（6、7、8和9行）。更好的说法是，我们希望在基线上（数字 1）有一个数字和一个刻度标记，然后在距离底部第五行以及每个是五的倍数的行上都有一个数字和一个刻度。

@ifnottex
@node Height of label
@unnumberedsubsec 标签的高度应该是多少？
@end ifnottex

下一个问题是标签应该是多高？假设图形中最高柱的高度是七。最高的 Y 轴标签应该是 @samp{5 -} 吗？图形应该突出标签吗？还是最高标签应该是 @samp{7 -}，标记图形的峰值？还是最高标签应该是 @code{10 -}，是五的倍数，并且高于图形的最高值？

我们更喜欢后一种形式。大多数图形都是在边长是整数步长的矩形内绘制的——步长为五时为5、10、15等。但一旦我们决定在垂直轴上使用步幅，我们会发现在计算高度的 varlist 中，简单的表达式是错误的。该表达式是 @code{(apply 'max numbers-list)}。这返回精确的高度，而不是最大高度加上使其四舍五入到最近的五的倍数所需的任何值。需要更复杂的表达式。

像这样的复杂问题，如果分成几个较小的问题，通常会变得更简单。

首先，考虑最高值是五的整数倍时的情况——当它是5、10、15或更高的五的倍数时。我们可以将此值用作 Y 轴的高度。

确定一个数字是否是五的倍数的一种相当简单的方法是将其除以五，看看除法是否有余数。如果没有余数，那么该数字是五的倍数。因此，七除以五的余数是二，七不是五的整数倍。稍微用不同的措辞，更像是课堂上的表达方式，五除以七一次有余数二，但五除以十两次没有余数：十是五的整数倍。

@node Compute a Remainder
@appendixsubsec 附录：计算余数

@findex % @r{(余数函数)}
@cindex 余数函数，@code{%}
在Lisp中，用于计算余数的函数是@code{%}。该函数返回其第一个参数除以第二个参数的余数。正巧，@code{%}在Emacs Lisp中是一个无法通过@code{apropos}发现的函数：如果输入@kbd{M-x apropos @key{RET} remainder @key{RET}}，你将找不到任何结果。了解@code{%}存在的唯一方式是通过阅读本书或Emacs Lisp源代码。

你可以通过评估以下两个表达式来尝试@code{%}函数：

@smallexample
@group
(% 7 5)

(% 10 5)
@end group
@end smallexample

@noindent
第一个表达式返回2，第二个表达式返回0。

为了测试返回值是否为零或其他数字，我们可以使用@code{zerop}函数。该函数在其参数（必须是数字）为零时返回@code{t}。

@smallexample
@group
(zerop (% 7 5))
     @result{} nil

(zerop (% 10 5))
     @result{} t
@end group
@end smallexample

因此，以下表达式将在图的高度能够被五整除时返回@code{t}：

@smallexample
(zerop (% height 5))
@end smallexample

@noindent
（当然，@code{height}的值可以通过@code{(apply 'max numbers-list)}获得。）

另一方面，如果@code{height}的值不是五的倍数，我们希望将其重置为下一个更高的五的倍数。这是使用我们已经熟悉的函数进行的简单算术。首先，我们将@code{height}的值除以五，以确定五可以整除该数多少次。因此，五可以整除十二两次。如果我们将这个商加一并乘以五，就会得到大于该高度的下一个五的倍数的值。五可以整除十二两次。将二加一，并乘以五；结果是十五，这是大于十二的下一个五的倍数。这个Lisp表达式是：

@smallexample
(* (1+ (/ height 5)) 5)
@end smallexample

@noindent
例如，如果你评估以下表达式，结果将是15：

@smallexample
(* (1+ (/ 12 5)) 5)
@end smallexample

在整个讨论中，我们一直使用5作为Y轴标签间隔的值；但我们可能想要使用其他值。为了通用性，我们应该用一个变量替换5，以便我们可以为其赋值。我能想到的这个变量的最佳名称是@code{Y-axis-label-spacing}。

@need 1250
使用这个术语和一个@code{if}表达式，我们可以得到以下结果：

@smallexample
@group
(if (zerop (% height Y-axis-label-spacing))
    height
  ;; @r{否则}
  (* (1+ (/ height Y-axis-label-spacing))
     Y-axis-label-spacing))
@end group
@end smallexample

@noindent
如果高度是@code{Y-axis-label-spacing}的偶数倍，此表达式将返回@code{height}本身，否则它计算并返回一个等于@code{Y-axis-label-spacing}的下一个更高倍数的@code{height}值。

现在，我们可以将此表达式包含在@code{print-graph}函数的@code{let}表达式中（首先设置@code{Y-axis-label-spacing}的值）：

@vindex Y-axis-label-spacing

@smallexample
@group
(defvar Y-axis-label-spacing 5
  "从一个Y轴标签到下一个的行数。")
@end group

@group
@dots{}
(let* ((height (apply 'max numbers-list))
       (height-of-top-line
        (if (zerop (% height Y-axis-label-spacing))
            height
@end group
@group
          ;; @r{否则}
          (* (1+ (/ height Y-axis-label-spacing))
             Y-axis-label-spacing)))
       (symbol-width (length graph-blank))))
@dots{}
@end group
@end smallexample

@noindent
（注意使用@code{let*}函数：通过@code{(apply 'max numbers-list)}表达式计算一次@code{height}的初始值，然后使用@code{height}的结果值计算其最终值。有关@code{let*}的更多信息，请参阅@xref{fwd-para let, , The @code{let*} expression}。）

@node Y Axis Element
@appendixsubsec 构建Y轴元素

当我们打印垂直轴时，我们希望在每五行插入诸如 @w{@samp{5 -}} 和 @w{@samp{10 - }} 等字符串。
此外，我们希望数字和破折号对齐，因此较短的数字必须填充前导空格。
如果一些字符串使用两位数字，则具有单个数字的字符串必须在数字前包含前导空格。

@findex number-to-string
为了确定数字的长度，使用了 @code{length} 函数。
但是 @code{length} 函数只能处理字符串，而不能处理数字。因此，数字必须转换为字符串。
这是通过 @code{number-to-string} 函数完成的。例如，

@smallexample
@group
(length (number-to-string 35))
     @result{} 2

(length (number-to-string 100))
     @result{} 3
@end group
@end smallexample

(@code{number-to-string} 也被称为 @code{int-to-string}；在各种来源中，您会看到这个替代名称。)

此外，在每个标签中，每个数字后面都跟着一个字符串，例如 @w{@samp{ - }}，我们将其称为 @code{Y-axis-tic} 标记。
该变量使用 @code{defvar} 定义：

@vindex Y-axis-tic
@smallexample
@group
(defvar Y-axis-tic " - "
   "Y轴标签中数字后面跟随的字符串。")
@end group
@end smallexample

Y标签的长度是Y轴标记的长度和图表顶部的数字的长度之和。

@smallexample
(length (concat (number-to-string height) Y-axis-tic)))
@end smallexample

此值将由 @code{print-graph} 函数在其 varlist 中作为 @code{full-Y-label-width} 计算，并传递给下一个函数。（请注意，在我们首次提出 varlist 时，我们没有考虑包含这个。）

为了创建完整的垂直轴标签，一个刻度标记与一个数字连接在一起；两者一起可能在数字前包含一个或多个空格，这取决于数字有多长。
标签由三部分组成：（可选的）前导空格、数字和刻度标记。
该函数接收特定行的数字值和由 @code{print-graph} 计算的顶部线的宽度的值，该值仅计算一次。

@smallexample
@group
(defun Y-axis-element (number full-Y-label-width)
  "构建一个带有数字的标签元素。
数字元素的外观如下 `  5 - '，并根据最大数字的元素进行必要的填充，以使所有元素对齐。")
@end group
@group
  (let* ((leading-spaces
         (- full-Y-label-width
            (length
             (concat (number-to-string number)
                     Y-axis-tic)))))
@end group
@group
    (concat
     (make-string leading-spaces ? )
     (number-to-string number)
     Y-axis-tic)))
@end group
@end smallexample

@code{Y-axis-element} 函数将前导空格（如果有的话）、作为字符串的数字和刻度标记连接在一起。

为了确定标签需要多少前导空格，该函数从实际标签的长度（数字长度加刻度标记长度）中减去所需的标签宽度。

@findex make-string
使用 @code{make-string} 函数插入空格。该函数接受两个参数：第一个参数告诉它字符串的长度，第二个是要插入的字符的符号，以特殊的格式。格式是一个问号后跟一个空格，如此，@samp{? }。参见@xref{Character Type, , Character Type, elisp, The GNU Emacs Lisp Reference Manual}，以获取有关字符语法的描述。（当然，您可能希望将空格替换为其他字符@dots{} 您知道该怎么做。）

在连接表达式中使用 @code{number-to-string} 函数，将数字转换为与前导空格和刻度标记连接的字符串。

@node Y-axis-column
@appendixsubsec 创建Y轴标签列

前述函数提供了构建生成垂直轴标签的编号和空字符串列表所需的所有工具：

@findex Y-axis-column
@smallexample
@group
(defun Y-axis-column (height width-of-label)
  "构建Y轴标签和空字符串的列表。
对于线以上的高度和标签的宽度WIDTH-OF-LABEL。"
  (let (Y-axis)
@group
@end group
    (while (> height 1)
      (if (zerop (% height Y-axis-label-spacing))
          ;; @r{插入标签。}
          (setq Y-axis
                (cons
                 (Y-axis-element height width-of-label)
                 Y-axis))
@group
@end group
        ;; @r{否则，插入空白。}
        (setq Y-axis
              (cons
               (make-string width-of-label ? )
               Y-axis)))
      (setq height (1- height)))
    ;; @r{插入基准线。}
    (setq Y-axis
          (cons (Y-axis-element 1 width-of-label) Y-axis))
    (nreverse Y-axis)))
@end group
@end smallexample

在这个函数中，我们从@code{height}的值开始，重复减去1。在每次减法之后，我们测试值是否是@code{Y-axis-label-spacing}的整数倍。如果是，我们使用@code{Y-axis-element}函数构造一个带有编号的标签；如果不是，我们使用@code{make-string}函数构造一个空白标签。基准线由数字1和一个刻度标记组成。

@need 2000
@node print-Y-axis Penultimate
@appendixsubsec @code{print-Y-axis}的未完全最终版本

由@code{Y-axis-column}函数构建的列表被传递给@code{print-Y-axis}函数，该函数将列表作为列插入。

@findex print-Y-axis
@smallexample
@group
(defun print-Y-axis (height full-Y-label-width)
  "使用HEIGHT和FULL-Y-LABEL-WIDTH插入Y轴。
Height必须是图形的最大高度。
全宽度是最高标签元素的宽度。"
;; Height和full-Y-label-width的值由print-graph传递。
@end group
@group
  (let ((start (point)))
    (insert-rectangle
     (Y-axis-column height full-Y-label-width))
    ;; @r{将点置于插入图形的正确位置。}
    (goto-char start)
    ;; @r{将点向前移动FULL-Y-LABEL-WIDTH的值}
    (forward-char full-Y-label-width)))
@end group
@end smallexample

@code{print-Y-axis}使用@code{insert-rectangle}函数插入由@code{Y-axis-column}函数创建的Y轴标签。此外，它将点放置在正确的位置以打印图形的主体。

您可以测试@code{print-Y-axis}：

@enumerate
@item
安装

@smallexample
@group
Y-axis-label-spacing
Y-axis-tic
Y-axis-element
Y-axis-column
print-Y-axis
@end group
@end smallexample

@item
复制以下表达式：

@smallexample
(print-Y-axis 12 5)
@end smallexample

@item
切换到@file{*scratch*}缓冲区，并将光标放在希望开始轴标签的位置。

@item
键入@kbd{M-:}（@code{eval-expression}）。

@item
使用@kbd{C-y}（@code{yank}）将@code{graph-body-print}表达式粘贴到迷你缓冲区中。

@item
按下@key{RET}以评估表达式。
@end enumerate

Emacs将垂直打印标签，顶部的标签为@w{@samp{10 -@w{
}}}.（在这种情况下，@code{print-graph}函数将传递@code{height-of-top-line}的值，这将最终变为15，从而消除可能出现的错误。）

@need 2000
@node print-X-axis
@appendixsec @code{print-X-axis} 函数
@cindex 坐标轴，水平打印
@cindex X轴打印
@cindex 打印水平轴
@cindex 水平轴打印

X轴标签与Y轴标签类似，不同之处在于刻度位于数字上方的一条线上。标签应该如下所示：

@smallexample
@group
    |   |    |    |
    1   5   10   15
@end group
@end smallexample

第一个刻度位于图表的第一列下方，并且前面有几个空格。这些空格在上面的行中为Y轴标签提供了空间。第二、第三、第四和随后的刻度都是等距的，根据 @code{X-axis-label-spacing} 的值确定。

X轴的第二行包含数字，前面有几个空格，并且也根据变量 @code{X-axis-label-spacing} 的值分隔。

变量 @code{X-axis-label-spacing} 的值本身应该以 @code{symbol-width} 的单位来衡量，因为您可能希望更改用于打印图表主体的符号的宽度，而不改变图表的标签方式。

@menu
* Similarities differences::    与 @code{print-Y-axis} 类似，但不完全相同。
* X Axis Tic Marks::            为水平轴创建刻度标记。
@end menu

@ifnottex
@node Similarities differences
@unnumberedsubsec 相似性与差异
@end ifnottex

@code{print-X-axis} 函数的构建方式与 @code{print-Y-axis} 函数几乎相同，只是它有两行：刻度线和数字。我们将编写两个单独的函数分别打印这两行，然后在 @code{print-X-axis} 函数中将它们组合起来。

这是一个三步过程：

@enumerate
@item
编写一个用于打印X轴刻度标记的函数，@code{print-X-axis-tic-line}。

@item
编写一个用于打印X轴数字的函数，@code{print-X-axis-numbered-line}。

@item
编写一个用于同时打印两行的函数，即 @code{print-X-axis} 函数，使用 @code{print-X-axis-tic-line} 和 @code{print-X-axis-numbered-line}。
@end enumerate

@node X Axis Tic Marks
@appendixsubsec X轴刻度标记

第一个函数应该打印X轴的刻度标记。我们需要指定刻度标记本身及其间距：

@smallexample
@group
(defvar X-axis-label-spacing
  (if (boundp 'graph-blank)
      (* 5 (length graph-blank)) 5)
  "相邻X轴标签之间的单位数。")
@end group
@end smallexample

@noindent
（注意，@code{graph-blank}的值由另一个@code{defvar}设置。@code{boundp}谓词检查它是否已经被设置；如果尚未设置@code{graph-blank}，并且我们没有使用此条件构造，将进入调试器，并显示错误消息，其中包含 @samp{@w{Debugger entered--Lisp error:}
@w{(void-variable graph-blank)}}。）

@need 1200
这是@code{X-axis-tic-symbol}的@code{defvar}：

@smallexample
@group
(defvar X-axis-tic-symbol "|"
  "插入到X轴列的字符串。")
@end group
@end smallexample

@need 1250
目标是生成如下一行：

@smallexample
       |   |    |    |
@end smallexample

第一个刻度标记缩进，使其位于第一列下方，该列缩进以提供给Y轴标签留出空间。

刻度元素包括从一个刻度到下一个刻度的空格以及一个刻度符号。空格的数量由刻度符号的宽度和@code{X-axis-label-spacing}确定。

@need 1250
代码如下：

@smallexample
@group
;;; X-axis-tic-element
@dots{}
(concat
 (make-string
  ;; @r{生成空格字符串。}
  (-  (* symbol-width X-axis-label-spacing)
      (length X-axis-tic-symbol))
  ? )
 ;; @r{将空格与刻度符号连接起来。}
 X-axis-tic-symbol)
@dots{}
@end group
@end smallexample

接下来，我们确定需要多少空格来缩进第一个刻度标记以对齐图表的第一列。这使用由@code{print-graph}函数传递的@code{full-Y-label-width}的值。

@need 1250
生成@code{X-axis-leading-spaces}的代码如下：

@smallexample
@group
;; X-axis-leading-spaces
@dots{}
(make-string full-Y-label-width ? )
@dots{}
@end group
@end smallexample

我们还需要确定水平轴的长度，即数字列表的长度，以及水平轴上的刻度数：

@smallexample
@group
;; X-length
@dots{}
(length numbers-list)
@end group

@group
;; tic-width
@dots{}
(* symbol-width X-axis-label-spacing)
@end group

@group
;; number-of-X-ticks
(if (zerop (% (X-length tic-width)))
    (/ (X-length tic-width))
  (1+ (/ (X-length tic-width))))
@end group
@end smallexample

@need 1250
所有这些直接导致打印X轴刻度线的函数：

@findex print-X-axis-tic-line
@smallexample
@group
(defun print-X-axis-tic-line
  (number-of-X-tics X-axis-leading-spaces X-axis-tic-element)
  "打印X轴的刻度标记。"
    (insert X-axis-leading-spaces)
    (insert X-axis-tic-symbol)  ; @r{在第一列下方插入刻度符号。}
@end group
@group
    ;; @r{在正确的位置插入第二个刻度。}
    (insert (concat
             (make-string
              (-  (* symbol-width X-axis-label-spacing)
                  ;; @r{插入到第二个刻度符号的空格。}
                  (* 2 (length X-axis-tic-symbol)))
              ? )
             X-axis-tic-symbol))
@end group
@group
    ;; @r{插入剩余的刻度标记。}
    (while (> number-of-X-tics 1)
      (insert X-axis-tic-element)
      (setq number-of-X-tics (1- number-of-X-tics))))
@end group
@end smallexample

数字行同样简单：

@need 1250
首先，我们使用空格在每个数字之前创建一个带编号的元素：

@findex X-axis-element
@smallexample
@group
(defun X-axis-element (number)
  "构造带编号的X轴元素。"
  (let ((leading-spaces
         (-  (* symbol-width X-axis-label-spacing)
             (length (number-to-string number)))))
    (concat (make-string leading-spaces ? )
            (number-to-string number))))
@end group
@end smallexample

接下来，我们创建打印带编号行的函数，从数字1开始，位于第一列下方：

@findex print-X-axis-numbered-line
@smallexample
@group
(defun print-X-axis-numbered-line
  (number-of-X-tics X-axis-leading-spaces)
  "打印X轴数字行"
  (let ((number X-axis-label-spacing))
    (insert X-axis-leading-spaces)
    (insert "1")
@end group
@group
    (insert (concat
             (make-string
              ;; @r{插入到下一个数字的空格。}
              (-  (* symbol-width X-axis-label-spacing) 2)
              ? )
             (number-to-string number)))
@end group
@group
    ;; @r{插入剩余的数字。}
    (setq number (+ number X-axis-label-spacing))
    (while (> number-of-X-tics 1)
      (insert (X-axis-element number))
      (setq number (+ number X-axis-label-spacing))
      (setq number-of-X-tics (1- number-of-X-tics)))))
@end group
@end smallexample

最后，我们需要编写@code{print-X-axis}函数，该函数使用@code{print-X-axis-tic-line}和@code{print-X-axis-numbered-line}。

该函数必须确定两个函数都使用的变量的局部值，然后调用它们。此外，它必须打印分隔两行的换行符。

该函数包含一个varlist，指定了五个局部变量，并调用了两个打印行的函数：

@findex print-X-axis
@smallexample
@group
(defun print-X-axis (numbers-list)
  "打印X轴标签到NUMBERS-LIST的长度。"
  (let* ((leading-spaces
          (make-string full-Y-label-width ? ))
@end group
@group
       ;; symbol-width @r{由} graph-body-print @r{提供}
       (tic-width (* symbol-width X-axis-label-spacing))
       (X-length (length numbers-list))
@end group
@group
       (X-tic
        (concat
         (make-string
@end group
@group
          ;; @r{生成空格字符串。}
          (-  (* symbol-width X-axis-label-spacing)
              (length X-axis-tic-symbol))
          ? )
@end group
@group
         ;; @r{将空格与刻度符号连接起来。}
         X-axis-tic-symbol))
@end group
@group
       (tic-number
        (if (zerop (% X-length tic-width))
            (/ X-length tic-width)
          (1+ (/ X-length tic-width)))))
@end group
@group
    (print-X-axis-tic-line tic-number leading-spaces X-tic)
    (insert "\n")
    (print-X-axis-numbered-line tic-number leading-spaces)))
@end group
@end smallexample

@need 1250
您可以测试@code{print-X-axis}：

@enumerate
@item
安装@code{X-axis-tic-symbol}，@code{X-axis-label-spacing}，@code{print-X-axis-tic-line}以及@code{X-axis-element}，@code{print-X-axis-numbered-line}和@code{print-X-axis}。

@item
复制以下表达式：

@smallexample
@group
(progn
 (let ((full-Y-label-width 5)
       (symbol-width 1))
   (print-X-axis
    '(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16))))
@end group
@end smallexample

@item
切换到@file{*scratch*}缓冲区，并将光标放到希望开始轴标签的位置。

@item
输入@kbd{M-:}（@code{eval-expression}）。

@item
使用@kbd{C-y}（@code{yank}）将测试表达式粘贴到迷你缓冲区中。

@item
按下@key{RET}以评估表达式。
@end enumerate

@need 1250
Emacs将打印出水平轴，如下所示：
@sp 1

@smallexample
@group
     |   |    |    |    |
     1   5   10   15   20
@end group
@end smallexample

@node Print Whole Graph
@appendixsec 打印整个图表
@cindex 打印整个图表
@cindex 整个图表打印
@cindex 图表，全部打印

现在我们几乎准备好打印整个图表了。

打印带有适当标签的图表的函数遵循我们之前创建的大纲（@pxref{Full Graph, , 带标签的图表}），但是有一些增加。

@need 1250
以下是大纲：

@smallexample
@group
(defun print-graph (numbers-list)
  "@var{documentation}@dots{}"
  (let ((height  @dots{}
        @dots{}))
@end group
@group
    (print-Y-axis height @dots{} )
    (graph-body-print numbers-list)
    (print-X-axis @dots{} )))
@end group
@end smallexample

@menu
* The final version::                   几处更改。
* Test print-graph::            运行简短测试。
* Graphing words in defuns::        执行最终代码。
* lambda::                      如何编写匿名函数。
* mapcar::                      对列表元素应用函数。
* Another Bug::                 又一个错误 @dots{} 最隐匿。
* Final printed graph::             图表本身！
@end menu

@ifnottex
@node The final version
@unnumberedsubsec 最终版本的更改
@end ifnottex

最终版本与我们计划的不同，有两点不同：首先，它包含了一次在变量列表中计算的附加值；其次，它带有一个选项，用于指定标签每行的增量。
后者的功能证明是必要的；否则，图表可能具有超过显示屏或纸张上能容纳的行数。

@need 1500
这个新功能需要对 @code{Y-axis-column} 函数进行更改，以添加 @code{vertical-step}。该函数如下：

@findex Y-axis-column @r{最终版本。}
@smallexample
@group
;;; @r{最终版本。}
(defun Y-axis-column
  (height width-of-label &optional vertical-step)
  "构建Y轴标签列表。
HEIGHT 是图表的最大高度。
WIDTH-OF-LABEL 是标签的最大宽度。
VERTICAL-STEP，一个可选项，是一个正整数，
用于指定每行的Y轴标签增量。
例如，步长为5表示每行是图表的五个单位。"
@end group
@group
  (let (Y-axis
        (number-per-line (or vertical-step 1)))
    (while (> height 1)
      (if (zerop (% height Y-axis-label-spacing))
@end group
@group
          ;; @r{插入标签。}
          (setq Y-axis
                (cons
                 (Y-axis-element
                  (* height number-per-line)
                  width-of-label)
                 Y-axis))
@end group
@group
        ;; @r{否则，插入空白。}
        (setq Y-axis
              (cons
               (make-string width-of-label ? )
               Y-axis)))
      (setq height (1- height)))
@end group
@group
    ;; @r{插入基准线。}
    (setq Y-axis (cons (Y-axis-element
                        (or vertical-step 1)
                        width-of-label)
                       Y-axis))
    (nreverse Y-axis)))
@end group
@end smallexample

图表的最大高度和符号宽度的值由 @code{print-graph} 在其 @code{let} 表达式中计算；因此，@code{graph-body-print} 必须更改以接受它们。

@findex graph-body-print @r{最终版本。}
@smallexample
@group
;;; @r{最终版本。}
(defun graph-body-print (numbers-list height symbol-width)
  "打印NUMBERS-LIST的条形图。
numbers-list 包含Y轴值。
HEIGHT 是图表的最大高度。
SYMBOL-WIDTH 是每列的数字。"
@end group
@group
  (let (from-position)
    (while numbers-list
      (setq from-position (point))
      (insert-rectangle
       (column-of-graph height (car numbers-list)))
      (goto-char from-position)
      (forward-char symbol-width)
@end group
@group
      ;; @r{逐列绘制图表。}
      (sit-for 0)
      (setq numbers-list (cdr numbers-list)))
    ;; @r{放置X轴标签的点。}
    (forward-line height)
    (insert "\n")))
@end group
@end smallexample

@need 1250
最后，@code{print-graph} 函数的代码：

@findex print-graph @r{最终版本。}
@smallexample
@group
;;; @r{最终版本。}
(defun print-graph
  (numbers-list &optional vertical-step)
  "打印带有标签的条形图 NUMBERS-LIST。
numbers-list 包含Y轴值。
@end group

@group
可选的，VERTICAL-STEP，一个正整数，
指定每行的Y轴标签增量。
例如，步长为5表示每行是图表的五个单位。"
@end group
@group
  (let* ((symbol-width (length graph-blank))
         ;; @code{height} @r{既是最大的数字}
         ;; @r{也是数字位数最多的数字。}
         (height (apply 'max numbers-list))
@end group
@group
         (height-of-top-line
          (if (zerop (% height Y-axis-label-spacing))
              height
            ;; @r{否则}
            (* (1+ (/ height Y-axis-label-spacing))
               Y-axis-label-spacing)))
@end group
@group
         (vertical-step (or vertical-step 1))
         (full-Y-label-width
          (length
@end group
@group
           (concat
            (number-to-string
             (* height-of-top-line vertical-step))
            Y-axis-tic))))
@end group

@group
    (print-Y-axis
     height-of-top-line full-Y-label-width vertical-step)
@end group
@group
    (graph-body-print
     numbers-list height-of-top-line symbol-width)
    (print-X-axis numbers-list)))
@end group
@end smallexample

@node Test print-graph
@appendixsubsec 测试 @code{print-graph}

@need 1250
我们可以使用一个短数字列表来测试 @code{print-graph} 函数：

@enumerate
@item
安装 @code{Y-axis-column}、@code{graph-body-print} 和 @code{print-graph} 的最终版本（以及其余的代码）。

@item
复制以下表达式：

@smallexample
(print-graph '(3 2 5 6 7 5 3 4 6 4 3 2 1))
@end smallexample

@item
切换到 @file{*scratch*} 缓冲区，并将光标放在你希望轴标签开始的位置。

@item
键入 @kbd{M-:}（@code{eval-expression}）。

@item
使用 @kbd{C-y}（@code{yank}）将测试表达式粘贴到迷你缓冲区中。

@item
按下 @key{RET} 键来评估表达式。
@end enumerate

@need 1250
Emacs 将打印一个看起来像这样的图表：

@smallexample
@group
10 -


         *
        **   *
 5 -   ****  *
       **** ***
     * *********
     ************
 1 - *************

     |   |    |    |
     1   5   10   15
@end group
@end smallexample

@need 1200
另一方面，如果你将 @code{print-graph} 的 @code{vertical-step} 值设为 2，通过评估以下表达式：

@smallexample
(print-graph '(3 2 5 6 7 5 3 4 6 4 3 2 1) 2)
@end smallexample

@need 1250
@noindent
图表看起来像这样：

@smallexample
@group
20 -


         *
        **   *
10 -   ****  *
       **** ***
     * *********
     ************
 2 - *************

     |   |    |    |
     1   5   10   15
@end group
@end smallexample

@noindent
（一个问题：垂直轴底部的 @samp{2} 是一个错误还是一个特性？如果你认为这是一个错误，应该是 @samp{1} 而不是 @samp{2}（甚至是 @samp{0}），你可以修改源代码。）

@node Graphing words in defuns
@appendixsubsec 绘制单词和符号数量的函数图表

现在是为了这段代码而编写的图表：显示包含少于 10 个单词和符号的函数定义的数量，包含 10 到 19 个单词和符号的函数定义的数量，包含 20 到 29 个单词和符号的函数定义的数量，依此类推。

这是一个多步骤的过程。首先确保你已经加载了所有必要的代码。

@need 1500
最好重置 @code{top-of-ranges} 的值，以防你将其设置为不同的值。你可以评估以下内容：

@smallexample
@group
(setq top-of-ranges
 '(10  20  30  40  50
   60  70  80  90 100
  110 120 130 140 150
  160 170 180 190 200
  210 220 230 240 250
  260 270 280 290 300)
@end group
@end smallexample

@noindent
接下来创建一个包含每个范围中单词和符号数量的列表。

@need 1500
@noindent
评估以下内容：

@smallexample
@group
(setq list-for-graph
       (defuns-per-range
         (sort
          (recursive-lengths-list-many-files
           (directory-files "/usr/local/emacs/lisp"
                            t ".+el$"))
          '<)
         top-of-ranges))
@end group
@end smallexample

@noindent
在我的旧机器上，这大约花费了一个小时。它遍历了我在 Emacs 版本 19.23 中的 303 个 Lisp 文件。在所有这些计算之后，@code{list-for-graph} 的值如下：

@smallexample
@group
(537 1027 955 785 594 483 349 292 224 199 166 120 116 99
90 80 67 48 52 45 41 33 28 26 25 20 12 28 11 13 220)
@end group
@end smallexample

@noindent
这意味着我的 Emacs 副本中有 537 个包含少于 10 个单词或符号的函数定义，1,027 个包含 10 到 19 个单词或符号的函数定义，955 个包含 20 到 29 个单词或符号的函数定义，依此类推。

显然，仅通过查看这个列表，我们就可以看到大多数函数定义包含十到三十个单词和符号。

现在是打印的时候。我们 @emph{不}希望打印一个高达 1,030 行的图表 @dots{} 相反，我们应该打印一个不到二十五行高的图表。这样高度的图表可以显示在几乎任何显示器上，并且可以轻松地打印在一张纸上。

这意味着 @code{list-for-graph} 中的每个值必须减少到其当前值的五十分之一。

这里是一个用两个我们还没有看到的函数，@code{mapcar} 和 @code{lambda}，来做到这一点的简短函数。

@smallexample
@group
(defun one-fiftieth (full-range)
  "返回一个列表，其中每个数字是先前值的五十分之一。"
 (mapcar (lambda (arg) (/ arg 50)) full-range))
@end group
@end smallexample

@node lambda
@appendixsubsec A @code{lambda} 表达式：有用的匿名性
@cindex 匿名函数
@findex lambda

@code{lambda} 是匿名函数的符号，即没有名字的函数。每次使用匿名函数时，都需要包含它的整个体。

@need 1250
@noindent
因此，

@smallexample
(lambda (arg) (/ arg 50))
@end smallexample

@noindent
是一个函数，返回将传递给它的@code{arg}除以50的结果。

@need 1200
@noindent
早些时候，例如，我们有一个函数@code{multiply-by-seven}；它将其参数乘以7。这个函数类似，只是它将其参数除以50；而且，它没有名字。@code{multiply-by-seven}的匿名等价物是：

@smallexample
(lambda (number) (* 7 number))
@end smallexample

@noindent
（@xref{defun, ,  @code{defun} 宏}。）

@need 1250
@noindent
如果我们想将3乘以7，我们可以写：

@c clear print-postscript-figures
@c lambda example diagram #1
@ifnottex
@smallexample
@group
(multiply-by-seven 3)
 \_______________/ ^
         |         |
      function  argument
@end group
@end smallexample
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{lambda-1}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
(multiply-by-seven 3)
 \_______________/ ^
         |         |
      function  argument
@end group
@end smallexample
@end iftex
@end ifclear

@noindent
这个表达式返回21。

@need 1250
@noindent
同样，我们可以写：

@c lambda example diagram #2
@ifnottex
@smallexample
@group
((lambda (number) (* 7 number)) 3)
 \____________________________/ ^
               |                |
      anonymous function     argument
@end group
@end smallexample
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{lambda-2}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
((lambda (number) (* 7 number)) 3)
 \____________________________/ ^
               |                |
      anonymous function     argument
@end group
@end smallexample
@end iftex
@end ifclear

@need 1250
@noindent
如果我们想将100除以50，我们可以写：

@c lambda example diagram #3
@ifnottex
@smallexample
@group
((lambda (arg) (/ arg 50)) 100)
 \______________________/  \_/
             |              |
    anonymous function   argument
@end group
@end smallexample
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{lambda-3}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
((lambda (arg) (/ arg 50)) 100)
 \______________________/  \_/
             |              |
    anonymous function   argument
@end group
@end smallexample
@end iftex
@end ifclear

@noindent
这个表达式返回2。将100传递给函数，该函数将该数字除以50。

@xref{Lambda Expressions, , Lambda 表达式, elisp, GNU Emacs Lisp 参考手册}，了解有关@code{lambda}的更多信息。Lisp 和 lambda 表达式源于 Lambda 演算。

@node mapcar
@appendixsubsec The @code{mapcar} Function
@findex mapcar

@code{mapcar}是一个函数，它依次调用它的第一个参数，并将第二个参数的每个元素传递给它的第一个参数。第二个参数必须是一个序列。

名称中的@samp{map}部分来自数学短语，“在一个域上进行映射”，意味着对域中的每个元素应用一个函数。这个数学短语基于一个测量员逐步走过他正在绘制地图的区域的隐喻。而@samp{car}当然来自Lisp中列表的第一个元素的概念。

@need 1250
@noindent
例如，

@smallexample
@group
(mapcar '1+ '(2 4 6))
     @result{} (3 5 7)
@end group
@end smallexample

@noindent
函数@code{1+}，它将其参数加一，被执行在列表的@emph{每个}元素上，并返回一个新的列表。

与之相对的是@code{apply}，它将其第一个参数应用于其余的所有参数。
（@xref{Readying a Graph, , 准备图表}，有关@code{apply}的解释。）

@need 1250
在@code{one-fiftieth}的定义中，第一个参数是匿名函数：

@smallexample
(lambda (arg) (/ arg 50))
@end smallexample

@noindent
而第二个参数是@code{full-range}，它将绑定到@code{list-for-graph}。

@need 1250
整个表达式看起来像这样：

@smallexample
(mapcar (lambda (arg) (/ arg 50)) full-range))
@end smallexample

@xref{Mapping Functions, , Mapping Functions, elisp, The GNU Emacs
Lisp Reference Manual}，有关@code{mapcar}的更多信息。

使用@code{one-fiftieth}函数，我们可以生成一个列表，其中每个元素都是@code{list-for-graph}中相应元素的1/50大小。

@smallexample
@group
(setq fiftieth-list-for-graph
      (one-fiftieth list-for-graph))
@end group
@end smallexample

@need 1250
生成的列表如下：

@smallexample
@group
(10 20 19 15 11 9 6 5 4 3 3 2 2
1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 4)
@end group
@end smallexample

@noindent
这样，我们几乎可以打印出来了！（我们还注意到信息的丢失：许多较高的范围为0，意味着少于50个defuns有那么多单词或符号，但不一定意味着没有那么多单词或符号。）

@node Another Bug
@appendixsubsec 另一个错误 @dots{} 最阴险的
@cindex 错误，最阴险的类型
@cindex 阴险类型的错误

我说过“几乎准备好打印”！当然，在@code{print-graph}函数中存在一个错误 @dots{} 它有一个@code{vertical-step}选项，但没有@code{horizontal-step}选项。@code{top-of-range}刻度从10到300，间隔为十。但@code{print-graph}函数只会打印每个单位。

这是某些人认为最阴险类型的错误的典型例子，即遗漏错误。这不是你可以通过研究代码找到的错误，因为它不在代码中；它是一个被遗漏的特性。你最好的行动是尽早而经常地尝试你的程序；并且尽量安排，尽可能写出易于理解和修改的代码。尽量在任何时候都意识到，无论你写了什么，@emph{都}会被重新编写，如果不是很快，那就是迟早的事。这是一个难以遵循的格言。

需要对@code{print-X-axis-numbered-line}函数进行修改；然后需要调整@code{print-X-axis}和@code{print-graph}函数。不需要做太多事情；有一个小技巧：数字应该对齐在刻度标记下方。这需要一点思考。

@need 1250
以下是修正后的@code{print-X-axis-numbered-line}：

@smallexample
@group
(defun print-X-axis-numbered-line
  (number-of-X-tics X-axis-leading-spaces
   &optional horizontal-step)
  "打印X轴数字线"
  (let ((number X-axis-label-spacing)
        (horizontal-step (or horizontal-step 1)))
@end group
@group
    (insert X-axis-leading-spaces)
    ;; @r{删除多余的前导空格。}
    (delete-char
     (- (1-
         (length (number-to-string horizontal-step)))))
    (insert (concat
             (make-string
@end group
@group
              ;; @r{插入空白。}
              (-  (* symbol-width
                     X-axis-label-spacing)
                  (1-
                   (length
                    (number-to-string horizontal-step)))
                  2)
              ? )
             (number-to-string
              (* number horizontal-step))))
@end group
@group
    ;; @r{插入剩余的数字。}
    (setq number (+ number X-axis-label-spacing))
    (while (> number-of-X-tics 1)
      (insert (X-axis-element
               (* number horizontal-step)))
      (setq number (+ number X-axis-label-spacing))
      (setq number-of-X-tics (1- number-of-X-tics)))))
@end group
@end smallexample

@need 1500
如果你在Info中阅读此内容，你可以查看@code{print-X-axis}和@code{print-graph}的新版本，并对其进行评估。如果你在印刷的书中阅读此内容，你可以在这里看到更改的行（完整文本太长，无法打印）。

@iftex
@smallexample
@group
(defun print-X-axis (numbers-list horizontal-step)
  @dots{}
    (print-X-axis-numbered-line
     tic-number leading-spaces horizontal-step))
@end group
@end smallexample

@smallexample
@group
(defun print-graph
  (numbers-list
   &optional vertical-step horizontal-step)
  @dots{}
    (print-X-axis numbers-list horizontal-step))
@end group
@end smallexample
@end iftex

@ifnottex
@smallexample
@group
(defun print-X-axis (numbers-list horizontal-step)
  "打印X轴标签，长度为NUMBERS-LIST。
可选参数HORIZONTAL-STEP，一个正整数，
指定每列的X轴标签增量。"
@end group
@group
;; 符号宽度和full-Y-label-width的值由print-graph传递。
  (let* ((leading-spaces
          (make-string full-Y-label-width ? ))
       ;; 符号宽度由graph-body-print提供
       (tic-width (* symbol-width X-axis-label-spacing))
       (X-length (length numbers-list))
@end group
@group
       (X-tic
        (concat
         (make-string
          ;; 制作一串空格。
          (-  (* symbol-width X-axis-label-spacing)
              (length X-axis-tic-symbol))
          ? )
@end group
@group
         ;; 用空格和刻度符号连接。
         X-axis-tic-symbol))
       (tic-number
        (if (zerop (% X-length tic-width))
            (/ X-length tic-width)
          (1+ (/ X-length tic-width)))))
@end group

@group
    (print-X-axis-tic-line
     tic-number leading-spaces X-tic)
    (insert "\n")
    (print-X-axis-numbered-line
     tic-number leading-spaces horizontal-step)))
@end group
@end smallexample

@smallexample
@group
(defun print-graph
  (numbers-list &optional vertical-step horizontal-step)
  "打印带标签的条形图，NUMBERS-LIST的Y轴值构成。
@end group

@group
可选参数VERTICAL-STEP，一个正整数，
指定每行的Y轴标签增量。例如，步长为5表示每行五个单位。
@end group

@group
可选参数HORIZONTAL-STEP，一个正整数，
指定每列的X轴标签增量。"
  (let* ((symbol-width (length graph-blank))
         ;; height既是最大的数字，也是具有最多数字的数字。
         (height (apply 'max numbers-list))
@end group
@group
         (height-of-top-line
          (if (zerop (% height Y-axis-label-spacing))
              height
            ;; 否则
            (* (1+ (/ height Y-axis-label-spacing))
               Y-axis-label-spacing)))
@end group
@group
         (vertical-step (or vertical-step 1))
         (full-Y-label-width
          (length
           (concat
            (number-to-string
             (* height-of-top-line vertical-step))
            Y-axis-tic))))
@end group
@group
    (print-Y-axis
     height-of-top-line full-Y-label-width vertical-step)
    (graph-body-print
        numbers-list height-of-top-line symbol-width)
    (print-X-axis numbers-list horizontal-step)))
@end group
@end smallexample
@end ifnottex

@c qqq
@ignore
图表定义重新列出

@need 1250
以下是所有图表定义的最终形式：

@smallexample
@group
(defvar top-of-ranges
 '(10  20  30  40  50
   60  70  80  90 100
  110 120 130 140 150
  160 170 180 190 200
  210 220 230 240 250)
 "指定`defuns-per-range'范围的列表。")
@end group

@group
(defvar graph-symbol "*"
  "图表中使用的字符串，通常是星号。")
@end group

@group
(defvar graph-blank " "
  "图表中使用的空白字符串，通常是一个空格。
graph-blank的列数必须与graph-symbol相同。")
@end group

@group
(defvar Y-axis-tic " - "
   "Y轴标签中数字后跟的字符串。")
@end group

@group
(defvar Y-axis-label-spacing 5
  "从一个Y轴标签到下一个的行数。")
@end group

@group
(defvar X-axis-tic-symbol "|"
  "插入到X轴中指向列的字符串。")
@end group

@group
(defvar X-axis-label-spacing
  (if (boundp 'graph-blank)
      (* 5 (length graph-blank)) 5)
  "从一个X轴标签到下一个的单位数。")
@end group
@end smallexample

@smallexample
@group
(defun count-words-in-defun ()
  "返回defun中的单词和符号数。"
  (beginning-of-defun)
  (let ((count 0)
        (end (save-excursion (end-of-defun) (point))))
@end group

@group
    (while
        (and (< (point) end)
             (re-search-forward
              "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"
              end t))
      (setq count (1+ count)))
    count))
@end group
@end smallexample

@smallexample
@group
(defun lengths-list-file (filename)
  "返回文件中定义的长度列表。
返回的列表是一个数字列表。
每个数字是一个函数定义中的单词或符号数。"
@end group

@group
  (message "正在处理 `%s' ... " filename)
  (save-excursion
    (let ((buffer (find-file-noselect filename))
          (lengths-list))
      (set-buffer buffer)
      (setq buffer-read-only t)
      (widen)
      (goto-char (point-min))
@end group

@group
      (while (re-search-forward "^(defun" nil t)
        (setq lengths-list
              (cons (count-words-in-defun) lengths-list)))
      (kill-buffer buffer)
      lengths-list)))
@end group
@end smallexample

@smallexample
@group
(defun lengths-list-many-files (list-of-files)
  "返回LIST-OF-FILES中defun的长度列表。"
  (let (lengths-list)
;;; 真或假测试
    (while list-of-files
      (setq lengths-list
            (append
             lengths-list
@end group
@group
;;; 生成长度列表。
             (lengths-list-file
              (expand-file-name (car list-of-files)))))
;;; 缩短文件列表。
      (setq list-of-files (cdr list-of-files)))
;;; 返回最终的长度列表值。
    lengths-list))
@end group
@end smallexample

@smallexample
@group
(defun defuns-per-range (sorted-lengths top-of-ranges)
  "在每个TOP-OF-RANGES范围内对SORTED-LENGTHS中的defun进行计数。"
  (let ((top-of-range (car top-of-ranges))
        (number-within-range 0)
        defuns-per-range-list)
@end group

@group
    ;; 外部循环。
    (while top-of-ranges

      ;; 内部循环。
      (while (and
              ;; 需要数字进行数值测试。
              (car sorted-lengths)
              (< (car sorted-lengths) top-of-range))

        ;; 计算当前范围内的定义数量。
        (setq number-within-range (1+ number-within-range))
        (setq sorted-lengths (cdr sorted-lengths)))
@end group

@group
      ;; 退出内部循环但保持在外部循环中。

      (setq defuns-per-range-list
            (cons number-within-range defuns-per-range-list))
      (setq number-within-range 0)      ; 重置计数为零。

      ;; 移动到下一个范围。
      (setq top-of-ranges (cdr top-of-ranges))
      ;; 指定下一个范围的值。
      (setq top-of-range (car top-of-ranges)))
@end group

@group
    ;; 退出外部循环并计算大于最大TOP-OF-RANGES值的defun数量。
    (setq defuns-per-range-list
          (cons
           (length sorted-lengths)
           defuns-per-range-list))

    ;; 返回每个范围内定义数量的列表，从小到大。
    (nreverse defuns-per-range-list)))
@end group
@end smallexample

@smallexample
@group
(defun column-of-graph (max-graph-height actual-height)
  "返回一个包含 MAX-GRAPH-HEIGHT 个字符串的列表；
ACTUAL-HEIGHT 是图表符号的数量。
图表符号是列表末尾的连续项。
该列表将作为图表的一列插入。
字符串要么是图表空白，要么是图表符号。"
@end group

@group
  (let ((insert-list nil)
        (number-of-top-blanks
         (- max-graph-height actual-height)))

    ;; @r{填充 @code{graph-symbols}。}
    (while (> actual-height 0)
      (setq insert-list (cons graph-symbol insert-list))
      (setq actual-height (1- actual-height)))
@end group

@group
    ;; @r{填充 @code{graph-blanks}。}
    (while (> number-of-top-blanks 0)
      (setq insert-list (cons graph-blank insert-list))
      (setq number-of-top-blanks
            (1- number-of-top-blanks)))

    ;; @r{返回整个列表。}
    insert-list))
@end group
@end smallexample

@smallexample
@group
(defun Y-axis-element (number full-Y-label-width)
  "构造一个带编号的标签元素。
带编号的元素看起来像这样 `  5 - '，
并根据需要进行填充，以便与最大编号的元素对齐。"
@end group
@group
  (let* ((leading-spaces
         (- full-Y-label-width
            (length
             (concat (number-to-string number)
                     Y-axis-tic)))))
@end group
@group
    (concat
     (make-string leading-spaces ? )
     (number-to-string number)
     Y-axis-tic)))
@end group
@end smallexample

@smallexample
@group
(defun print-Y-axis
  (height full-Y-label-width &optional vertical-step)
  "通过 HEIGHT 和 FULL-Y-LABEL-WIDTH 插入 Y 轴。
Height 必须是图表的最大高度。
Full width 是最高标签元素的宽度。
可选地，根据 VERTICAL-STEP 打印。"
@end group
@group
;; height 和 full-Y-label-width 的值由 'print-graph' 传递。
  (let ((start (point)))
    (insert-rectangle
     (Y-axis-column height full-Y-label-width vertical-step))
@end group
@group
    ;; @r{放置点以准备插入图表。}
    (goto-char start)
    ;; @r{将点前进 full-Y-label-width 的值。}
    (forward-char full-Y-label-width)))
@end group
@end smallexample

@smallexample
@group
(defun print-X-axis-tic-line
  (number-of-X-tics X-axis-leading-spaces X-axis-tic-element)
  "打印 X 轴的刻度线。"
    (insert X-axis-leading-spaces)
    (insert X-axis-tic-symbol)  ; @r{在第一列下。}
@end group
@group
    ;; @r{在正确的位置插入第二个刻度线。}
    (insert (concat
             (make-string
              (-  (* symbol-width X-axis-label-spacing)
                  ;; @r{插入空白，直到第二个刻度线符号。}
                  (* 2 (length X-axis-tic-symbol)))
              ? )
             X-axis-tic-symbol))
@end group
@group
    ;; @r{插入剩余的刻度线。}
    (while (> number-of-X-tics 1)
      (insert X-axis-tic-element)
      (setq number-of-X-tics (1- number-of-X-tics))))
@end group
@end smallexample

@smallexample
@group
(defun X-axis-element (number)
  "构造一个编号的 X 轴元素。"
  (let ((leading-spaces
         (-  (* symbol-width X-axis-label-spacing)
             (length (number-to-string number)))))
    (concat (make-string leading-spaces ? )
            (number-to-string number))))
@end group
@end smallexample

@smallexample
@group
(defun graph-body-print (numbers-list height symbol-width)
  "打印 NUMBERS-LIST 的柱状图。
numbers-list 包含 Y 轴值。
HEIGHT 是图表的最大高度。
SYMBOL-WIDTH 是每列的数字。"
@end group
@group
  (let (from-position)
    (while numbers-list
      (setq from-position (point))
      (insert-rectangle
       (column-of-graph height (car numbers-list)))
      (goto-char from-position)
      (forward-char symbol-width)
@end group
@group
      ;; @r{逐列绘制图表。}
      (sit-for 0)
      (setq numbers-list (cdr numbers-list)))
    ;; @r{放置点以插入 X 轴标签。}
    (forward-line height)
    (insert "\n")))
@end group
@end smallexample

@smallexample
@group
(defun Y-axis-column
  (height width-of-label &optional vertical-step)
  "构造 Y 轴标签的列表。
HEIGHT 是图表的最大高度。
WIDTH-OF-LABEL 是标签的最大宽度。
@end group
@group
VERTICAL-STEP 是一个可选项，是正整数，
指定每行的 Y 轴标签递增多少。
例如，步长为 5 意味着每行是五个图表单位。"
  (let (Y-axis
        (number-per-line (or vertical-step 1)))
@end group
@group
    (while (> height 1)
      (if (zerop (% height Y-axis-label-spacing))
          ;; @r{插入标签。}
          (setq Y-axis
                (cons
                 (Y-axis-element
                  (* height number-per-line)
                  width-of-label)
                 Y-axis))
@end group
@group
        ;; @r{否则，插入空白。}
        (setq Y-axis
              (cons
               (make-string width-of-label ? )
               Y-axis)))
      (setq height (1- height)))
@end group
@group
    ;; @r{插入基线。}
    (setq Y-axis (cons (Y-axis-element
                        (or vertical-step 1)
                        width-of-label)
                       Y-axis))
    (nreverse Y-axis)))
@end group
@end smallexample

@smallexample
@group
(defun print-X-axis-numbered-line
  (number-of-X-tics X-axis-leading-spaces
   &optional horizontal-step)
  "打印 X 轴数字的行"
  (let ((number X-axis-label-spacing)
        (horizontal-step (or horizontal-step 1)))
@end group
@group
    (insert X-axis-leading-spaces)
    ;; 对齐数字
    (delete-char (- (1- (length (number-to-string horizontal-step)))))
    (insert (concat
             (make-string
              ;; @r{插入空白，直到下一个数字。}
              (-  (* symbol-width X-axis-label-spacing)
                  (1- (length (number-to-string horizontal-step)))
                  2)
              ? )
             (number-to-string (* number horizontal-step))))
@end group
@group
    ;; @r{插入剩余的数字。}
    (setq number (+ number X-axis-label-spacing))
    (while (> number-of-X-tics 1)
      (insert (X-axis-element (* number horizontal-step)))
      (setq number (+ number X-axis-label-spacing))
      (setq number-of-X-tics (1- number-of-X-tics)))))
@end group
@end smallexample

@smallexample
@group
(defun print-X-axis (numbers-list horizontal-step)
  "根据 NUMBERS-LIST 的长度打印 X 轴标签。
可选地，HORIZONTAL-STEP 是正整数，
指定每列的 X 轴标签递增多少。"
@end group
@group
;; 符号宽度和 full-Y-label-width 的值由 'print-graph' 传递。
  (let* ((leading-spaces
          (make-string full-Y-label-width ? ))
       ;; symbol-width @r{由} graph-body-print @r{提供}
       (tic-width (* symbol-width X-axis-label-spacing))
       (X-length (length numbers-list))
@end group
@group
       (X-tic
        (concat
         (make-string
          ;; @r{制作一个空白字符串。}
          (-  (* symbol-width X-axis-label-spacing)
              (length X-axis-tic-symbol))
          ? )
@end group
@group
         ;; @r{将空白与刻度线符号连接起来。}
         X-axis-tic-symbol))
       (tic-number
        (if (zerop (% X-length tic-width))
            (/ X-length tic-width)
          (1+ (/ X-length tic-width)))))
@end group

@group
    (print-X-axis-tic-line
     tic-number leading-spaces X-tic)
    (insert "\n")
    (print-X-axis-numbered-line
     tic-number leading-spaces horizontal-step)))
@end group
@end smallexample

@smallexample
@group
(defun one-fiftieth (full-range)
  "返回一个列表，其中每个数字都是前一个数字的 1/50。"
 (mapcar (lambda (arg) (/ arg 50)) full-range))
@end group
@end smallexample

@smallexample
@group
(defun print-graph
  (numbers-list &optional vertical-step horizontal-step)
  "打印带标签的 NUMBERS-LIST 的柱状图。
numbers-list 包含 Y 轴值。
@end group

@group
可选地，VERTICAL-STEP 是正整数，
指定每行的 Y 轴标签递增多少。
例如，步长为 5 意味着每行是五个单位。
@end group

@group
可选地，HORIZONTAL-STEP 是正整数，
指定每列的 X 轴标签递增多少。"
  (let* ((symbol-width (length graph-blank))
         ;; @code{height} @r{既是最大的数字}
         ;; @r{也是数字位数最多的数字。}
         (height (apply 'max numbers-list))
@end group
@group
         (height-of-top-line
          (if (zerop (% height Y-axis-label-spacing))
              height
            ;; @r{否则}
            (* (1+ (/ height Y-axis-label-spacing))
               Y-axis-label-spacing)))
@end group
@group
         (vertical-step (or vertical-step 1))
         (full-Y-label-width
          (length
           (concat
            (number-to-string
             (* height-of-top-line vertical-step))
            Y-axis-tic))))
@end group
@group

    (print-Y-axis
     height-of-top-line full-Y-label-width vertical-step)
    (graph-body-print
        numbers-list height-of-top-line symbol-width)
    (print-X-axis numbers-list horizontal-step)))
@end group
@end smallexample
@c qqq
@end ignore

@page
@node Final printed graph
@appendixsubsec 打印图表

当制作并安装完成后，您可以像这样调用 @code{print-graph} 命令：
@sp 1

@smallexample
@group
(print-graph fiftieth-list-for-graph 50 10)
@end group
@end smallexample
@sp 1

@noindent
这是图表：
@sp 2

@smallexample
@group
1000 -  *
        **
        **
        **
        **
 750 -  ***
        ***
        ***
        ***
        ****
 500 - *****
       ******
       ******
       ******
       *******
 250 - ********
       *********                     *
       ***********                   *
       *************                 *
  50 - ***************** *           *
       |   |    |    |    |    |    |    |
      10  50  100  150  200  250  300  350
@end group
@end smallexample

@sp 2

@noindent
最大的函数组包含每个函数 10--19 个字和符号。

@node Free Software and Free Manuals
@appendix 自由软件和自由手册

@strong{作者：理查德·斯托曼}
@sp 1

自由操作系统中最大的不足之处不在于软件本身，而在于我们无法在这些系统中包含好的自由手册。许多我们最重要的程序都没有附带完整的手册。文档是任何软件包的基本组成部分；当一个重要的自由软件包没有附带自由手册时，这是一个重大的缺陷。我们今天有许多这样的缺口。

很多年前的一天，我想学习Perl。我找到了一本免费的手册副本，但我发现它很难阅读。当我询问Perl用户是否有其他选择时，他们告诉我有更好的入门手册---但那些手册并不是免费的。

为什么会这样呢？好的手册作者为O'Reilly Associates编写了手册，该出版社以限制性条款发布它们---禁止复制、禁止修改、源文件不可用---这些条件使它们无法进入自由软件社区。

这并不是这种情况发生的第一次，而且（令我们的社区丧失很多）远非最后一次。自从那时以来，专有手册出版商引诱了许多作者限制他们的手册。许多次我听到GNU用户热切地告诉我，他正在撰写一本手册，他希望能够帮助GNU项目---然后我的希望落空，因为他继续解释说他已经签署了一份与出版商的合同，该合同将限制使用，以至于我们无法使用它。

鉴于写好英语是程序员中一种罕见的技能，我们不能承受以这种方式失去手册的代价。

自由文档，就像自由软件一样，是关乎自由而非价格的问题。这些手册的问题并不在于O'Reilly Associates对印刷品收费---这本身是可以接受的。自由软件基金会在@uref{https://shop.fsf.org, 官方商店}出售免费@uref{https://www.gnu.org/doc/doc.html, GNU手册}的印刷本。但GNU手册以源代码形式提供，而这些手册只能以纸质形式获得。GNU手册附带有复制和修改的权限；Perl手册则没有。这些限制是问题所在。

对于一个自由手册，标准几乎与自由软件相同：它涉及给予所有用户特定的自由。必须允许重新分发（包括商业重新分发），以便手册可以随程序的每个副本一起提供，无论是在线还是纸质的。修改的许可也是至关重要的。

总的来说，我不认为人们有必要获得修改各种文章和书籍的权限。对于文学作品，问题不一定与软件相同。例如，我认为你和我没有义务允许修改像这篇文章这样描述我们行动和观点的文章。

但是，为自由软件提供文档的关键原因之一是修改的自由至关重要。当人们行使他们修改软件的权利，添加或更改其功能时，如果他们是尽责的，他们将同时更改手册---以便他们可以为修改后的程序提供准确可用的文档。一份手册，禁止程序员尽责并完成工作，或者更确切地说，如果他们更改程序，则要求他们从头开始编写新手册，这将无法满足我们社区的需求。

虽然对修改的全面禁令是不可接受的，但对修改方式的某些限制并不构成问题。例如，要求保留原作者的版权声明、分发条款或作者列表是可以接受的。还要求修改版本包含修改通知，甚至包含整个部分不得删除或更改，只要这些部分涉及非技术主题，也没有问题（一些GNU手册有这些限制）。

这些种类的限制不是问题，因为从实际角度来看，它们并不阻止认真的程序员调整手册以适应修改后的程序。换句话说，它们并不阻止自由软件社区充分利用手册。

然而，必须有可能修改手册的所有技术内容，然后通过所有通常的媒体、通过所有通常的渠道分发结果；否则，这些限制将阻碍社区，手册就不是自由的，因此我们需要另一份手册。

不幸的是，当存在专有手册时，很难找到愿意写另一份手册的人。阻碍在于许多用户认为专有手册已经足够好---因此他们认为没有必要写一份自由手册。他们没有意识到自由操作系统存在需要填补的空白。

为什么用户认为专有手册已经足够好呢？有些人还没有考虑这个问题。我希望这篇文章能够改变这种看法。

其他用户认为专有手册是可以接受的，原因与许多人认为专有软件是可以接受的原因相同：他们纯粹以实际的角度进行判断，而不使用自由作为标准。这些人有权发表他们的观点，但由于这些观点源于不包括自由的价值观，对于那些重视自由的人来说，它们并不是指导。

请传播关于这个问题的信息。我们继续失去手册，因为它们受到专有出版的限制。如果我们传播这样的信息，即专有手册是不够的，也许下一个想通过撰写文档来帮助GNU的人在为时已晚之前会意识到，他首先必须使其自由。

我们还可以鼓励商业出版商销售自由的、遵循版权的手册，而不是专有的手册。你可以帮助实现这一点的一种方式是在购买手册之前检查其分发条款，并更喜欢遵循版权的手册而不是非遵循版权的手册。

@sp 2
@noindent
注：自由软件基金会在其网站上维护了一个页面，列出了其他出版商提供的免费图书：@*
@uref{https://www.gnu.org/doc/other-free-books.html}

@node GNU Free Documentation License
@appendix GNU Free Documentation License

@cindex FDL, GNU Free Documentation License
@include doclicense.texi

@node Index
@unnumbered Index

@ignore
MENU ENTRY: NODE NAME.
@end ignore

@printindex cp

@iftex
@c Place biographical information on right-hand (verso) page

@tex
\par\vfill\supereject
\ifodd\pageno
    \global\evenheadline={\hfil} \global\evenfootline={\hfil}
    \global\oddheadline={\hfil} \global\oddfootline={\hfil}
    %\page\hbox{}\page
\else
%    \par\vfill\supereject
    \global\evenheadline={\hfil} \global\evenfootline={\hfil}
    \global\oddheadline={\hfil} \global\oddfootline={\hfil}
    %\page\hbox{}%\page
    %\page\hbox{}%\page
\fi
@end tex

@c page
@w{ }

@c ================ Biographical information ================

@w{ }
@sp 8
@center About the Author
@sp 1
@end iftex

@ifnottex
@node About the Author
@unnumbered 作者简介
@end ifnottex

@quotation
罗伯特·J·查瑟尔（1946--2017）于1985年开始使用GNU Emacs。他撰写和编辑了Emacs和Emacs Lisp的教材，并在世界各地演讲，倡导软件自由。查瑟尔是自由软件基金会（Free Software Foundation, Inc.）的创始董事兼财务主管。他是《Texinfo》手册的合著者，还编辑了十多本其他书籍。他毕业于英格兰剑桥大学，对社会和经济历史有浓厚兴趣，同时还是一名私人飞行爱好者。

@uref{https://www.fsf.org/blogs/community/goodbye-to-bob-chassell,
"向鲍勃·查瑟尔告别"}
@end quotation

@c @page
@c @w{ }
@c
@c @c Prevent page number on blank verso, so eject it first.
@c @tex
@c \par\vfill\supereject
@c @end tex

@c @iftex
@c @headings off
@c @evenheading @thispage @| @| @thistitle
@c @oddheading            @| @| @thispage
@c @end iftex

@bye
