\input texinfo                       @c -*- mode: texinfo; coding: utf-8 -*-
@comment %**start of header
@setfilename ../../info/eintr.info
@settitle Programming in Emacs Lisp
@include docstyle.texi
@syncodeindex vr cp
@syncodeindex fn cp
@finalout

@include emacsver.texi

@c ================ How to Print a Book in Various Sizes ================

@c This book can be printed in any of three different sizes.
@c Set the following @-commands appropriately.

@c     7 by 9.25 inches:
@c              @smallbook
@c              @clear largebook

@c     8.5 by 11 inches:
@c              @c smallbook
@c              @set largebook

@c     European A4 size paper:
@c              @c smallbook
@c              @afourpaper
@c              @set largebook

@c (Note: if you edit the book so as to change the length of the
@c table of contents, you may have to change the value of 'pageno' below.)

@c <<<< For hard copy printing, this file is now
@c      set for smallbook, which works for all sizes
@c      of paper, and with PostScript figures >>>>

@set smallbook
@ifset smallbook
@smallbook
@clear  largebook
@end ifset

@c ================ Included Figures ================

@c If you clear this, the figures will be printed as ASCII diagrams
@c rather than PostScript/PDF.
@c (This is not relevant to Info, since Info only handles ASCII.)
@set print-postscript-figures
@c clear print-postscript-figures

@comment %**end of header

@c per rms and peterb, use 10pt fonts for the main text, mostly to
@c save on paper cost.
@c Do this inside @tex for now, so current makeinfo does not complain.
@tex
@ifset smallbook
@fonttextsize 10

@end ifset
\global\hbadness=6666 % don't worry about not-too-underfull boxes
@end tex

@c For next or subsequent edition:
@c   create function using with-output-to-temp-buffer
@c   create a major mode, with keymaps
@c   run an asynchronous process, like grep or diff

@c For 8.5 by 11 inch format: do not use such a small amount of
@c whitespace between paragraphs as smallbook format
@ifset largebook
@tex
\global\parskip 6pt plus 1pt
@end tex
@end ifset

@c For all sized formats:  print within-book cross
@c reference with ``...''  rather than [...]

@c This works with the texinfo.tex file, version 2003-05-04.08,
@c in the Texinfo version 4.6 of the 2003 Jun 13 distribution.

@tex
\if \xrefprintnodename
 \global\def\xrefprintnodename#1{\unskip, ``#1''}
 \else
 \global\def\xrefprintnodename#1{ ``#1''}
\fi
% \global\def\xrefprintnodename#1{, ``#1''}
@end tex

@c ----------------------------------------------------

@dircategory Emacs lisp
@direntry
* Emacs Lisp Intro: (eintr).    A simple introduction to Emacs Lisp programming.
@end direntry

@c When printing, define edition-number to be the printed edition
@c number, titlepage-edition-number to be the spelled out edition
@c number suitable for the title page, and update-date to be the date,
@c in the preferred style for these.  E.g., run the shell command:
@c   texi2any -D 'edition-number 3.11' \
@c            -D 'titlepage-edition-number Revised Third Edition' \
@c            -D 'update-date 31 March 2020'
@c This relates mainly to the published book sold by the FSF.

@copying
这是针对非程序员的 @cite{Emacs Lisp 编程简介}
@sp 1
@ifset edition-number
版本 @value{edition-number}, @value{update-date}
@end ifset
@sp 1
随 Emacs 版本 @value{EMACSVER} 发行.
@sp 1
Copyright @copyright{} 1990--1995, 1997, 2001--2023 自由软件基金会.
@sp 1

@iftex
由以下机构出版:@*

GNU Press,               @hfill @uref{https://www.fsf.org/licensing/gnu-press/}@*
自由软件基金会旗下的一个分部               @hfill email: @email{sales@@fsf.org}@*
Free Software Foundation, Inc.  @hfill 电话: +1 (617) 542-5942@*
51 Franklin Street, Fifth Floor @hfill 传真: +1 (617) 542-2652@*
美国马萨诸塞州波士顿，邮编02110-1301
@end iftex

@ifnottex
纸质版本可在 @uref{https://shop.fsf.org/} 获得。由以下机构出版：

@example
GNU Press,                        https://www.fsf.org/licensing/gnu-press/
自由软件基金会旗下的一个分部                 电子邮件：sales@@fsf.org
Free Software Foundation, Inc.    电话：+1 (617) 542-5942
51 Franklin Street, Fifth Floor   传真：+1 (617) 542-2652
美国马萨诸塞州波士顿，邮编02110-1301
@end example
@end ifnottex

@sp 1
ISBN 1-882114-43-4

@quotation
允许复制、分发和/或修改本文档，遵循 GNU 自由文档许可证 1.3 版或由自由软件基金会发布的任何以后版本的条款；本文档没有不变章节，封面文本为“GNU 手册”，反面封面文本如 (a) 所示。许可证的副本包含在名为“GNU 自由文档许可证”的章节中。

(a) FSF 的背面封面文本是：“你有自由复制和修改这份 GNU 手册。从 FSF 购买副本支持其开发 GNU 并推广软件自由。”
@end quotation
@end copying

@c half title; two lines here, so do not use 'shorttitlepage'
@tex
{\begingroup%
    \hbox{}\vskip 1.5in \chaprm \centerline{An Introduction to}%
        \endgroup}%
{\begingroup\hbox{}\vskip 0.25in \chaprm%
        \centerline{Programming in Emacs Lisp}%
        \endgroup\page\hbox{}\page}
@end tex

@titlepage
@sp 6
@center @titlefont{An Introduction to}
@sp 2
@center @titlefont{Programming in Emacs Lisp}
@sp 2
@ifset titlepage-edition-number
@center @value{titlepage-edition-number}
@end ifset
@sp 4
@center by Robert J. Chassell

@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@iftex
@headings off
@evenheading @thispage @| @| @thischapter
@oddheading @thissection @| @| @thispage
@end iftex

@ifnothtml
@c     Keep T.O.C. short by tightening up for largebook
@ifset largebook
@tex
\global\parskip 2pt plus 1pt
\global\advance\baselineskip by -1pt
@end tex
@end ifset
@end ifnothtml

@c If you think this manual is too large for an introduction, please
@c consider this email exchange:
@c
@c       >> The intro is almost 300 pages in full.  I had expected 60 pages.
@c       >
@c       > This is an important point in its own right.  Could you
@c       > write a simplified introduction that is only 50 pages or so?
@c       > That would be helpful to many potential users, I'd think.
@c
@c   > The problem with the introduction is that it was written when
@c   > programming was only starting to be a skill "normal" people could
@c   > have access to.  So the text is extremely verbose and is
@c   > sometimes hard to follow because of that.  The gist of the
@c   > document could be summarized in 50 pages.
@c
@c This book is intentionally addressed to people who don't know how to
@c program.  That is its purpose.  We recommend people start learning to
@c program using this book.
@c
@c If you DO know how to program in some other language, you can probably
@c learn Emacs Lisp starting with the Emacs Lisp Reference Manual.
@c
@c        Richard Stallman <rms@gnu.org>,
@c        https://lists.gnu.org/r/emacs-devel/2018-05/msg00374.html

@shortcontents
@contents

@ifnottex
@node Top
@top Emacs Lisp 编程简介

@ifset WWW_GNU_ORG
@html
<p>GNU Emacs的网站位于
<a href="/software/emacs/">https://www.gnu.org/software/emacs/</a>.<br>
要查看其他格式的本手册，请点击
<a href="/software/emacs/manual/eintr.html">这里</a>.
@end html
@end ifset

@insertcopying

此主菜单首先列出每个章节和索引；然后列出每个章节中的每个节点。
@end ifnottex

@c Uncomment the 3 lines below, starting with @iftex, if you want the
@c pages of Preface to be numbered in roman numerals.  Use -9 instead
@c of -11 for smallbook format.

@c >>>> Set pageno appropriately <<<<

@c The first page of the Preface is a roman numeral; it is the first
@c right handed page after the Table of Contents; hence the following
@c setting must be for an odd negative number.

@c iftex
@c global@pageno = -11
@c end iftex

@set COUNT-WORDS count-words-example
@c Length of variable name chosen so that things still line up when expanded.

@menu
* Preface::                     What to look for.
* List Processing::             What is Lisp?
* Practicing Evaluation::       Running several programs.
* Writing Defuns::              How to write function definitions.
* Buffer Walk Through::         Exploring a few buffer-related functions.
* More Complex::                A few, even more complex functions.
* Narrowing & Widening::        Restricting your and Emacs attention to
                                    a region.
* car cdr & cons::              Fundamental functions in Lisp.
* Cutting & Storing Text::      Removing text and saving it.
* List Implementation::         How lists are implemented in the computer.
* Yanking::                     Pasting stored text.
* Loops & Recursion::           How to repeat a process.
* Regexp Search::               Regular expression searches.
* Counting Words::              A review of repetition and regexps.
* Words in a defun::            Counting words in a @code{defun}.
* Readying a Graph::            A prototype graph printing function.
* Emacs Initialization::        How to write a @file{.emacs} file.
* Debugging::                   How to run the Emacs Lisp debuggers.
* Conclusion::                  Now you have the basics.
* the-the::                     An appendix: how to find reduplicated words.
* Kill Ring::                   An appendix: how the kill ring works.
* Full Graph::                  How to create a graph with labeled axes.
* Free Software and Free Manuals::
* GNU Free Documentation License::
* Index::
* About the Author::

@detailmenu
 --- The Detailed Node Listing ---

Preface

* Why::                         Why learn Emacs Lisp?
* On Reading this Text::        Read, gain familiarity, pick up habits....
* Who You Are::                 For whom this is written.
* Lisp History::
* Note for Novices::            You can read this as a novice.
* Thank You::

List Processing

* Lisp Lists::                  What are lists?
* Run a Program::               Any list in Lisp is a program ready to run.
* Making Errors::               Generating an error message.
* Names & Definitions::         Names of symbols and function definitions.
* Lisp Interpreter::            What the Lisp interpreter does.
* Evaluation::                  Running a program.
* Variables::                   Returning a value from a variable.
* Arguments::                   Passing information to a function.
* set & setq::                  Setting the value of a variable.
* Summary::                     The major points.
* Error Message Exercises::

Lisp Lists

* Numbers Lists::               List have numbers, other lists, in them.
* Lisp Atoms::                  Elemental entities.
* Whitespace in Lists::         Formatting lists to be readable.
* Typing Lists::                How GNU Emacs helps you type lists.

The Lisp Interpreter

* Complications::               Variables, Special forms, Lists within.
* Byte Compiling::              Specially processing code for speed.

Evaluation

* How the Interpreter Acts::    Returns and Side Effects...
* Evaluating Inner Lists::      Lists within lists...

Variables

* fill-column Example::
* Void Function::               The error message for a symbol
                                  without a function.
* Void Variable::               The error message for a symbol without a value.

Arguments

* Data types::                  Types of data passed to a function.
* Args as Variable or List::    An argument can be the value
                                  of a variable or list.
* Variable Number of Arguments::  Some functions may take a
                                  variable number of arguments.
* Wrong Type of Argument::      Passing an argument of the wrong type
                                  to a function.
* message::                     A useful function for sending messages.

Setting the Value of a Variable

* Using set::                  Setting values.
* Using setq::                 Setting a quoted value.
* Counting::                   Using @code{setq} to count.

Practicing Evaluation

* How to Evaluate::            Typing editing commands or @kbd{C-x C-e}
                                 causes evaluation.
* Buffer Names::               Buffers and files are different.
* Getting Buffers::            Getting a buffer itself, not merely its name.
* Switching Buffers::          How to change to another buffer.
* Buffer Size & Locations::    Where point is located and the size of
                               the buffer.
* Evaluation Exercise::

How To Write Function Definitions

* Primitive Functions::
* defun::                        The @code{defun} macro.
* Install::                      Install a function definition.
* Interactive::                  Making a function interactive.
* Interactive Options::          Different options for @code{interactive}.
* Permanent Installation::       Installing code permanently.
* let::                          Creating and initializing local variables.
* if::                           What if?
* else::                         If--then--else expressions.
* Truth & Falsehood::            What Lisp considers false and true.
* save-excursion::               Keeping track of point and buffer.
* Review::
* defun Exercises::

Install a Function Definition

* Effect of installation::
* Change a defun::              How to change a function definition.

Make a Function Interactive

* Interactive multiply-by-seven::  An overview.
* multiply-by-seven in detail::    The interactive version.

@code{let}

* Prevent confusion::
* Parts of let Expression::
* Sample let Expression::
* Uninitialized let Variables::

The @code{if} Special Form

* if in more detail::
* type-of-animal in detail::    An example of an @code{if} expression.

Truth and Falsehood in Emacs Lisp

* nil explained::               @code{nil} has two meanings.

@code{save-excursion}

* Point and mark::              A review of various locations.
* Template for save-excursion::

A Few Buffer-Related Functions

* Finding More::                How to find more information.
* simplified-beginning-of-buffer::  Shows @code{goto-char},
                                @code{point-min}, and @code{push-mark}.
* mark-whole-buffer::           Almost the same as @code{beginning-of-buffer}.
* append-to-buffer::            Uses @code{save-excursion} and
                                @code{insert-buffer-substring}.
* Buffer Related Review::       Review.
* Buffer Exercises::

The Definition of @code{mark-whole-buffer}

* mark-whole-buffer overview::
* Body of mark-whole-buffer::   Only three lines of code.

The Definition of @code{append-to-buffer}

* append-to-buffer overview::
* append interactive::          A two part interactive expression.
* append-to-buffer body::       Incorporates a @code{let} expression.
* append save-excursion::       How the @code{save-excursion} works.

A Few More Complex Functions

* copy-to-buffer::              With @code{set-buffer}, @code{get-buffer-create}.
* insert-buffer::               Read-only, and with @code{or}.
* beginning-of-buffer::         Shows @code{goto-char},
                                @code{point-min}, and @code{push-mark}.
* Second Buffer Related Review::
* optional Exercise::

The Definition of @code{insert-buffer}

* insert-buffer code::
* insert-buffer interactive::   When you can read, but not write.
* insert-buffer body::          The body has an @code{or} and a @code{let}.
* if & or::                     Using an @code{if} instead of an @code{or}.
* Insert or::                   How the @code{or} expression works.
* Insert let::                  Two @code{save-excursion} expressions.
* New insert-buffer::

The Interactive Expression in @code{insert-buffer}

* Read-only buffer::            When a buffer cannot be modified.
* b for interactive::           An existing buffer or else its name.

Complete Definition of @code{beginning-of-buffer}

* Optional Arguments::
* beginning-of-buffer opt arg::  Example with optional argument.
* beginning-of-buffer complete::

@code{beginning-of-buffer} with an Argument

* Disentangle beginning-of-buffer::
* Large buffer case::
* Small buffer case::

Narrowing and Widening

* Narrowing advantages::        The advantages of narrowing
* save-restriction::            The @code{save-restriction} special form.
* what-line::                   The number of the line that point is on.
* narrow Exercise::

@code{car}, @code{cdr}, @code{cons}: Fundamental Functions

* Strange Names::               A historical aside: why the strange names?
* car & cdr::                   Functions for extracting part of a list.
* cons::                        Constructing a list.
* nthcdr::                      Calling @code{cdr} repeatedly.
* nth::
* setcar::                      Changing the first element of a list.
* setcdr::                      Changing the rest of a list.
* cons Exercise::

@code{cons}

* Build a list::
* length::                      How to find the length of a list.

Cutting and Storing Text

* Storing Text::                Text is stored in a list.
* zap-to-char::                 Cutting out text up to a character.
* kill-region::                 Cutting text out of a region.
* copy-region-as-kill::         A definition for copying text.
* Digression into C::           Minor note on C programming language macros.
* defvar::                      How to give a variable an initial value.
* cons & search-fwd Review::
* search Exercises::

@code{zap-to-char}

* Complete zap-to-char::        The complete implementation.
* zap-to-char interactive::     A three part interactive expression.
* zap-to-char body::            A short overview.
* search-forward::              How to search for a string.
* progn::                       The @code{progn} special form.
* Summing up zap-to-char::      Using @code{point} and @code{search-forward}.

@code{kill-region}

* Complete kill-region::        The function definition.
* condition-case::              Dealing with a problem.
* Lisp macro::

@code{copy-region-as-kill}

* Complete copy-region-as-kill::  The complete function definition.
* copy-region-as-kill body::      The body of @code{copy-region-as-kill}.

The Body of @code{copy-region-as-kill}

* last-command & this-command::
* kill-append function::
* kill-new function::

Initializing a Variable with @code{defvar}

* See variable current value::
* defvar and asterisk::

How Lists are Implemented

* Lists diagrammed::
* Symbols as Chest::            Exploring a powerful metaphor.
* List Exercise::

Yanking Text Back

* Kill Ring Overview::
* kill-ring-yank-pointer::      The kill ring is a list.
* yank nthcdr Exercises::       The @code{kill-ring-yank-pointer} variable.

Loops and Recursion

* while::                       Causing a stretch of code to repeat.
* dolist dotimes::
* Recursion::                   Causing a function to call itself.
* Looping exercise::

@code{while}

* Looping with while::          Repeat so long as test returns true.
* Loop Example::                A @code{while} loop that uses a list.
* print-elements-of-list::      Uses @code{while}, @code{car}, @code{cdr}.
* Incrementing Loop::           A loop with an incrementing counter.
* Incrementing Loop Details::
* Decrementing Loop::           A loop with a decrementing counter.

Details of an Incrementing Loop

* Incrementing Example::        Counting pebbles in a triangle.
* Inc Example parts::           The parts of the function definition.
* Inc Example altogether::      Putting the function definition together.

Loop with a Decrementing Counter

* Decrementing Example::        More pebbles on the beach.
* Dec Example parts::           The parts of the function definition.
* Dec Example altogether::      Putting the function definition together.

Save your time: @code{dolist} and @code{dotimes}

* dolist::
* dotimes::

Recursion

* Building Robots::             Same model, different serial number ...
* Recursive Definition Parts::  Walk until you stop ...
* Recursion with list::         Using a list as the test whether to recurse.
* Recursive triangle function::
* Recursion with cond::
* Recursive Patterns::          Often used templates.
* No Deferment::                Don't store up work ...
* No deferment solution::

Recursion in Place of a Counter

* Recursive Example arg of 1 or 2::
* Recursive Example arg of 3 or 4::

Recursive Patterns

* Every::
* Accumulate::
* Keep::

Regular Expression Searches

* sentence-end::                The regular expression for @code{sentence-end}.
* re-search-forward::           Very similar to @code{search-forward}.
* forward-sentence::            A straightforward example of regexp search.
* forward-paragraph::           A somewhat complex example.
* Regexp Review::
* re-search Exercises::

@code{forward-sentence}

* Complete forward-sentence::
* fwd-sentence while loops::    Two @code{while} loops.
* fwd-sentence re-search::      A regular expression search.

@code{forward-paragraph}: a Goldmine of Functions

* forward-paragraph in brief::  Key parts of the function definition.
* fwd-para let::                The @code{let*} expression.
* fwd-para while::              The forward motion @code{while} loop.

Counting: Repetition and Regexps

* Why Count Words::
* @value{COUNT-WORDS}::         Use a regexp, but find a problem.
* recursive-count-words::       Start with case of no words in region.
* Counting Exercise::

The @code{@value{COUNT-WORDS}} Function

* Design @value{COUNT-WORDS}::  The definition using a @code{while} loop.
* Whitespace Bug::              The Whitespace Bug in @code{@value{COUNT-WORDS}}.

Counting Words in a @code{defun}

* Divide and Conquer::
* Words and Symbols::           What to count?
* Syntax::                      What constitutes a word or symbol?
* count-words-in-defun::        Very like @code{@value{COUNT-WORDS}}.
* Several defuns::              Counting several defuns in a file.
* Find a File::                 Do you want to look at a file?
* lengths-list-file::           A list of the lengths of many definitions.
* Several files::               Counting in definitions in different files.
* Several files recursively::   Recursively counting in different files.
* Prepare the data::            Prepare the data for display in a graph.

Count Words in @code{defuns} in Different Files

* lengths-list-many-files::     Return a list of the lengths of defuns.
* append::                      Attach one list to another.

Prepare the Data for Display in a Graph

* Data for Display in Detail::
* Sorting::                     Sorting lists.
* Files List::                  Making a list of files.
* Counting function definitions::

Readying a Graph

* Columns of a graph::
* graph-body-print::            How to print the body of a graph.
* recursive-graph-body-print::
* Printed Axes::
* Line Graph Exercise::

Your @file{.emacs} File

* Default Configuration::
* Site-wide Init::              You can write site-wide init files.
* defcustom::                   Emacs will write code for you.
* Beginning init File::         How to write a @file{.emacs} init file.
* Text and Auto-fill::          Automatically wrap lines.
* Mail Aliases::                Use abbreviations for email addresses.
* Indent Tabs Mode::            Don't use tabs with @TeX{}
* Key Bindings::                Create some personal key bindings.
* Keymaps::                     More about key binding.
* Loading Files::               Load (i.e., evaluate) files automatically.
* Autoload::                    Make functions available.
* Simple Extension::            Define a function; bind it to a key.
* X11 Colors::                  Colors in X.
* Miscellaneous::
* Mode Line::                   How to customize your mode line.

Debugging

* debug::                       How to use the built-in debugger.
* debug-on-entry::              Start debugging when you call a function.
* debug-on-quit::               Start debugging when you quit with @kbd{C-g}.
* edebug::                      How to use Edebug, a source level debugger.
* Debugging Exercises::

Handling the Kill Ring

* What the Kill Ring Does::
* current-kill::
* yank::                        Paste a copy of a clipped element.
* yank-pop::                    Insert element pointed to.
* ring file::

The @code{current-kill} Function

* Code for current-kill::
* Understanding current-kill::

@code{current-kill} in Outline

* Body of current-kill::
* Digression concerning error::  How to mislead humans, but not computers.
* Determining the Element::

A Graph with Labeled Axes

* Labeled Example::
* print-graph Varlist::         @code{let} expression in @code{print-graph}.
* print-Y-axis::                Print a label for the vertical axis.
* print-X-axis::                Print a horizontal label.
* Print Whole Graph::           The function to print a complete graph.

The @code{print-Y-axis} Function

* print-Y-axis in Detail::
* Height of label::             What height for the Y axis?
* Compute a Remainder::         How to compute the remainder of a division.
* Y Axis Element::              Construct a line for the Y axis.
* Y-axis-column::               Generate a list of Y axis labels.
* print-Y-axis Penultimate::    A not quite final version.

The @code{print-X-axis} Function

* Similarities differences::    Much like @code{print-Y-axis}, but not exactly.
* X Axis Tic Marks::            Create tic marks for the horizontal axis.

Printing the Whole Graph

* The final version::           A few changes.
* Test print-graph::            Run a short test.
* Graphing words in defuns::    Executing the final code.
* lambda::                      How to write an anonymous function.
* mapcar::                      Apply a function to elements of a list.
* Another Bug::                 Yet another bug @dots{} most insidious.
* Final printed graph::         The graph itself!

@end detailmenu
@end menu

@node Preface
@unnumbered 前言

GNU Emacs集成环境的大部分都是用一种叫做Emacs Lisp的编程语言编写的。用这种编程语言编写的代码是软件，是一组指令，告诉计算机在你给它命令时应该做什么。Emacs被设计成可以用Emacs Lisp编写新代码，并轻松地将其安装为编辑器的扩展。

(GNU Emacs有时被称为“可扩展编辑器”，但它的功能远不止提供编辑功能。更恰当的称呼是将Emacs视为“可扩展计算环境”。然而，这个短语有点拗口。简单地将Emacs称为编辑器更容易理解。此外，在Emacs中的一切活动，如查找玛雅日期和月相、简化多项式、调试代码、管理文件、阅读邮件、撰写书籍，都可以看作是一种最一般意义上的编辑。)

@menu
* Why::                         Why learn Emacs Lisp?
* On Reading this Text::        Read, gain familiarity, pick up habits....
* Who You Are::                 For whom this is written.
* Lisp History::
* Note for Novices::            You can read this as a novice.
* Thank You::
@end menu

@ifnottex
@node Why
@unnumberedsec 为什么要学习 Emacs Lisp？
@end ifnottex

尽管Emacs Lisp通常只与Emacs相关，但它是一种完整的计算机编程语言。您可以像使用其他编程语言一样使用Emacs Lisp。

也许您想了解编程；也许您想扩展Emacs；或者也许您想成为一名程序员。这个关于Emacs Lisp的介绍旨在帮助您入门：引导您学习编程的基础知识，更重要的是，向您展示如何自学以更进一步。

@node On Reading this Text
@unnumberedsec 关于阅读本文

在本文中，您将看到一些可以在Emacs中运行的小示例程序。如果您正在使用GNU Emacs的Info模式阅读本文，您可以按照示例中的说明来运行这些程序（这很容易做到，当示例程序出现时会有解释）。或者，您可以在运行Emacs的计算机旁边阅读这本介绍性的书籍。（这是我个人偏好的方式；我喜欢纸质书籍。）如果您旁边没有正在运行的Emacs，您仍然可以阅读这本书，但在这种情况下，最好将其视为一部小说或一本尚未探索过的国家的旅行指南：虽然有趣，但不同于亲自实践。

这个介绍的大部分内容都是关于GNU Emacs中的代码演练和代码导览。这些导览有两个目的：首先，使您熟悉真实的、可工作的代码（您每天使用的代码）；其次，使您熟悉Emacs的工作方式。看到一个工作环境是如何实现的是非常有趣的。此外，我希望您会养成浏览源代码的习惯。您可以从中学习并获得灵感。拥有GNU Emacs就像拥有一个充满宝藏的巨龙巢穴。

除了学习作为编辑器的Emacs和作为编程语言的Emacs Lisp，示例和导览还将让您有机会熟悉作为Lisp编程环境的Emacs。GNU Emacs支持编程，并提供了各种工具，如@kbd{M-.}（调用@code{xref-find-definitions}命令的键）。您还将学习关于缓冲区和环境中的其他对象的信息。学习这些Emacs的特性就像探索自己家乡的新路线一样。

@ignore
In addition, I have written several programs as extended examples.
Although these are examples, the programs are real.  I use them.
Other people use them.  You may use them.  Beyond the fragments of
programs used for illustrations, there is very little in here that is
just for teaching purposes; what you see is used.  This is a great
advantage of Emacs Lisp: it is easy to learn to use it for work.
@end ignore

最后，我希望传授一些使用Emacs来学习您不了解的编程方面的技能。您通常可以使用Emacs来帮助您理解困扰您的事情或做一些新的东西。这种自力更生不仅是一种乐趣，还是一种优势。

@node Who You Are
@unnumberedsec 目标读者

本文是为那些不是程序员的人写的初级介绍。如果您是一名程序员，可能对这篇入门文章感到不满意。原因是您可能已经熟练掌握了阅读参考手册的技巧，并且可能不喜欢这篇文章的组织方式。

一位经验丰富的程序员在审阅这篇文章后对我说：

@quotation
@i{我更喜欢从参考手册中学习。我在每个段落中深入阅读，然后在段落之间稍作休息。}

@i{当我阅读完一个段落时，我假设该主题已经讲解完毕，我知道我需要的一切信息（除非下一个段落开始更详细地讨论它）。我期望一个写得很好的，不会有太多冗余的参考手册，而且会有出色的指向（一个）我想要的信息的链接。}
@end quotation

这个介绍不是针对这样的人写的！

首先，我尽量将每件事情都至少重复三次：首先是介绍它；其次是在上下文中展示它；第三是在不同的上下文中展示它，或者进行复习。

其次，我通常不会把有关某个主题的所有信息都集中在一个地方，更不用说一个段落了。根据我的思维方式，这会对读者造成过多的负担。相反，我只会尝试在您需要了解时提供解释。（有时我会包含一些额外信息，以便稍后当额外信息正式介绍时，您不会觉得突然)。

当您阅读这篇文章时，您不必一次性掌握所有内容。通常，您只需要对提到的一些项目有一点了解。我希望我已经结构化了这篇文章并提供了足够的提示，以便您能够意识到什么是重要的，并专注于它。

您需要深入研究一些段落；别无他法。但我已经尽量减少这类段落的数量。这本书旨在作为一个平易近人的小山丘，而不是一个令人望而却步的高峰。

这本名为 @cite{An Introduction to Programming in Emacs Lisp} 的书有一个配套文档,
@iftex
@cite{The GNU Emacs Lisp Reference Manual}.
@end iftex
@ifnottex
@ref{Top, , The GNU Emacs Lisp Reference Manual, elisp, The GNU
Emacs Lisp Reference Manual}.
@end ifnottex
参考手册比这个入门介绍包含更多细节。在参考手册中，有关一个主题的所有信息都集中在一个地方。如果您是像上面的程序员一样，就应该参考它。当然，在阅读完这本@cite{Introduction}后, 您在编写自己的程序时会发现 @cite{Reference Manual} 很有用.

@node Lisp History
@unnumberedsec Lisp的历史
@cindex Lisp history

Lisp语言在20世纪50年代晚期由麻省理工学院为人工智能研究而开发。Lisp语言的强大之处使其在其他领域也表现出色，例如编写编辑器命令和集成环境。

@cindex Maclisp
@cindex Common Lisp
GNU Emacs Lisp在很大程度上受到Maclisp的启发，Maclisp是在20世纪60年代由麻省理工学院开发的。它也在一定程度上受到Common Lisp的启发，Common Lisp在20世纪80年代成为了一种标准。然而，Emacs Lisp比Common Lisp简单得多。（标准的Emacs发行版包含一个可选的扩展文件@file{cl-lib.el}，它为Emacs Lisp添加了许多Common Lisp功能。）

@node Note for Novices
@unnumberedsec 新手须知

即使您不了解GNU Emacs，您仍然可以从本文中有所收获。但是，我建议您学习Emacs，即使只是为了学会在计算机屏幕上移动。您可以使用内置教程来自学如何使用Emacs。要使用它，输入@kbd{C-h t}。（这意味着您同时按下和释放@key{CTRL}键和@kbd{h}键，然后按下和释放@kbd{t}键。）

此外，我经常通过列出用于调用标准Emacs命令的按键，然后在括号中给出命令的名称，来引用Emacs的标准命令之一，就像这样：@kbd{M-C-\}（@code{indent-region}）。这意味着@code{indent-region}命令通常是通过键入@kbd{M-C-\}来调用的。（如果您愿意，您可以更改用于调用命令的按键；这被称为@dfn{rebinding, 重新绑定}。@xref{Keymaps, , Keymaps}。）@kbd{M-C-\}的缩写意味着你需要同时按下@key{META}键、@key{CTRL}键和@kbd{\}键。在许多现代键盘上，@key{META}键帽上标着@key{ALT}。像这样的组合被称为组合键(keychord)。如果你的键盘没有@key{META}键，单击@key{ESC}键来代替它。在这种情况下，@kbd{M-C-\}意味着您按下并释放@key{ESC}键，然后同时按下@key{CTRL}键和@kbd{\}键。但通常@kbd{M-C-\}意味着同时按下标有@key{ALT}的键和@key{CTRL}键，同时再按@kbd{\}键。

除了长按单个组合键外，您还可以在你输入的内容前加上@kbd{C-u}，这被称为@dfn{通用参数}。@kbd{C-u}组合键会将参数传递给后续的命令。因此，要以6空格缩进一段纯文本的区域，首先标记该区域，然后输入@w{@kbd{C-u 6 M-C-\}}。（如果您不指定一个数字，Emacs将默认数字为4，或者以不同于其他情况的方式运行该命令。）@xref{Arguments, , Numeric Arguments, emacs, The GNU Emacs Manual}。

如果您是在GNU Emacs中使用Info模式阅读这篇文章，您可以通过按下空格键@key{SPC}来浏览整个文档。（要了解Info，请输入@kbd{C-h i}，然后选择Info。）

关于术语的说明：当我单独使用Lisp这个词时，我通常是在泛指各种Lisp方言，但当我谈到Emacs Lisp时，我指的是特定的GNU Emacs Lisp。

@node Thank You
@unnumberedsec 致谢

感谢所有帮助我完成这本书的人。特别感谢@r{Jim Blandy}，@r{Noah Friedman}，@w{Jim Kingdon}，@r{Roland McGrath}，@w{Frank Ritter}，@w{Randy Smith}，@w{Richard M. Stallman}和@w{Melissa Weisshaus}。我还要感谢@w{Philip Johnson}和@w{David Stampe}，他们的耐心鼓励对我非常重要。如有遗漏是我的问题。

@flushright
Robert J. Chassell
@ifnothtml
@email{bob@@gnu.org}
@end ifnothtml
@ifhtml
bob@@gnu.org
@end ifhtml
@end flushright

@c ================ Beginning of main text ================

@c Start main text on right-hand (verso) page

@tex
\par\vfill\supereject
\headings off
\ifodd\pageno
    \par\vfill\supereject
\else
    \par\vfill\supereject
    \page\hbox{}\page
    \par\vfill\supereject
\fi
@end tex

@c Note: this resetting of the page number back to 1 causes TeX to gripe
@c about already having seen page numbers 1-4 before (in the preface):
@c   pdfTeX warning (ext4): destination with the same identifier (name{1})
@c   has been already used, duplicate ignored
@c I guess that is harmless (what happens if a later part of the text
@c makes a link to something in the first 4 pages though?).
@c E.g., note that the Emacs manual has a preface, but does not bother
@c resetting the page numbers back to 1 after that.
@c Alternatively, uncomment the 3 lines above (search for ``pageno'')
@c to have the preface numbered in roman numerals.
@iftex
@headings off
@evenheading @thispage @| @| @thischapter
@oddheading @thissection @| @| @thispage
@global@pageno = 1
@end iftex

@node List Processing
@chapter 列表处理

对于未经培训的人来说，Lisp 是一种奇特的编程语言。在 Lisp 代码中，到处都是括号。甚至有人声称这个名字代表“Lots of Isolated Silly Parentheses”（很多孤立的愚蠢括号）。但这种说法是不准确的。Lisp 代表 LISt Processing，这种编程语言通过处理括号中的@emph{列表}（以及列表的列表）来工作。括号标示着列表的边界。有时候，列表前面会有一个撇号@samp{'}，称作 Lisp 中的@dfn{单引号}。
@footnote{A single-quote is an
abbreviation for the special form @code{quote}; you need not think
about special forms now.
@ifnottex
@xref{Complications}.
@end ifnottex
@iftex
@xref{Lisp Interpreter}.
@end iftex
}  列表是 Lisp 的基础。

@menu
* Lisp Lists::                  什么是列表？
* Run a Program::               Lisp中的任何列表都可以直接运行
* Making Errors::               生成错误消息
* Names & Definitions::         符号的名称和函数定义
* Lisp Interpreter::            Lisp解释器的作用
* Evaluation::                  运行程序
* Variables::                   从变量返回值
* Arguments::                   向函数传递信息
* set & setq::                  设置变量的值
* Summary::                     总结
* Error Message Exercises::
@end menu

@node Lisp Lists
@section Lisp列表
@cindex Lisp Lists

在Lisp中，一个列表看起来像这样：@code{'(rose violet daisy buttercup)}。这个列表前面有一个单引号。它也可以写成如下形式，更像你可能熟悉的列表：

@smallexample
@group
'(rose
  violet
  daisy
  buttercup)
@end group
@end smallexample

@noindent
这个列表的元素是四种不同花的名称，它们之间用空格分隔，被括号包围，就像田野中的花朵被一堵石墙围绕着。
@cindex 田野中的花朵

@menu
* Numbers Lists::               包含数字和其他列表的列表。
* Lisp Atoms::                  基本实体。
* Whitespace in Lists::         格式化使列表更易阅读。
* Typing Lists::                GNU Emacs如何帮助您输入列表。
@end menu

@ifnottex
@node Numbers Lists
@unnumberedsubsec 列表中的数字与列表
@end ifnottex

在 Lisp 中,列表也可以包含数值，就像这个列表：@code{(+ 2 2)}。
这个列表包含一个加号，@samp{+}，后面跟着两个 @samp{2}，它们之间用空格分隔。

在Lisp中，数据和程序都以相同的方式表示；也就是说，它们都是由单词、数字或其他列表组成，之间用空格分隔，括在括号中。 (由于程序看起来像数据，一个程序可以轻松地作为另一个程序的数据；这是Lisp的一个非常强大的特性。) (顺便说一下，这两个括号中的注释@emph{不是}Lisp列表，因为它们包含了分号 @samp{;} 和句点 @samp{.} 作为标点符号。)

@need 1200
这里还有一个列表，这次里面包含了一个列表：

@smallexample
'(this list has (a list inside of it))
@end smallexample

这个列表的组成部分包括单词 @samp{this}, @samp{list},
@samp{has}, 和列表 @samp{(a list inside of it)}.  内部列表由单词 @samp{a}, @samp{list}, @samp{inside},
@samp{of}, @samp{it} 组成。

@node Lisp Atoms
@subsection Lisp原子
@cindex Lisp Atoms

在Lisp中，我们一直称之为单词的东西被称为@dfn{原子}。这个术语来自于“原子”一词的历史含义，即“不可分割”。就Lisp而言，我们在列表中使用的单词不能再分割成更小的部分，仍然具有与程序的某个部分相同的含义；数字和单字符符号（如@samp{+}）也是如此。然而，与古代的原子不同，列表可以被分割成部分。 (@xref{car cdr & cons,
, @code{car} @code{cdr} & @code{cons} Fundamental Functions}.)

在列表中，原子之间由空格分隔。它们可以紧邻括号。

@cindex @samp{empty list} defined
从技术上讲，Lisp中的列表由括号括起，括号内部包含由空格分隔的原子，或者括号内部包含其他列表，或者同时包含原子和其他列表。一个列表可以只包含一个原子，也可以什么都不包含。一个什么都不包含的列表看起来像这样：@code{()}，称为@dfn{空列表}。与其他东西不同，空列表既是原子又是列表。

@cindex Symbolic expressions, introduced
@cindex @samp{表达式} defined
@cindex @samp{形式} defined
原子和列表的打印表示被称为@dfn{符号表达式}，或更简洁地称为@dfn{s-表达式}。单词@dfn{表达式}本身可以指的是打印表示，也可以指的是计算机内部保存的原子或列表。通常，人们会不加区分地使用@dfn{表达式}一词。 (此外，许多文本中，@dfn{形式}也被用作表达式的同义词。)

@c This and the next paragraph say ``kinds of atom'', but that is not
@c a typo, just slightly ``old-fashioned wording which adds a fillip
@c of interest to it'', and ``is more elegant writing'', according to
@c RMS.
顺便提一下，构成我们宇宙的原子最初被认为是不可分割的。但后来发现，原子并非不可分割。原子可以分裂成两个大致相等的部分，或者可以有部分组成从原子中分离出来。也就是说，原子在其真正性质被发现之前就被过早地命名了。在Lisp中，某些类型的原子，例如数组，也可以被分割成部分，但这种分割数组的机制与分割列表的机制不同。就列表操作而言，列表的原子是不可分割的。

与汉语词语的含义不同于单个汉字的含义一样,Lisp语言中的原子也不等同于组成它的字母。例如，熊猫，与"熊" 和 "猫"完全不同。

自然界中有许多种类的原子，而在Lisp中只有少数几种：例如，@dfn{数字}，比如37、511或1729，以及@dfn{符号}，比如@samp{+}、@samp{foo}或@samp{forward-line}。我们在上面的示例中列出的单词都是符号。在日常的Lisp对话中，“原子”这个术语很少被直接使用，因为程序员通常会尽量明确他们正在处理哪一类型的原子。Lisp编程主要涉及列表中符号的处理（有时还涉及数字）。(顺便一提，前文中的括号注释也是一个合法的Lisp列表，因为它由原子组成，这些原子是符号，被空格分隔并用括号括起，没有任何非Lisp符号。)

@need 1250
用双引号括起的文本，即使是句子或段落，也会被视为一个原子。下面是一个例子：
@cindex Text between double quotation marks

@smallexample
'(this list includes "text between quotation marks.")
@end smallexample

@cindex @samp{string} defined
@noindent
在Lisp中，所有引号括起的内容，包括标点符号和空格，都会被视为一个单独的原子。这种类型的原子被称为@dfn{字符串}(string)，通常用于让计算机打印出人类可读的消息。字符串与数字或符号不同，使用方式也有区别。

@node Whitespace in Lists
@subsection 列表中的空格
@cindex Whitespace in lists

@need 1200
在Lisp语言中，表中的空格数量并不重要。从Lisp的角度看，

@smallexample
@group
'(this list
   looks like this)
@end group
@end smallexample

@need 800
@noindent
与这个表达式完全等价：

@smallexample
'(this list looks like this)
@end smallexample

这两个例子展示了在Lisp中相同的一个列表，它由这些符号 @samp{this}、@samp{list}、@samp{looks}、@samp{like} 和 @samp{this} 按顺序组成。

额外的空格和换行只是为了让人更容易阅读列表。当Lisp读取表达式时，会忽略额外的空格（但原子之间至少需要一个空格来区分）。

尽管看起来很奇怪，但我们已经涵盖了Lisp中几乎所有列表的情况！Lisp中的其他列表都或多或少与这些例子相似，只是列表可能更长更复杂。简而言之，列表在括号内，字符串在引号内，符号看起来像单词，数字看起来像数字。（对于某些情况，可能会使用方括号、点号等一些特殊字符；但即使没有它们，我们也已经可以处理很多情况了。）

@node Typing Lists
@subsection GNU Emacs帮助您输入列表
@cindex Help typing lists
@cindex Formatting help

在GNU Emacs中，当您在Lisp交互模式或Lisp模式下输入Lisp表达式时，可以使用一些命令来格式化Lisp表达式，以提高代码的可读性。例如，按下@key{TAB}键会自动合理缩进当前行。通常，用于正确缩进区域中的代码的快捷键绑定为@kbd{M-C-\}。代码缩进可以让您清楚地看出哪些元素属于某个列表---子列表的元素缩进会比包含它的列表更深。

此外，当您键入右括号时，Emacs会短暂地将光标跳回到对应的左括号，这样您可以看到右括号与哪个左括号匹配。这非常有用，因为在Lisp中，您写的每个列表都必须有对应的右括号和左括号。（有关Emacs模式的更多信息，@xref{Major Modes, , Major Modes, emacs, The GNU Emacs Manual}）

@node Run a Program
@section 运行程序
@cindex Run a program
@cindex Program, running one

@cindex @samp{evaluate} defined
在Lisp中，任何列表本身都可以作为一个准备执行的程序。如果对列表进行求值（在Lisp术语中称为@dfn{评估}(evaluate, eval)），计算机会执行以下三种操作之一：直接返回列表本身且不做任何处理；显示错误信息；或者将列表中的第一个符号视为命令并执行相应操作。 （当然，通常您期望的是最后一种情况！）

@c 用代码表示单引号，而不是samp。
@findex quote
@cindex @code{'} for quoting
@cindex quoting using apostrophe
@cindex apostrophe for quoting
在前面章节的示例中，我在某些列表之前使用的@code{'}，称为@dfn{单引号}；它的作用是告诉Lisp直接原样输出这个列表，不做任何处理。但是，如果列表前没有单引号，那么列表中的第一个元素就具有特殊意义：它是计算机要执行的命令。 （在Lisp中，这些命令被称为@emph{函数}。）上例中的@code{(+ 2 2)}列表没有单引号，因此Lisp会将@code{+}视为指示对后面的数字进行相加运算的命令。

@need 1250
如果您在GNU Emacs中的Info模式下阅读此文档，可以通过以下步骤来执行Lisp表达式的计算：将光标置于以下列表的右括号之后，键入@kbd{C-x C-e}：

@smallexample
(+ 2 2)
@end smallexample

@c 这里使用代码格式表示数字四，而不是samp。
@noindent
您将在回显区域看到数字@code{4}@footnote{Emacs以十进制、八进制和十六进制以及字符的方式显示整数值，但现在让我们忽略这个便利功能。}。 （您刚刚对该列表进行了评估。回显区域位于屏幕底部区域，或是输出文本信息。）现在尝试对一个带引号的列表执行相同的操作：将光标放在下例列表的右括号后，键入@kbd{C-x C-e}：

@smallexample
'(this is a quoted list)
@end smallexample

@noindent
您将在回显区域看到 @code{(this is a quoted list)}。

@cindex Lisp interpreter, explained
@cindex Interpreter, Lisp, explained
在上述两种情况下，您所做的是向GNU Emacs内部的一个叫做@dfn{Lisp解释器}的程序发送一个命令，即给解释器一个要评估的表达式。Lisp解释器(interpreter)得名于它解释表达式含义的功能,就像一个人在解释一样。

您也可以评估一个不是列表的原子，即一个没有被括号包围的原子；同样，Lisp解释器会将这种人类可读的表达式翻译成计算机语言。但在讨论这个之前（@pxref{Variables}），我们先来看当出现错误时Lisp解释器会做什么。

@node Making Errors
@section 生成错误信息
@cindex Generate an error message
@cindex Error message generation

部分原因是,如果您不小心出错了,也不用担心，我们现在将向 Lisp 解释器发出一个命令，让它生成一条错误信息。 这是一项无害的尝试； 事实上，我们经常会尝试故意生成错误信息。 一旦您理解了相关术语，错误信息就可以提供丰富的信息帮助。 它们不应该被称为“错误”信息，而更应该被称为“帮助”信息。 它们就像异国游客遇到的路标； 解读这些信息可能很困难，但一旦理解其含义，它们就能指明道路。

错误信息是由GNU Emacs内置的调试器生成的。我们将进入调试器环境。您可以通过键入 @code{q} 来退出调试器。

我们要做的是对一个没有加单引号且第一个元素不是有效命令的列表进行评估。这个列表和我们之前用过的类似,只是没有加上单引号。将光标定位到该列表的后面，然后输入 @kbd{C-x C-e}：

@smallexample
(this is an unquoted list)
@end smallexample

这将打开一个 @file{*Backtrace*} 的窗口，您应该在其中看到以下内容：

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function this)
  (this is an unquoted list)
  eval((this is an unquoted list) nil)
  elisp--eval-last-sexp(nil)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@need 1200
@noindent
此时光标会定位在这个窗口中（可能需要等待几秒才显示出来）。要退出调试器并关闭调试器窗口，请输入：

@smallexample
q
@end smallexample

@noindent
请现在按下 @kbd{q}键，以确保您能退出调试器。然后再次输入 @kbd{C-x C-e} 重新进入调试器。

@cindex @samp{函数} defined
根据我们已经了解的知识，我们基本可以解析这个错误信息的含义。

从下往上查看 @file{*Backtrace*} 缓冲区的内容；它记录了Emacs执行的步骤。当您输入 @kbd{C-x C-e} 时，向命令 @code{eval-last-sexp} 发起了交互调用。@code{eval} 是“evaluate（评估）”的缩写，@code{sexp} 是“symbolic expression（符号表达式）”的缩写。该命令的含义是“评估最后一个符号表达式”，也就是光标前的那个表达式。

以上每一行都在告诉我们Lisp解释器接下来评估的内容。最新的操作在顶部。这个缓冲区被称为 @file{*Backtrace*} ，因为它允许我们回溯Emacs的执行步骤。

@need 800
在 @file{*Backtrace*} 缓冲区的顶部，您可以看到这样一行：

@smallexample
Debugger entered--Lisp error: (void-function this)
@end smallexample

@noindent
Lisp 解释器试图对列表的第一个原子 @samp{this} 进行评估。正是这个操作产生了错误信息 @samp{void-function this}。

这个信息包含了 @samp{void-function} 和 @samp{this} 两个词。

@cindex @samp{函数} defined
@samp{函数} (function)这个词之前提到过一次。这是一个非常重要的概念。对我们而言，可以定义简单理解为一组指令，用于告诉计算机要执行什么操作。

现在我们可以开始解析这个错误信息@samp{void-function this}的含义了。这个函数（也就是，@samp{this}这个词）没有关联任何一组指令来告诉计算机要执行什么操作。

这个比较奇怪的词@samp{void-function}是为了反映Emacs Lisp的实现方式，也就是说，当一个符号没有绑定函数定义时，原本要包含执行指令的位置是空的。

另一方面，由于我们可以成功对2和2进行相加（通过评估 @code{(+ 2 2)}），我们可以推断符号 @code{+} 一定有一组与之关联的指令，这些指令会指示计算机将紧随其后的数字相加。

在这种情况下，可以避免Emacs进入调试器。我们暂不解释如何实现，但会提及结果的样子，因为当您在使用某段Emacs代码遇到类似情况时，也可能看到类似的效果。在这种情况下，您只会看到一行错误信息；它会出现在回显区，看起来像这样：

@smallexample
Symbol's function definition is void:@: this
@end smallexample

@noindent
@ignore
(Also, your terminal may beep at you---some do, some don't; and others
blink.  This is just a device to get your attention.)
@end ignore
当你输入任何键，哪怕只是移动一下光标，这个消息就会消失。

我们知道@samp{Symbol}这个词的含义。它指代的是列表中的第一个原子，也就是词@samp{this}。@samp{function}一词表示用于告知计算机要执行什么操作的指令。（技术上来说，这个符号会告知计算机在何处可以找到这些指令，但这个复杂问题我们暂时可以忽略。）

所以错误信息可以这样理解：@samp{Symbol's function definition is void:@: this}。这个符号(Symbol)（也就是词@samp{this}）缺少可供计算机执行的指令。

@node Names & Definitions
@section 符号名称和函数定义
@cindex Symbol names

根据目前我们的讨论,我们可以归纳出Lisp的另一关键特性：像 @code{+} 这样的符号本身并不是计算机可执行的一组指令。相反，这些符号仅用于暂时定位相关的定义或指令集。我们看到的只是通过该符号名称才能找到实际指令的方式。人的名字也是一样的。我可以被称为 @samp{Bob}；然而，我不是字母 @samp{B}、@samp{o}、@samp{b} 的组合，而是（或者曾是）一个与特定生命形式长期关联的意识。名字并不是我，但可以用来指称我。

在 Lisp 中，一组指令可以被关联到多个名字上。例如，加法运算的计算机指令可以关联到符号 @code{plus}，也可以关联到符号 @code{+}上（在某些 Lisp 方言中是这样的）。对于人名，我可以被称为 @samp{Robert}，也可以被称为 @samp{Bob}，以及其他词汇。

但是，一个符号一次只能有一个函数定义与之关联。否则，计算机就会困惑应该使用哪个定义。如果这种情况发生在人类身上，世界上也只能有一个人被命名为 @samp{Bob}。然而，符号所代表的函数定义可以很容易地被更改。(@xref{安装, , 安装函数定义}.)

由于 Emacs Lisp 非常庞大，通常会以能够指明函数属于Emacs的哪个部分的方式来命名符号。因此，所有涉及 Texinfo 处理的函数名都以 @samp{texinfo-} 开头，而处理邮件读取的函数则以 @samp{rmail-} 开头。

@node Lisp Interpreter
@section Lisp解释器
@cindex Lisp interpreter, what it does
@cindex Interpreter, what it does

基于我们所见，现在我们可以开始弄清楚当命令Lisp解释器评估列表时它会做什么。首先，它会查看列表前是否有引号；如果有，解释器会直接返回这个列表。另一方面，如果没有引号，解释器会查看列表中的第一个元素，检查它是否有一个函数定义与之关联。如果有，解释器就会执行该函数定义中的指令。否则，解释器会打印错误信息。

这就是Lisp的工作原理。简单明了。当然，还有一些额外的复杂性，我们后面会提到，但这些是基础。想要编写Lisp程序，您还需要了解如何编写函数定义并将其关联到函数名上，以及如何在不使自己和计算机产生困惑的情况下实现这一点。

@menu
* Complications::               变量、特殊形式、内部列表。
* Byte Compiling::              为加速对代码特殊处理。
@end menu

@ifnottex
@node Complications
@unnumberedsubsec 复杂情况
@end ifnottex

现在，我们来看第一个复杂情况。除了列表，Lisp 解释器还可以对没有引号且没有被括号包围的单个符号进行评估。在这种情况下，Lisp 解释器会试图确定该符号作为@dfn{变量}的值。这种情况我们会在变量部分进行描述。(@xref{Variables}.)

@cindex Special form
第二个复杂情况是，有一些函数的工作方式与常规函数不同，那些不同寻常的函数被称为@dfn{特殊形式}。它们用于处理特定任务，比如定义函数，而且数量并不多。在后续章节中，您会了解到一些更重要的特殊形式。

除特殊形式外，还有@dfn{宏}。宏是Lisp中定义的一种构造，不同于函数的地方在于，它会将一个Lisp表达式转换成另一个要代替原始表达式进行评估的表达式。(@xref{Lisp macro}。)

就本书而言，您无需过于担心某个东西是特殊形式、宏还是普通函数。例如，@code{if} 是一个特殊形式（@pxref{if}），而@code{when} 是一个宏（@pxref{Lisp macro}）。在Emacs的早期版本中，@code{defun} 是一个特殊形式，但现在它是一个宏（@pxref{defun}），不过它的用法没有改变。

最后一个复杂情况是：如果Lisp解释器正在处理的函数不是特殊形式，并且它是列表的一部分，Lisp解释器会检查这个列表是否包含内部列表。如果存在内部列表，Lisp解释器先确定应该如何处理内部列表，然后再处理外部列表。如果内部列表中还嵌套了另一个列表，它还会先处理那个列表，以此类推。解释器总是先处理最内层的列表。它会首先对最内层列表进行评估，得到结果用于外层表达式。

否则，解释器会从左到右顺序处理表达式，每个表达式依次处理。

@node Byte Compiling
@subsection 字节编译
@cindex Byte compiling

Lisp解释器可以处理两种实体：人类可读的代码，这会是我们的重点；以及经过特殊处理的代码，称为 @dfn{字节编译}的代码，后者不是人类可读的。字节编译的代码的运行速度比人类可读的代码要快。

您可以通过运行像 @code{byte-compile-file} 这样的编译命令，将人类可读的代码转换为字节编译的代码。字节编译后的代码通常保存在以 @file{.elc} 为扩展名的文件中，而不是 @file{.el}。在 @file{emacs/lisp} 目录下您会看到这两种类型的文件；需要阅读的是那些 @file{.el} 扩展名的文件。

实际上，对于大多数自定义和扩展Emacs的需要，您不一定要进行字节编译；我在这里也不会详细讨论这个话题。要获取字节编译的完整描述，@xref{Byte Compilation, , Byte Compilation, elisp, The GNU Emacs Lisp Reference Manual}。

@node Evaluation
@section 评估
@cindex Evaluation

当Lisp解释器对表达式进行处理时，这个活动被称为 @dfn{评估}。我们说解释器 "评估表达式"。我之前已经多次使用过这个术语。这个词来源于日常语言中的 "确定价值或数量"，根据 @cite{Webster's New Collegiate Dictionary} 的定义。

@menu
* How the Interpreter Acts::    返回值和副作用...
* Evaluating Inner Lists::      列表内部的列表...
@end menu

@ifnottex
@node How the Interpreter Acts
@unnumberedsubsec Lisp 解释器的行为方式
@end ifnottex

@cindex @samp{returned value} explained
在对表达式评估后，Lisp 解释器很可能会@dfn{返回}计算机通过执行函数定义中的指令得到的值，或者它可能放弃对该函数的处理并生成错误消息。（也可能出现解释器被抛入另一个函数的执行,或者陷入无限循环的情况,但这些比较少见,我们可以忽略。）最常见的情况是，解释器返回一个值。

@cindex @samp{side effect} defined
与此同时，解释器还可能执行其他操作，如移动光标或复制文件；这类被称为@dfn{副作用}。我们人类认为重要的操作，比如打印结果，通常是 Lisp 解释器的副作用。学习使用副作用相对比较简单。

综上所述，对符号表达式评估通常会导致 Lisp 解释器返回一个值，并可能产生副作用；否则就会产生错误信息。

@node Evaluating Inner Lists
@subsection 评估内部列表
@cindex Inner list evaluation
@cindex Evaluating inner lists

如果对嵌套在另一个列表中的内部列表进行评估，外部列表在评估时可能会使用内层列表的评估结果作为信息。这解释了为什么要首先对内部表达式进行评估：它们的返回值会被外部表达式使用。

@need 1250
我们可以通过对另一个加法示例进行评估来调查这个过程。将光标置于以下表达式之后，键入@kbd{C-x C-e}：

@smallexample
(+ 2 (+ 3 3))
@end smallexample

@noindent
数字8将会出现在回显区域。

过程是这样的，Lisp解释器首先对内部表达式@code{(+ 3 3)}进行评估，返回值是6；然后它对外部表达式评估，就像表达式写成@code{(+ 2 6)}一样，返回值是8。由于没有更多外层表达式需要评估，解释器将这个值打印在回显区域。

现在很容易理解@kbd{C-x C-e}这个快捷键所调用命令的名称 @code{eval-last-sexp}。@code{sexp}是“symbolic expression”（符号表达式）的缩写，而@code{eval}是“evaluate”（评估）的缩写。该命令对最后一个符号表达式进行评估。

作为实验，您可以尝试通过将光标放在表达式后面紧跟的下一行行首，或者放在表达式内部来评估该表达式。

@need 800
下面是表达式的另一份副本：

@smallexample
(+ 2 (+ 3 3))
@end smallexample

@noindent
如果将光标放在紧随表达式后面的空白行行首，然后键入 @kbd{C-x C-e}，您仍然会在回显区域中看到打印的值8。现在试着将光标放在表达式内部。如果将光标放在倒数第二个括号后（使它看起来位于最后一个括号上方），您会在回显区域看到打印的值6！这是因为该命令评估了表达式 @code{(+ 3 3)}。

现在将光标放在一个数字后面。键入 @kbd{C-x C-e}，您会得到那个数字本身。在Lisp中，对一个数字评估会直接返回这个数字本身——这是数字与符号的区别。如果对以像 @code{+} 这样的符号开头的列表评估，您会得到一个返回值，该返回值是计算机执行附加在该符号上的函数定义中的指令所得到的结果。如果单独对一个符号评估，会发生一些不同的事情，我们将在下一节看到。

@node Variables
@section 变量
@cindex Variables

在 Emacs Lisp 中，一个符号可以附加一个值，就像它可以附加一个函数定义一样。这两者是不同的。函数定义是计算机将执行的一组指令。值，另一方面，是一些可以变化的东西，比如一个数字或一个名称（这就是为什么这样的符号被称为变量的原因）。一个符号的值可以是Lisp中的任何表达式，比如一个符号、数字、列表或字符串。一个具有值的符号通常被称为@dfn{变量}。

一个符号可以同时有一个函数定义和一个值。或者它可以只有其中之一。这两者是独立的。这与剑桥这个名称既可以指代马萨诸塞州的城市，又可以附带一些信息，比如“伟大的编程中心”，有些相似。

@ignore
（顺便说一下，在Emacs Lisp中，一个符号还可以附加两个其他东西：属性列表和文档字符串；这些稍后会讨论。）
@end ignore

另一种思考这个问题的方式是将一个符号想象成一个抽屉柜。函数定义放在一个抽屉里，值放在另一个抽屉里，依此类推。在值的抽屉里放置的东西可以更改，而不影响放置函数定义的抽屉的内容，反之亦然。

@menu
* fill-column Example::
* Void Function::               一个没有函数的符号的错误消息。
* Void Variable::               一个没有值的符号的错误消息。
@end menu

@ifnottex
@node fill-column Example
@unnumberedsubsec @code{fill-column}，一个示例变量
@end ifnottex

@findex fill-column@r{，一个示例变量}
@cindex 示例变量，@code{fill-column}
@cindex 变量，示例，@code{fill-column}
变量 @code{fill-column} 说明了一个带有值的符号：在每个 GNU Emacs 缓冲区中，该符号被设置为某个值，通常是 72 或 70，但有时也可能是其他值。要找到此符号的值，请通过单独评估它来执行。如果您在 GNU Emacs 中的 Info 中阅读此信息，可以将光标放在符号后面，然后键入 @kbd{C-x C-e} 来执行：

@smallexample
fill-column
@end smallexample

@noindent
在我键入 @kbd{C-x C-e} 后，Emacs 在我的回显区打印了数字 72。这是我在编写此内容时为 @code{fill-column} 设置的值。在您的 Info 缓冲区中，这个值可能是不同的。请注意，变量返回的值与执行其指令的函数返回的值的打印方式完全相同。从 Lisp 解释器的角度来看，返回的值就是返回的值。一旦知道值是什么，它来自哪种表达式就不再重要。

一个符号可以附有任何值，或者用行话说，我们可以将变量@dfn{绑定}到一个值上：可以是一个数字，比如 72；可以是一个字符串，比如 @code{"如此"}；可以是一个列表，比如 @code{(云杉 松树 橡树)}；我们甚至可以将变量绑定到一个函数定义上。

一个符号可以以多种方式绑定到一个值。有关如何执行此操作的信息，请参阅@xref{set & setq, , Setting the Value of a Variable}。

@node Void Function
@subsection 没有函数的符号的错误消息
@cindex 没有函数的符号错误
@cindex 没有函数的符号错误消息

当我们评估变量 @code{fill-column} 以获取其值时，我们没有在单词周围加括号。这是因为我们没有打算将其用作函数名称。

如果 @code{fill-column} 是列表的第一个或唯一元素，Lisp 解释器将尝试找到与之关联的函数定义。但是 @code{fill-column} 没有函数定义。尝试评估以下内容：

@smallexample
(fill-column)
@end smallexample

@need 1250
@noindent
将会创建一个 @file{*Backtrace*} 缓冲区，其中显示：

@smallexample
@group
---------- 缓冲区：*Backtrace* ----------
Debugger entered--Lisp error: (void-function fill-column)
  (fill-column)
  eval((fill-column) nil)
  elisp--eval-last-sexp(nil)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
---------- 缓冲区：*Backtrace* ----------
@end group
@end smallexample

@noindent
（记住，要退出调试器并关闭调试器窗口，请在 @file{*Backtrace*} 缓冲区中键入 @kbd{q}。）

@node Void Variable
@subsection 没有值的符号的错误消息
@cindex 没有值的符号错误
@cindex 没有值的符号错误消息

如果你尝试评估一个没有绑定值的符号，你将收到一个错误消息。你可以通过尝试我们的2加2的加法来看到这一点。在下面的表达式中，将光标放在第一个数字2之前的@code{+}右边，然后输入@kbd{C-x C-e}：

@smallexample
(+ 2 2)
@end smallexample

@need 1500
@noindent
在GNU Emacs 22中，你将创建一个名为@file{*Backtrace*}的缓冲区，显示如下错误消息：

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-variable +)
  eval(+)
  elisp--eval-last-sexp(nil)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@noindent
（同样，你可以在@file{*Backtrace*}缓冲区中输入@kbd{q}来退出调试器。）

这个回溯与我们最初看到的第一个错误消息不同，它说的是@samp{Debugger entered--Lisp error: (void-function this)}。在这种情况下，该函数没有作为变量的值；而在其他错误消息中，函数（单词@samp{this}）没有定义。

在这个对@code{+}的实验中，我们的做法是导致Lisp解释器评估@code{+}并寻找变量的值，而不是函数的定义。我们通过将光标放在符号右边而不是在封闭列表的括号后面，使Lisp解释器执行了前一个S表达式，这种情况下是单独的@code{+}。

由于@code{+}没有绑定到任何值，只有函数定义，错误消息报告该符号作为变量的值为空。

@node 参数
@section 参数
@cindex 参数
@cindex 将信息传递给函数

为了了解信息是如何传递给函数的，让我们再次看看我们的老朋友，@code{2 + 2}。在Lisp中，它被写成如下形式：

@smallexample
(+ 2 2)
@end smallexample

如果你评估这个表达式，数字4将出现在你的回显区。Lisp解释器所做的是将跟随@code{+}的数字相加。

@cindex @samp{argument} 的定义
由@code{+}相加的数字被称为函数@code{+}的@dfn{参数}。这些数字是传递给函数的信息。

“参数”这个词来自数学中的用法，不是指两个人之间的辩论；而是指提供给函数的信息，在这种情况下，是提供给@code{+}的信息。在Lisp中，函数的参数是跟随函数的原子或列表。通过评估这些原子或列表的结果值传递给函数。不同的函数需要不同数量的参数；有些函数根本不需要参数。@footnote{追踪“参数”这个词如何在数学中和日常英语中拥有两个不同的含义是很有趣的。根据《牛津英语词典》的说法，这个词源于拉丁语，意思是“澄清，证明”；因此，它通过一条推导线的方式，来表示“作为证据提供的信息”，也就是说，“提供的信息”，这导致了它在Lisp中的含义。但在另一条推导线上，它的意思变成了“以一种其他人可以提出反对主张的方式断言”，这解释了这个词作为争论的含义。(注意这里英语单词同时拥有两个不同的定义。相比之下，在Emacs Lisp中，一个符号在同一时间不能拥有两个不同的函数定义。)}

@menu
* 数据类型::                  传递给函数的数据类型。
* 将参数作为变量或列表::    参数可以是变量或列表的值。
* 可变数量的参数::  一些函数可能接受可变数量的参数。
* 错误类型的参数::      将错误类型的参数传递给函数。
* message::                     用于发送消息的有用函数。
@end menu

@node 数据类型
@subsection 参数的数据类型
@cindex 数据类型
@cindex 数据的类型
@cindex 参数的数据类型

应传递给函数的数据类型取决于它使用的信息的种类。例如，像@code{+}这样的函数的参数必须是数字，因为@code{+}是对数字进行加法运算的。其他函数使用不同类型的数据作为它们的参数。

@need 1250
@findex concat
例如，@code{concat}函数将两个或多个文本字符串连接或合并成一个字符串。其参数是字符串。连接两个字符字符串@code{abc}和@code{def}将产生单个字符串@code{abcdef}。通过评估以下表达式可以看到这一点：

@smallexample
(concat "abc" "def")
@end smallexample

@noindent
评估这个表达式产生的值是@code{"abcdef"}。

@cindex substring
像@code{substring}这样的函数使用字符串和数字作为参数。该函数返回字符串的一部分，即第一个参数的@dfn{子字符串}。该函数接受三个参数。其第一个参数是字符字符串，第二个和第三个参数是指示子字符串的开始（包括）和结束（不包括）的数字。这些数字表示从字符串开头开始的字符数（包括空格和标点符号）。注意字符串中的字符是从零开始编号的，而不是从一开始。

@need 800
例如，如果你评估以下表达式：

@smallexample
(substring "The quick brown fox jumped." 16 19)
@end smallexample

@noindent
你将在回显区看到@code{"fox"}。这些参数分别是字符串和两个数字。

请注意，传递给@code{substring}的字符串是一个单一的原子，即使它由多个用空格分隔的单词组成。Lisp将引号之间的所有内容都计为字符串的一部分，包括空格。你可以将@code{substring}函数看作是一种原子粒子解体器，因为它从一个否则不可分割的原子中提取了一部分。但是，@code{substring}只能从参数是字符串的原子中提取子字符串，而不能从其他类型的原子（如数字或符号）中提取。

@node 将参数作为变量或列表
@subsection 参数作为变量或列表的值

参数可以是一个符号，在评估时返回一个值。例如，当单独评估符号@code{fill-column}时，它会返回一个数字。这个数字可以在加法中使用。

@need 1250
将光标定位到以下表达式后，键入@kbd{C-x C-e}：

@smallexample
(+ 2 fill-column)
@end smallexample

@noindent
该值将是比仅评估@code{fill-column}得到的数字多两个。对我来说，这是74，因为我的@code{fill-column}值是72。

正如我们刚刚看到的，参数可以是在评估时返回值的符号。此外，参数还可以是在评估时返回值的列表。例如，在以下表达式中，函数@code{concat}的参数是字符串@w{@code{"The "}}和@w{@code{" red foxes."}}，以及列表@code{(number-to-string (+ 2 fill-column))}。

@smallexample
(concat "The " (number-to-string (+ 2 fill-column)) " red foxes.")
@end smallexample

@noindent
如果你评估这个表达式——如果像我的Emacs一样，@code{fill-column}评估为72——@code{"The 74 red foxes."}将出现在回显区。 (注意，你必须在单词@samp{The}后面和单词@samp{red}前面加上空格，这样它们才会出现在最终的字符串中。函数@code{number-to-string}将加法函数返回的整数转换为字符串。@code{number-to-string}也被称为@code{int-to-string}。)

@node 可变数量的参数
@subsection 可变数量的参数
@cindex 可变数量的参数
@cindex 参数，可变数量的

一些函数，如@code{concat}，@code{+}或@code{*}，可以接受任意数量的参数。（@code{*}是乘法的符号。）这可以通过以通常的方式评估以下每个表达式来看到。在回显区域中看到的内容在此文本中以@samp{@result{}}打印出来，你可以将其理解为“求值为”。

@need 1250
在第一组中，函数没有参数：

@smallexample
@group
(+)       @result{} 0

(*)       @result{} 1
@end group
@end smallexample

@need 1250
在这一组中，函数每个都有一个参数：

@smallexample
@group
(+ 3)     @result{} 3

(* 3)     @result{} 3
@end group
@end smallexample

@need 1250
在这一组中，函数每个都有三个参数：

@smallexample
@group
(+ 3 4 5) @result{} 12

(* 3 4 5) @result{} 60
@end group
@end smallexample

@node 错误类型的参数
@subsection 使用错误类型的对象作为参数
@cindex 错误类型的参数
@cindex 参数，错误类型的

当一个函数被传递一个错误类型的参数时，Lisp解释器会产生一个错误消息。例如，@code{+}函数期望其参数的值为数字。作为实验，我们可以传递给它带引号的符号@code{hello}，而不是一个数字。将光标放在以下表达式后，然后输入@kbd{C-x C-e}：

@smallexample
(+ 2 'hello)
@end smallexample

@noindent
当你这样做时，将生成一个错误消息。发生的情况是，@code{+}试图将2添加到@code{'hello}返回的值，但@code{'hello}返回的值是符号@code{hello}，而不是一个数字。只有数字可以相加。所以@code{+}无法执行其加法运算。

@need 1250
你将创建并进入一个@file{*Backtrace*}缓冲区，其中显示：

@noindent
@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error:
         (wrong-type-argument number-or-marker-p hello)
  +(2 hello)
  eval((+ 2 'hello) nil)
  elisp--eval-last-sexp(t)
  eval-last-sexp(nil)
  funcall-interactively(eval-print-last-sexp nil)
  call-interactively(eval-print-last-sexp nil nil)
  command-execute(eval-print-last-sexp)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@need 1250
和往常一样，错误消息试图提供帮助，并在学会如何阅读后变得有意义。@footnote{@code{(quote hello)}是@code{'hello}缩写的扩展。}

错误消息的第一部分很简单，它说@samp{wrong type argument}。接下来是神秘的行话词@samp{number-or-marker-p}。这个词试图告诉你@code{+}期望的参数类型。

符号@code{number-or-marker-p}表示Lisp解释器正在尝试确定所呈现的信息（参数的值）是一个数字还是一个标记（表示缓冲区位置的特殊对象）。它的操作是测试@code{+}是否被赋予要相加的数字。它还测试参数是否是一种称为标记的东西，这是Emacs Lisp的一个特定特性。（在Emacs中，缓冲区中的位置被记录为标记。当使用@kbd{C-@@}或@kbd{C-@key{SPC}}命令设置标记时，其位置被保留为标记。标记可以被视为一个数字---表示该位置距离缓冲区开头的字符数。在Emacs Lisp中，@code{+}可以用于将标记位置的数值作为数字相加。

@cindex @samp{predicate} 的定义
@code{number-or-marker-p}中的@samp{p}体现了Lisp编程早期实践的一种做法。@samp{p}代表@dfn{谓词}。在早期Lisp研究者使用的行话中，谓词是指一个函数，用于确定某个属性是否为真或为假。因此，@samp{p}告诉我们@code{number-or-marker-p}是一个函数的名称，该函数确定所提供的参数是否为数字或标记。其他以@samp{p}结尾的Lisp符号包括@code{zerop}，一个测试其参数是否为零值的函数，以及@code{listp}，一个测试其参数是否为列表的函数。

最后，错误消息的最后部分是符号@code{hello}。这是传递给@code{+}的参数的值。如果相加操作传递了正确类型的对象，传递的值将是一个数字，如37，而不是像@code{hello}这样的符号。但那样你就不会收到错误消息。

@node message
@subsection @code{message} 函数
@findex message

类似于@code{+}函数，@code{message}函数接受可变数量的参数。它用于向用户发送消息，非常实用，我们将在这里描述它。

@need 1250
消息将被打印在回显区。例如，通过评估以下列表，您可以在回显区中打印一条消息：

@smallexample
(message "This message appears in the echo area!")
@end smallexample

双引号之间的整个字符串是一个单一的参数，并被整体打印出来。（请注意，在这个例子中，消息本身将在回显区中用双引号括起来；这是因为您看到了@code{message}函数返回的值。在您编写的程序中，@code{message}的大多数用法将作为副作用将文本在回显区中打印出来，而不带引号。@xref{multiply-by-seven in detail, , @code{multiply-by-seven} in
detail}，了解其中的一个示例。）

然而，如果在带引号的字符字符串中有一个@samp{%s}，@code{message}函数不会像这样打印@samp{%s}，而是查看跟随字符串的参数。它评估第二个参数，并在字符串中@samp{%s}的位置打印该值。

@need 1250
您可以通过将光标定位在以下表达式之后，然后键入@kbd{C-x C-e}来查看这一点：

@smallexample
(message "The name of this buffer is: %s." (buffer-name))
@end smallexample

@noindent
在Info中，@code{"The name of this buffer is: *info*."} 将出现在回显区。函数 @code{buffer-name} 返回缓冲区的名称作为字符串，@code{message} 函数将其插入到 @code{%s} 的位置。

要将值以整数形式打印，可以使用 @samp{%d}，与 @samp{%s} 的使用方式相同。例如，要在回显区中打印一条消息，指出 @code{fill-column} 的值，请评估以下内容：

@smallexample
(message "The value of fill-column is %d." fill-column)
@end smallexample

@noindent
在我的系统上，当我评估这个列表时，@code{"The value of fill-column is 72."} 将出现在我的回显区@footnote{实际上，你可以使用 @code{%s} 打印一个数字。它是非具体的。@code{%d} 只打印小数点左边的数字部分，而不包括任何非数字内容。}。

如果在引用的字符串中有多个 @samp{%s}，则在第一个 @samp{%s} 的位置打印跟在引用字符串后的第一个参数的值，并在第二个 @samp{%s} 的位置打印第二个参数的值，依此类推。

@need 1250
例如，如果你评估以下内容，

@smallexample
@group
(message "There are %d %s in the office!"
         (- fill-column 14) "pink elephants")
@end group
@end smallexample

@noindent
你的回显区将显示一条相当奇特的消息。在我的系统上，它会显示，@code{"There are 58 pink elephants in the office!"}。

表达式@code{(- fill-column 14)}被评估，生成的数字插入到@samp{%d}的位置；双引号中的字符串@code{"pink elephants"}被视为单个参数，插入到@samp{%s}的位置。（也就是说，双引号之间的字符串评估为它本身，就像一个数字一样。）

最后，这里有一个稍微复杂的例子，不仅说明了一个数字的计算，而且还展示了如何在一个表达式中使用另一个表达式来生成替代@samp{%s}的文本：

@smallexample
@group
(message "He saw %d %s"
         (- fill-column 32)
         (concat "red "
                 (substring
                  "The quick brown foxes jumped." 16 21)
                 " leaping."))
@end group
@end smallexample

在这个例子中，@code{message}有三个参数：字符串@code{"He saw %d %s"}，表达式@code{(- fill-column 32)}，以及以@code{concat}函数开头的表达式。通过评估@code{(- fill-column 32)}生成的值插入到@samp{%d}的位置；以及通过评估以@code{concat}开头的表达式生成的值插入到@samp{%s}的位置。

当你的填充列为70时，评估这个表达式，消息@code{"He saw 38 red foxes leaping."}将出现在你的回显区。

@node set & setq
@section 设置变量的值
@cindex 变量，设置值
@cindex 设置变量的值

@cindex @samp{bind}定义
有几种方式可以给一个变量赋值。其中一种方式是使用函数@code{set}或特殊形式@code{setq}。另一种方式是使用@code{let}（@pxref{let}）。（这个过程的行话术语是将变量@dfn{bind}到一个值上。）

以下章节不仅描述了@code{set}和@code{setq}的工作方式，还说明了如何传递参数。

@menu
* 使用 set::                  设置值。
* 使用 setq::                 设置引用值。
* 计数::                      使用@code{setq}进行计数。
@end menu

@node 使用 set
@subsection 使用 @code{set}
@findex set

要将符号 @code{flowers} 的值设置为列表 @code{'(rose violet daisy buttercup)}，请通过将光标定位在表达式后并键入 @kbd{C-x C-e} 来评估以下表达式。

@smallexample
(set 'flowers '(rose violet daisy buttercup))
@end smallexample

@noindent
列表 @code{(rose violet daisy buttercup)} 将出现在回显区域。这是由 @code{set} 函数@emph{返回}的内容。作为副作用，符号 @code{flowers} 被绑定到该列表；也就是说，可以将符号 @code{flowers} 视为变量，然后将该列表赋给它作为值。（顺便说一下，这个过程说明了对于Lisp解释器来说，设置值是我们人类感兴趣的主要效果。这是因为如果Lisp函数没有出错，它必须返回一个值，但只有在设计为具有副作用时才会有副作用。）

在评估 @code{set} 表达式后，可以评估符号 @code{flowers}，它将返回刚刚设置的值。这是该符号。将光标放在其后，然后键入 @kbd{C-x C-e}。

@smallexample
flowers
@end smallexample

@noindent
当你评估 @code{flowers} 时，列表 @code{(rose violet daisy buttercup)} 将出现在回显区域。

顺便说一下，如果你评估 @code{'flowers}，在带引号的变量前面，你将在回显区域看到符号本身，即 @code{flowers}。这是带引号的符号，所以你可以试一下：

@smallexample
'flowers
@end smallexample

还要注意，当你使用 @code{set} 时，需要引用 @code{set} 的两个参数，除非你想要它们被评估。因为我们不想让任何一个参数被评估，所以变量 @code{flowers} 和列表 @code{(rose violet daisy buttercup)} 都被引用。（当你使用 @code{set} 而不引用其第一个参数时，第一个参数在执行任何其他操作之前被评估。如果你这样做而且 @code{flowers} 没有一个已经存在的值，你会得到一个错误消息，指明 @samp{Symbol's value as variable is void}；另一方面，如果在评估后 @code{flowers} 返回了一个值，@code{set} 将尝试设置返回的值。有些情况下这是函数正确的行为，但这样的情况很少见。）

@node 使用 setq
@subsection 使用 @code{setq}
@findex setq

实际上，几乎总是对@code{set}的第一个参数加引号。@code{set}和引用的第一个参数的组合是如此常见，以至于它有自己的名称：特殊形式@code{setq}。这个特殊形式与@code{set}几乎相同，只是第一个参数被@code{setq}自动引用，因此您不需要自己输入引号。此外，作为额外的便利，@code{setq}允许您在一个表达式中设置多个不同的变量为不同的值。

为了使用@code{setq}将变量@code{carnivores}的值设置为列表@code{'(lion tiger leopard)}，可以使用以下表达式：

@smallexample
(setq carnivores '(lion tiger leopard))
@end smallexample

@noindent
这与使用@code{set}完全相同，只是@code{setq}自动引用了第一个参数。（@code{setq}中的@samp{q}表示@code{quote}。）

@need 1250
使用@code{set}，表达式如下：

@smallexample
(set 'carnivores '(lion tiger leopard))
@end smallexample

此外，@code{setq}还可以用于为不同的变量分配不同的值。第一个参数绑定到第二个参数的值，第三个参数绑定到第四个参数的值，依此类推。例如，您可以使用以下表达式将树的列表分配给符号@code{trees}，将食草动物的列表分配给符号@code{herbivores}：

@smallexample
@group
(setq trees '(pine fir oak maple)
      herbivores '(gazelle antelope zebra))
@end group
@end smallexample

@noindent
（表达式同样可以在一行上，但它可能不适合一页；并且人们更容易阅读格式良好的列表。）

尽管我一直在使用术语“分配”，但还有一种理解@code{set}和@code{setq}运作方式的方式；即@code{set}和@code{setq}使符号@emph{指向}列表。这种思考方式非常常见，在接下来的章节中，我们将至少遇到一个其名称中包含“指针”的符号。之所以选择这个名称，是因为符号有一个值，具体来说是一个列表，与之相关联；或者，换句话说，该符号被设置为指向该列表。

@node 计数
@subsection 计数
@cindex 计数

以下是一个示例，展示了如何在计数器中使用@code{setq}。您可以使用这种方法来计算程序的某个部分重复的次数。首先将一个变量设置为零；然后在程序重复自身时每次将该数字加一。为此，您需要一个用作计数器的变量，以及两个表达式：一个初始的@code{setq}表达式，将计数器变量设置为零；和第二个@code{setq}表达式，在每次评估时递增计数器。

@smallexample
@group
(setq counter 0)                ; @r{我们称之为初始化器。}

(setq counter (+ counter 1))    ; @r{这是递增器。}

counter                         ; @r{这是计数器。}
@end group
@end smallexample

@noindent
（在@samp{;}之后的文本是注释。@xref{修改 defun, , 修改函数定义}。）

如果您评估这些表达式中的第一个，即初始化器@code{(setq counter 0)}，然后评估第三个表达式@code{counter}，数字@code{0}将显示在回显区域中。然后，如果您评估第二个表达式，即递增器@code{(setq counter (+ counter 1))}，计数器将获得值1。因此，如果您再次评估@code{counter}，数字@code{1}将显示在回显区域中。每次评估第二个表达式时，计数器的值将递增。

当您评估递增器@code{(setq counter (+ counter 1))}时，Lisp解释器首先评估最内层的列表；这是加法。为了评估此列表，它必须评估变量@code{counter}和数字@code{1}。当它评估变量@code{counter}时，它会得到它的当前值。它将这个值和数字@code{1}传递给@code{+}，将它们相加。然后，总和作为内部列表的值返回，并传递给@code{setq}，将变量@code{counter}设置为这个新值。因此，变量@code{counter}的值被更改。

@node 总结
@section 总结

学习 Lisp 就像攀登一座山，其中的第一部分是最陡峭的。你现在已经攀登过最困难的部分；随着你继续前进，剩下的部分会变得更容易。

@need 1000
总的来说，

@itemize @bullet

@item
Lisp 程序由表达式组成，这些表达式可以是列表或单个原子。

@item
列表由零个或多个原子或内部列表组成，它们之间由空格分隔，并用括号括起来。列表可以为空。

@item
原子可以是多字符符号，比如 @code{forward-paragraph}，也可以是单字符符号，比如 @code{+}，还可以是双引号之间的字符字符串或数字。

@item
数字在求值时等于其自身。

@item
双引号之间的字符串在求值时也等于其自身。

@item
当你对一个符号进行单独求值时，它的值会被返回。

@item
当你对一个列表进行求值时，Lisp 解释器首先查看列表中的第一个符号，然后查找与该符号绑定的函数定义。然后执行函数定义中的指令。

@item
单引号 @samp{'} 告诉 Lisp 解释器它应该按照写法返回后面的表达式，而不是像没有引号那样对其进行求值。

@item
参数是传递给函数的信息。函数的参数是通过求值列表的其余元素来计算的，其中函数是第一个元素。

@item
函数在求值时总是返回一个值（除非出现错误）；此外，它还可能执行一些是副作用的动作。在许多情况下，函数的主要目的是创建副作用。
@end itemize

@node 错误消息练习
@section 练习

一些简单的练习：

@itemize @bullet
@item
通过评估一个适当的不在括号内的符号生成一个错误消息。

@item
通过评估一个适当的在括号之间的符号生成一个错误消息。

@item
创建一个计数器，其增量为两而不是一。

@item
编写一个在评估时在回显区域打印消息的表达式。
@end itemize

@node 练习评估
@chapter 练习评估
@cindex 练习评估
@cindex 评估练习

在学习如何在Emacs Lisp中编写函数定义之前，花一点时间评估已经编写的各种表达式是很有用的。这些表达式将是具有函数作为它们的第一个（通常是唯一的）元素的列表。由于与缓冲区相关的一些函数既简单又有趣，我们将从这些函数开始。在本节中，我们将评估其中的一些。在另一节中，我们将研究其他几个与缓冲区相关的函数的代码，以了解它们是如何编写的。

@menu
* 如何进行评估::            键入编辑命令或 @kbd{C-x C-e} 会导致评估。
* 缓冲区名称::               缓冲区和文件是不同的。
* 获取缓冲区::               获取缓冲区本身，而不仅仅是它的名称。
* 切换缓冲区::               如何切换到另一个缓冲区。
* 缓冲区大小与位置::         point 的位置以及缓冲区的大小。
* 评估练习::
@end menu

@ifnottex
@node 如何进行评估
@unnumberedsec 如何进行评估
@end ifnottex

@i{每当你向Emacs Lisp发送一个编辑命令}，比如移动光标或滚动屏幕时，@i{你都在评估一个表达式，}其第一个元素是一个函数。@i{这就是Emacs的工作原理。}

@cindex @samp{交互函数}定义
@cindex @samp{命令}定义
当你键入键位时，你会导致Lisp解释器评估一个表达式，这就是你获得结果的方式。甚至键入纯文本也涉及评估一个Emacs Lisp函数，这种情况下，使用的是@code{self-insert-command}，它简单地插入你键入的字符。通过键入按键而评估的函数称为@dfn{交互}函数或@dfn{命令}；如何使函数具有交互性将在编写函数定义的章节中说明。@xref{交互操作, , 使函数具有交互性}。

除了键入键盘命令，我们已经看到第二种评估表达式的方法：将光标定位在列表后面，然后键入@kbd{C-x C-e}。这是本节其余部分将要做的事情。还有其他评估表达式的方式；当我们遇到它们时会进行描述。

除了用于练习评估之外，下面几节中显示的函数在其自身方面也是重要的。研究这些函数清晰地展示了缓冲区和文件之间的区别，如何切换到一个缓冲区以及如何确定其中的位置。

@node 缓冲区名称
@section 缓冲区名称
@findex buffer-name
@findex buffer-file-name

两个函数，@code{buffer-name} 和 @code{buffer-file-name}，展示了文件和缓冲区之间的区别。当你评估下面的表达式 @code{(buffer-name)} 时，缓冲区的名称会出现在回显区。当你评估 @code{(buffer-file-name)} 时，缓冲区所引用的文件的名称会出现在回显区。通常，由 @code{(buffer-name)} 返回的名称与它引用的文件的名称相同，而由 @code{(buffer-file-name)} 返回的名称是文件的完整路径名。

文件和缓冲区是两个不同的实体。文件是永久记录在计算机中的信息（除非你删除它）。另一方面，缓冲区是 Emacs 内部的信息，在编辑会话结束时（或者当你杀死缓冲区时）将会消失。通常，缓冲区包含你从文件中复制的信息；我们说缓冲区正在@dfn{访问}该文件。这份副本是你要操作和修改的。对缓冲区的更改不会影响文件，直到你保存缓冲区。当你保存缓冲区时，缓冲区被复制到文件中，因此被永久保存。

@need 1250
如果你正在 GNU Emacs 中的 Info 中阅读本文，你可以通过将光标定位在表达式后并键入 @kbd{C-x C-e} 来评估以下每个表达式。

@example
@group
(buffer-name)

(buffer-file-name)
@end group
@end example

@noindent
在 Info 中执行 @code{(buffer-name)} 时，返回的值是 @file{"*info*"}，而执行 @code{(buffer-file-name)} 时返回的值是 @file{nil}。

另一方面，在我编写这个文档时，执行 @code{(buffer-name)} 返回的值是 @file{"introduction.texinfo"}，而执行 @code{(buffer-file-name)} 返回的值是 @file{"/gnu/work/intro/introduction.texinfo"}。

@cindex @code{nil}，单词的历史
前者是缓冲区的名称，而后者是文件的名称。在 Info 中，缓冲区名称是 @file{"*info*"}。Info 没有指向任何文件，因此执行 @code{(buffer-file-name)} 的结果是 @file{nil}。符号 @code{nil} 源自拉丁语单词 "nothing"，在这种情况下，它表示该缓冲区未关联任何文件。（在 Lisp 中，@code{nil} 也用于表示 "false"，并且是空列表 @code{()} 的同义词。）

在编写文档时，我的缓冲区名称是 @file{"introduction.texinfo"}。它指向的文件名称是 @file{"/gnu/work/intro/introduction.texinfo"}。

（在这些表达式中，括号告诉 Lisp 解释器将 @w{@code{buffer-name}} 和 @w{@code{buffer-file-name}} 视为函数；没有括号，解释器将尝试将这些符号评估为变量。@xref{Variables}。）

尽管文件和缓冲区之间有区别，但你经常会发现人们在指代文件时实际上是指缓冲区，反之亦然。实际上，大多数人会说：“我正在编辑一个文件”，而不是说：“我正在编辑一个缓冲区，稍后将保存到文件。” 从上下文中几乎总能清楚人们的意思。然而，在处理计算机程序时，保持区别是重要的，因为计算机没有人类那么智能。

@cindex 缓冲区，单词的历史
顺便说一下，“缓冲区”这个词的意义来源于它作为减缓碰撞力的缓冲物。在早期计算机中，缓冲区起到了文件与计算机中央处理单元之间相互作用的缓冲作用。持有文件的磁鼓或磁带和中央处理单元是非常不同的设备，它们以各自的速度、断断续续地工作。缓冲区使它们能够有效地协同工作。最终，缓冲区从一个中介、一个临时存放的地方，发展成为工作完成的地方。这种转变有点像一个小港口发展成为一个大城市：曾经它只是在货物被装上船之前的临时仓库；然后它成为一个独立的商业和文化中心。

并非所有的缓冲区都与文件相关。例如，`*scratch*` 缓冲区没有访问任何文件。同样，`*Help*` 缓冲区也没有与任何文件相关。

在过去，当你没有 `~/.emacs` 文件，通过输入 `emacs` 命令启动 Emacs 会话时，不指定任何文件，Emacs 会以 `*scratch*` 缓冲区可见的状态启动。现在，你会看到一个启动画面。你可以按照启动画面上建议的命令之一，访问一个文件，或按 `q` 键退出启动画面并进入 `*scratch*` 缓冲区。

如果切换到 `*scratch*` 缓冲区，输入 `(buffer-name)`，将光标定位到其后，然后键入 `C-x C-e` 以评估表达式。将返回并显示 `*scratch*` 的名称在回显区。`*scratch*` 就是该缓冲区的名称。当你在 `*scratch*` 缓冲区中输入 `(buffer-file-name)` 并评估时，回显区将显示 `nil`，就像在 Info 中评估 `(buffer-file-name)` 时一样。

顺便提一下，如果你在 `*scratch*` 缓冲区中，想要将表达式返回的值显示在 `*scratch*` 缓冲区本身而不是在回显区，可以键入 `C-u C-x C-e` 而不是 `C-x C-e`。这将导致返回的值出现在表达式之后。缓冲区会看起来像这样：

@smallexample
(buffer-name)"*scratch*"
@end smallexample

@noindent
在 Info 中你不能这样做，因为 Info 是只读的，它不允许你更改缓冲区的内容。但是在任何你可以编辑的缓冲区中，你都可以这样做；当你编写代码或文档（比如这本书）时，这个功能非常有用。

@node 获取缓冲区
@section 获取缓冲区
@findex current-buffer
@findex other-buffer
@cindex 获取缓冲区

函数@code{buffer-name}返回缓冲区的@emph{名称}；要获取缓冲区@emph{本身}，需要使用另一个函数：@code{current-buffer}函数。如果在代码中使用这个函数，你将得到缓冲区本身。

名称和名称所指代的对象或实体是不同的。你不是你的名字。你是一个被别人用名字指称的人。如果你要求与George交谈，而有人递给你一张写有字母@samp{G}、@samp{e}、@samp{o}、@samp{r}、@samp{g}和@samp{e}的卡片，你可能会感到有趣，但你不会满意。你不想和名字交谈，而是想和名字所指代的人交谈。缓冲区类似：临时缓冲区的名称是@file{*scratch*}，但名称不是缓冲区。要获取缓冲区本身，需要使用诸如@code{current-buffer}这样的函数。

然而，有一个小复杂性：如果在一个表达式中评估@code{current-buffer}，就像我们在这里所做的那样，你所看到的是缓冲区名称的打印表示，而不是缓冲区的内容。Emacs之所以以这种方式工作有两个原因：缓冲区可能有成千上万行长---太长了无法方便地显示；另一个缓冲区可能具有相同的内容但具有不同的名称，区分它们是很重要的。

@need 800
下面是包含该函数的表达式：

@smallexample
(current-buffer)
@end smallexample

@noindent
如果你在Emacs中通常的方式下在Info中评估这个表达式，@file{#<buffer *info*>} 将会出现在回显区。这个特殊的格式表示正在返回的是缓冲区本身，而不仅仅是它的名称。

顺便提一下，虽然你可以在程序中键入数字或符号，但不能在缓冲区的打印表示中这样做：获取缓冲区本身的唯一方式是使用诸如@code{current-buffer}的函数。

一个相关的函数是@code{other-buffer}。它返回除了当前所在的缓冲区之外最近选择的缓冲区，而不是其名称的打印表示。如果你最近在@file{*scratch*}缓冲区之间切换，@code{other-buffer}将返回该缓冲区。

@need 800
你可以通过评估以下表达式来看到这一点：

@smallexample
(other-buffer)
@end smallexample

@noindent
你应该在回显区看到@file{#<buffer *scratch*>}出现，或者是你最近切换回来的任何其他缓冲区的名称@footnote{实际上，默认情况下，如果你刚刚从中切换的缓冲区在另一个窗口中可见，@code{other-buffer}将选择你无法看到的最近的缓冲区；这是我经常忘记的一个细微之处。}。

@node 切换缓冲区
@section 切换缓冲区
@findex switch-to-buffer
@findex set-buffer
@cindex 切换到缓冲区

实际上，当将@code{other-buffer}函数用作需要缓冲区参数的函数的参数时，它实际上提供了一个缓冲区。通过使用@code{other-buffer}和@code{switch-to-buffer}来切换到不同的缓冲区，我们可以看到这一点。

但首先，让我们简要介绍一下@code{switch-to-buffer}函数。当你在Info和@file{*scratch*}缓冲区之间切换以评估@code{(buffer-name)}时，你很可能会输入@kbd{C-x b}，然后在迷你缓冲区中输入@file{*scratch*}。@footnote{或者更确切地说，为了节省输入，如果默认缓冲区是@file{*scratch*}，你可能只输入@kbd{RET}，或者如果它不同，则只输入部分名称，如@code{*sc}，按下@kbd{TAB}键使其扩展为完整名称，然后输入@kbd{RET}。} 用于切换到所需缓冲区的名称。按下@kbd{C-x b}这些按键会导致Lisp解释器评估交互函数@code{switch-to-buffer}。正如我们之前所说，这就是Emacs的工作原理：不同的按键调用或运行不同的函数。例如，@kbd{C-f}调用@code{forward-char}，@kbd{M-e}调用@code{forward-sentence}等等。

通过在表达式中编写@code{switch-to-buffer}，并给它一个要切换到的缓冲区，我们可以像@kbd{C-x b}一样切换缓冲区：

@smallexample
(switch-to-buffer (other-buffer))
@end smallexample

@noindent
符号 @code{switch-to-buffer} 是列表的第一个元素，因此Lisp解释器将其视为一个函数并执行与其关联的指令。但在执行之前，解释器会注意到 @code{other-buffer} 在括号内，并首先处理该符号。@code{other-buffer} 是此列表的第一个元素（在这种情况下，也是唯一的元素），因此Lisp解释器调用或运行该函数。它返回另一个缓冲区。接下来，解释器运行 @code{switch-to-buffer}，将另一个缓冲区作为参数传递给它，这就是Emacs将要切换到的缓冲区。如果您正在Info中阅读此内容，请立即尝试。评估此表达式。（要返回，请键入 @kbd{C-x b @key{RET}}。）@footnote{请记住，此表达式将将您移动到您无法看到的最近的其他缓冲区。如果您真的想转到最近选择的缓冲区，即使您仍然可以看到它，您需要评估以下更复杂的表达式：

@smallexample
(switch-to-buffer (other-buffer (current-buffer) t))
@end smallexample

@c noindent
在这种情况下，@code{other-buffer} 的第一个参数告诉它要跳过的缓冲区（当前的缓冲区），第二个参数告诉 @code{other-buffer} 可以切换到可见的缓冲区。在常规用法中，@code{switch-to-buffer}将您带到窗口中不可见的缓冲区，因为您很可能使用 @kbd{C-x o}（@code{other-window}）转到另一个可见的缓冲区。}

在本文档后面的编程示例中，您将更频繁地看到函数 @code{set-buffer} 而不是 @code{switch-to-buffer}。这是因为计算机程序和人类之间存在一个差异：人类有眼睛，并期望在计算机终端上看到他们正在操作的缓冲区。这是如此明显，几乎不言而喻。然而，程序没有眼睛。当计算机程序在缓冲区上工作时，该缓冲区不需要在屏幕上可见。

@code{switch-to-buffer} 是为人类设计的，它执行两个不同的操作：它切换Emacs关注的缓冲区，并将窗口显示的缓冲区切换到新的缓冲区。另一方面，@code{set-buffer} 只执行一项任务：它将计算机程序的注意力切换到另一个缓冲区。屏幕上的缓冲区保持不变（当然，通常在命令运行完成之前不会发生任何变化）。

@cindex @samp{call} 定义
此外，我们刚刚介绍了另一个行话术语，即词语 @dfn{call}。当您评估一个列表，其中第一个符号是一个函数时，您正在调用该函数。该术语的使用来自于将函数视为如果您调用它可以为您做一些事情的实体的概念，就像水管工是一个实体，如果您呼叫他或她，他或她可以修理漏水一样。

@node 缓冲区大小与位置
@section 缓冲区大小和点的位置
@cindex 缓冲区大小
@cindex 缓冲区大小
@cindex 点的位置
@cindex 点的位置

最后，让我们看一些相当简单的函数，@code{buffer-size}、@code{point}、@code{point-min}和@code{point-max}。它们提供有关缓冲区大小和点在其中的位置的信息。

函数@code{buffer-size}告诉您当前缓冲区的大小；也就是说，该函数返回缓冲区中字符的数量。

@smallexample
(buffer-size)
@end smallexample

@noindent
您可以通过将光标放置在表达式后，并键入@kbd{C-x C-e}来评估它。

@cindex @samp{point}定义
在Emacs中，光标的当前位置被称为@dfn{point}。表达式@code{(point)}返回一个数字，告诉您光标的位置，以字符数表示，从缓冲区开头到point的位置。

@need 1250
您可以通过以通常的方式评估以下表达式来查看point在该缓冲区的字符计数：

@smallexample
(point)
@end smallexample

@noindent
在我写这篇文章的时候，point的值是65724。@code{point}函数在本书的一些后面的示例中经常被使用。

@need 1250
point的值当然取决于它在缓冲区内的位置。如果在这个位置评估point，数字会更大：

@smallexample
(point)
@end smallexample

@noindent
对我而言，在这个位置，point的值是66043，这意味着两个表达式之间有319个字符（包括空格）。 （毫无疑问，由于我首次评估point后进行了编辑，你可能会看到不同的数字。）

@cindex @samp{narrowing}定义
函数@code{point-min}与@code{point}有些相似，但它返回当前缓冲区中point的最小允许值。这个值是1，除非启用了@dfn{narrowing}。（Narrowing是一种机制，通过它，您可以将自己或程序限制在仅对缓冲区的一部分进行操作。@xref{缩窄与扩大, , 窄化和扩展}。）同样，函数@code{point-max}返回当前缓冲区中point的最大允许值。

@node 评估练习
@section 练习

找到您正在使用的文件，并移动到其中间。
找到其缓冲区名称、文件名称、长度以及您在文件中的位置。

@node 编写 Defuns
@chapter 如何编写函数定义
@cindex 定义编写
@cindex 函数定义编写
@cindex 编写函数定义

当Lisp解释器评估一个列表时，它会查看列表上的第一个符号是否附有一个函数定义；或者换句话说，该符号是否指向一个函数定义。如果是的话，计算机将执行定义中的指令。一个具有函数定义的符号被简单地称为函数（尽管严格来说，定义是函数，符号是它的引用）。

@menu
* 原始函数::
* defun::                        @code{defun} 宏。
* 安装::                          安装函数定义。
* 交互操作::                        使函数具有交互性。
* 交互选项::                    @code{interactive} 的不同选项。
* 永久安装::                      永久安装代码。
* let::                          创建并初始化局部变量。
* if::                           如果是这样怎么办？
* else::                         If--then--else 表达式。
* 真与假::                       Lisp认为的真和假。
* save-excursion::               跟踪点和缓冲区。
* 回顾::
* defun 练习::
@end menu

@ifnottex
@node 原始函数
@unnumberedsec 关于原始函数的一些说明
@end ifnottex
@cindex 原始函数
@cindex 函数，原始

@cindex C语言原语
@cindex 用C编写的原语
所有函数都是基于其他函数定义的，除了一些用C编写的@dfn{原始}函数。当你编写函数定义时，你将使用Emacs Lisp编写它们，并将其他函数作为构建块。你将使用的一些函数本身是用Emacs Lisp编写的（也许是由你编写的），而另一些是用C编写的原语。这些原始函数的使用方式与用Emacs Lisp编写的函数完全相同，并且其行为也相同。它们是用C编写的，以便我们可以轻松地在任何具有足够计算能力且能够运行C的计算机上运行GNU Emacs。

让我再强调一下：当你在Emacs Lisp中编写代码时，你不区分是使用用C编写的函数还是使用用Emacs Lisp编写的函数。这种区别是无关紧要的。我提到这个区别只是因为它是有趣的。实际上，除非你调查，你不会知道一个已经编写好的函数是用Emacs Lisp还是C编写的。

@node defun
@section @code{defun} 宏
@findex defun

@cindex @samp{函数定义} 已定义
在Lisp中，像 @code{mark-whole-buffer} 这样的符号附有与其关联的代码，告诉计算机在调用该函数时应该执行什么操作。这段代码称为 @dfn{函数定义}，它是通过评估以符号 @code{defun}（它是 @emph{define function} 的缩写）开头的Lisp表达式创建的。

在后续的章节中，我们将查看Emacs源代码中的函数定义，比如 @code{mark-whole-buffer}。在本节中，我们将描述一个简单的函数定义，以便您了解其外观。这个函数定义使用算术运算，因为这样做可以提供一个简单的例子。有些人不喜欢使用算术的例子；然而，如果您是这样的人，请不要绝望。在本介绍的其余部分中，我们将几乎不涉及算术或数学的代码。例子主要涉及以某种方式涉及文本的内容。

一个函数定义由跟在 @code{defun} 之后的最多五个部分组成：

@enumerate
@item
应该附加函数定义的符号的名称。

@item
将传递给函数的参数列表。如果不会传递任何参数给函数，这是一个空列表，即 @code{()}。

@item
描述函数的文档。（从技术上讲是可选的，但强烈推荐。）

@item
可选地，一个表达式，使函数具有交互性，以便您可以通过键入 @kbd{M-x}，然后输入函数的名称来使用它；或通过输入适当的键或键组。

@cindex @samp{函数体} 已定义
@item
告诉计算机要执行的代码：函数定义的 @dfn{函数体}。
@end enumerate

有助于将函数定义的五个部分视为一个模板，其中为每个部分都留有槽位：

@smallexample
@group
(defun @var{function-name} (@var{arguments}@dots{})
  "@var{optional-documentation}@dots{}"
  (interactive @var{argument-passing-info})     ; @r{可选}
  @var{body}@dots{})
@end group
@end smallexample

以一个将其参数乘以7的函数为例说明。 （此示例不是交互式的。有关此信息，请参阅@xref{交互操作,,使函数具有交互性}。）

@smallexample
@group
(defun multiply-by-seven (number)
  "将NUMBER乘以七。"
  (* 7 number))
@end group
@end smallexample

这个定义以括号和符号@code{defun}开始，后跟函数的名称。

@cindex @samp{argument list} defined
函数名称后面是一个包含将传递给函数的参数的列表。 这个列表称为@dfn{参数列表}。 在这个例子中，列表只有一个元素，即符号@code{number}。 当使用函数时，该符号将绑定到作为函数参数的值。

与选择@code{number}作为参数名称不同，我可以选择任何其他名称。 例如，我可以选择单词@code{multiplicand}。 我选择了单词“number”是因为它说明了此槽位所需的值的类型； 但是我完全可以选择单词“multiplicand”来指示在函数运作中放入此槽位的值所起的作用。 我可以称其为@code{foogle}，但那是一个不好的选择，因为它不会告诉人们它的含义。 名称的选择由程序员决定，应该选择使函数的含义清晰的名称。

确实，你可以为参数列表中的符号选择任何你喜欢的名称，甚至是在其他函数中使用的符号的名称：在参数列表中使用的名称对于该特定定义是私有的。在该定义中，该名称指的是与函数定义之外使用的同名实体不同的实体。假设在你的家庭中你有一个绰号“矮子”；当你的家庭成员提到“矮子”时，他们指的是你。但在你的家庭之外，比如在电影中，“矮子”这个名字指的是别人。因为参数列表中的名称对函数定义是私有的，你可以在函数体内改变这样一个符号的值，而不会改变它在函数外的值。这个效果类似于`let`表达式（@xref{let, , @code{let}}）。

@ignore
还要注意，我们以两种不同的方式讨论“number”这个词：一是作为代码中出现的符号，二是作为在函数评估过程中将被其他东西替换的东西的名称。在第一种情况下，@code{number}是一个符号，而不是一个数字；恰巧在函数内部，它是一个其值为相应数字的变量，但我们对它的主要关注是作为一个符号。另一方面，当我们谈论该函数时，我们关注的是我们将用一个数字替换掉@var{number}这个词。为了保持这种区别清晰，我们在这两种情况下使用不同的排版。当我们谈论这个函数，或者它的工作原理时，我们通过写@var{number}来引用这个数字。在函数本身中，我们通过写@code{number}来引用它。
@end ignore

参数列表后面是描述函数的文档字符串。这是当你键入@w{@kbd{C-h f}}和函数的名称时所看到的内容。顺便说一句，当你编写这样的文档字符串时，应该将第一行写成完整的句子，因为有些命令（比如@code{apropos}）只打印多行文档字符串的第一行。此外，如果有第二行文档字符串，不应该对其进行缩进，因为在使用@kbd{C-h f}（@code{describe-function}）时，这样看起来很奇怪。文档字符串是可选的，但它非常有用，几乎应该包含在你编写的每个函数中。

@findex * @r{(乘法)}
该示例的第三行是函数定义的主体。 （当然，大多数函数的定义要比这个长。）在这个函数中，主体是列表@code{(* 7 number)}，它表示将@var{number}的值乘以7。（在Emacs Lisp中，@code{*}是乘法的函数，就像@code{+}是加法的函数一样。）

当你使用 @code{multiply-by-seven} 函数时，参数 @code{number} 会被评估为你希望使用的实际数字。下面是展示如何使用 @code{multiply-by-seven} 的示例；但现在不要尝试评估它！

@smallexample
(multiply-by-seven 3)
@end smallexample

@noindent
在函数定义的下一部分中指定的符号 @code{number} 在实际使用函数时被绑定到值 3。请注意，尽管在函数定义中 @code{number} 处于括号中，但传递给 @code{multiply-by-seven} 函数的参数不在括号中。括号写在函数定义中，这样计算机可以确定参数列表的结束位置和函数定义的其余部分的开始位置。

如果你评估这个示例，很可能会收到错误消息。（试试看吧！）这是因为我们已经写了函数定义，但还没有告诉计算机有关定义——我们还没有在Emacs中加载函数定义。安装函数是告诉Lisp解释器函数定义的过程。安装过程在下一部分中描述。

@node 安装
@section 安装函数定义
@cindex 安装函数定义
@cindex 定义安装
@cindex 函数定义安装

如果你正在 Emacs 的 Info 中阅读本文，你可以尝试执行 @code{multiply-by-seven} 函数，首先评估函数定义，然后评估 @code{(multiply-by-seven 3)}。函数定义的副本如下。将光标放在函数定义的最后一个括号之后，然后键入 @kbd{C-x C-e}。当你这样做时，@code{multiply-by-seven} 将显示在回显区域。（这意味着当评估函数定义时，它返回的值是定义的函数的名称。）与此同时，此操作安装了函数定义。

@smallexample
@group
(defun multiply-by-seven (number)
  "将 NUMBER 乘以七。"
  (* 7 number))
@end group
@end smallexample

@noindent
通过评估这个 @code{defun}，你刚刚在 Emacs 中安装了 @code{multiply-by-seven}。该函数现在与 Emacs 中的其他编辑函数（如 @code{forward-word}）一样成为 Emacs 的一部分。（@code{multiply-by-seven} 将一直保持安装状态，直到你退出 Emacs。要在每次启动 Emacs 时自动重新加载代码，请参阅 @ref{永久安装, , 永久安装代码}。）

@menu
* 安装的效果::
* 更改 defun::              如何更改函数定义。
@end menu

@ifnottex
@node 安装效果
@unnumberedsubsec 安装的效果
@end ifnottex

通过评估以下示例，您可以看到安装 @code{multiply-by-seven} 的效果。将光标放在下面的表达式之后，然后键入 @kbd{C-x C-e}。数字 21 将出现在回显区域。

@smallexample
(multiply-by-seven 3)
@end smallexample

如果您愿意，可以通过键入 @kbd{C-h f}（@code{describe-function}）然后输入函数的名称 @code{multiply-by-seven} 来阅读该函数的文档。这样做时，您的屏幕上将出现一个 @file{*Help*} 窗口，内容如下：

@smallexample
@group
multiply-by-seven 是一个 Lisp 函数。

(multiply-by-seven NUMBER)

将 NUMBER 乘以七。
@end group
@end smallexample

@noindent
（要返回到屏幕上的单个窗口，请键入 @kbd{C-x 1}。）
@menu
* 安装效果::
* 更改 defun::              如何更改函数定义。
@end menu

@node 修改 defun
@subsection 修改函数定义
@cindex 修改函数定义
@cindex 函数定义，如何修改
@cindex 定义，如何修改

如果你想修改 @code{multiply-by-seven} 中的代码，只需重新编写它。要将新版本安装到旧版本的位置，重新评估函数定义即可。这就是在Emacs中修改代码的方式，非常简单。

举个例子，你可以将 @code{multiply-by-seven} 函数更改为将数字加到自身七次，而不是将数字乘以七。它产生相同的答案，但是通过不同的路径。同时，我们将在代码中添加一条注释；注释是Lisp解释器忽略的文本，但对人类读者可能很有用或启发。注释是这是第二个版本。

@smallexample
@group
(defun multiply-by-seven (number)       ; @r{第二个版本。}
  "将 NUMBER 乘以七。"
  (+ number number number number number number number))
@end group
@end smallexample

@cindex Lisp 代码中的注释
注释以分号 @samp{;} 开头。在Lisp中，分号后面的一行上的所有内容都是注释。行的结尾是注释的结尾。要将注释延伸到两行或更多行，请在每一行开头加上分号。

@xref{Beginning init File, , 开始一个 @file{.emacs}
文件}，和 @ref{Comments, , 注释, elisp, GNU Emacs Lisp
参考手册}，了解更多关于注释的信息。

你可以通过以与第一个函数相同的方式评估它来安装 @code{multiply-by-seven} 函数的这个版本：将光标放在最后一个括号后，然后输入 @kbd{C-x C-e}。

总之，这就是在Emacs Lisp中编写代码的方式：编写函数；安装它；测试它；然后进行修复或增强，并再次安装它。

@node 交互操作
@section 使函数具有交互性
@cindex 交互式函数
@findex interactive

通过在文档后面紧跟以特殊形式 @code{interactive} 开头的列表，可以使函数具有交互性。用户可以通过键入 @kbd{M-x}，然后键入函数名，或者通过键入其绑定的键来调用交互式函数，例如通过键入 @kbd{C-n} 调用 @code{next-line}，或者通过键入 @kbd{C-x h} 调用 @code{mark-whole-buffer}。

有趣的是，当你以交互方式调用交互式函数时，返回的值不会自动显示在回显区。这是因为通常你调用交互式函数是为了其副作用，比如按单词或行前进，而不是为了返回的值。如果每次键入一个键时都在回显区显示返回的值，会非常分散注意力。

@menu
* 交互式multiply-by-seven::  概述。
* multiply-by-seven in detail::  交互式版本。
@end menu

@ifnottex
@node 交互式multiply-by-seven
@unnumberedsubsec 交互式 @code{multiply-by-seven}，概述
@end ifnottex

通过创建 @code{multiply-by-seven} 的交互式版本，可以演示特殊形式 @code{interactive} 的使用以及在回显区域显示值的一种方式。

@need 1250
以下是代码：

@smallexample
@group
(defun multiply-by-seven (number)       ; @r{交互式版本.}
  "将 NUMBER 乘以七。"
  (interactive "p")
  (message "结果是 %d" (* 7 number)))
@end group
@end smallexample

@noindent
您可以通过将光标放置在代码后并键入 @kbd{C-x C-e} 来安装此代码。函数的名称将出现在回显区域中。然后，您可以通过键入 @kbd{C-u} 和一个数字，然后键入 @kbd{M-x multiply-by-seven} 并按 @key{RET} 使用此代码。回显区域中将出现短语 @samp{结果是 @dots{}}，后面跟着乘积。

更一般地说，可以通过以下两种方式调用这样的函数：

@enumerate
@item
通过键入包含要传递的数字的前缀参数，然后键入 @kbd{M-x} 和函数的名称，如 @kbd{C-u 3 M-x forward-sentence}；或者，

@item
通过键入函数绑定的键或键序列，如 @kbd{C-u 3 M-e}。
@end enumerate

@noindent
刚才提到的两个示例均以相同的方式工作，将光标向前移动三个句子。 (由于 @code{multiply-by-seven} 未绑定到键，它无法用作绑定键的示例。)

(@xref{Key Bindings, , 一些按键绑定}, 了解如何将命令绑定到键。)

通过键入数字键后跟一个数字，例如 @kbd{M-3 M-e}，或者通过键入 @kbd{C-u} 然后是一个数字，例如 @kbd{C-u 3 M-e}，将一个 @dfn{前缀参数} 传递给交互式函数（如果键入 @kbd{C-u} 而没有数字，则默认为 4）。

@node multiply-by-seven in detail
@subsection 交互式 @code{multiply-by-seven} 详解

让我们看一下特殊形式 @code{interactive} 的使用，然后再看一下@code{multiply-by-seven} 的交互版本中的函数 @code{message}。你会记得该函数定义如下：

@smallexample
@group
(defun multiply-by-seven (number)       ; @r{交互版本。}
  "将 NUMBER 乘以七。"
  (interactive "p")
  (message "结果是 %d" (* 7 number)))
@end group
@end smallexample

在这个函数中，表达式 @code{(interactive "p")} 是一个包含两个元素的列表。@code{"p"} 告诉 Emacs 将前缀参数传递给函数，并将其值用作函数的参数。

@need 1000
参数将是一个数字。这意味着在以下行中，符号@code{number} 将绑定到一个数字：

@smallexample
(message "结果是 %d" (* 7 number))
@end smallexample

@need 1250
@noindent
例如，如果你的前缀参数是 5，Lisp 解释器将将该行解释为：

@smallexample
(message "结果是 %d" (* 7 5))
@end smallexample

@noindent
(如果你在 GNU Emacs 中阅读此文，你可以自行评估这个表达式。)首先，解释器将评估内部列表，即 @code{(* 7 5)}。这将返回一个值为 35。接下来，它将评估外部列表，将列表的第二个和随后的元素的值传递给函数 @code{message}。

正如我们所见，@code{message} 是一个专为向用户发送单行消息而设计的 Emacs Lisp 函数。（@xref{message, , The @code{message} function}。）总体而言，@code{message} 函数会将其第一个参数原样打印在回显区域，但会替换@samp{%d} 或 @samp{%s}（以及我们未提及的其他各种 %-sequences）的出现。当它看到控制序列时，该函数会查找第二个或随后的参数，并在字符串中的控制序列位置打印参数的值。

在交互式 @code{multiply-by-seven} 函数中，控制字符串是 @samp{%d}，需要一个数字，而通过评估 @code{(* 7 5)} 返回的值是数字 35。因此，数字 35 将在 @samp{%d} 的位置打印，消息为 @samp{结果是 35}。

（请注意，当调用函数 @code{multiply-by-seven} 时，消息会以无引号形式打印，但调用 @code{message} 时，文本将以双引号形式打印。这是因为 @code{message} 返回的值是在评估其第一个元素为 @code{message} 的表达式时出现在回显区域中的内容；但在嵌入函数中时，@code{message} 以副作用的方式打印文本，没有引号。）

@node 交互选项
@section @code{interactive} 的不同选项
@cindex @code{interactive} 的选项
@cindex 交互选项

在例子中，@code{multiply-by-seven} 使用 @code{"p"} 作为@code{interactive} 的参数。这个参数告诉 Emacs 解释你的输入，无论是 @kbd{C-u} 后跟一个数字还是 @key{META} 后跟一个数字，都是将该数字作为参数传递给函数。Emacs 预定义了超过二十个字符，可以用于 @code{interactive}。在几乎所有情况下，这些选项之一将使你能够以交互方式向函数传递正确的信息。(@xref{Interactive Codes, , @code{interactive} 代码章节, elisp, GNU Emacs Lisp 参考手册}.)

@need 1250
考虑函数 @code{zap-to-char}。它的交互表达式为

@c FIXME: zap-to-char 的交互表达式已更改
@c (在2012-04-10)。

@smallexample
(interactive "p\ncZap to char: ")
@end smallexample

@code{interactive} 的参数的第一部分是 @samp{p}，这是你已经熟悉的。这个参数告诉 Emacs 解释一个前缀，作为传递给函数的数字。你可以通过键入 @kbd{C-u} 后跟一个数字或者键入 @key{META} 后跟一个数字来指定前缀。前缀是指定的字符数。因此，如果你的前缀是三，指定的字符是@samp{x}，那么你将删除所有文本，包括第三个 @samp{x}。如果你没有设置前缀，那么你将删除所有文本，包括指定的字符，但不包括之后的文本。

@samp{c} 告诉函数要删除的字符的名称。

更正式地说，具有两个或更多参数的函数可以通过向跟随 @code{interactive} 的字符串添加部分来将信息传递给每个参数。当你这样做时，信息将按照它在@code{interactive} 列表中指定的顺序传递给每个参数。在字符串中，每个部分都由一个 @samp{\n}（换行符）与下一个部分分隔开。例如，你可以在 @samp{p} 后面加上一个 @samp{\n} 和一个 @samp{cZap to char:}。这将导致 Emacs 传递前缀参数的值（如果有的话）和字符。

在这种情况下，函数定义如下，其中 @code{arg} 和 @code{char} 是由 @code{interactive} 绑定的前缀参数和指定字符：

@smallexample
@group
(defun @var{name-of-function} (arg char)
  "@var{documentation}@dots{}"
  (interactive "p\ncZap to char: ")
  @var{body-of-function}@dots{})
@end group
@end smallexample

@noindent
（在提示符的冒号后加一个空格使其看起来更好。@xref{copy-to-buffer, , 函数 @code{copy-to-buffer} 的定义}，提供一个例子。）

当函数不接受参数时，@code{interactive} 不需要任何参数。这样的函数包含简单的表达式 @code{(interactive)}。@code{mark-whole-buffer} 函数就是这样的一个例子。

或者，如果特殊的字母代码不适合你的应用程序，你可以将自己的参数作为列表传递给 @code{interactive}。

@xref{append-to-buffer, , 函数 @code{append-to-buffer} 的定义}，提供一个例子。@xref{Using Interactive, , 使用 @code{Interactive}, elisp, GNU Emacs Lisp 参考手册}，提供有关这一技术的更完整解释。

@node 永久安装
@section 永久安装代码
@cindex 永久安装代码
@cindex 永久性代码安装
@cindex 代码安装

当通过评估来安装函数定义时，它将一直保持安装状态，直到退出 Emacs。下次启动 Emacs 时，除非重新评估函数定义，否则该函数将不会安装。

在某个时刻，您可能希望在每次启动新的 Emacs 会话时自动安装代码。有几种方法可以实现这一点：

@itemize @bullet
@item
如果您的代码只是针对您个人的，您可以将函数定义的代码放入您的 @file{.emacs} 初始化文件中。当您启动 Emacs 时，您的 @file{.emacs} 文件会自动评估，并安装其中的所有函数定义。
@xref{Emacs Initialization, , 您的 @file{.emacs} 文件}。

@item
或者，您可以将要安装的函数定义放入一个或多个单独的文件中，并使用 @code{load} 函数使 Emacs 评估并安装这些文件中的每个函数。
@xref{Loading Files, , 加载文件}。

@item
第三，如果您有整个站点都会使用的代码，通常将其放入一个名为 @file{site-init.el} 的文件中，在构建 Emacs 时加载该文件。这使得代码对使用您的计算机的每个人都可用。（请参阅 Emacs 发行版的 @file{INSTALL} 文件。）
@end itemize

最后，如果您的代码是每个使用 Emacs 的人都可能需要的，您可以将其发布到计算机网络上，或将副本发送给自由软件基金会。（在执行此操作时，请使用许可证许可代码及其文档，允许其他人运行、复制、研究、修改和重新分发代码，并保护您免受他人夺走您的工作的风险。）如果您向自由软件基金会发送代码的副本，并正确保护自己和其他人，它可能会包含在下一个 Emacs 发布版中。在很大程度上，这就是 Emacs 在过去几年中发展的方式，通过捐赠。

@node let
@section @code{let}
@findex let

@code{let}表达式是Lisp中的一种特殊形式，你在大多数函数定义中都需要使用它。

@code{let}用于以一种方式将符号绑定到值，使得Lisp解释器不会将该变量与不属于函数的同名变量混淆。

为了理解为什么需要@code{let}特殊形式，考虑以下情况：假设你拥有一所房子，通常将其称为“房子”，就像在句子中说：“房子需要粉刷。” 如果你正在访问朋友，而你的主人提到“房子”，他可能是在指的是@emph{他}的房子，而不是你的，也就是说，是另一座房子。

如果你的朋友正在指他的房子，而你认为他正在指你的房子，那么可能会产生一些混乱。在Lisp中，如果在一个函数内部使用的变量与另一个函数内部使用的同名变量相同，并且两者意图不是引用相同的值，则可能发生类似的情况。@code{let}特殊形式防止了这种混淆。

@menu
* 避免混淆::
* let 表达式的组成部分::
* 示例 let 表达式::
* 未初始化的let语句变量::
@end menu

@ifnottex
@node 避免混淆
@unnumberedsubsec @code{let} 避免混淆
@end ifnottex

@cindex @samp{局部变量} 定义
@cindex @samp{变量, 局部}, 定义
特殊形式 @code{let} 可以避免混淆。@code{let} 创建一个@dfn{局部变量}的名称，它会遮蔽任何在 @code{let} 表达式之外使用相同名称的情况。这就像理解当你的主机提到“房子”时，他指的是他的房子，而不是你的房子一样。（在参数列表中使用的符号也是同样的道理。@xref{defun, , @code{defun} 宏}。）

由 @code{let} 表达式创建的局部变量只在 @code{let} 表达式本身（以及在 @code{let} 表达式内调用的表达式中）中保持其值；这些局部变量在 @code{let} 表达式之外没有影响。

另一种理解 @code{let} 的方式是，它就像一个临时和局部的 @code{setq}。由 @code{let} 设置的值在 @code{let} 结束时会自动撤销。这个设置只影响在 @code{let} 表达式边界内的表达式。在计算机科学的术语中，我们会说符号的绑定仅在 @code{let} 表单中调用的函数中可见；在 Emacs Lisp 中，默认的作用域是动态的，而不是词法的。 （非默认的词法绑定在本手册中未讨论。）

@code{let} 可以一次创建多个变量。此外，@code{let} 为它创建的每个变量都提供一个初始值，可以是你指定的值，也可以是 @code{nil}。（在术语中，这是将变量绑定到值。）在 @code{let} 创建并绑定了变量之后，它会执行 @code{let} 主体中的代码，并返回主体中最后一个表达式的值，作为整个 @code{let} 表达式的值。（“执行”是一个术语，指的是评估列表；它源自“实施”一词的使用，意味着“实际生效”（@cite{Oxford English Dictionary}）。由于你评估一个表达式来执行一个动作，“执行”已经演变为“评估”的同义词。）

@node let 表达式的组成部分
@subsection @code{let} 表达式的组成部分
@cindex @code{let} 表达式，组成部分
@cindex @code{let} 表达式的组成

@cindex @samp{varlist} 的定义
一个 @code{let} 表达式包含三个部分。第一部分是符号 @code{let}。第二部分是一个列表，称为@dfn{varlist}，其中每个元素要么是一个单独的符号，要么是一个两元素列表，其中第一个元素是一个符号。@code{let} 表达式的第三部分是 @code{let} 的主体。主体通常包含一个或多个列表。

@need 800
@code{let} 表达式的模板如下：

@smallexample
(let @var{varlist} @var{body}@dots{})
@end smallexample

@noindent
varlist 中的符号是由 @code{let} 特殊形式给予初始值的变量。单独的符号被赋予 @code{nil} 的初始值；而每个作为两元素列表的第一个元素的符号则被绑定到 Lisp 解释器评估第二个元素时返回的值。

因此，varlist 可以看起来像这样：@code{(thread (needles 3))}。在这种情况下，在 @code{let} 表达式中，Emacs 将符号 @code{thread} 绑定到初始值 @code{nil}，并将符号 @code{needles} 绑定到初始值 3。

当编写 @code{let} 表达式时，你要做的是将适当的表达式放入 @code{let} 表达式模板的各个部分。

如果 varlist 由两元素列表组成，这在许多情况下是常见的，那么 @code{let} 表达式的模板如下：

@smallexample
@group
(let ((@var{variable} @var{value})
      (@var{variable} @var{value})
      @dots{})
  @var{body}@dots{})
@end group
@end smallexample

@node 示例 let 表达式
@subsection 示例 @code{let} 表达式
@cindex 示例 @code{let} 表达式
@cindex @code{let} 表达式示例

以下表达式创建并为两个变量 @code{zebra} 和 @code{tiger} 赋予初始值。@code{let} 表达式的主体是一个调用 @code{message} 函数的列表。

@smallexample
@group
(let ((zebra "条纹")
      (tiger "凶猛"))
  (message "一种动物有 %s，另一种是 %s。"
           zebra tiger))
@end group
@end smallexample

在这里，varlist 是 @code{((zebra "条纹") (tiger "凶猛"))}。

这两个变量是 @code{zebra} 和 @code{tiger}。每个变量都是两元素列表的第一个元素，每个值都是其两元素列表的第二个元素。在 varlist 中，Emacs 将变量 @code{zebra} 绑定到值 @code{"条纹"}@footnote{根据Jared Diamond在 @cite{枪炮、病菌与钢铁} 中的说法，“@dots{} 斑马在变老时变得异常危险”，但这里的说法是它们不会像老虎一样变得凶猛。(1997, W. W. Norton 和 Co., ISBN 0-393-03894-2, 第171页)}，并将变量 @code{tiger} 绑定到值 @code{"凶猛"}。在这个例子中，两个值都是字符串。这些值同样可以是另一个列表或符号。@code{let} 的主体紧随包含变量的列表之后。在这个例子中，主体是一个列表，使用 @code{message} 函数在回显区域打印一个字符串。

@need 1500
您可以按照通常的方式评估这个示例，将光标放在最后一个括号后，然后键入 @kbd{C-x C-e}。这样做时，回显区域将显示以下内容：

@smallexample
"一种动物有条纹，另一种是凶猛。"
@end smallexample

正如我们之前看到的，@code{message} 函数打印其第一个参数，除了 @samp{%s}。在这个例子中，变量 @code{zebra} 的值将打印在第一个 @samp{%s} 的位置，而变量 @code{tiger} 的值将打印在第二个 @samp{%s} 的位置。

@node 未初始化的let语句变量
@subsection @code{let} 语句中的未初始化变量
@cindex 未初始化的 @code{let} 变量
@cindex @code{let} 变量未初始化

如果在 @code{let} 语句中不将变量绑定到特定的初始值，它们将自动绑定到初始值为 @code{nil}，如下面的表达式所示：

@smallexample
@group
(let ((birch 3)
      pine
      fir
      (oak 'some))
  (message
   "这里有 %d 个变量，分别具有 %s、%s 和 %s 的值。"
   birch pine fir oak))
@end group
@end smallexample

@noindent
这里，变量列表是 @code{((birch 3) pine fir (oak 'some))}。

@need 1250
如果以通常的方式评估此表达式，将在你的回显区域中看到以下内容：

@smallexample
"这里有 3 个变量，分别具有 nil、nil 和 some 的值。"
@end smallexample

@noindent
在这个例子中，Emacs将符号 @code{birch} 绑定到数字3，将符号 @code{pine} 和 @code{fir} 绑定到 @code{nil}，并将符号 @code{oak} 绑定到值 @code{some}。

注意，在 @code{let} 的第一部分中，变量 @code{pine} 和 @code{fir} 作为不带括号的原子独立存在；这是因为它们被绑定到 @code{nil}，即空列表。但是，@code{oak} 被绑定到 @code{some}，因此是列表 @code{(oak 'some)} 的一部分。类似地，@code{birch} 被绑定到数字3，因此在具有该数字的列表中。 (由于数字在评估时为自身，因此数字不需要引用。此外，消息中使用 @samp{%d} 而不是 @samp{%s} 打印数字。) 这四个变量作为一个组被放入列表中，以将它们与 @code{let} 的主体分开。

@node if
@section 特殊形式 @code{if}
@findex if
@cindex 使用 @code{if} 的条件语句

另一种特殊形式是条件语句 @code{if}。该形式用于指导计算机进行决策。您可以编写不使用 @code{if} 的函数定义，但它被经常使用且足够重要，因此在这里进行介绍。例如，在函数 @code{beginning-of-buffer} 的代码中就使用了它。

@code{if} 的基本思想是，@emph{如果}测试为真，@emph{那么}就会评估一个表达式。如果测试不为真，则不会评估该表达式。例如，您可能会做出这样的决定：“如果天气暖和而且阳光明媚，那么就去海滩！”

@menu
* if 详细说明::
* type-of-animal 详细说明::    一个 @code{if} 表达式的示例。
@end menu

@ifnottex
@node if 详细说明
@unnumberedsubsec @code{if}详细说明
@end ifnottex

@cindex @samp{if-part}定义
@cindex @samp{then-part}定义
在Lisp中，@code{if}表达式不使用单词“then”；测试和动作是列表的第二个和第三个元素，其第一个元素是@code{if}。尽管如此，@code{if}表达式的测试部分通常称为@dfn{if-part}，第二个参数通常称为@dfn{then-part}。

此外，当编写@code{if}表达式时，通常将真假测试写在与符号@code{if}相同的行上，但如果测试为真，则执行的操作，即then-part，会写在第二行及后续行。这样可以使@code{if}表达式更易读。

@smallexample
@group
(if @var{true-or-false-test}
    @var{action-to-carry-out-if-test-is-true})
@end group
@end smallexample

@noindent
真假测试将是由Lisp解释器评估的表达式。

以下是一个您可以按照通常方式评估的示例。测试是数字5是否大于数字4。由于是，将打印消息@samp{5 is greater than 4!}。

@smallexample
@group
(if (> 5 4)                             ; @r{if-part}
    (message "5 is greater than 4!"))   ; @r{then-part}
@end group
@end smallexample

@noindent
（函数@code{>}测试其第一个参数是否大于其第二个参数，并在其为真时返回true。）
@findex > @r{(greater than)}

当然，在实际使用中，@code{if} 表达式中的测试将不会像表达式 @code{(> 5 4)} 中那样永远固定。相反，测试中至少一个变量将被绑定到一个预先未知的值。
（如果值在预先知道，我们就不需要运行测试了！）

例如，该值可以绑定到函数定义的参数上。在以下函数定义中，动物的特性是传递给函数的值。如果绑定到 @code{characteristic} 的值是 @code{"fierce"}，则将打印消息 @samp{It is a tiger!}；否则，将返回 @code{nil}。

@smallexample
@group
(defun type-of-animal (characteristic)
  "根据 CHARACTERISTIC 在回显区打印消息。
如果 CHARACTERISTIC 是字符串 \"fierce\"，
则警告是一只老虎。"
  (if (equal characteristic "fierce")
      (message "It is a tiger!")))
@end group
@end smallexample

@need 1500
@noindent
如果您正在 GNU Emacs 中阅读此文档，您可以按照通常的方式评估函数定义以在 Emacs 中安装它，然后可以评估以下两个表达式以查看结果：

@smallexample
@group
(type-of-animal "fierce")

(type-of-animal "striped")
@end group
@end smallexample

@c 以下句子已重新编写以防止 hbox 溢出。
@noindent
当您评估 @code{(type-of-animal "fierce")} 时，您将在回显区看到打印的以下消息：@code{"It is a tiger!"}；当您评估 @code{(type-of-animal "striped")} 时，您将在回显区看到打印的 @code{nil}。

@node type-of-animal 详细说明
@subsection 详细介绍 @code{type-of-animal} 函数

让我们详细看一下 @code{type-of-animal} 函数。

@code{type-of-animal} 函数的定义是通过填充两个模板而完成的，一个用于整个函数定义，另一个用于 @code{if} 表达式。

@need 1250
每个非交互式函数的模板如下：

@smallexample
@group
(defun @var{name-of-function} (@var{argument-list})
  "@var{documentation}@dots{}"
  @var{body}@dots{})
@end group
@end smallexample

@need 800
符合此模板的函数部分如下：

@smallexample
@group
(defun type-of-animal (characteristic)
  "根据 CHARACTERISTIC 在回显区域打印消息。
如果 CHARACTERISTIC 是字符串 \"fierce\"，则警告可能是老虎。"
  @var{body: the} @code{if} @var{expression})
@end group
@end smallexample

函数的名称是 @code{type-of-animal}；它接受一个参数的值。参数列表后面是多行文档字符串。在示例中包含文档字符串是一个良好的习惯，建议为每个函数定义都编写文档字符串。函数定义的主体由 @code{if} 表达式组成。

@need 800
@code{if} 表达式的模板如下：

@smallexample
@group
(if @var{true-or-false-test}
    @var{action-to-carry-out-if-the-test-returns-true})
@end group
@end smallexample

@need 1250
在 @code{type-of-animal} 函数中，@code{if} 的代码如下：

@smallexample
@group
(if (equal characteristic "fierce")
    (message "它是一只老虎！"))
@end group
@end smallexample

@need 800
在这里，true-or-false-test 是表达式：

@smallexample
(equal characteristic "fierce")
@end smallexample

在 Lisp 中，@code{equal} 是一个函数，它确定其第一个参数是否等于第二个参数。第二个参数是字符串 @code{"fierce"}，第一个参数是符号 @code{characteristic} 的值，换句话说，就是传递给该函数的参数。

在 @code{type-of-animal} 的第一个示例中，传递了参数 @code{"fierce"}。由于 @code{"fierce"} 等于 @code{"fierce"}，表达式 @code{(equal characteristic "fierce")} 返回 true。当发生这种情况时，@code{if} 会评估 @code{if} 的第二个参数或 true 部分：@code{(message "它是一只老虎！")}。

另一方面，在 @code{type-of-animal} 的第二个示例中，传递了参数 @code{"striped"}。@code{"striped"} 不等于 @code{"fierce"}，因此 true 部分不会被评估，@code{if} 表达式返回 @code{nil}。

@node else
@section If--then--else 表达式
@cindex Else

一个 @code{if} 表达式可能有一个可选的第三个参数，称为 @dfn{else-部分}，用于当真假测试返回 false 时的情况。当这种情况发生时，整个 @code{if} 表达式的第二个参数或者 then-部分 @emph{不会} 被评估，而第三个参数或 else-部分 @emph{会} 被评估。你可以将其看作是决策的“如果天气温暖且晴朗，则去海滩，否则读一本书”的多云日备选方案。

在Lisp代码中并没有写下单词 "else"；@code{if} 表达式的 else-部分在 then-部分之后。在书写的Lisp中，else-部分通常写在自己的一行上，并且比 then-部分的缩进少：

@smallexample
@group
(if @var{真假测试}
    @var{真时执行的动作}
  @var{假时执行的动作})
@end group
@end smallexample

例如，下面的 @code{if} 表达式在通常的情况下，当你对其进行求值时，会打印消息 @samp{4不大于5！}：

@smallexample
@group
(if (> 4 5)                               ; @r{if-部分}
    (message "4 falsely greater than 5!") ; @r{then-部分}
  (message "4 is not greater than 5!"))   ; @r{else-部分}
@end group
@end smallexample

@noindent
请注意，不同缩进级别使得很容易区分 then-部分 和 else-部分。（GNU Emacs 有几个命令可以自动正确缩进 @code{if} 表达式。@xref{Typing Lists, , GNU Emacs Helps You Type Lists}.）

我们可以通过在 @code{type-of-animal} 函数中加入一个 else 部分来扩展它，只需在 @code{if} 表达式中加入一个额外的部分即可。

@need 1500
如果你评估以下版本的 @code{type-of-animal} 函数定义以安装它，然后评估两个后续表达式，将不同的参数传递给函数，你就能看到这样做的后果。

@smallexample
@group
(defun type-of-animal (characteristic)  ; @r{第二个版本。}
  "根据 CHARACTERISTIC 在回显区域打印消息。
如果 CHARACTERISTIC 是字符串 \"fierce\"，
则警告是一只老虎；否则说它不凶猛。"
  (if (equal characteristic "fierce")
      (message "这是一只老虎！")
    (message "它不凶猛！")))
@end group
@end smallexample
@sp 1

@smallexample
@group
(type-of-animal "fierce")

(type-of-animal "striped")

@end group
@end smallexample

@c 为了防止 hbox 过满，以下句子已重新编写。
@noindent
当你评估 @code{(type-of-animal "fierce")} 时，你将在回显区域看到以下消息打印出来：@code{"这是一只老虎！"}；但是当你评估 @code{(type-of-animal "striped")} 时，你将看到 @code{"它不凶猛！"}。

（当然，如果 @var{characteristic} 是 @code{"ferocious"}，则将打印消息 @code{"它不凶猛！"}；这可能会产生误导！在编写代码时，你需要考虑到 @code{if} 可能会测试到这样的参数，并相应地编写你的程序。）

@node 真值与假值
@section Emacs Lisp 中的真值和假值
@cindex Emacs Lisp 中的真值和假值
@cindex Emacs Lisp 中的假值和真值
@findex nil

在 @code{if} 表达式中，有一个重要的关于真值测试的方面。到目前为止，我们已经谈到“true”和“false”作为谓词的值，好像它们是新种类的 Emacs Lisp 对象一样。实际上，“false”只是我们的老朋友 @code{nil}。任何其他东西——无论什么——都是“true”。

对真值进行测试的表达式在解释时会被视为 @dfn{真}，如果它的求值结果不是 @code{nil}。换句话说，如果返回的值是一个数字，比如 47，一个字符串，比如 @code{"hello"}，或者一个符号（除了 @code{nil} 之外的任何符号），或者一个列表（只要它不是空的），甚至是一个缓冲区，测试的结果就被认为是真的！

@menu
* nil explained::               @code{nil} 有两个含义。
@end menu

@ifnottex
@node nil解释
@unnumberedsubsec @code{nil}的解释
@end ifnottex

在说明真值测试之前，我们需要解释一下 @code{nil}。

在Emacs Lisp中，符号 @code{nil} 有两个含义。首先，它表示空列表。其次，它表示假，是在真假测试返回假时返回的值。@code{nil}可以被写成空列表，@code{()}，或者写作 @code{nil}。就Lisp解释器而言，@code{()} 和 @code{nil} 是一样的。然而，人们倾向于将 @code{nil} 用于表示假，而将 @code{()} 用于表示空列表。

在Emacs Lisp中，任何不是 @code{nil}，即非空列表的值，被认为是真。这意味着如果一个求值返回了不是空列表的值，一个 @code{if} 表达式将测试为真。例如，如果一个数字被放在测试的槽位，它将被求值并返回它自己，因为这是数字在被求值时所做的。在这个条件语句中，@code{if} 表达式将测试为真。该表达式仅在通过求值表达式返回 @code{nil}，即空列表时测试为假。

通过对以下示例中的两个表达式进行求值，您可以看到这一点。

在第一个示例中，数字4作为 @code{if} 表达式中的测试被求值并返回自己；因此，表达式的then部分被求值并返回：在回显区域中显示 @samp{true}。在第二个示例中，@code{nil} 表示假；因此，表达式的else部分被求值并返回：在回显区域中显示 @samp{false}。

@smallexample
@group
(if 4
    'true
  'false)
@end group

@group
(if nil
    'true
  'false)
@end group
@end smallexample

@need 1250
顺便说一句，如果某个有用的值在返回真的测试时不可用，那么Lisp解释器将返回符号 @code{t} 代表真。例如，表达式 @code{(> 5 4)} 在被求值时返回 @code{t}，您可以通过通常的方式进行求值查看：

@smallexample
(> 5 4)
@end smallexample

@need 1250
@noindent
另一方面，如果测试为假，则该函数返回 @code{nil}。

@smallexample
(> 4 5)
@end smallexample

@node save-excursion
@section @code{save-excursion}
@findex save-excursion
@cindex Region, what it is
@cindex Preserving point and buffer
@cindex Point and buffer preservation
@findex point
@findex mark

@code{save-excursion}函数是我们将在本章中讨论的最后一个特殊形式。

在用于编辑的Emacs Lisp程序中，@code{save-excursion}函数非常常见。它保存点（point）的位置，执行函数体，然后如果点的位置发生了变化，则将点还原到其先前的位置。其主要目的是防止用户因点的意外移动而感到惊讶和困扰。

@menu
* Point and mark::              各种位置的回顾。
* Template for save-excursion::
@end menu

@ifnottex
@node 光标位置和标记
@unnumberedsubsec 光标位置和标记
@end ifnottex

然而，在讨论 @code{save-excursion} 之前，首先回顾一下在 GNU Emacs 中点（Point）和标记（Mark）的概念可能会很有用。@dfn{点} 是光标的当前位置。光标所在的位置就是点。更准确地说，在光标位于字符之上的终端上，点位于紧接在字符之前。在 Emacs Lisp 中，点是一个整数。缓冲区中的第一个字符是编号为一，第二个是编号为二，依此类推。函数 @code{point} 返回光标的当前位置作为一个数字。每个缓冲区都有其自己的点值。

@dfn{标记} 是缓冲区中的另一个位置；它的值可以通过诸如 @kbd{C-@key{SPC}}（@code{set-mark-command}）的命令设置。如果已经设置了标记，可以使用命令 @kbd{C-x C-x}（@code{exchange-point-and-mark}）使光标跳到标记位置，并将标记设置为点的先前位置。此外，如果设置了另一个标记，前一个标记的位置将保存在标记环中。可以通过键入 @kbd{C-u C-@key{SPC}} 一次或多次将光标跳到保存的标记位置。

点和标记之间的缓冲区部分称为@dfn{区域}。许多命令在区域上起作用，包括 @code{center-region}、@code{count-words-region}、@code{kill-region} 和 @code{print-region}。

@code{save-excursion} 特殊形式保存点的位置，并在该特殊形式的主体内的代码被 Lisp 解释器评估后恢复这个位置。因此，如果点在文本的开头，某些代码将点移到缓冲区的末尾，@code{save-excursion} 将在函数主体中的表达式被评估后将点放回到它之前的位置。

在 Emacs 中，一个函数通常会在其内部工作的过程中移动点，尽管用户不希望这样。例如，@code{count-words-region} 会移动点。为了防止用户受到既意外又（从用户的角度）不必要的跳跃的困扰，通常使用 @code{save-excursion} 来保持点在用户预期的位置上。使用 @code{save-excursion} 是良好的编码风格。

为了确保代码书写规范，@code{save-excursion} 即使在其内部代码发生错误时也会恢复点的值（或者更准确地说，``在异常退出的情况下''）。这个特性非常有帮助。

除了记录点的值，@code{save-excursion} 还跟踪当前缓冲区，并在需要时进行恢复。这意味着你可以编写改变缓冲区的代码，并通过 @code{save-excursion} 切换回原始缓冲区。这就是 @code{save-excursion} 在 @code{append-to-buffer} 中的使用方式。(@xref{append-to-buffer, , @code{append-to-buffer} 的定义}.) 

@node save-excursion 表达式模板
@subsection @code{save-excursion} 表达式的模板

@need 800
使用 @code{save-excursion} 的代码模板很简单：

@smallexample
@group
(save-excursion
  @var{body}@dots{})
@end group
@end smallexample

@noindent
函数体是一个或多个表达式，它们将按顺序由Lisp解释器求值。如果在函数体中有多个表达式，则最后一个表达式的值将作为 @code{save-excursion} 函数的返回值。函数体中的其他表达式仅用于它们的副作用；而 @code{save-excursion} 本身仅用于其副作用（即还原point的位置）。

@need 1250
更详细地说，@code{save-excursion} 表达式的模板如下：

@smallexample
@group
(save-excursion
  @var{函数体中的第一个表达式}
  @var{函数体中的第二个表达式}
  @var{函数体中的第三个表达式}
   @dots{}
  @var{函数体中的最后一个表达式})
@end group
@end smallexample

@noindent
一个表达式当然可以是一个独立的符号或一个列表。

在Emacs Lisp代码中，@code{save-excursion} 表达式经常出现在 @code{let} 表达式的体内。它的形式如下：

@smallexample
@group
(let @var{变量列表}
  (save-excursion
    @var{函数体}@dots{}))
@end group
@end smallexample

@node Review
@section 复习

在过去的几章中，我们介绍了一个宏和相当多的函数和特殊形式。这里对它们进行简要描述，以及一些尚未提到的类似函数。

@table @code
@item eval-last-sexp
评估光标前的最后一个符号表达式。除非在调用该函数时使用参数，否则该值将打印在回显区域；在这种情况下，输出将打印在当前缓冲区中。通常，此命令绑定到 @kbd{C-x C-e}。

@item defun
定义函数。此宏最多有五个部分：名称、传递给函数的参数的模板、文档、可选的交互声明和定义的主体。

@need 1250
例如，在Emacs中，@code{dired-unmark-all-marks} 的函数定义如下。

@smallexample
@group
(defun dired-unmark-all-marks ()
  "从Dired缓冲区中的所有文件中删除所有标记。"
  (interactive)
  (dired-unmark-all-files ?\r))
@end group
@end smallexample

@item interactive
声明函数可交互使用。此特殊形式后面可能跟着一个包含一个或多个部分的字符串，将信息传递给函数的参数，按顺序。这些部分还可以告诉解释器提示信息。字符串的各部分由新行，即 @samp{\n} 分隔。

@need 1000
常见的代码字符包括：

@table @code
@item b
现有缓冲区的名称。

@item f
现有文件的名称。

@item p
数值前缀参数。（注意，此处的 @code{p} 是小写。）

@item r
光标和标记，作为两个数值参数，从最小到最大。这是唯一指定两个连续参数而不是一个参数的代码字母。
@end table

@xref{Interactive Codes, , 用于 @samp{interactive} 的代码字符, elisp, GNU Emacs Lisp参考手册}，以获取完整的代码字符列表。

@item let
声明一个变量列表，用于在@code{let}体内使用，并给它们一个初始值，可以是@code{nil}或指定的值；然后评估@code{let}体内的其余表达式，并返回最后一个表达式的值。在@code{let}体内，Lisp解释器看不到与外部绑定的同名变量的值。

@need 1250
例如，

@smallexample
@group
(let ((foo (buffer-name))
      (bar (buffer-size)))
  (message
   "当前缓冲区是 %s，包含 %d 个字符。"
   foo bar))
@end group
@end smallexample

@item save-excursion
在评估此特殊形式的体之前，记录point和当前缓冲区的值。在评估完体后，恢复point和缓冲区的值。

@need 1250
例如，

@smallexample
@group
(message "我们已经在这个缓冲区中 %d 个字符。"
         (- (point)
            (save-excursion
              (goto-char (point-min)) (point))))
@end group
@end smallexample

@item if
评估函数的第一个参数；如果为真，则评估第二个参数；否则，如果存在第三个参数，则评估第三个参数。

@code{if}特殊形式被称为@dfn{条件语句}。Emacs Lisp中还有其他条件语句，但@code{if}可能是最常用的。

@need 1250
例如，

@smallexample
@group
(if (= 22 emacs-major-version)
    (message "这是22版的Emacs")
  (message "这不是22版的Emacs"))
@end group
@end smallexample

@need 1250
@item <
@itemx >
@itemx <=
@itemx >=
@code{<}函数测试其第一个参数是否小于第二个参数。相应的函数@code{>}测试第一个参数是否大于第二个参数。类似地，@code{<=}测试第一个参数是否小于或等于第二个参数，而@code{>=}测试第一个参数是否大于或等于第二个参数。在所有情况下，两个参数必须是数字或标记（标记表示缓冲区中的位置）。

@need 800
@item =
@code{=}函数测试两个参数是否相等，这两个参数都必须是数字或标记。

@need 1250
@item equal
@itemx eq
测试两个对象是否相同。@code{equal}使用“相同”一词的一种含义，而@code{eq}使用另一种含义：如果两个对象具有相似的结构和内容，例如同一本书的两个副本，则@code{equal}返回真。另一方面，@code{eq}返回真，如果两个参数实际上是同一个对象。

@findex equal
@findex eq

@need 1250
@item string<
@itemx string-lessp
@itemx string=
@itemx string-equal
@code{string-lessp}函数测试其第一个参数是否小于第二个参数。同样功能的较短名称（@code{defalias}）是@code{string<}。

@code{string-lessp}的参数必须是字符串或符号；排序是词法的，因此大小写是敏感的。使用符号的打印名称而不是符号本身。

@cindex @samp{empty string}定义
空字符串，即@samp{""}，即不包含字符的字符串，小于任何包含字符的字符串。

@code{string-equal}提供相应的相等测试。它的较短名称是@code{string=}。没有与@var{>}，@code{>=}或@code{<=}相对应的字符串测试函数。

@item message
在回显区域打印消息。第一个参数是一个字符串，可以包含@samp{%s}，@samp{%d}或@samp{%c}，用于打印紧随其后的参数的值。由@samp{%s}使用的参数必须是字符串或符号；由@samp{%d}使用的参数必须是数字。由@samp{%c}使用的参数必须是@sc{ascii}代码数字；它将被打印为具有该@sc{ascii}代码的字符。 （其他各种未提到的%-序列未在此提及。）

@item setq
@itemx set
@code{setq}特殊形式将其第一个参数的值设置为第二个参数的值。第一个参数由@code{setq}自动引用。它对后续的参数对执行相同的操作。另一个函数@code{set}只接受两个参数，并在设置其第一个参数返回的值之前评估两个参数。

@item buffer-name
没有参数时，返回缓冲区的名称，作为字符串。

@item buffer-file-name
没有参数时，返回缓冲区正在访问的文件的名称。

@item current-buffer
返回Emacs处于活动状态的缓冲区；它可能不是屏幕上可见的缓冲区。

@item other-buffer
返回最近选择的缓冲区（不包括作为参数传递给@code{other-buffer}的缓冲区和当前缓冲区）。

@item switch-to-buffer
选择Emacs处于活动状态并在当前窗口中显示的缓冲区，以便用户可以查看它。通常绑定到@kbd{C-x b}。

@item set-buffer
切换Emacs的注意力到将运行程序的缓冲区。不更改窗口显示的内容。

@item buffer-size
返回当前缓冲区中字符的数量。

@item point
返回光标当前位置的值，作为从缓冲区开头计算的整数字符数。

@item point-min
返回当前缓冲区中point的最小允许值。除非限制了缩小，否则为1。

@item point-max
返回当前缓冲区中point的最大允许值。除非限制了缩小，否则为缓冲区的末尾。
@end table

@need 1500
@node defun 练习
@section 练习

@itemize @bullet
@item
编写一个非交互式函数，它将其参数（一个数字）的值加倍。将该函数设为交互式。

@item
编写一个函数，检查当前的@code{fill-column}值是否大于传递给函数的参数，如果是，则打印相应的消息。
@end itemize

@node Buffer Walk Through
@chapter 几个与缓冲区相关的函数

在这一章中，我们详细研究了GNU Emacs中使用的几个函数。这被称为“步进演示”。这些函数被用作Lisp代码的示例，但它们并不是虚构的例子；除了第一个简化的函数定义之外，这些函数展示了GNU Emacs中实际使用的代码。你可以从这些定义中学到很多东西。这里描述的函数都与缓冲区有关。稍后，我们将研究其他函数。

@menu
* 查找更多信息::                  如何查找更多信息。
* simplified-beginning-of-buffer::  展示了 @code{goto-char}、
                                  @code{point-min} 和 @code{push-mark}。
* mark-whole-buffer::             几乎与 @code{beginning-of-buffer} 相同。
* append-to-buffer::              使用 @code{save-excursion} 和
                                  @code{insert-buffer-substring}。
* 缓冲区相关回顾::                  回顾。
* 缓冲区练习::
@end menu

@node 查找更多
@section 查找更多信息

@findex describe-function@r{, introduced}
@cindex 查找函数文档
在这个步骤中，我将在遇到新函数时逐一描述它，有时详细介绍，有时简要说明。如果你感兴趣，你可以随时通过输入@kbd{C-h f}，然后输入函数的名称（然后按@key{RET}）获取任何Emacs Lisp函数的完整文档。类似地，你可以通过输入@kbd{C-h v}，然后输入变量的名称（然后按@key{RET}）获取变量的完整文档。

@cindex 查找函数源码
@c 在版本22中，告诉C和Emacs Lisp的函数定义位置
此外，@code{describe-function}还会告诉你函数定义的位置。

将光标放在包含函数的文件名上，然后按@key{RET}键。在这种情况下，@key{RET}意味着@code{push-button}，而不是“return”或“enter”。Emacs将直接跳转到函数定义处。

@ignore
在版本22中不存在

如果将光标移到文件名上并按@key{RET}键，这种情况下@key{RET}意味着@code{help-follow}而不是“return”或“enter”，Emacs将直接跳转到函数定义处。
@end ignore

更一般地说，如果你想在原始源文件中查看函数，你可以使用@code{xref-find-definitions}函数跳转到它。@code{xref-find-definitions}适用于各种语言，不仅限于Lisp和C，它还适用于非编程文本。例如，@code{xref-find-definitions}将跳转到本文档的Texinfo源文件的各个节点（前提是你已经运行@command{etags}实用程序记录了Emacs附带手册中的所有节点；@pxref{Create Tags Table,,, emacs, The GNU Emacs Manual}）。

要使用@code{xref-find-definitions}命令，输入@kbd{M-.}（即，按住@key{META}键的同时按下句点键，或者按@key{ESC}键，然后输入句点键），然后在提示符处输入你想要查看源代码的函数的名称，比如@code{mark-whole-buffer}，然后输入@key{RET}。 （如果命令没有提示，带一个参数调用它：@kbd{C-u M-.}；@pxref{交互选项}。）Emacs将切换缓冲区并在屏幕上显示函数的源代码@footnote{
如果Emacs不是显示Lisp函数的源代码，而是询问你要访问哪个标签表，请在其主要模式为Emacs Lisp或Lisp Interaction的缓冲区中调用@kbd{M-.}。
}。要切换回当前缓冲区，输入@kbd{M-,}或@kbd{C-x b @key{RET}}。（在某些键盘上，@key{META}键标记为@key{ALT}。）

@cindex Library, 作为“文件”一词的用法
顺便说一下，包含Lisp代码的文件通常被称为@dfn{库}。这个比喻来源于专业图书馆的概念，比如法律图书馆或工程图书馆，而不是普通图书馆。每个库或文件都包含与特定主题或活动相关的函数，比如处理缩写和其他输入快捷方式的@file{abbrev.el}，以及用于帮助的@file{help.el}。（有时，多个库提供单个活动的代码，就像各种@file{rmail@dots{}}文件提供阅读电子邮件的代码一样。）在@cite{The GNU Emacs Manual}中，你会看到类似“@kbd{C-h p}命令允许你按主题关键字搜索标准的Emacs Lisp库。”的句子。

@node simplified-beginning-of-buffer
@section 一个简化的 @code{beginning-of-buffer} 定义
@findex simplified-beginning-of-buffer

@code{beginning-of-buffer} 命令是一个很好的起点函数，因为你可能熟悉它，并且它易于理解。作为交互式命令使用时，@code{beginning-of-buffer} 将光标移动到缓冲区的开头，同时在先前的位置留下标记。通常绑定到 @kbd{M-<}。

在这一节中，我们将讨论该函数的一个简化版本，展示它最常用的形式。这个简化的函数按原样工作，但不包含复杂选项的代码。在另一节中，我们将描述整个函数。(@xref{beginning-of-buffer, , @code{beginning-of-buffer} 的完整定义}。)

在查看代码之前，让我们考虑函数定义必须包含的内容：必须包括一个使函数可交互的表达式，以便通过键入 @kbd{M-x beginning-of-buffer} 或键入键序（如 @kbd{M-<}）来调用它；必须包括代码以在缓冲区中原始位置留下一个标记；必须包括将光标移动到缓冲区开头的代码。

@need 1250
以下是该函数简化版本的完整文本：

@smallexample
@group
(defun simplified-beginning-of-buffer ()
  "将光标移动到缓冲区开头；在先前位置留下标记。"
  (interactive)
  (push-mark)
  (goto-char (point-min)))
@end group
@end smallexample

与所有函数定义一样，此定义在宏 @code{defun} 之后有五个部分：

@enumerate
@item
名称：在这个例子中是 @code{simplified-beginning-of-buffer}。

@item
参数列表：在这个例子中是一个空列表，@code{()}。

@item
文档字符串。

@item
交互表达式。

@item
主体。
@end enumerate

@noindent
在此函数定义中，参数列表为空，这意味着此函数不需要任何参数。 （当我们查看完整函数定义时，我们将看到它可以传递一个可选参数。）

交互式表达式告诉Emacs该函数旨在以交互方式使用。在这个例子中，@code{interactive} 没有参数，因为 @code{simplified-beginning-of-buffer} 不需要参数。

@need 800
函数的主体包括两行：

@smallexample
@group
(push-mark)
(goto-char (point-min))
@end group
@end smallexample

这些行中的第一行是表达式 @code{(push-mark)}。当Lisp解释器评估此表达式时，它在光标当前位置设置一个标记，无论光标在哪里。该标记的位置保存在标记环中。

接下来的一行是 @code{(goto-char (point-min))}。此表达式将光标跳到缓冲区的最小点，即缓冲区的开头（如果缩小了，则是缓冲区的可访问部分的开头。@xref{缩窄与扩大, , 缩小和扩大}.)

@code{push-mark} 命令在光标被 @code{(goto-char (point-min))} 表达式移动到缓冲区开头之前的位置设置一个标记。因此，如果愿意，可以通过键入 @kbd{C-x C-x} 返回到最初的位置。

这就是整个函数定义的全部内容！

@findex describe-function
当阅读这样的代码并遇到不熟悉的函数时，比如 @code{goto-char}，可以使用 @code{describe-function} 命令了解它的作用。要使用此命令，输入 @kbd{C-h f}，然后输入函数的名称并按 @key{RET}。@code{describe-function} 命令将在 @file{*Help*} 窗口中打印函数的文档字符串。例如，@code{goto-char} 的文档如下：

@smallexample
@group
将点设置为 POSITION，一个数字或标记。
缓冲区的开头是位置 (point-min)，结束是 (point-max)。
@end group
@end smallexample

@noindent
函数的一个参数是所需的位置。

@noindent
（对于 @code{describe-function} 的提示将提供光标下或之前的符号，因此您可以通过将光标直接定位到函数上方或之后，然后键入 @kbd{C-h f @key{RET}} 以节省输入。）

@code{end-of-buffer} 函数定义与 @code{beginning-of-buffer} 定义的方式相同，只是函数的主体包含 @code{(goto-char (point-max))} 表达式，而不是 @code{(goto-char (point-min))}。

@node mark-whole-buffer
@section 定义 @code{mark-whole-buffer}
@findex mark-whole-buffer

@code{mark-whole-buffer} 函数的理解并不比 @code{simplified-beginning-of-buffer} 函数更难。然而，在这种情况下，我们将看一下完整的函数，而不是缩短版本。

@code{mark-whole-buffer} 函数并不像 @code{beginning-of-buffer} 函数那样常用，但仍然很有用：它通过将点放在开头并在缓冲区末尾放置标记来标记整个缓冲区作为一个区域。通常绑定到 @kbd{C-x h}。

@menu
* mark-whole-buffer 概述::
* mark-whole-buffer 函数体::   只有三行代码。
@end menu

@ifnottex
@node mark-whole-buffer 概述
@unnumberedsubsec @code{mark-whole-buffer} 概述
@end ifnottex

@need 1250
在GNU Emacs 22中，完整函数的代码如下：

@smallexample
@group
(defun mark-whole-buffer ()
  "将点放在缓冲区的开头，将标记放在缓冲区的末尾。
在Lisp程序中，您可能不应该使用此函数；
让Lisp函数使用使用或设置标记的任何子例程通常是一个错误。"
  (interactive)
  (push-mark (point))
  (push-mark (point-max) nil t)
  (goto-char (point-min)))
@end group
@end smallexample

@need 1250
与所有其他函数一样，@code{mark-whole-buffer} 函数符合函数定义的模板。模板如下：

@smallexample
@group
(defun @var{name-of-function} (@var{argument-list})
  "@var{documentation}@dots{}"
  (@var{interactive-expression}@dots{})
  @var{body}@dots{})
@end group
@end smallexample

函数的名称是 @code{mark-whole-buffer}；后面是一个空的参数列表，@samp{()} 表示函数不需要参数。接下来是文档。

下一行是一个 @code{(interactive)} 表达式，告诉Emacs该函数将以交互方式使用。这些细节类似于前一节中描述的 @code{simplified-beginning-of-buffer} 函数。

@need 1250
@node mark-whole-buffer 函数体
@subsection @code{mark-whole-buffer} 函数体

@code{mark-whole-buffer} 函数的主体由三行代码组成：

@c GNU Emacs 22
@smallexample
@group
(push-mark (point))
(push-mark (point-max) nil t)
(goto-char (point-min))
@end group
@end smallexample

这些行中的第一行是表达式 @code{(push-mark (point))}。

这行与 @code{simplified-beginning-of-buffer} 函数体的第一行 @code{(push-mark)} 完全相同。在这两种情况下，Lisp解释器在光标的当前位置设置一个标记。

我不知道为什么 @code{mark-whole-buffer} 中的表达式写为 @code{(push-mark (point))}，而在 @code{beginning-of-buffer} 中的表达式写为 @code{(push-mark)}。也许编写代码的人不知道 @code{push-mark} 的参数是可选的，如果 @code{push-mark} 没有传递参数，该函数默认会在点的位置自动设置标记。或者也许该表达式是为了与下一行的结构相呼应而写的。无论如何，这行使Emacs确定点的位置并在那里设置一个标记。

在GNU Emacs的早期版本中，@code{mark-whole-buffer} 的下一行是 @code{(push-mark (point-max))}。此表达式在缓冲区中具有最大编号的地方设置一个标记。这将是缓冲区的末尾（或者，如果缓冲区被缩小，缓冲区的可访问部分的末尾。有关缩小的更多信息，请参见 @xref{缩窄与扩大, , Narrowing and Widening}）。设置了此标记后，前一个标记（在点处设置的标记）不再设置，但Emacs记住了其位置，就像始终记住所有其他最近的标记一样。这意味着您可以通过键入 @kbd{C-u C-@key{SPC}} 两次返回到该位置，如果您愿意的话。

@need 1250
在GNU Emacs 22中，@code{(point-max)} 稍微复杂一些。该行读取

@smallexample
(push-mark (point-max) nil t)
@end smallexample

@noindent
该表达式几乎与之前相同。它在缓冲区中具有最大编号的位置设置一个标记。然而，在此版本中，@code{push-mark} 有两个额外的参数。@code{push-mark} 的第二个参数是 @code{nil}。这告诉函数在推送标记时应显示一个消息，该消息说“标记已设置”。第三个参数是 @code{t}。这告诉 @code{push-mark} 在启用瞬时标记模式时激活标记。瞬时标记模式突出显示当前活动的区域。通常情况下会关闭它。

最后，函数的最后一行是 @code{(goto-char (point-min)))}。这与 @code{beginning-of-buffer} 中写得一样。该表达式将光标移动到缓冲区的最小点，即缓冲区的开头（或者可访问部分的开头）。因此，点被放置在缓冲区的开头，标记被设置在缓冲区的末尾。整个缓冲区因此成为了一个区域。

@node append-to-buffer
@section @code{append-to-buffer}的定义
@findex append-to-buffer

@code{append-to-buffer}命令比@code{mark-whole-buffer}命令更复杂。其功能是将当前缓冲区中点和标记之间的区域复制到指定的缓冲区。

@menu
* append-to-buffer概述::
* append交互::          由两部分交互式表达式组成。
* append-to-buffer主体::       包含@code{let}表达式。
* append保存位置::       @code{save-excursion}的工作原理。
@end menu

@ifnottex
@node append-to-buffer概述
@unnumberedsubsec @code{append-to-buffer}的概述
@end ifnottex

@findex insert-buffer-substring
@code{append-to-buffer}命令使用@code{insert-buffer-substring}函数来复制区域。@code{insert-buffer-substring}的名称已经解释了它的功能：它从一个缓冲区中取出子字符串，然后插入到另一个缓冲区中。

大部分@code{append-to-buffer}涉及设置@code{insert-buffer-substring}工作条件：代码必须指定文本将进入的缓冲区，它来自的窗口以及它要去的窗口，以及将被复制的区域。

@need 1250
下面是该函数的可能实现：

@c GNU Emacs 22
@smallexample
@group
(defun append-to-buffer (buffer start end)
  "将区域的文本附加到指定缓冲区。
它插入到该缓冲区的点之前。
@end group

@group
在从程序调用时，提供三个参数：
BUFFER（或缓冲区名称），START和END。
START和END指定要复制的当前缓冲区的部分。"
  (interactive
   (list (read-buffer "追加到缓冲区：" (other-buffer
                                            (current-buffer) t))
         (region-beginning) (region-end)))
@end group
@group
  (let ((oldbuf (current-buffer)))
    (save-excursion
      (let* ((append-to (get-buffer-create buffer))
             (windows (get-buffer-window-list append-to t t))
             point)
        (set-buffer append-to)
        (setq point (point))
        (barf-if-buffer-read-only)
        (insert-buffer-substring oldbuf start end)
        (dolist (window windows)
          (when (= (window-point window) point)
            (set-window-point window (point))))))))
@end group
@end smallexample

通过查看该函数，可以理解它是一系列填充模板。

最外层模板是函数定义。在这个函数中，它看起来像这样（填充了几个槽）：

@smallexample
@group
(defun append-to-buffer (buffer start end)
  "@var{文档}@dots{}"
  (interactive @dots{})
  @var{主体}@dots{})
@end group
@end smallexample

函数的第一行包括其名称和三个参数。这些参数是文本将要复制到的@code{buffer}，以及将要复制的当前缓冲区的@code{start}和@code{end}。

函数的下一部分是文档，非常清晰而完整。按照惯例，这三个参数以大写字母写入，以便您轻松注意到它们。更好的是，它们按照参数列表中的顺序进行描述。

请注意文档区分了缓冲区和其名称。（该函数可以处理任何一种。）

@node append interactive
@subsection @code{append-to-buffer} 交互式表达式

由于 @code{append-to-buffer} 函数将被交互使用，该函数必须具有一个 @code{interactive} 表达式。 (有关 @code{interactive} 的详细信息，请参阅 @ref{交互操作, , 使函数具有交互性}。)

表达式如下：

@smallexample
@group
(interactive
 (list (read-buffer
        "追加到缓冲区: "
        (other-buffer (current-buffer) t))
       (region-beginning)
       (region-end)))
@end group
@end smallexample

@noindent
该表达式不是一个字母代表部分的表达式，如前所述。相反，它以这些部分开始一个列表：

列表的第一部分是一个表达式，用于读取缓冲区的名称并将其作为字符串返回。那就是 @code{read-buffer}。该函数需要一个提示作为其第一个参数，即 @samp{"追加到缓冲区: "}。其第二个参数告诉命令如果不指定任何值，应提供什么值。

在这种情况下，第二个参数是一个包含函数 @code{other-buffer}、一个异常和 @samp{t} 的表达式，表示为真。

@code{other-buffer} 的第一个参数是异常，是另一个函数 @code{current-buffer}。这不会被返回。第二个参数是真的符号，即 @code{t}。这告诉 @code{other-buffer} 它可以显示可见缓冲区（在这种情况下，它将不显示当前缓冲区，这是有道理的）。

@need 1250
表达式如下：

@smallexample
(other-buffer (current-buffer) t)
@end smallexample

@code{list} 表达式的第二个和第三个参数是 @code{(region-beginning)} 和 @code{(region-end)}。这两个函数指定要追加的文本的开头和结尾。

@need 1250
最初，该命令使用字母 @samp{B} 和 @samp{r}。整个 @code{interactive} 表达式如下：

@smallexample
(interactive "B追加到缓冲区:@: \nr")
@end smallexample

@noindent
但是当这样做时，切换到的缓冲区的默认值变为不可见。这是不想要的。

（提示与第二个参数之间用换行符 @samp{\n} 分隔。它后面跟着一个 @samp{r}，告诉 Emacs 将跟随函数参数列表中 @code{buffer} 符号后面的两个参数（即 @code{start} 和 @code{end}）绑定到点和标记的值。这个参数运行良好。）

@node append-to-buffer body
@subsection @code{append-to-buffer} 函数体

@code{append-to-buffer} 函数的体部分以 @code{let} 开始。

正如我们之前所见 (@pxref{let, , @code{let}})，@code{let} 表达式的目的是在 @code{let} 的体内创建并给予一个或多个变量初始值。这意味着这样的变量不会与 @code{let} 表达式外部同名的任何变量混淆。

通过以下提纲展示了 @code{append-to-buffer} 函数的模板，其中包含 @code{let} 表达式：

@smallexample
@group
(defun append-to-buffer (buffer start end)
  "@var{documentation}@dots{}"
  (interactive @dots{})
  (let ((@var{variable} @var{value}))
        @var{body}@dots{}))
@end group
@end smallexample

@code{let} 表达式包含三个元素：

@enumerate
@item
符号 @code{let}；

@item
一个 varlist，包含一个两元素列表，即 @code{(@var{variable} @var{value})}；

@item
@code{let} 表达式的体部分。
@end enumerate

@need 800
在 @code{append-to-buffer} 函数中，varlist 的样式如下：

@smallexample
(oldbuf (current-buffer))
@end smallexample

@noindent
在 @code{let} 表达式的这部分中，唯一的变量 @code{oldbuf} 被绑定到 @code{(current-buffer)} 表达式返回的值。这个变量 @code{oldbuf} 用于跟踪你正在操作的缓冲区，并从中复制。

varlist 的元素或元素组被一对括号括起，以便 Lisp 解释器能够区分 varlist 和 @code{let} 的体部分。因此，varlist 中的两元素列表被一对括号包围。这一行看起来像这样：

@smallexample
@group
(let ((oldbuf (current-buffer)))
  @dots{} )
@end group
@end smallexample

@noindent
在 @code{oldbuf} 之前的两个括号可能会让你感到惊讶，如果你没有意识到 @code{oldbuf} 之前的第一个括号标记了 varlist 的边界，而第二个括号标记了两元素列表 @code{(oldbuf (current-buffer))} 的开始。

@node append save-excursion
@subsection @code{save-excursion} 在 @code{append-to-buffer} 中的应用

在 @code{append-to-buffer} 中的 @code{let} 表达式的主体由一个 @code{save-excursion} 表达式组成。

@code{save-excursion} 函数保存 point 的位置，并在 @code{save-excursion} 主体表达式执行完成后将其恢复到该位置。此外，@code{save-excursion} 还跟踪原始缓冲区并将其恢复，这就是在 @code{append-to-buffer} 中使用 @code{save-excursion} 的方式。

@need 1500
@cindex 缩进用于格式化
@cindex 格式化约定
顺便提一下，值得注意的是，Lisp 函数通常格式化为多行展开的形式，其中所有被包裹在多行展开的内容都比第一个符号缩进得更多。在这个函数定义中，@code{let} 的缩进比 @code{defun} 大，而 @code{save-excursion} 的缩进比 @code{let} 大，就像这样：

@smallexample
@group
(defun @dots{}
  @dots{}
  @dots{}
  (let@dots{}
    (save-excursion
      @dots{}
@end group
@end smallexample

@need 1500
@noindent
这种格式约定使得很容易看到 @code{save-excursion} 主体中的行是由与 @code{save-excursion} 相关的括号括起来的，就像 @code{save-excursion} 本身由与 @code{let} 相关的括号括起来一样：

@smallexample
@group
(let ((oldbuf (current-buffer)))
  (save-excursion
    @dots{}
    (set-buffer @dots{})
    (insert-buffer-substring oldbuf start end)
    @dots{}))
@end group
@end smallexample

@need 1200
使用 @code{save-excursion} 函数的方式可以看作是填充模板的过程：

@smallexample
@group
(save-excursion
  @var{主体中的第一个表达式}
  @var{主体中的第二个表达式}
   @dots{}
  @var{主体中的最后一个表达式})
@end group
@end smallexample

@need 1200
@noindent
@anchor{let* introduced}
@findex let*
在这个函数中，@code{save-excursion} 的主体只包含一个表达式，即 @code{let*} 表达式。你已经了解了 @code{let} 函数，而 @code{let*} 函数则不同。它允许 Emacs 按顺序设置 varlist 中的每个变量，依次设置在 varlist 较早部分设置的变量的值，以便 varlist 较后部分的变量可以使用 varlist 较早部分设置的值。

观察 @code{append-to-buffer} 中的 @code{let*} 表达式：

@smallexample
@group
(let* ((append-to (get-buffer-create buffer))
       (windows (get-buffer-window-list append-to t t))
       point)
  BODY...)
@end group
@end smallexample

@noindent
我们可以看到，@code{append-to} 被绑定到由 @w{@code{(get-buffer-create buffer)}} 返回的值上。在下一行，@code{append-to} 作为参数传递给了 @code{get-buffer-window-list}；这在 @code{let} 表达式中是不可能的。注意，@code{point} 被自动绑定为 @code{nil}，就像在 @code{let} 语句中一样。

现在让我们专注于 @code{let*} 表达式的主体中的 @code{set-buffer} 和 @code{insert-buffer-substring} 函数。

@need 1250
在旧版本中，@code{set-buffer} 表达式是简单的

@smallexample
(set-buffer (get-buffer-create buffer))
@end smallexample

@need 1250
@noindent
但现在它是

@smallexample
(set-buffer append-to)
@end smallexample

@noindent
这是因为 @code{append-to} 在 @code{let*} 表达式中先绑定到了 @code{(get-buffer-create buffer)} 的值上。

@code{append-to-buffer} 函数定义将文本从当前缓冲区插入到一个命名的缓冲区中。巧合的是，@code{insert-buffer-substring} 恰好相反——它从另一个缓冲区复制文本到当前缓冲区——这就是为什么 @code{append-to-buffer} 定义以一个 @code{let} 开始的原因，该 @code{let} 将本地符号 @code{oldbuf} 绑定到在执行 @code{append-to-buffer} 命令时的 @code{current-buffer} 的值上。

@need 1250
@code{insert-buffer-substring} 表达式看起来像这样：

@smallexample
(insert-buffer-substring oldbuf start end)
@end smallexample

@noindent
@code{insert-buffer-substring} 函数将一个字符串从其第一个参数指定的缓冲区中复制并插入到当前缓冲区。在这种情况下，@code{insert-buffer-substring} 的参数是由 @code{let} 创建并绑定的变量的值，即 @code{oldbuf} 的值，这是在给出 @code{append-to-buffer} 命令时的当前缓冲区。

在 @code{insert-buffer-substring} 完成其工作后，@code{save-excursion} 将恢复操作到原始缓冲区，而 @code{append-to-buffer} 将完成其工作。

@need 800
以骨架形式编写，主体的工作看起来像这样：

@smallexample
@group
(let (@var{将-}@code{current-buffer}@var{的值绑定到-}@code{oldbuf})
  (save-excursion                       ; @r{跟踪缓冲区。}
    @var{更改缓冲区}
    @var{从-}@code{oldbuf}@var{中插入子串到缓冲区})

  @var{完成时切换回原始缓冲区}
  @var{完成时使-}@code{oldbuf}@var{的局部含义消失}
@end group
@end smallexample

总之，@code{append-to-buffer} 的工作方式如下：它保存了当前缓冲区的值在名为 @code{oldbuf} 的变量中。它获取新的缓冲区（如果需要，创建一个），并将 Emacs 的注意力切换到它。使用 @code{oldbuf} 的值，它将来自旧缓冲区的文本区域插入新缓冲区；然后使用 @code{save-excursion}，它将你带回原始缓冲区。

通过查看 @code{append-to-buffer}，你已经探索了一个相当复杂的函数。它展示了如何使用 @code{let}、@code{save-excursion} 以及如何在不同缓冲区之间切换和返回的方法。许多函数定义都以这种方式使用 @code{let}、@code{save-excursion} 和 @code{set-buffer}。

@node 缓冲区相关复习
@section 复习

这里是本章讨论的各种函数的简要总结。

@table @code
@item describe-function
@itemx describe-variable
打印函数或变量的文档。通常绑定到 @kbd{C-h f} 和 @kbd{C-h v}。

@item xref-find-definitions
查找包含函数或变量源代码的文件，并切换到该文件，将光标定位在该项的开头。通常绑定到 @kbd{M-.}（这是在 @key{META} 键后面加上句点）。

@item save-excursion
保存光标位置，并在评估 @code{save-excursion} 参数后还原其值。还记住当前缓冲区并返回到它。

@item push-mark
在某个位置设置标记，并记录标记环上前一个标记的值。标记是缓冲区中的一个位置，即使在缓冲区中添加或删除文本，它也会保持相对位置。

@item goto-char
将光标设置为由参数的值指定的位置，该参数可以是数字、标记或返回位置数字的表达式，例如 @code{(point-min)}。

@item insert-buffer-substring
从作为参数传递给函数的缓冲区中复制文本区域，并将该区域插入到当前缓冲区中。

@item mark-whole-buffer
将整个缓冲区标记为一个区域。通常绑定到 @kbd{C-x h}。

@item let*
声明一个变量列表并为它们赋初始值；然后评估 @code{let*} 体中的其余表达式。变量的值可以用来绑定列表中随后的变量。

@item set-buffer
将Emacs的注意力切换到另一个缓冲区，但不更改显示的窗口。在程序而不是人类要在不同的缓冲区上工作时使用。

@item get-buffer-create
@itemx get-buffer
查找命名的缓冲区，如果不存在该名称的缓冲区，则创建一个。如果命名的缓冲区不存在，@code{get-buffer} 函数返回 @code{nil}。
@end table

@need 1500
@node 缓冲区练习
@section 练习

@itemize @bullet
@item
编写自己的 @code{simplified-end-of-buffer} 函数定义；然后测试它是否有效。

@item
使用 @code{if} 和 @code{get-buffer} 编写一个函数，该函数打印一条消息，告诉您缓冲区是否存在。

@item
使用 @code{xref-find-definitions} 查找 @code{copy-to-buffer} 函数的源代码。
@end itemize

@node 复杂一些
@chapter 几个更复杂的函数

在这一章中，我们在前几章学到的基础上，深入研究更复杂的函数。@code{copy-to-buffer} 函数演示了在一个定义中使用两个 @code{save-excursion} 表达式，而 @code{insert-buffer} 函数则演示了在 @code{interactive} 表达式中使用星号、使用 @code{or}，以及名称和名称引用的对象之间的重要区别。

@menu
* copy-to-buffer::              使用 @code{set-buffer}、@code{get-buffer-create}。
* insert-buffer::               只读，并带有 @code{or}。
* beginning-of-buffer::         展示了 @code{goto-char}、@code{point-min} 和 @code{push-mark}。
* 第二缓冲区相关回顾::
* 可选练习::
@end menu

@node copy-to-buffer
@section 函数 @code{copy-to-buffer} 的定义
@findex copy-to-buffer

在理解了 @code{append-to-buffer} 的工作原理后，很容易理解 @code{copy-to-buffer}。这个函数将文本复制到一个缓冲区，但与其向第二个缓冲区添加文本不同，它替换了第二个缓冲区中的所有先前文本。

@need 800
@code{copy-to-buffer} 的主体如下，

@smallexample
@group
@dots{}
(interactive "BCopy to buffer: \nr")
(let ((oldbuf (current-buffer)))
  (with-current-buffer (get-buffer-create buffer)
    (barf-if-buffer-read-only)
    (erase-buffer)
    (save-excursion
      (insert-buffer-substring oldbuf start end)))))
@end group
@end smallexample

与 @code{append-to-buffer} 不同，@code{copy-to-buffer} 函数的交互表达式更简单。

@need 800
接下来的定义如下

@smallexample
(with-current-buffer (get-buffer-create buffer) @dots{}
@end smallexample

首先，看最内部的表达式；它首先被评估。该表达式以 @code{get-buffer-create buffer} 开头。该函数告诉计算机使用指定为要复制到的缓冲区的名称，或者如果不存在这样的缓冲区，则创建它。然后，@code{with-current-buffer} 函数使用该缓冲区临时作为当前缓冲区来评估其主体。

（这展示了另一种改变计算机注意力但不改变用户注意力的方法。@code{append-to-buffer} 函数展示了如何使用 @code{save-excursion} 和 @code{set-buffer} 来实现相同的效果。@code{with-current-buffer} 是一种较新、可能更简单的机制。）

@code{barf-if-buffer-read-only} 函数在您无法修改缓冲区时发送错误消息，指示该缓冲区为只读。

接下来的一行只包含 @code{erase-buffer} 函数。该函数擦除缓冲区。

最后，最后两行包含 @code{save-excursion} 表达式，其主体是 @code{insert-buffer-substring}。@code{insert-buffer-substring} 表达式将文本从当前缓冲区复制到另一个缓冲区（您并没有看到计算机改变其注意力，因此您不知道该缓冲区现在被称为 @code{oldbuf}）。

顺便说一下，这就是“替换”的含义。为了替换文本，Emacs 先擦除先前的文本，然后插入新文本。

@need 1250
大致上，@code{copy-to-buffer} 的主体如下：

@smallexample
@group
(let (@var{bind-}@code{oldbuf}@var{-to-value-of-}@code{current-buffer})
    (@var{with-the-buffer-you-are-copying-to}
      (@var{but-do-not-erase-or-copy-to-a-read-only-buffer})
      (erase-buffer)
      (save-excursion
        @var{insert-substring-from-}@code{oldbuf}@var{-into-buffer})))
@end group
@end smallexample

@node insert-buffer
@section 函数 @code{insert-buffer} 的定义
@findex insert-buffer

@code{insert-buffer} 是另一个与缓冲区相关的函数。该命令将另一个缓冲区的内容@emph{插入}到当前缓冲区中。它是 @code{append-to-buffer} 或 @code{copy-to-buffer} 的反向操作，因为它们将文本区域从当前缓冲区@emph{复制到}另一个缓冲区。

以下讨论基于原始代码。该代码在2003年进行了简化，变得更难理解。

(@xref{New insert-buffer, , @code{insert-buffer} 的新主体}, 以查看新主体的讨论。)

此外，这段代码说明了与可能是@dfn{只读}的缓冲区一起使用@code{interactive}的用法，以及对象名称与实际引用的对象之间的重要区别。

@menu
* insert-buffer code::
* insert-buffer interactive::   当您能读取但无法写入时。
* insert-buffer body::          主体包含一个 @code{or} 和一个 @code{let}。
* if & or::                     使用 @code{if} 而不是 @code{or}。
* Insert or::                   @code{or} 表达式的工作原理。
* Insert let::                  两个 @code{save-excursion} 表达式。
* New insert-buffer::
@end menu

@ifnottex
@node insert-buffer code
@unnumberedsubsec @code{insert-buffer} 的代码
@end ifnottex

@need 800
以下是早期的代码：

@smallexample
@group
(defun insert-buffer (buffer)
  "在点之后插入缓冲区的内容。
在插入的文本之后设置标记。
BUFFER 可以是缓冲区或缓冲区名称。"
  (interactive "*bInsert buffer:@: ")
@end group
@group
  (or (bufferp buffer)
      (setq buffer (get-buffer buffer)))
  (let (start end newmark)
    (save-excursion
      (save-excursion
        (set-buffer buffer)
        (setq start (point-min) end (point-max)))
@end group
@group
      (insert-buffer-substring buffer start end)
      (setq newmark (point)))
    (push-mark newmark)))
@end group
@end smallexample

@need 1200
与其他函数定义一样，您可以使用模板查看函数的轮廓：

@smallexample
@group
(defun insert-buffer (buffer)
  "@var{documentation}@dots{}"
  (interactive "*bInsert buffer:@: ")
  @var{body}@dots{})
@end group
@end smallexample

@node insert-buffer interactive
@subsection @code{insert-buffer} 函数中的交互表达式
@findex interactive@r{, 用法示例}

在 @code{insert-buffer} 中，@code{interactive} 声明的参数有两部分，一个星号 @samp{*} 和 @samp{bInsert buffer:@: }。

@menu
* 只读缓冲区::            当缓冲区无法修改时。
* b 用于交互::             存在的缓冲区或其名称。
@end menu

@node 只读缓冲区
@unnumberedsubsubsec 只读缓冲区
@cindex 只读缓冲区
@cindex 用于只读缓冲区的星号
@findex * @r{用于只读缓冲区}

星号用于当前缓冲区为只读缓冲区的情况---无法修改的缓冲区。如果在当前缓冲区为只读时调用 @code{insert-buffer}，将在回显区打印相应的消息，并且终端可能会发出哔声或闪烁；您将无法将任何内容插入当前缓冲区。星号后无需加换行符以将其与下一个参数分隔开。

@node b 用于交互
@unnumberedsubsubsec 交互表达式中的 @samp{b}

交互表达式中的下一个参数以小写 @samp{b} 开头。 （这与 @code{append-to-buffer} 的代码不同，后者使用大写 @samp{B}。@xref{append-to-buffer, , @code{append-to-buffer} 的定义}。）小写 @samp{b} 表示 Lisp 解释器应该将 @code{insert-buffer} 的参数绑定到一个现有缓冲区，否则应该绑定到其名称。Emacs 将提示您输入缓冲区的名称，并提供默认缓冲区，并启用名称补全。如果缓冲区不存在，您将收到消息“没有匹配”；终端也可能会哔哔作响。

新的简化代码生成了 @code{interactive} 的列表。它使用我们已经熟悉的 @code{barf-if-buffer-read-only} 和 @code{read-buffer} 函数以及我们尚不熟悉的 @code{progn} 特殊形式（稍后将进行描述）。

@node insert-buffer body
@subsection @code{insert-buffer} 函数的主体

@code{insert-buffer} 函数的主体有两个主要部分：一个 @code{or} 表达式和一个 @code{let} 表达式。 @code{or} 表达式的目的是确保参数 @code{buffer} 绑定到一个缓冲区，而不仅仅是缓冲区的名称。 @code{let} 表达式的主体包含将另一个缓冲区复制到当前缓冲区的代码。

@need 1250
简而言之，这两个表达式适合于 @code{insert-buffer} 函数，如下所示：

@smallexample
@group
(defun insert-buffer (buffer)
  "@var{documentation}@dots{}"
  (interactive "*bInsert buffer:@: ")
  (or @dots{}
      @dots{}
@end group
@group
  (let (@var{varlist})
      @var{body-of-}@code{let}@dots{} )
@end group
@end smallexample

要理解 @code{or} 表达式如何确保参数 @code{buffer} 绑定到一个缓冲区而不是缓冲区的名称，首先需要了解 @code{or} 函数。

在这之前，让我使用 @code{if} 重新编写此函数的一部分，以便您可以以熟悉的方式看到所做的事情。

@node if & or
@subsection 使用 @code{if} 替代 @code{or} 的 @code{insert-buffer}

要完成的任务是确保 @code{buffer} 的值是一个缓冲区本身，而不是缓冲区的名称。如果值是名称，则必须获取缓冲区本身。

你可以想象自己在一个会议上，一个引座员正拿着一张带有你的名字的名单四处寻找你：引座员与你的名字绑定，而不是与你绑定；但当引座员找到你并搀扶你的手臂时，引座员就与你绑定了。

@need 800
在 Lisp 中，你可以这样描述这种情况：

@smallexample
@group
(if (not (holding-on-to-guest))
    (find-and-take-arm-of-guest))
@end group
@end smallexample

我们想要使用缓冲区做同样的事情——如果我们没有缓冲区本身，我们就希望获取它。

@need 1200
使用一个叫做 @code{bufferp} 的谓词，它告诉我们是否有一个缓冲区（而不是它的名称），我们可以这样编写代码：

@smallexample
@group
(if (not (bufferp buffer))              ; @r{if-部分}
    (setq buffer (get-buffer buffer)))  ; @r{then-部分}
@end group
@end smallexample

@noindent
这里，@code{if} 表达式的真假测试是 @w{@code{(not (bufferp buffer))}}；然后部分是表达式 @w{@code{(setq buffer (get-buffer buffer))}}。

在测试中，函数 @code{bufferp} 如果其参数是一个缓冲区，则返回 true——但如果其参数是缓冲区的名称，则返回 false。 （函数名 @code{bufferp} 的最后一个字符是字符 @samp{p}；正如我们前面看到的，@samp{p} 的这种用法是一个约定，表示该函数是一个谓词，这是一个术语，表示该函数将确定某个属性是真还是假。@xref{错误类型的参数, , 使用错误类型的对象作为参数}.)

@need 1200
函数 @code{not} 位于表达式 @code{(bufferp buffer)} 之前，因此真假测试看起来像这样：

@smallexample
(not (bufferp buffer))
@end smallexample

@noindent
@code{not} 是一个函数，如果其参数为 false，则返回 true；如果其参数为 true，则返回 false。因此，如果 @code{(bufferp buffer)} 返回 true，则 @code{not} 表达式返回 false，反之亦然。

使用这个测试，@code{if} 表达式的工作方式如下：当变量 @code{buffer} 的值实际上是一个缓冲区而不是其名称时，真假测试返回 false，@code{if} 表达式不会评估 then-部分。这是可以的，因为如果它确实是一个缓冲区，我们就不需要对变量 @code{buffer} 做任何操作。

另一方面，当 @code{buffer} 的值不是一个缓冲区本身，而是缓冲区的名称时，真假测试返回 true，并且评估表达式的 then-部分。在这种情况下，then-部分是 @code{(setq buffer (get-buffer buffer))}。该表达式使用 @code{get-buffer} 函数通过名称返回实际的缓冲区本身。然后，@code{setq} 将变量 @code{buffer} 设置为缓冲区本身的值，替换其先前的值（该值是缓冲区的名称）。

@node Insert or
@subsection @code{insert-buffer} 中的 @code{or} 表达式

@code{insert-buffer} 函数中 @code{or} 表达式的目的是确保参数 @code{buffer} 绑定到一个缓冲区，而不仅仅是缓冲区的名称。前一节展示了如何使用 @code{if} 表达式完成此任务。然而，@code{insert-buffer} 函数实际上使用了 @code{or}。要理解这一点，有必要了解 @code{or} 的工作原理。

@findex or
一个 @code{or} 函数可以有任意数量的参数。它依次评估每个参数，并返回其参数中第一个不是 @code{nil} 的值。此外，这是 @code{or} 的一个关键特性，即在返回第一个非 @code{nil} 值后，它不再评估任何后续参数。

@need 800
@code{or} 表达式如下：

@smallexample
@group
(or (bufferp buffer)
    (setq buffer (get-buffer buffer)))
@end group
@end smallexample

@noindent
@code{or} 的第一个参数是表达式 @code{(bufferp buffer)}。如果缓冲区实际上是一个缓冲区而不仅仅是缓冲区的名称，则此表达式返回 true（一个非 @code{nil} 值）。在 @code{or} 表达式中，如果是这种情况，@code{or} 表达式返回这个 true 值，并且不评估下一个表达式——这对我们来说是可以的，因为如果它确实是一个缓冲区，我们就不希望对 @code{buffer} 的值做任何操作。

另一方面，如果 @code{(bufferp buffer)} 的值是 @code{nil}，那么如果 @code{buffer} 的值是缓冲区的名称，Lisp 解释器将评估 @code{or} 表达式的下一个元素。这是表达式 @code{(setq buffer (get-buffer buffer))}。此表达式返回一个非 @code{nil} 值，这是它设置变量 @code{buffer} 的值——并且这个值是缓冲区本身，而不是缓冲区的名称。

所有这些的结果是，符号 @code{buffer} 总是绑定到缓冲区本身而不是缓冲区的名称。所有这些是必要的，因为后面的一行中的 @code{set-buffer} 函数只能与缓冲区本身一起使用，而不能与缓冲区的名称一起使用。

@need 1250
顺便说一下，使用 @code{or}，引座员的情况可以写成这样：

@smallexample
(or (holding-on-to-guest) (find-and-take-arm-of-guest))
@end smallexample

@node Insert let
@subsection @code{insert-buffer} 中的 @code{let} 表达式

在确保变量 @code{buffer} 引用的是缓冲区本身而不仅仅是缓冲区的名称后，@code{insert-buffer} 函数继续使用 @code{let} 表达式。这个表达式指定了三个局部变量 @code{start}、@code{end} 和 @code{newmark}，并将它们绑定到初始值 @code{nil}。这些变量在 @code{let} 的其余部分中被使用，并在 @code{let} 结束之前暂时隐藏了任何同名变量的其他出现。

@need 1200
@code{let} 的主体包含两个 @code{save-excursion} 表达式。首先，我们将详细查看内部 @code{save-excursion} 表达式。表达式如下：

@smallexample
@group
(save-excursion
  (set-buffer buffer)
  (setq start (point-min) end (point-max)))
@end group
@end smallexample

@noindent
表达式 @code{(set-buffer buffer)} 将 Emacs 的注意力从当前缓冲区切换到将要复制文本的缓冲区。在该缓冲区中，使用命令 @code{point-min} 和 @code{point-max} 将变量 @code{start} 和 @code{end} 设置为缓冲区的开始和结束。请注意，这里演示了 @code{setq} 如何能够在同一个表达式中设置两个变量。@code{setq} 的第一个参数设置为其第二个参数的值，其第三个参数设置为其第四个参数的值。

在内部 @code{save-excursion} 的主体被评估之后，@code{save-excursion} 会恢复原始缓冲区，但是 @code{start} 和 @code{end} 仍然设置为将要复制文本的缓冲区的开始和结束的值。

@need 1250
外部 @code{save-excursion} 表达式如下：

@smallexample
@group
(save-excursion
  (@var{inner-}@code{save-excursion}@var{-expression}
     (@var{go-to-new-buffer-and-set-}@code{start}@var{-and-}@code{end})
  (insert-buffer-substring buffer start end)
  (setq newmark (point)))
@end group
@end smallexample

@noindent
@code{insert-buffer-substring} 函数将文本从 @code{buffer} 中的 @code{start} 和 @code{end} 位置插入到当前缓冲区中。由于第二个缓冲区的整体位于 @code{start} 和 @code{end} 之间，第二个缓冲区的整体被复制到你正在编辑的缓冲区中。接下来，点的值，它将位于插入文本的末尾，被记录在变量 @code{newmark} 中。

在外部 @code{save-excursion} 的主体被评估之后，点被重新定位到其原始位置。

然而，方便的是在新插入的文本的末尾放置一个标记，并将点定位在其开头。@code{newmark} 变量记录了插入文本的末尾。在 @code{let} 表达式的最后一行中，@code{(push-mark newmark)} 表达式函数将标记设置为此位置。（标记的先前位置仍然可访问；它记录在标记环上，你可以使用 @kbd{C-u C-@key{SPC}} 返回到它。）与此同时，点位于插入文本的开头，这是你调用插入函数之前的位置，该位置由第一个 @code{save-excursion} 保存。

@need 1250
整个 @code{let} 表达式如下：

@smallexample
@group
(let (start end newmark)
  (save-excursion
    (save-excursion
      (set-buffer buffer)
      (setq start (point-min) end (point-max)))
    (insert-buffer-substring buffer start end)
    (setq newmark (point)))
  (push-mark newmark))
@end group
@end smallexample

与 @code{append-to-buffer} 函数一样，@code{insert-buffer} 函数使用了 @code{let}、@code{save-excursion} 和 @code{set-buffer}。此外，该函数演示了使用 @code{or} 的一种方式。所有这些函数都是我们将一遍又一遍找到并使用的构建块。

@node New insert-buffer
@subsection @code{insert-buffer} 的新主体
@findex insert-buffer@r{, 新版本主体}
@cindex @code{insert-buffer} 的新版本主体

GNU Emacs 22 版本中的主体比原始版本更令人困惑。

@need 1250
它包含两个表达式，

@smallexample
@group
  (push-mark
   (save-excursion
     (insert-buffer-substring (get-buffer buffer))
     (point)))

   nil
@end group
@end smallexample

@noindent
除外，这是使初学者困惑的地方，@code{push-mark} 表达式内部执行了非常重要的工作。

@code{get-buffer} 函数返回一个以提供的名称命名的缓冲区。请注意，该函数并@emph{不}被称为 @code{get-buffer-create}；如果不存在缓冲区，则不会创建一个。由 @code{get-buffer} 返回的缓冲区（已存在的缓冲区）被传递给 @code{insert-buffer-substring}，该函数插入整个缓冲区（因为您没有指定其他内容）。

@code{push-mark} 记录插入缓冲区的位置。然后，该函数返回 @code{nil}，即其最后一条命令的值。换句话说，@code{insert-buffer} 函数仅用于产生副作用，即插入另一个缓冲区，而不是返回任何值。

@node beginning-of-buffer
@section @code{beginning-of-buffer} 函数的完整定义
@findex beginning-of-buffer

@code{beginning-of-buffer} 函数的基本结构已经讨论过了。(@xref{simplified-beginning-of-buffer, , 一个简化的 @code{beginning-of-buffer} 定义}.) 本节描述了定义的复杂部分。

如前所述，当没有参数调用时，@code{beginning-of-buffer} 将光标移动到缓冲区的开头（实际上是可访问部分的开头），并将标记留在先前的位置。然而，当以介于一到十之间的数字调用该命令时，该函数将该数字视为缓冲区长度的十分之一，Emacs 将光标移动到缓冲区的该部分。因此，您可以使用键命令 @kbd{M-<} 调用该函数，将光标移动到缓冲区的开头，或者使用键命令，例如 @kbd{C-u 7 M-<}，将光标移动到缓冲区的70％处。如果使用大于十的数字作为参数，则光标将移动到缓冲区的末尾。

@code{beginning-of-buffer} 函数可以带有或不带有参数调用。使用参数是可选的。

@menu
* Optional Arguments::
* beginning-of-buffer opt arg::  带有可选参数的示例。
* beginning-of-buffer complete::
@end menu

@node Optional Arguments
@subsection 可选参数

除非另有说明，Lisp 期望具有函数定义中参数的函数在调用时将为该参数传递一个值。如果没有这样做，将出现错误并显示消息 @samp{Wrong number of arguments}。

@cindex 可选参数
@cindex 关键字
@findex optional
然而，可选参数是Lisp的一个特性：使用特定的@dfn{关键字}告诉Lisp解释器该参数是可选的。关键字是 @code{&optional}。 （@samp{&} 在 @samp{optional} 前面是关键字的一部分。）在函数定义中，如果一个参数跟在关键字 @code{&optional} 后面，那么在调用函数时无需传递值给该参数。

@need 1200
因此，@code{beginning-of-buffer} 函数的函数定义的第一行看起来像这样：

@smallexample
(defun beginning-of-buffer (&optional arg)
@end smallexample

@need 1250
概括而言，整个函数看起来像这样：

@smallexample
@group
(defun beginning-of-buffer (&optional arg)
  "@var{documentation}@dots{}"
  (interactive "P")
  (or (@var{is-the-argument-a-cons-cell} arg)
      (and @var{are-both-transient-mark-mode-and-mark-active-true})
      (push-mark))
  (let (@var{determine-size-and-set-it})
  (goto-char
    (@var{if-there-is-an-argument}
        @var{figure-out-where-to-go}
      @var{else-go-to}
      (point-min))))
   @var{do-nicety}
@end group
@end smallexample

该函数类似于 @code{simplified-beginning-of-buffer} 函数，只是 @code{interactive} 表达式的参数是 @code{"P"}，并且 @code{goto-char} 函数后面跟着一个 if-then-else 表达式，用于确定如果有一个不是 cons cell 的参数，光标应该放在哪里。

（由于我在很多章节里都没有解释 cons cell，请考虑忽略函数 @code{consp}。@xref{列表实现, , 如何实现列表}，以及 @ref{Cons Cell Type, , Cons Cell and List Types, elisp, The GNU Emacs Lisp Reference Manual}。）

@code{interactive} 表达式中的 @code{"P"} 告诉 Emacs 将前缀参数（如果有的话）以原始形式传递给函数。前缀参数是通过按 @key{META} 键后面跟一个数字，或者按 @kbd{C-u} 然后是一个数字来生成的。（如果不输入数字，@kbd{C-u} 默认为带有 4 的 cons cell。在 @code{interactive} 表达式中的小写 @code{"p"} 会导致函数将前缀参数转换为数字。）

@code{if} 表达式的真值测试看起来复杂，但实际上并不复杂：它检查 @code{arg} 是否具有非 @code{nil} 的值，以及它是否是 cons cell。 （这就是 @code{consp} 做的事情；它检查其参数是否为 cons cell。）如果 @code{arg} 具有非 @code{nil} 的值（并且不是 cons cell），这个真值测试将返回 true，并且 @code{if} 表达式的 then-部分将被评估。另一方面，如果 @code{beginning-of-buffer} 没有带参数调用，@code{arg} 的值将为 @code{nil}，并且 @code{if} 表达式的 else-部分将被评估。else-部分就是 @code{point-min}，当这是结果时，整个 @code{goto-char} 表达式是 @code{(goto-char (point-min))}，这就是我们在简化形式中看到的 @code{beginning-of-buffer} 函数。

@node beginning-of-buffer opt arg
@subsection @code{beginning-of-buffer} with an Argument

当使用参数调用@code{beginning-of-buffer}时，将计算一个表达式来确定传递给@code{goto-char}的值。这个表达式乍一看相当复杂。它包括一个内部的@code{if}表达式和许多算术运算。具体如下：

@smallexample
@group
(if (> (buffer-size) 10000)
    ;; @r{避免大缓冲区大小溢出！}
                          (* (prefix-numeric-value arg)
                             (/ size 10))
  (/
   (+ 10
      (*
       size (prefix-numeric-value arg))) 10)))
@end group
@end smallexample

@menu
* Disentangle beginning-of-buffer::
* Large buffer case::
* Small buffer case::
@end menu

@ifnottex
@node Disentangle beginning-of-buffer
@unnumberedsubsubsec Disentangle @code{beginning-of-buffer}
@end ifnottex

与其他复杂的表达式一样，@code{beginning-of-buffer}中的条件表达式可以通过将其视为模板的一部分（在这种情况下，是if-then-else表达式的模板）来解开。在骨架形式中，该表达式如下：

@smallexample
@group
(if (@var{buffer-is-large}
    @var{divide-buffer-size-by-10-and-multiply-by-arg}
  @var{else-use-alternate-calculation}
@end group
@end smallexample

这个内部的@code{if}表达式的真值或假值测试检查缓冲区的大小。这样做的原因是，旧版本的Emacs使用的数字不超过八百万左右，在随后的计算中，程序员担心如果缓冲区很大，Emacs可能会尝试使用过大的数字。注释中提到的术语“溢出”意味着数字过大。更近期的Emacs版本使用更大的数字，但由于人们现在查看的缓冲区远远大于以往，这段代码没有被更改。

有两种情况：如果缓冲区很大，如果不大。

@node Large buffer case
@unnumberedsubsubsec 在大缓冲区中发生了什么

在@code{beginning-of-buffer}中，内部的@code{if}表达式测试缓冲区的大小是否大于10,000个字符。为了做到这一点，它使用了@code{>}函数和来自let表达式的@code{size}计算。

在旧版本中，使用了@code{buffer-size}函数。不仅调用了该函数多次，而且它给出的是整个缓冲区的大小，而不是可访问部分的大小。当只处理可访问部分时，计算会更有意义。关于将注意力集中到可访问部分的更多信息，请参阅《缩小和扩大》。

@need 800
这一行看起来像这样：

@smallexample
(if (> size 10000)
@end smallexample

@need 1200
@noindent
当缓冲区很大时，@code{if}表达式的then部分将被评估。它读起来像这样（格式化以便阅读）：

@smallexample
@group
(*
  (prefix-numeric-value arg)
  (/ size 10))
@end group
@end smallexample

@noindent
这个表达式是一个乘法，具有@code{*}函数的两个参数。

第一个参数是@code{(prefix-numeric-value arg)}。当@code{interactive}的参数为@code{"P"}时，传递给函数的参数是一个@dfn{原始前缀参数}，而不是一个数字（它是一个列表中的数字）。为了进行算术运算，需要进行转换，@code{prefix-numeric-value}完成了这个任务。

@findex / @r{(division)}
@cindex Division
第二个参数是@code{(/ size 10)}。这个表达式将数值除以十---可访问部分缓冲区大小的数值。这产生一个数字，告诉我们十分之一缓冲区大小由多少字符组成。在Lisp中，@code{/}用于除法，就像@code{*}用于乘法一样。

@need 1200
在整个乘法表达式中，这个数量被乘以前缀参数的值---乘法看起来像这样：

@smallexample
@group
(* @var{numeric-value-of-prefix-arg}
   @var{number-of-characters-in-one-tenth-of-the-accessible-buffer})
@end group
@end smallexample

@noindent
例如，如果前缀参数是@samp{7}，那么十分之一的值将乘以7，以给出在缓冲区大小的70%的位置。

@need 1200
所有这些的结果是，如果可访问部分的缓冲区很大，那么@code{goto-char}表达式将如下：

@smallexample
@group
(goto-char (* (prefix-numeric-value arg)
              (/ size 10)))
@end group
@end smallexample

这把光标放在我们想要的位置。

@node 小缓冲区情况
@unnumberedsubsubsec 小缓冲区中的情况

如果缓冲区包含的字符少于10,000个，将执行略有不同的计算。你可能认为这是不必要的，因为第一种计算方法可以完成工作。然而，在小缓冲区中，第一种方法可能无法将光标精确放置在所需的行上；而第二种方法效果更好。

@need 800
以下是代码：

@c 请将此内容放在一行上。
@smallexample
(/ (+ 10 (* size (prefix-numeric-value arg))) 10))
@end smallexample

@need 1200
@noindent
这是一段代码，你可以通过发现函数嵌套在括号中的方式来理解它的运行。如果每个表达式都比其封闭表达式缩进得更深，那么代码会更容易阅读：

@smallexample
@group
  (/
   (+ 10
      (*
       size
       (prefix-numeric-value arg)))
   10))
@end group
@end smallexample

@need 1200
@noindent
通过查看括号，我们可以看到最内层的操作是@code{(prefix-numeric-value arg)}，它将原始参数转换为数字。在下面的表达式中，这个数字被乘以缓冲区的可访问部分的大小：

@smallexample
(* size (prefix-numeric-value arg))
@end smallexample

@noindent
这个乘法会产生一个可能比缓冲区的大小更大的数字——例如，如果参数是7，那么这个数字会大七倍。然后，这个数字加上10，最终将这个大数字除以10，得到的值比缓冲区中的百分比位置多一个字符。

所有这些计算得到的数字被传递给@code{goto-char}，并将光标移动到该位置。

@need 1500
@node beginning-of-buffer complete
@subsection 完整的@code{beginning-of-buffer}

@need 1000
下面是@code{beginning-of-buffer}函数的完整文本：
@sp 1

@c 在GNU Emacs 22中
@smallexample
@group
(defun beginning-of-buffer (&optional arg)
  "将点移到缓冲区的开头；在先前位置留下标记。
使用 \\[universal-argument] 前缀时，不在先前位置设置标记。
使用数值参数 N 时，将点设置为从开头开始的 N/10 处。

如果缩小了缓冲区，
此命令使用缓冲区的可访问部分的开头和大小。
@end group

@group
不要在Lisp程序中使用这个命令！
\(goto-char (point-min))更快
且不会破坏标记。"
  (interactive "P")
  (or (consp arg)
      (and transient-mark-mode mark-active)
      (push-mark))
@end group
@group
  (let ((size (- (point-max) (point-min))))
    (goto-char (if (and arg (not (consp arg)))
                   (+ (point-min)
                      (if (> size 10000)
                          ;; 避免大缓冲区大小的溢出！
                          (* (prefix-numeric-value arg)
                             (/ size 10))
                        (/ (+ 10 (* size (prefix-numeric-value arg)))
                           10)))
                 (point-min))))
  (if (and arg (not (consp arg))) (forward-line 1)))
@end group
@end smallexample

@ignore
从GNU Emacs 22之前
@smallexample
@group
(defun beginning-of-buffer (&optional arg)
  "将点移到缓冲区的开头；在先前位置留下标记。
如果有参数 N，则将点设置为从真正开头开始的 N/10 处。
@end group
@group
不要在Lisp程序中使用这个！
\(goto-char (point-min))更快
且不会设置标记。"
  (interactive "P")
  (push-mark)
@end group
@group
  (goto-char
   (if arg
       (if (> (buffer-size) 10000)
           ;; @r{避免大缓冲区大小的溢出！}
           (* (prefix-numeric-value arg)
              (/ (buffer-size) 10))
@end group
@group
         (/ (+ 10 (* (buffer-size)
                     (prefix-numeric-value arg)))
            10))
     (point-min)))
  (if arg (forward-line 1)))
@end group
@end smallexample
@end ignore

@noindent
除了文档字符串中的一个细节和函数的最后一行之外，前面的讨论展示了这个函数的工作原理。

@need 800
在文档字符串中，有一个表达式的引用：

@smallexample
\\[universal-argument]
@end smallexample

@noindent
在这个表达式的第一个方括号之前使用了@samp{\\}。这个@samp{\\}告诉Lisp解释器替换当前绑定到@samp{[@dots{}]}的键。在@code{universal-argument}的情况下，通常是@kbd{C-u}，但也可能不同。有关更多信息，@xref{Documentation Tips, ,文档字符串提示, GNU Emacs Lisp参考手册}。

@need 1200
最后，@code{beginning-of-buffer}命令的最后一行指示，如果带有参数调用命令：

@smallexample
(if (and arg (not (consp arg))) (forward-line 1))
@end smallexample

@noindent
如果使用@kbd{C-u}指定命令，但没有数字，也就是说，原始前缀参数只是一个cons单元，该命令将光标放在第二行的开头。

@node 第二缓冲区相关复习
@section 复习

这里是对本章涵盖的一些主题的简要总结。

@table @code
@item or
依次评估每个参数，并返回第一个不是 @code{nil} 的参数的值；如果没有返回一个不是 @code{nil} 的值，则返回 @code{nil}。简言之，返回参数中的第一个真值；如果其中任何一个是真值，则返回真值。

@item and
依次评估每个参数，并且如果任何一个是 @code{nil}，则返回 @code{nil}；如果没有一个是 @code{nil}，则返回最后一个参数的值。简言之，只有当所有参数都为真时才返回真值；如果其中任何一个为真，则返回真值。

@item &optional
用于指示函数定义中的参数是可选的关键字；这意味着如果需要，可以在不提供参数的情况下评估函数。

@item prefix-numeric-value
将由 @code{(interactive "P")} 生成的原始前缀参数转换为数值。

@item forward-line
将点移动到下一行的开头，或者如果参数大于一，则向前移动那么多行。如果无法移动到应该移动到的位置，@code{forward-line} 将尽量向前移动，并返回无法移动的额外行数的计数。

@item erase-buffer
删除当前缓冲区的所有内容。

@item bufferp
如果其参数是缓冲区，则返回 @code{t}；否则返回 @code{nil}。
@end table

@node optional Exercise
@section @code{optional} 参数练习

编写一个交互式函数，该函数带有一个可选参数，用于测试其参数（一个数字）是否大于或等于 @code{fill-column} 的值，否则，小于该值，并通过消息告诉您结果。然而，如果您没有向函数传递参数，则使用默认值56。

@node 缩窄与扩大
@chapter 缩窄与扩大
@cindex 焦点集中（缩窄）
@cindex 缩窄
@cindex 扩大

缩窄是Emacs的一个功能，使您能够专注于缓冲区的特定部分，并且在不小心更改其他部分的情况下工作。通常情况下，缩窄是禁用的，因为它可能使初学者感到困惑。

@menu
* 缩窄的优势::              缩窄的优势
* save-restriction::        @code{save-restriction} 特殊形式。
* what-line::               光标所在行的行号。
* 缩窄练习::
@end menu

@ifnottex
@node 缩小的优势
@unnumberedsec 缩小的优势
@end ifnottex

通过缩小，缓冲区的其余部分被隐藏起来，就好像它们不存在一样。这是一个优势，例如，如果你想替换缓冲区的某个部分中的一个单词，而不影响其他部分，你可以缩小到你想要的部分，替换只在该部分进行，而不影响缓冲区的其余部分。搜索也仅在缩小的区域内工作，而不在外部，因此如果你正在修复文档的一部分，你可以通过缩小到你想要的区域来防止意外地找到不需要修复的部分。
（@code{narrow-to-region}的键绑定是@kbd{C-x n n}。）

然而，缩小会使缓冲区的其余部分变得不可见，这可能会吓到那些不小心调用缩小并认为已删除文件的一部分的人。此外，@code{undo}命令（通常绑定到@kbd{C-x u}）不会取消缩小（也不应该取消），所以如果人们不知道可以使用@code{widen}命令将缓冲区的其余部分恢复为可见状态，他们可能会变得相当绝望。
（@code{widen}的键绑定是@kbd{C-x n w}。）

缩小对Lisp解释器和人类一样有用。通常，Emacs Lisp函数被设计为仅在缓冲区的一部分上工作；或者相反，Emacs Lisp函数需要在已经缩小的整个缓冲区上工作。例如，@code{what-line}函数会在缓冲区存在缩小的情况下移除缩小，并在完成工作后将缩小恢复到原来的状态。另一方面，@code{count-lines}函数使用缩小来限制自己只在其感兴趣的缓冲区部分中运行，然后恢复到先前的情况。

@node save-restriction
@section 特殊形式 @code{save-restriction}
@findex save-restriction

在Emacs Lisp中，你可以使用特殊形式 @code{save-restriction} 来追踪当前是否存在缩小范围的情况。当Lisp解释器遇到 @code{save-restriction} 时，它会执行 @code{save-restriction} 表达式体中的代码，然后撤销代码引起的任何缩小范围的更改。例如，如果缓冲区被缩小，而跟在 @code{save-restriction} 后面的代码消除了缩小，则 @code{save-restriction} 将在之后将缓冲区恢复到缩小的区域。在 @code{what-line} 命令中，由 @code{save-restriction} 命令后立即执行的 @code{widen} 命令会撤销缓冲区可能存在的任何缩小。任何原始的缩小在函数完成之前都会被恢复。

@need 1250
@code{save-restriction} 表达式的模板很简单：

@smallexample
@group
(save-restriction
  @var{body}@dots{} )
@end group
@end smallexample

@noindent
@code{save-restriction} 的体是一个或多个将由Lisp解释器按顺序评估的表达式。

最后，需要注意的一点是：当你同时使用 @code{save-excursion} 和 @code{save-restriction}，并且它们紧跟在彼此之后时，应该将 @code{save-excursion} 放在最外层。如果你以相反的顺序编写它们，可能无法记录Emacs在调用 @code{save-excursion} 后切换到的缓冲区的缩小。因此，在一起编写时，@code{save-excursion} 和 @code{save-restriction} 应该像这样编写：

@smallexample
@group
(save-excursion
  (save-restriction
    @var{body}@dots{}))
@end group
@end smallexample

在其他情况下，当它们没有一起编写时，@code{save-excursion} 和 @code{save-restriction} 特殊形式必须按照适合函数的顺序编写。

@need 1250
例如，

@smallexample
@group
  (save-restriction
    (widen)
    (save-excursion
    @var{body}@dots{}))
@end group
@end smallexample

@ignore
Emacs 22
/usr/local/src/emacs/lisp/simple.el

(defun what-line ()
  "Print the current buffer line number and narrowed line number of point."
  (interactive)
  (let ((start (point-min))
        (n (line-number-at-pos)))
    (if (= start 1)
        (message "Line %d" n)
      (save-excursion
        (save-restriction
          (widen)
          (message "line %d (narrowed line %d)"
                   (+ n (line-number-at-pos start) -1) n))))))

(defun line-number-at-pos (&optional pos)
  "Return (narrowed) buffer line number at position POS.
If POS is nil, use current buffer location.
Counting starts at (point-min), so the value refers
to the contents of the accessible portion of the buffer."
  (let ((opoint (or pos (point))) start)
    (save-excursion
      (goto-char (point-min))
      (setq start (point))
      (goto-char opoint)
      (forward-line 0)
      (1+ (count-lines start (point))))))

(defun count-lines (start end)
  "Return number of lines between START and END.
This is usually the number of newlines between them,
but can be one more if START is not equal to END
and the greater of them is not at the start of a line."
  (save-excursion
    (save-restriction
      (narrow-to-region start end)
      (goto-char (point-min))
      (if (eq selective-display t)
          (save-match-data
            (let ((done 0))
              (while (re-search-forward "[\n\C-m]" nil t 40)
                (setq done (+ 40 done)))
              (while (re-search-forward "[\n\C-m]" nil t 1)
                (setq done (+ 1 done)))
              (goto-char (point-max))
              (if (and (/= start end)
                       (not (bolp)))
                  (1+ done)
                done)))
        (- (buffer-size) (forward-line (buffer-size)))))))
@end ignore

@node 行号
@section @code{what-line}
@findex what-line
@cindex 扩展，示例

@code{what-line}命令告诉您光标所在位置的行号。该函数演示了@code{save-restriction}和@code{save-excursion}命令的用法。以下是该函数的原始文本：

@smallexample
@group
(defun what-line ()
  "打印光标所在位置（在缓冲区中）的当前行号。"
  (interactive)
  (save-restriction
    (widen)
    (save-excursion
      (beginning-of-line)
      (message "第%d行"
               (1+ (count-lines 1 (point)))))))
@end group
@end smallexample

（在GNU Emacs的现代版本中，@code{what-line}函数已经扩展，不仅告诉您在扩展缓冲区中的行号，还告诉您在狭窄缓冲区中的行号。现代版本比这里展示的版本更复杂。如果您感到有冒险精神，可以在弄清楚此版本的工作原理后查看它。您可能需要使用@kbd{C-h f}（@code{describe-function}）。新版本使用条件判断确定缓冲区是否已经被狭窄。

此外，@code{what-line}的现代版本使用@code{line-number-at-pos}，它除了简单的表达式（例如@code{(goto-char (point-min))}）外，还使用@code{(forward-line 0)}将光标移动到当前行的开头，而不是@code{beginning-of-line}。）

这里展示的@code{what-line}函数具有文档行并且是交互式的，正如您所期望的那样。接下来的两行使用了@code{save-restriction}和@code{widen}函数。

@code{save-restriction}特殊形式记录当前缓冲区中任何有效的缩小范围（如果有的话），并在@code{save-restriction}的主体代码被评估后恢复该缩小范围。

@code{save-restriction}特殊形式后跟@code{widen}。此函数撤消了在调用@code{what-line}时当前缓冲区可能存在的任何缩小。 （@code{save-restriction}记住的是存在的缩小。）这种扩展使得行计数命令能够从缓冲区的开头计数。否则，它们将受限于在可访问区域内计数。任何原始缩小都在@code{save-restriction}特殊形式完成函数后立即恢复。

对@code{widen}的调用后跟@code{save-excursion}，该函数保存光标（即点）的位置，并在@code{save-excursion}的主体代码使用@code{beginning-of-line}函数移动点后恢复它。

（请注意，@code{(widen)}表达式位于@code{save-restriction}和@code{save-excursion}特殊形式之间。当您按顺序编写两个@code{save- @dots{}}表达式时，将@code{save-excursion}写在最外层。）

@need 1200
@code{what-line}函数的最后两行是用于计算缓冲区中行数然后在回显区打印该数字的函数。

@smallexample
@group
(message "第%d行"
         (1+ (count-lines 1 (point)))))))
@end group
@end smallexample

@code{message}函数在Emacs屏幕底部打印一行消息。第一个参数位于引号中，被打印为一个字符串。但是，它可能包含@samp{%d}表达式，以打印后续参数。@samp{%d}将参数打印为十进制数，因此消息将显示类似于@samp{第243行}的内容。

@need 1200
替换@samp{%d}的位置打印的数字由函数的最后一行计算：

@smallexample
(1+ (count-lines 1 (point)))
@end smallexample

@ignore
GNU Emacs 22

(defun count-lines (start end)
  "返回START和END之间的行数。
通常这是它们之间的换行符数，
但是如果START不等于END并且它们中的较大者不在行的开头，则可能多一行。"
  (save-excursion
    (save-restriction
      (narrow-to-region start end)
      (goto-char (point-min))
      (if (eq selective-display t)
          (save-match-data
            (let ((done 0))
              (while (re-search-forward "[\n\C-m]" nil t 40)
                (setq done (+ 40 done)))
              (while (re-search-forward "[\n\C-m]" nil t 1)
                (setq done (+ 1 done)))
              (goto-char (point-max))
              (if (and (/= start end)
                       (not (bolp)))
                  (1+ done)
                done)))
        (- (buffer-size) (forward-line (buffer-size)))))))
@end ignore

@noindent
这是从缓冲区的第一个位置（由@code{1}指示）到@code{(point)}的行数，然后将其加一。 （@code{1+}函数将其参数加一。）我们加一是因为第2行之前只有一行，而@code{count-lines}只计算当前行之前的行。

在@code{count-lines}完成其工作并且消息已经在回显区打印后，@code{save-excursion}将点还原到其原始位置；@code{save-restriction}恢复原始的缩小（如果有的话）。

@node narrow Exercise
@section 使用 Narrowing 进行练习

编写一个函数，即使将缓冲区缩小到其后半部分以至于第一行不可访问，也能显示当前缓冲区的前60个字符。需要使用一系列函数，包括 @code{save-restriction}、@code{widen}、@code{goto-char}、@code{point-min}、@code{message} 和 @code{buffer-substring}。

@cindex 属性提及 @code{buffer-substring-no-properties}
（@code{buffer-substring} 是一个先前未提及的函数，您需要自行查阅；或者您可能需要使用 @code{buffer-substring-no-properties} 或 @code{filter-buffer-substring} @dots{}，还有其他函数。文本属性是本文未讨论的另一个功能。@xref{文本属性, , 文本属性, elisp, The GNU Emacs Lisp Reference Manual}。）

另外，是否真的需要 @code{goto-char} 或 @code{point-min}？或者您能否在不使用它们的情况下编写该函数？

@node car cdr & cons
@chapter @code{car}、@code{cdr} 和 @code{cons}：基本函数
@findex car@r{, introduced}
@findex cdr@r{, introduced}

在 Lisp 中，@code{car}、@code{cdr} 和 @code{cons} 是基本函数。@code{cons} 函数用于构建列表，而 @code{car} 和 @code{cdr} 函数用于分解列表。

在 @code{copy-region-as-kill} 函数的演练中，我们将看到 @code{cons} 以及两个变体的 @code{cdr}，即 @code{setcdr} 和 @code{nthcdr}。(@xref{copy-region-as-kill}.)

@menu
* Strange Names::               一个历史插曲：为什么是这些奇怪的名字？
* car & cdr::                   用于提取列表的部分的函数。
* cons::                        构建列表。
* nthcdr::                      反复调用 @code{cdr}。
* nth::
* setcar::                      更改列表的第一个元素。
* setcdr::                      更改列表的其余部分。
* cons Exercise::
@end menu

@ifnottex
@node Strange Names
@unnumberedsec Strange Names
@end ifnottex

@code{cons} 函数的名称并不无道理：它是“construct”一词的缩写。另一方面，@code{car} 和 @code{cdr} 的命名起源有些深奥：@code{car} 是短语“Contents of the Address part of the Register”的首字母缩写；而 @code{cdr}（发音为“could-er”）是短语“Contents of the Decrement part of the Register”的首字母缩写。这些短语指的是原始 Lisp 开发时使用的 IBM 704 计算机。

IBM 704 在历史上留下了痕迹，但这些名字现在已经成为 Lisp 珍爱的传统。

@node car & cdr
@section @code{car} 和 @code{cdr}

列表的 @sc{car}（首元素）简单地就是列表中的第一个项。因此，列表 @code{(rose violet daisy buttercup)} 的 @sc{car} 就是 @code{rose}。

@need 1200
如果你在 GNU Emacs 的 Info 中阅读此文档，你可以通过执行以下命令来验证：

@smallexample
(car '(rose violet daisy buttercup))
@end smallexample

@noindent
在执行此表达式之后，@code{rose} 将会出现在回显区域。

@code{car} 不会从列表中删除第一个项；它只是报告这个项是什么。在术语中，@code{car} 是“非破坏性”的。这一特性事实上变得很重要。

列表的 @sc{cdr}（剩余元素）是列表中剩下的部分，即 @code{cdr} 函数返回紧随第一个项之后的列表部分。因此，虽然列表 @code{'(rose violet daisy buttercup)} 的 @sc{car} 是 @code{rose}，但列表的其余部分，即 @code{cdr} 函数返回的值，是 @code{(violet daisy buttercup)}。

@need 800
你可以通过以通常的方式执行以下命令来验证这一点：

@smallexample
(cdr '(rose violet daisy buttercup))
@end smallexample

@noindent
当你执行此命令时，@code{(violet daisy buttercup)} 将会出现在回显区域。

与 @code{car} 一样，@code{cdr} 也不会从列表中移除任何元素，它只是返回第二个及后续元素的报告。

顺便说一下，在例子中，花卉列表是被引用的。如果没有引用，Lisp 解释器会尝试通过调用 @code{rose} 作为函数来评估列表。在这个例子中，我们不想这样做。

在处理列表时，使用 @code{first} 和 @code{rest} 这样的名称可能比 @code{car} 和 @code{cdr} 更有意义。事实上，一些程序员会将 @code{first} 和 @code{rest} 定义为 @code{car} 和 @code{cdr} 的别名，然后在代码中使用 @code{first} 和 @code{rest}。

然而，在Lisp中，列表是使用称为“cons单元”（@pxref{列表实现}）的较低级结构构建的，在其中“第一个”或“剩余”这样的概念是不存在的，而 @sc{car} 和 @sc{cdr} 是对称的。Lisp 不会隐藏 cons 单元的存在，程序也会将它们用于除列表之外的其他事物。因此，这些名称有助于提醒程序员，尽管在列表中它们是不对称使用的，但 @code{car} 和 @code{cdr} 实际上是对称的。

@ignore
很显然，对于 @code{cdr} 来说，一个更合理的名字应该是 @code{rest}。

（这里有一个教训：当给新函数命名时，要非常谨慎，因为你可能会一直使用这些名称的时间比你预期的长。这份文档之所以延续使用这些名称，是因为 Emacs Lisp 源代码使用了它们，如果我不使用它们，你将很难阅读代码；但请尽量避免在自己的代码中使用这些术语。以后的人会感激你的。）
@end ignore

当 @code{car} 和 @code{cdr} 应用于由符号组成的列表时（例如，列表 @code{(pine fir oak maple)}），函数 @code{car} 返回的列表元素是符号 @code{pine} 而没有括号。@code{pine} 是列表中的第一个元素。然而，列表的 @sc{cdr} 本身是一个列表，即 @code{(fir oak maple)}，你可以通过以通常的方式执行以下表达式来验证：

@smallexample
@group
(car '(pine fir oak maple))

(cdr '(pine fir oak maple))
@end group
@end smallexample

另一方面，在列表的列表中，第一个元素本身是一个列表。例如，以下列表包含三个子列表，一个肉食动物列表，一个食草动物列表和一个海洋哺乳动物列表：

@smallexample
@group
(car '((lion tiger cheetah)
       (gazelle antelope zebra)
       (whale dolphin seal)))
@end group
@end smallexample

@noindent
在这个例子中，列表的第一个元素或 @sc{car} 是肉食动物列表 @code{(lion tiger cheetah)}，而列表的其余部分是 @code{((gazelle antelope zebra) (whale dolphin seal))}。

@smallexample
@group
(cdr '((lion tiger cheetah)
       (gazelle antelope zebra)
       (whale dolphin seal)))
@end group
@end smallexample

值得再次强调的是，@code{car} 和 @code{cdr} 是非破坏性的——也就是说，它们不会修改或改变应用到它们的列表。这对它们的使用非常重要。

另外，在第一章中，关于原子的讨论中，我提到在Lisp中，某些类型的原子，例如数组，可以被分解成部分；但这个机制与拆分列表的机制不同。就Lisp而言，列表的原子是不可分割的。(@xref{Lisp Atoms}.) @code{car} 和 @code{cdr} 函数用于拆分列表，被认为是Lisp的基本功能。由于它们不能拆分或访问数组的部分，数组被认为是原子。相反，另一个基本函数 @code{cons} 可以组合或构造列表，但不能构造数组。 （数组由数组特定的函数处理。@xref{Arrays, , Arrays, elisp, The GNU Emacs Lisp Reference Manual}。）

@node cons
@section @code{cons}
@findex cons@r{, introduced}

@code{cons}函数用于构建列表；它是@code{car}和@code{cdr}的反函数。例如，@code{cons}可以用来从三元素列表@code{(fir oak maple)}中创建一个四元素列表：

@smallexample
(cons 'pine '(fir oak maple))
@end smallexample

@need 800
@noindent
在评估了这个列表之后，你将会看到：

@smallexample
(pine fir oak maple)
@end smallexample

@noindent
出现在回显区。@code{cons}导致创建一个新的列表，其中元素后面是原始列表的元素。

我们经常说@code{cons}将一个新元素放在列表的开头，或者附加或推送元素到列表中，但这种表达可能会误导，因为@code{cons}不会改变现有的列表，而是创建一个新列表。

与@code{car}和@code{cdr}一样，@code{cons}是非破坏性的。

@menu
* 构建列表::
* 长度::                      如何找到列表的长度。
@end menu

@ifnottex
@node 构建列表
@unnumberedsubsec 构建列表
@end ifnottex

@code{cons}必须有一个要附加的列表。@footnote{实际上，你可以将元素@code{cons}到原子上以生成一个点对。这里不讨论点对；参见@ref{Dotted Pair Notation, , Dotted Pair Notation, elisp, The GNU Emacs Lisp Reference Manual}。} 你不能从绝对的空白开始。如果你正在构建一个列表，你需要至少在开头提供一个空列表。以下是一系列的@code{cons}表达式，用于构建一系列花的列表。如果你在GNU Emacs中的Info中阅读这个，你可以按照通常的方式评估每个表达式；值将在这个文本中以@samp{@result{}}打印出来，你可以将其解读为“评估为”。

@smallexample
@group
(cons 'buttercup ())
     @result{} (buttercup)
@end group

@group
(cons 'daisy '(buttercup))
     @result{} (daisy buttercup)
@end group

@group
(cons 'violet '(daisy buttercup))
     @result{} (violet daisy buttercup)
@end group

@group
(cons 'rose '(violet daisy buttercup))
     @result{} (rose violet daisy buttercup)
@end group
@end smallexample

@noindent
在第一个例子中，空列表显示为@code{()}，并构建了一个由@code{buttercup}后面跟着空列表的列表。正如你所见，空列表在构建的列表中没有显示。因为空列表中没有任何内容，通常来说，空列表是不可见的。

在第二个例子中，@code{(cons 'daisy '(buttercup))}通过将@code{daisy}放在@code{buttercup}前面构建了一个新的两元素列表；第三个例子通过将@code{violet}放在@code{daisy}和@code{buttercup}前面构建了一个三元素列表。

@node 长度
@subsection 查找列表的长度：@code{length}
@findex length

你可以使用Lisp函数@code{length}来查找列表中有多少元素，例如以下示例：

@smallexample
@group
(length '(buttercup))
     @result{} 1
@end group

@group
(length '(daisy buttercup))
     @result{} 2
@end group

@group
(length (cons 'violet '(daisy buttercup)))
     @result{} 3
@end group
@end smallexample

@noindent
在第三个例子中，@code{cons}函数用于构建一个包含三个元素的列表，然后将其作为参数传递给@code{length}函数。

@need 1200
我们还可以使用@code{length}来计算空列表中的元素个数：

@smallexample
@group
(length ())
     @result{} 0
@end group
@end smallexample

@noindent
正如你所期望的那样，空列表中的元素个数为零。

一个有趣的实验是找出当你尝试找到根本没有列表的长度时会发生什么；也就是说，如果你尝试调用@code{length}而没有给它提供参数，甚至没有空列表：

@smallexample
(length )
@end smallexample

@need 800
@noindent
如果你评估这个表达式，你将看到错误消息：

@smallexample
Lisp error: (wrong-number-of-arguments length 0)
@end smallexample

@noindent
这意味着函数在期望某个其他数量的参数时（在本例中是一个参数），收到了错误数量的参数，即零。在这种情况下，期望一个参数，而参数是要测量其长度的列表。（注意，@emph{一个}列表是@emph{一个}参数，即使列表内有多个元素。）

错误消息中的@samp{length}是函数的名称。

@ignore
@code{length}仍然是一个子例程，但你需要使用C-h f来发现这一点。

在早期版本中：
这是用一种特殊的符号@samp{#<subr}写的，表示函数@code{length}是用C编写而不是用Emacs Lisp编写的原始函数之一。(@samp{subr}是“子例程”的缩写。) 更多关于子例程的信息，请参阅@ref{What Is a Function, , What Is a Function?, elisp, The GNU Emacs Lisp Reference Manual}。
@end ignore

@node nthcdr
@section @code{nthcdr}
@findex nthcdr

函数 @code{nthcdr} 与函数 @code{cdr} 相关联。它的作用是重复地取一个列表的 @sc{cdr}。

如果对列表 @code{(pine fir oak maple)} 进行 @sc{cdr} 操作，将得到列表 @code{(fir oak maple)}。如果在这个结果上再进行一次 @sc{cdr}，将得到列表 @code{(oak maple)}。当然，对原始列表反复 @sc{cdr} 只会得到原始的 @sc{cdr}，因为该函数不会改变列表。需要对 @sc{cdr} 进行评估，然后继续操作。最终，你将得到一个空列表，在这个例子中，它显示为 @code{nil} 而非 @code{()}。

@need 1200
为了复习，以下是一系列重复的 @sc{cdr} 操作，@samp{@result{}} 后的文本显示了返回的结果。

@smallexample
@group
(cdr '(pine fir oak maple))
     @result{} (fir oak maple)
@end group

@group
(cdr '(fir oak maple))
     @result{} (oak maple)
@end group

@group
(cdr '(oak maple))
     @result{} (maple)
@end group

@group
(cdr '(maple))
     @result{} nil
@end group

@group
(cdr 'nil)
     @result{} nil
@end group

@group
(cdr ())
     @result{} nil
@end group
@end smallexample

@need 1200
你也可以进行多次 @sc{cdr} 操作而不打印中间值，像这样：

@smallexample
@group
(cdr (cdr '(pine fir oak maple)))
     @result{} (oak maple)
@end group
@end smallexample

@noindent
在这个例子中，Lisp 解释器首先评估最内层的列表。最内层的列表被引用，因此它只是将列表传递给最内层的 @code{cdr}。这个 @code{cdr} 将由列表的第二个及之后的元素组成的列表传递给最外层的 @code{cdr}，产生一个由原始列表的第三个及之后的元素组成的列表。在这个例子中，重复调用 @code{cdr} 函数并返回一个由原始列表的前两个元素之外的元素组成的列表。

函数 @code{nthcdr} 的作用与重复调用 @code{cdr} 相同。在下面的例子中，参数 2 被传递给函数 @code{nthcdr}，连同列表一起传递，返回的值是没有前两个项的列表，这与在列表上连续调用两次 @code{cdr} 是一样的：

@smallexample
@group
(nthcdr 2 '(pine fir oak maple))
     @result{} (oak maple)
@end group
@end smallexample

@need 1200
使用原始的四个元素列表，我们可以看到当传递不同的数值参数给 @code{nthcdr} 时会发生什么，包括 0、1 和 5：

@smallexample
@group
;; @r{保留列表不变。}
(nthcdr 0 '(pine fir oak maple))
     @result{} (pine fir oak maple)
@end group

@group
;; @r{返回去掉第一个元素的列表副本。}
(nthcdr 1 '(pine fir oak maple))
     @result{} (fir oak maple)
@end group

@group
;; @r{返回去掉三个元素的列表副本。}
(nthcdr 3 '(pine fir oak maple))
     @result{} (maple)
@end group

@group
;; @r{返回去掉所有四个元素的列表副本。}
(nthcdr 4 '(pine fir oak maple))
     @result{} nil
@end group

@group
;; @r{返回去掉所有元素的列表副本。}
(nthcdr 5 '(pine fir oak maple))
     @result{} nil
@end group
@end smallexample

@node nth
@section @code{nth}
@findex nth

函数 @code{nthcdr} 重复获取列表的 @sc{cdr}。函数 @code{nth} 获取由 @code{nthcdr} 返回的结果的 @sc{car}。它返回列表的第 N 个元素。

@need 1500
因此，如果不是为了速度而在C中定义，@code{nth} 的定义将是：

@smallexample
@group
(defun nth (n list)
  "返回列表 LIST 的第 N 个元素。
N 从零开始计数。如果列表没有那么长，则返回 nil。"
  (car (nthcdr n list)))
@end group
@end smallexample

@noindent
(最初，@code{nth} 是在Emacs Lisp中在@file{subr.el}中定义的，但它的定义在1980年代被重写为C语言。)

@code{nth} 函数返回列表的单个元素。这可能非常方便。

请注意，元素从零开始编号，而不是从一开始。也就是说，列表的第一个元素，它的 @sc{car} 是零号元素。这种从零开始计数通常会让习惯于列表中第一个元素为编号一的人感到困扰。

@need 1250
例如：

@smallexample
@group
(nth 0 '("one" "two" "three"))
    @result{} "one"

(nth 1 '("one" "two" "three"))
    @result{} "two"
@end group
@end smallexample

值得一提的是，@code{nth}、@code{nthcdr} 和 @code{cdr} 都不会改变原始列表---这些函数是非破坏性的。这与 @code{setcar} 和 @code{setcdr} 函数形成鲜明对比。

@node setcar
@section @code{setcar}
@findex setcar

从它们的名字中，你可能已经猜到了，@code{setcar} 和 @code{setcdr} 函数用于将列表的 @sc{car} 或 @sc{cdr} 设置为新值。它们实际上会改变原始列表，与 @code{car} 和 @code{cdr} 不同，它们保持原始列表不变。了解这是如何工作的一种方法是进行实验。我们首先来看一下 @code{setcar} 函数。

@need 1200
首先，我们可以创建一个列表，然后使用 @code{setq} 特殊形式将变量的值设置为该列表。因为我们打算使用 @code{setcar} 来更改列表，所以这个 @code{setq} 不应该使用引用形式 @code{'(antelope giraffe lion tiger)}，因为那将产生一个程序的一部分的列表，如果我们尝试在运行时更改程序的一部分，可能会导致问题。通常来说，Emacs Lisp 程序的组件在程序运行时应该是常量（或不变的）。因此，我们使用 @code{list} 函数构造一个动物列表，如下所示：

@smallexample
(setq animals (list 'antelope 'giraffe 'lion 'tiger))
@end smallexample

@noindent
如果你在 GNU Emacs 中的 Info 中阅读这篇文章，你可以通过按 @kbd{C-x C-e} 将光标定位在表达式之后，以通常的方式评估这个表达式。（我在写这篇文章的时候就是这样做的。这是将解释器内置到计算环境中的优势之一。顺便说一句，当最终括号之后的行上没有任何内容，比如注释时，光标可以在下一行。因此，如果你的光标在下一行的第一列，你不需要移动它。事实上，Emacs 允许在最终括号之后有任意量的空白。）

@need 1200
当我们评估变量 @code{animals} 时，我们看到它绑定到列表 @code{(antelope giraffe lion tiger)}：

@smallexample
@group
animals
     @result{} (antelope giraffe lion tiger)
@end group
@end smallexample

@noindent
换句话说，变量 @code{animals} 指向列表 @code{(antelope giraffe lion tiger)}。

接下来，评估函数 @code{setcar}，同时传递给它两个参数，变量 @code{animals} 和引用的符号 @code{hippopotamus}；这是通过编写三个元素的列表 @code{(setcar animals 'hippopotamus)}，然后以通常的方式评估它来完成的：

@smallexample
(setcar animals 'hippopotamus)
@end smallexample

@need 1200
@noindent
评估完这个表达式后，再次评估变量 @code{animals}。你会看到动物列表已经改变了：

@smallexample
@group
animals
     @result{} (hippopotamus giraffe lion tiger)
@end group
@end smallexample

@noindent
列表的第一个元素 @code{antelope} 被 @code{hippopotamus} 替换。

所以我们可以看到，@code{setcar} 并没有像 @code{cons} 那样向列表中添加新元素；它替换了 @code{antelope} 为 @code{hippopotamus}；它@emph{改变了}列表。

@node setcdr
@section @code{setcdr}
@findex setcdr

@code{setcdr}函数类似于@code{setcar}函数，不同之处在于该函数替换列表的第二个及其后的元素，而不是第一个元素。

(要了解如何更改列表的最后一个元素，请查看@ref{kill-new 函数, , @code{kill-new} 函数}，该函数使用@code{nthcdr}和@code{setcdr}函数。)

@need 1200
为了了解它是如何工作的，请通过评估以下表达式将变量的值设置为一组驯养的动物：

@smallexample
(setq domesticated-animals (list 'horse 'cow 'sheep 'goat))
@end smallexample

@need 1200
@noindent
如果现在评估该列表，将返回列表@code{(horse cow sheep goat)}：

@smallexample
@group
domesticated-animals
     @result{} (horse cow sheep goat)
@end group
@end smallexample

@need 1200
接下来，通过使用两个参数评估@code{setcdr}，第一个参数是具有列表值的变量的名称，第二个参数是将设置为第一个列表的@sc{cdr}的列表；

@smallexample
(setcdr domesticated-animals '(cat dog))
@end smallexample

@noindent
如果评估此表达式，将在回显区域看到列表@code{(cat dog)}。这是该函数返回的值。我们感兴趣的结果是副作用，可以通过评估变量@code{domesticated-animals}来查看：

@smallexample
@group
domesticated-animals
     @result{} (horse cat dog)
@end group
@end smallexample

@noindent
确实，列表从@code{(horse cow sheep goat)}更改为@code{(horse cat dog)}。列表的@sc{cdr}从@code{(cow sheep goat)}更改为@code{(cat dog)}。

@node cons 练习
@section 练习

通过评估多个表达式使用@code{cons}构建一个包含四只鸟的列表。了解当你使用@code{cons}将一个列表连接到自身时会发生什么。将四只鸟的列表的第一个元素替换为一条鱼。用其他鱼的列表替换该列表的其余部分。

@node 剪切与存储文本
@chapter 剪切与存储文本
@cindex 剪切与存储文本
@cindex 存储与剪切文本
@cindex 删除文本
@cindex 剪切文本
@cindex 擦除文本
@cindex 删除文本

无论何时在GNU Emacs中使用@dfn{kill}命令剪切或剪贴文本，它都会被存储在一个列表中，您可以使用@dfn{yank}命令将其恢复。

（在Emacs中使用“kill”一词来表示那些特别@emph{不}破坏实体值的过程是一个不幸的历史偶然。一个更合适的词语应该是“剪切”，因为kill命令的作用是剪切文本并将其放入存储中，从中可以重新调用。我经常被诱惑着全局替换Emacs源代码中所有“kill”出现的地方为“clip”，并将所有“killed”的出现地方替换为“clipped”）。

@menu
* 存储文本::                   文本被存储在一个列表中。
* zap-to-char::               剪切文本直到某个字符。
* kill-region::               从区域中剪切文本。
* copy-region-as-kill::       复制文本的定义。
* 进入C的插曲::               C编程语言宏的小注记。
* defvar::                    如何给变量一个初始值。
* cons & search-fwd 回顾::
* 搜索练习::
@end menu

@ifnottex
@node 存储文本
@unnumberedsec 将文本存储在列表中
@end ifnottex

当文本从缓冲区中剪切出来时，它被存储在一个列表中。连续的文本片段被依次存储在列表中，因此列表可能看起来像这样：

@smallexample
("一段文本" "之前的片段")
@end smallexample

@need 1200
@noindent
函数@code{cons}可用于从文本片段（称为“原子”）和现有列表创建一个新列表，如下所示：

@smallexample
@group
(cons "另一段"
      '("一段文本" "之前的片段"))
@end group
@end smallexample

@need 1200
@noindent
如果您评估此表达式，一个包含三个元素的列表将显示在回显区：

@smallexample
("另一段" "一段文本" "之前的片段")
@end smallexample

使用@code{car}和@code{nthcdr}函数，您可以检索您想要的任何文本片段。例如，在以下代码中，@code{nthcdr 1 @dots{}}返回删除第一个项目的列表；而@code{car}返回该剩余部分的第一个元素---原始列表的第二个元素：

@smallexample
@group
(car (nthcdr 1 '("另一段"
                 "一段文本"
                 "之前的片段")))
     @result{} "一段文本"
@end group
@end smallexample

实际的Emacs函数当然比这更复杂。剪切和检索文本的代码必须被编写，以便Emacs可以弄清楚您想要列表中的哪个元素---第一个、第二个、第三个等。此外，当到达列表的末尾时，Emacs应该给您列表的第一个元素，而不是什么都不给您。

保存文本片段的列表称为@dfn{kill环}。本章首先描述了kill环，以及首先追踪@code{zap-to-char}函数的工作方式。此函数调用一个调用函数，该函数操纵kill环。因此，在到达山脚之前，我们要先爬过丘陵。

后续章节描述了从缓冲区剪切的文本如何被检索。@xref{插入文本, , 检索文本}。

@node zap-to-char
@section @code{zap-to-char}
@findex zap-to-char

让我们看一下交互式函数 @code{zap-to-char}。

@menu
* Complete zap-to-char::        完整的实现。
* zap-to-char interactive::     一个三部分的交互式表达式。
* zap-to-char body::            简要概述。
* search-forward::              如何搜索字符串。
* progn::                       特殊形式 @code{progn}。
* Summing up zap-to-char::      使用 @code{point} 和 @code{search-forward}。
@end menu

@ifnottex
@node Complete zap-to-char
@unnumberedsubsec 完整的 @code{zap-to-char} 实现
@end ifnottex

@code{zap-to-char} 函数删除光标位置（即 point）到下一个指定字符（包括该字符）之间的文本。@code{zap-to-char} 删除的文本被放入 kill ring，可以通过键入 @kbd{C-y}（@code{yank}）从 kill ring 中检索。如果给命令传递了一个参数，它将通过指定数量的出现次数删除文本。因此，如果光标位于本句的开头，字符为 @samp{s}，则将删除 @samp{Thus}。如果参数为二，则将删除 @samp{Thus, if the curs}，直到 @samp{cursor} 中的 @samp{s}。

如果未找到指定的字符，@code{zap-to-char} 将显示“Search failed”，告诉您输入的字符，并且不会删除任何文本。

为了确定要删除多少文本，@code{zap-to-char} 使用搜索函数。搜索在处理文本的代码中广泛使用，我们将重点关注搜索以及删除命令。

@ignore
@c GNU Emacs version 19
(defun zap-to-char (arg char)  ; version 19 implementation
  "Kill up to and including ARG'th occurrence of CHAR.
Goes backward if ARG is negative; error if CHAR not found."
  (interactive "*p\ncZap to char: ")
  (kill-region (point)
               (progn
                 (search-forward
                  (char-to-string char) nil nil arg)
                 (point))))
@end ignore

@need 1250
下面是版本 22 的函数实现的完整文本：

@c GNU Emacs 22
@smallexample
@group
(defun zap-to-char (arg char)
  "Kill up to and including ARG'th occurrence of CHAR.
Case is ignored if `case-fold-search' is non-nil in the current buffer.
Goes backward if ARG is negative; error if CHAR not found."
  (interactive "p\ncZap to char: ")
  (if (char-table-p translation-table-for-input)
      (setq char (or (aref translation-table-for-input char) char)))
  (kill-region (point) (progn
                         (search-forward (char-to-string char)
                                         nil nil arg)
                         (point))))
@end group
@end smallexample

文档非常详细。您需要了解“kill”这个术语的含义。

@cindex curved quotes
@cindex curly quotes
@code{zap-to-char} 版本 22 的文档字符串使用 ASCII grave accent 和撇号引用一个符号，因此它显示为 @t{`case-fold-search'}。这种引用风格受到上世纪 70 年代显示器的启发，在那里 grave accent 和撇号经常是镜像图像，适合用作引号。在大多数现代显示器上，这不再成立，当这两个 ASCII 字符出现在文档字符串或诊断消息格式中时，Emacs 通常将它们转换为 @dfn{弯引号}（左右单引号），因此上面引用的符号显示为 @t{‘case-fold-search’}。源代码字符串也可以直接使用弯引号。

@node zap-to-char interactive
@subsection @code{interactive} 表达式

@need 800
@code{zap-to-char} 命令中的交互式表达式如下：

@smallexample
(interactive "p\ncZap to char: ")
@end smallexample

引号内的部分，@code{"p\ncZap to char: "}，指定了两个不同的信息。首先，最简单的是 @samp{p}。这一部分与下一部分由换行符 @samp{\n} 分隔。@samp{p} 表示函数的第一个参数将传递一个 @dfn{processed prefix} 的值。前缀参数通过键入 @kbd{C-u} 和一个数字，或者 @kbd{M-} 和一个数字传递。如果在不带前缀的情况下交互调用该函数，则将 1 传递给此参数。

@code{"p\ncZap to char: "} 的第二部分是 @samp{cZap to char:@:  }。在这一部分中，小写的 @samp{c} 表示 @code{interactive} 期望一个提示，并且参数将是一个字符。提示跟在 @samp{c} 后面，是字符串 @samp{Zap to char:@: }（冒号后面有一个空格，使其看起来更好）。

所有这些都是为了准备 @code{zap-to-char} 的参数，以使它们具有正确的类型，并为用户提供提示。

在只读缓冲区中，@code{zap-to-char} 函数将文本复制到 kill ring，但不删除它。回显区显示一条消息，指示缓冲区是只读的。此外，终端可能会发出哔声或闪烁提醒。

@node zap-to-char body
@subsection @code{zap-to-char}函数的主体

@code{zap-to-char}函数的主体包含了用于删除（即移除）文本的代码，该文本位于光标当前位置到指定字符（包括该字符）的区域。

代码的第一部分如下：

@smallexample
(if (char-table-p translation-table-for-input)
    (setq char (or (aref translation-table-for-input char) char)))
(kill-region (point) (progn
                       (search-forward (char-to-string char) nil nil arg)
                       (point)))
@end smallexample

@noindent
@code{char-table-p}是一个前文未见的函数。它用于确定其参数是否为字符表。当是字符表时，它将传递给@code{zap-to-char}的字符设置为其中之一（如果该字符存在），否则设置为字符本身。（这对于非欧洲语言中的某些字符很重要。@code{aref}函数从数组中提取元素。它是一个特定于数组的函数，本文档不详细描述。@xref{Arrays, , Arrays, elisp, The GNU Emacs Lisp Reference Manual}。）

@noindent
@code{(point)}是光标的当前位置。

代码的下一部分是一个使用@code{progn}的表达式。@code{progn}的主体由对@code{search-forward}和@code{point}的调用组成。

在学习@code{progn}之前，了解一下@code{search-forward}会更容易理解，因此我们将先看看@code{search-forward}，然后再看@code{progn}。

@node search-forward
@subsection @code{search-forward}函数
@findex search-forward

@code{search-forward}函数用于在@code{zap-to-char}中定位要删除的字符。如果搜索成功，@code{search-forward}将光标立即置于目标字符串的最后一个字符之后。（在@code{zap-to-char}中，目标字符串只有一个字符长。@code{zap-to-char}使用@code{char-to-string}函数确保计算机将该字符视为字符串。）如果搜索是向后的，@code{search-forward}将光标放在目标的第一个字符之前。此外，@code{search-forward}返回@code{t}表示真（移动光标因此是一个副作用）。

@need 1250
在@code{zap-to-char}中，@code{search-forward}函数如下：

@smallexample
(search-forward (char-to-string char) nil nil arg)
@end smallexample

@code{search-forward}函数接受四个参数：

@enumerate
@item
第一个参数是目标，即要搜索的内容。这必须是一个字符串，例如@samp{"z"}。

正好传递给@code{zap-to-char}的参数是一个单个字符。由于计算机的构造方式，Lisp解释器可能会将单个字符视为与字符串不同。在计算机内部，单个字符具有与一个字符的字符串不同的电子格式。（计算机中通常可以用一个字节精确地记录一个单个字符；但字符串可能更长，计算机需要为此做好准备。）因此，@code{zap-to-char}函数接收的字符必须在计算机内部从一种格式转换为另一种格式；否则，@code{search-forward}函数将失败。使用@code{char-to-string}函数进行此转换。

@item
第二个参数限制了搜索的范围；它指定为缓冲区中的位置。在这种情况下，搜索可以到达缓冲区的末尾，因此未设置边界，第二个参数为@code{nil}。

@item
第三个参数告诉函数如果搜索失败应该做什么——它可以发出错误（并打印一条消息），或者返回@code{nil}。将@code{nil}作为第三个参数会导致函数在搜索失败时发出错误。

@item
@code{search-forward}的第四个参数是重复计数——要查找字符串的出现次数。此参数是可选的，如果函数在没有重复计数的情况下调用，则此参数将传递值1。如果此参数为负数，则搜索将向后进行。
@end enumerate

@need 800
在模板形式中，@code{search-forward}表达式如下：

@smallexample
@group
(search-forward "@var{target-string}"
                @var{limit-of-search}
                @var{what-to-do-if-search-fails}
                @var{repeat-count})
@end group
@end smallexample

接下来我们将看一下@code{progn}。

@node progn
@subsection @code{progn}特殊形式
@findex progn

@code{progn}是一种特殊形式，它导致按顺序评估其每个参数，然后返回最后一个参数的值。前面的表达式仅为它们执行的副作用而进行评估。它们产生的值被丢弃。

@need 800
@code{progn}表达式的模板非常简单：

@smallexample
@group
(progn
  @var{body}@dots{})
@end group
@end smallexample

在`zap-to-char`中，@code{progn}表达式必须执行两个操作：将点放置在准确的位置，并返回点的位置，以便@code{kill-region}知道要删除多远。

@code{progn}的第一个参数是@code{search-forward}。当@code{search-forward}找到字符串时，该函数将点立即置于目标字符串的最后一个字符之后。（在本例中，目标字符串只有一个字符长。）如果搜索是向后的，则@code{search-forward}将点置于目标的第一个字符之前。点的移动是一个副作用。

@code{progn}的第二个也是最后一个参数是表达式@code{(point)}。此表达式返回点的值，而在这种情况下，它将是由@code{search-forward}移动到的位置。（在源代码中，一行指示函数转到前一个字符（如果它是向前的）的代码在1999年被注释掉了；我不记得这个功能或错误是否曾经是分布源代码的一部分。）@code{point}的值由@code{progn}表达式返回，并作为@code{kill-region}的第二个参数传递。

@node Summing up zap-to-char
@subsection 总结@code{zap-to-char}

现在我们已经看到了@code{search-forward}和@code{progn}的工作原理，我们可以看到@code{zap-to-char}函数是如何整体工作的。

@code{kill-region}的第一个参数是在给定@code{zap-to-char}命令时光标的位置——即那个时刻的点的值。在@code{progn}内，搜索函数然后将点移动到刚刚删除的字符之后，并且@code{point}返回此位置的值。@code{kill-region}函数将这两个点的值组合在一起，第一个作为区域的起始，第二个作为区域的结束，然后删除该区域。

@code{progn}特殊形式是必需的，因为@code{kill-region}命令接受两个参数；如果@code{search-forward}和@code{point}表达式被顺序写为两个额外的参数，它将失败。@code{progn}表达式是@code{kill-region}的单个参数，并返回@code{kill-region}所需的唯一值作为其第二个参数。

@node kill-region
@section @code{kill-region}
@findex kill-region

@code{zap-to-char} 函数使用 @code{kill-region} 函数。这个函数从一个区域裁剪文本并将其复制到 kill ring 中，然后可以从中检索该文本。

@ignore
GNU Emacs 22:

(defun kill-region (beg end &optional yank-handler)
  "杀死（\"cut\"）点和标记之间的文本。
这会从缓冲区中删除文本并将其保存在 kill ring 中。
命令 \\[yank] 可以从中检索它。
\(如果你想要立即杀死然后粘贴，使用 \\[kill-ring-save]。)

如果你想将被杀死的区域追加到上次被杀死的文本中，
在 \\[kill-region] 之前使用 \\[append-next-kill]。

如果缓冲区是只读的，Emacs 会响铃并且不会删除文本，但仍会将文本放入 kill ring 中。
这意味着你可以使用删除命令从只读缓冲区复制文本。

这是程序用于杀死文本的原语（与删除不同）。
提供两个参数，指示要杀死的文本范围的字符位置。
调用此函数的任何命令都是“杀死命令”。
如果上一个命令也是杀死命令，
这次被杀死的文本将追加到上次被杀死的文本中，
形成 kill ring 中的一个条目。

在 Lisp 代码中，可选的第三个参数 YANK-HANDLER，如果非空，指定要设置在被杀死文本上的 yank-handler 文本属性。参见 `insert-for-yank'。"
  ;; 传递 point 先，然后是 mark，因为在调用 kill-append 时顺序很重要。
  (interactive (list (point) (mark)))
  (unless (and beg end)
    (error "当前未设置标记，因此没有区域"))
  (condition-case nil
      (let ((string (filter-buffer-substring beg end t)))
        (when string                        ;如果 BEG = END，则 STRING 为 nil
          ;; 以某种方式将该字符串添加到 kill ring 中。
          (if (eq last-command 'kill-region)
              (kill-append string (< end beg) yank-handler)
            (kill-new string nil yank-handler)))
        (when (or string (eq last-command 'kill-region))
          (setq this-command 'kill-region))
        nil)
    ((buffer-read-only text-read-only)
     ;; 上面的代码失败，因为缓冲区或区域中的某些字符是只读的。
     ;; 我们应该响铃，以防用户不知道这一点。
     ;; 但是无论如何，将区域的文本放入 kill ring 中都没有害处。
     (copy-region-as-kill beg end)
     ;; 现在设置 this-command，以便即使出现错误也会设置它。
     (setq this-command 'kill-region)
     ;; 如果 kill-read-only-ok 为真，则不会发生错误，而是发出消息。
     (if kill-read-only-ok
         (progn (message "只读文本已复制到 kill ring") nil)
       ;; 如果缓冲区是只读的，则发出错误。
       (barf-if-buffer-read-only)
       ;; 如果缓冲区不是只读的，那么文本是只读的。
       (signal 'text-read-only (list (current-buffer)))))))
@end ignore

该函数的 Emacs 22 版本使用了 @code{condition-case} 和 @code{copy-region-as-kill}，我们将对两者进行解释。@code{condition-case} 是一个重要的特殊形式。

实质上，@code{kill-region} 函数调用 @code{condition-case}，它接受三个参数。在这个函数中，第一个参数什么也不做。第二个参数包含当一切顺利时执行的代码。第三个参数包含在出现错误时调用的代码。

@menu
* Complete kill-region::        函数定义。
* condition-case::              处理问题。
* Lisp macro::
@end menu

@ifnottex
@node 完整的 kill-region
@unnumberedsubsec 完整的 @code{kill-region} 定义
@end ifnottex

@need 1200
我们将逐步讲解 @code{condition-case} 代码。首先，让我们看一下 @code{kill-region} 的定义，附带注释：

@c GNU Emacs 22:
@smallexample
@group
(defun kill-region (beg end)
  "Kill (\"cut\") text between point and mark.
This deletes the text from the buffer and saves it in the kill ring.
The command \\[yank] can retrieve it from there. @dots{} "
@end group

@group
  ;; @bullet{} 由于顺序很重要，首先传递 point。
  (interactive (list (point) (mark)))
  ;; @bullet{} 并告诉我们如果无法剪切文本要怎么办。
  ;; 'unless' 是没有 then 部分的 'if'。
  (unless (and beg end)
    (error "The mark is not set now, so there is no region"))
@end group

@group
  ;; @bullet{} 'condition-case' 接受三个参数。
  ;;    如果第一个参数是 nil，就像这里一样，
  ;;    错误信号的信息就不会被存储以供其他函数使用。
  (condition-case nil
@end group

@group
      ;; @bullet{} 'condition-case' 的第二个参数告诉 Lisp 解释器
      ;;    一切正常时要做什么。
@end group

@group
      ;;    它以一个 'let' 函数开始，提取字符串并测试它是否存在。
      ;;    如果存在（这是 'when' 检查的内容），它调用一个 'if' 函数，
      ;;    用于确定前一个命令是否是对 'kill-region' 的另一个调用；
      ;;    如果是，则新文本附加到先前的文本；如果不是，则调用
      ;;    另一个函数 'kill-new'。
@end group

@group
      ;;    'kill-append' 函数连接新字符串和旧字符串。
      ;;    'kill-new' 函数将文本插入到 kill 环中的新项目中。
@end group

@group
      ;;    'when' 是没有 else 部分的 'if'。
      ;;    第二个 'when' 再次检查当前字符串是否存在；
      ;;    此外，它还检查前一个命令是否是对 'kill-region' 的另一个调用。
      ;;    如果其中一个条件为真，则将当前命令设置为 'kill-region'。
@end group
@group
      (let ((string (filter-buffer-substring beg end t)))
        (when string                    ; 如果 BEG = END，则 STRING 为 nil
          ;; 将该字符串添加到 kill ring 中，以某种方式。
          (if (eq last-command 'kill-region)
@end group
@group
              ;;    @minus{} 'yank-handler' 是传递给 'kill-region' 的可选参数，
              ;;    告诉 'kill-append' 和 'kill-new' 函数如何处理添加到文本中的属性，
              ;;    例如 'bold' 或 'italics'。
              (kill-append string (< end beg) yank-handler)
            (kill-new string nil yank-handler)))
        (when (or string (eq last-command 'kill-region))
          (setq this-command 'kill-region))
        nil)
@end group

@group
    ;;  @bullet{} 'condition-case' 的第三个参数告诉解释器
    ;;    发生错误时要做什么。
@end group
@group
    ;;    第三个参数有一个条件部分和一个体部分。
    ;;    如果满足条件（在这种情况下，如果文本或缓冲区是只读的）
    ;;    那么就执行体部分。
@end group
@group
    ((buffer-read-only text-read-only) ;; 条件部分
     ;; @dots{} 体部分
     (copy-region-as-kill beg end)
@end group
@group
     ;;    接下来，同样作为体部分的一部分，设置 this-command，
     ;;    这样它将在错误中被设置。
     (setq this-command 'kill-region)
     ;;    最后，在体部分，如果可以在不发出错误的情况下将文本复制到 kill ring 中，则发送消息，否则不发送。
@end group
@group
     (if kill-read-only-ok
         (progn (message "Read only text copied to kill ring") nil)
       (barf-if-buffer-read-only)
       ;; 如果缓冲区不是只读的，则文本是只读的。
       (signal 'text-read-only (list (current-buffer)))))))
@end group
@end smallexample

@ignore
@c v 21
@smallexample
@group
(defun kill-region (beg end)
  "Kill between point and mark.
The text is deleted but saved in the kill ring."
  (interactive "r")
@end group

@group
  ;; 1. 'condition-case' 接受三个参数。
  ;;    如果第一个参数是 nil，就像这里一样，
  ;;    错误信号的信息就不会被存储以供其他函数使用。
  (condition-case nil
@end group

@group
      ;; 2. 'condition-case' 的第二个参数告诉 Lisp 解释器
      ;;    一切正常时要做什么。
@end group

@group
      ;;    'delete-and-extract-region' 函数通常执行工作。
      ;;    如果区域的开头和结尾都相同，则变量 'string' 将为空，或 nil。
      (let ((string (delete-and-extract-region beg end)))
@end group

@group
        ;; 'when' 是一个不能有 'else-part' 的 'if' 子句。
        ;; Emacs 通常将 'last-command' 的值设置为前一个命令。
@end group
@group
        ;; 'kill-append' 连接新字符串和旧字符串。
        ;; 'kill-new' 在 kill 环中的新项目中插入文本。
        (when string
          (if (eq last-command 'kill-region)
              ;; 如果为真，则在字符串之前添加字符串
              (kill-append string (< end beg))
            (kill-new string)))
        (setq this-command 'kill-region))
@end group

@group
    ;; 3. 'condition-case' 的第三个参数告诉解释器
    ;;    发生错误时要做什么。
@end group
@group
    ;;    第三个参数有一个条件部分和一个体部分。
    ;;    如果满足条件（在这种情况下，
    ;;             如果文本或缓冲区是只读的）
    ;;    那么就执行体部分。
@end group
@group
    ((buffer-read-only text-read-only) ;; 这是条件部分
     ;; 然后...
     (copy-region-as-kill beg end)
@end group
@group
     (if kill-read-only-ok            ;; 通常这个变量是 nil
         (message "Read only text copied to kill ring")
       ;; 否则，如果缓冲区是只读的，发出错误信号；
       (barf-if-buffer-read-only)
       ;; 并且，在任何情况下，都发出文本是只读的信号。
       (signal 'text-read-only (list (current-buffer)))))))
@end group
@end smallexample
@end ignore

@node condition-case
@subsection @code{condition-case}
@findex condition-case

正如我们之前所看到的（@pxref{Making Errors, , Generate an Error
Message}），当Emacs Lisp解释器在评估表达式时遇到问题时，它会为您提供帮助；在行话中，这被称为“发出错误信号”。通常，计算机会停止程序并显示一条消息。

然而，一些程序执行复杂的操作。它们在发生错误时不应该简单地停止。在@code{kill-region}函数中，最可能的错误是您尝试删除只读且无法删除的文本。因此，@code{kill-region}函数包含处理此情况的代码。这段代码构成了@code{kill-region}函数的主体，位于@code{condition-case}特殊形式中。

@need 800
@code{condition-case}的模板如下：

@smallexample
@group
(condition-case
  @var{var}
  @var{bodyform}
  @var{error-handler}@dots{})
@end group
@end smallexample

第二个参数，@var{bodyform}，很直观。@code{condition-case}特殊形式导致Lisp解释器评估@var{bodyform}中的代码。如果没有错误发生，特殊形式将返回代码的值并产生副作用（如果有的话）。

简而言之，@code{condition-case}表达式的@var{bodyform}部分决定一切正常时应该发生什么。

然而，如果发生错误，除了其他动作，生成错误信号的函数还将定义一个或多个错误条件名。

错误处理程序是@code{condition-case}的第三个参数。错误处理程序有两个部分，一个是@var{condition-name}，另一个是@var{body}。如果错误处理程序的@var{condition-name}部分与错误生成的条件名匹配，那么将运行错误处理程序的@var{body}部分。

正如您所期望的那样，错误处理程序的@var{condition-name}部分可以是单个条件名或条件名列表。

此外，完整的@code{condition-case}表达式可能包含多个错误处理程序。当发生错误时，将运行第一个适用的处理程序。

最后，@code{condition-case}表达式的第一个参数，@var{var}参数，有时绑定到包含有关错误的信息的变量。但是，如果该参数为@code{nil}，如在@code{kill-region}中的情况，该信息将被丢弃。

@need 1200
简而言之，在@code{kill-region}函数中，@code{condition-case}的代码如下：

@smallexample
@group
@var{如果没有错误，运行仅此代码}
    @var{但是，如果发生错误，运行另一段代码}。
@end group
@end smallexample

@ignore
2006年10月24日
在Emacs 22中，
copy-region-as-kill很短，12行，并使用
filter-buffer-substring，它更长，39行
其中包含delete-and-extract-region。
delete-and-extract-region是用C编写的。

见使用@code{defvar}初始化变量
这是第8054行
使用@code{defvar}初始化变量包括第8350行
@end ignore

@node Lisp macro
@subsection Lisp macro
@cindex Macro, lisp
@cindex Lisp macro

在期望一切顺利的情况下评估的@code{condition-case}表达式的一部分具有@code{when}。该代码使用@code{when}来确定@code{string}变量是否指向存在的文本。

@code{when}表达式只是程序员的便利。它是一个没有else子句可能性的@code{if}。在你的脑海中，你可以用@code{if}替换@code{when}并理解发生了什么。这就是Lisp解释器所做的。

从技术上讲，@code{when}是一个Lisp宏。Lisp宏使您能够定义新的控制结构和其他语言功能。它告诉解释器如何计算另一个Lisp表达式，该表达式将进而计算值。在这种情况下，另一个表达式是一个@code{if}表达式。

@code{kill-region}函数定义还有一个@code{unless}宏；它是@code{when}的反义词。@code{unless}宏是一个没有then子句的@code{if}。

有关Lisp宏的更多信息，请参阅@ref{Macros, , Macros, elisp, The GNU
Emacs Lisp Reference Manual}。C编程语言也提供宏。它们是不同的，但同样有用。

@ignore
我们将简要查看C中的宏
请参阅@ref{Digression into C}。
@end ignore

@need 1200
关于@code{when}宏，在@code{condition-case}表达式中，当字符串具有内容时，然后执行另一个条件表达式。这是一个带有then-part和else-part的@code{if}。

@smallexample
@group
(if (eq last-command 'kill-region)
    (kill-append string (< end beg) yank-handler)
  (kill-new string nil yank-handler))
@end group
@end smallexample

如果前一个命令是另一个对@code{kill-region}的调用，则评估then-part；否则，评估else-part。

@code{yank-handler}是传递给@code{kill-region}的可选参数，告诉@code{kill-append}和@code{kill-new}函数如何处理添加到文本中的属性，例如粗体或斜体。

@code{last-command}是Emacs附带的一个我们之前没有见过的变量。通常，每当执行函数时，Emacs都会将@code{last-command}的值设置为前一个命令。

@need 1200
在这个定义片段中，@code{if}表达式检查前一个命令是否为@code{kill-region}。如果是，

@smallexample
(kill-append string (< end beg) yank-handler)
@end smallexample

@noindent
将新剪贴文本的副本连接到刚刚剪贴的文本在kill ring中。

@node copy-region-as-kill
@section @code{copy-region-as-kill}
@findex copy-region-as-kill
@findex nthcdr

@code{copy-region-as-kill}函数将文本缓冲区中的一段文本复制并（通过@code{kill-append}或@code{kill-new}）保存在@code{kill-ring}中。

如果在执行@code{kill-region}命令之后立即调用@code{copy-region-as-kill}，Emacs将新复制的文本附加到先前复制的文本上。这意味着如果您粘贴文本，则会得到来自此次和上一次操作的所有文本。另一方面，如果在@code{copy-region-as-kill}之前执行了其他命令，则该函数将文本复制到kill环中的一个单独条目中。

@menu
* Complete copy-region-as-kill::  @code{copy-region-as-kill}函数的完整定义。
* copy-region-as-kill body::      @code{copy-region-as-kill}的主体部分。
@end menu

@ifnottex
@node Complete copy-region-as-kill
@unnumberedsubsec @code{copy-region-as-kill}函数的完整定义
@end ifnottex

@need 1200
以下是版本22的@code{copy-region-as-kill}函数的完整文本：

@smallexample
@group
(defun copy-region-as-kill (beg end)
  "将区域保存为已杀死，但不要杀死它。
在瞬时标记模式下，取消激活标记。
如果`interprogram-cut-function'非空，还为窗口系统剪切和粘贴保存文本。"
  (interactive "r")
@end group
@group
  (if (eq last-command 'kill-region)
      (kill-append (filter-buffer-substring beg end) (< end beg))
    (kill-new (filter-buffer-substring beg end)))
@end group
@group
  (if transient-mark-mode
      (setq deactivate-mark t))
  nil)
@end group
@end smallexample

@need 800
像往常一样，此函数可以分为其组成部分：

@smallexample
@group
(defun copy-region-as-kill (@var{argument-list})
  "@var{documentation}@dots{}"
  (interactive "r")
  @var{body}@dots{})
@end group
@end smallexample

参数是@code{beg}和@code{end}，函数以@code{"r"}交互，因此两个参数必须引用区域的起始和结束。如果您从文档开头阅读到这里，理解函数的这些部分几乎变得很常规。

文档有点令人困惑，除非您记得“kill”一词的意义与通常不同。瞬时标记和@code{interprogram-cut-function}的注释解释了某些副作用。

一旦设置了标记，缓冲区始终包含一个区域。如果愿意，可以使用瞬时标记模式临时突出显示区域。 （没有人希望一直突出显示区域，因此瞬时标记模式仅在适当的时候突出显示。许多人关闭瞬时标记模式，因此区域永远不会被突出显示。）

此外，窗口系统允许在不同程序之间复制、剪切和粘贴。例如，在X窗口系统中，@code{interprogram-cut-function}函数是@code{x-select-text}，它与窗口系统的Emacs kill环的等价物一起工作。

@code{copy-region-as-kill}函数的主体以一个@code{if}子句开始。该子句的作用是区分两种不同的情况：是否立即在先前的@code{kill-region}命令之后执行此命令。在第一种情况下，新区域将附加到先前复制的文本。否则，它将作为一个独立的文本片段插入到kill环的开头。

函数的最后两行阻止区域在瞬时标记模式打开时突出显示。

@node copy-region-as-kill body
@subsection @code{copy-region-as-kill}的主体

@code{copy-region-as-kill}函数的工作方式与@code{kill-region}函数类似。两者都被编写为使连续两次或更多次的杀死将它们的文本组合成单个条目。如果从kill环粘贴文本，则会得到一个整体。此外，从当前光标位置向前杀死的杀死将添加到先前复制的文本的末尾，而将文本向后复制的命令将其添加到先前复制的文本的开头。这样，文本中的单词保持正确的顺序。

与@code{kill-region}一样，@code{copy-region-as-kill}函数利用了@code{last-command}变量，该变量跟踪先前的Emacs命令。

@menu
* last-command & this-command::
* kill-append函数::
* kill-new函数::
@end menu

@ifnottex
@node last-command & this-command
@unnumberedsubsubsec @code{last-command}和@code{this-command}
@end ifnottex

通常情况下，每当执行函数时，Emacs将@code{this-command}的值设置为正在执行的函数（在本例中将是@code{copy-region-as-kill}）。同时，Emacs将@code{last-command}的值设置为@code{this-command}的先前值。

在@code{copy-region-as-kill}函数的主体的第一部分中，一个@code{if}表达式确定@code{last-command}的值是否为@code{kill-region}。如果是，@code{if}表达式的then-part将被评估；它使用@code{kill-append}函数将此次调用函数时复制的文本与kill环的第一个元素（@sc{car}）中已有的文本连接起来。另一方面，如果@code{last-command}的值不是@code{kill-region}，那么@code{copy-region-as-kill}函数将使用@code{kill-new}函数将一个新元素附加到kill环中。

@need 1250
@code{if}表达式如下所示；它使用@code{eq}：

@smallexample
@group
  (if (eq last-command 'kill-region)
      ;; @r{then-part}
      (kill-append  (filter-buffer-substring beg end) (< end beg))
    ;; @r{else-part}
    (kill-new  (filter-buffer-substring beg end)))
@end group
@end smallexample

@findex filter-buffer-substring
（@code{filter-buffer-substring}函数返回缓冲区的过滤子字符串，如果有的话。可选地——这里没有参数，因此也没有做任何事——该函数可以删除初始文本或返回不带其属性的文本；此函数是较早的@code{buffer-substring}函数的替代，该函数在实现文本属性之前出现。）

@findex eq @r{（用法示例）}
@noindent
@code{eq}函数测试其第一个参数是否与其第二个参数相同的Lisp对象。@code{eq}函数类似于@code{equal}函数，因为它用于测试相等性，但不同之处在于它确定两个表示实际上是计算机内部相同对象，只是具有不同的名称。@code{equal}确定两个表达式的结构和内容是否相同。

如果先前的命令是@code{kill-region}，则Emacs Lisp解释器调用@code{kill-append}函数。

@node kill-append 函数
@unnumberedsubsubsec @code{kill-append} 函数
@findex kill-append

@need 800
@code{kill-append} 函数的定义如下：

@c 在GNU Emacs 22中
@smallexample
@group
(defun kill-append (string before-p &optional yank-handler)
  "将STRING追加到kill环中最新的kill的末尾。
如果BEFORE-P非空，则将STRING插入到kill的开头。
@dots{} "
  (let* ((cur (car kill-ring)))
    (kill-new (if before-p (concat string cur) (concat cur string))
              (or (= (length cur) 0)
                  (equal yank-handler
                         (get-text-property 0 'yank-handler cur)))
              yank-handler)))
@end group
@end smallexample

@ignore
曾经的定义:
(defun kill-append (string before-p)
  "将STRING追加到kill环中最新的kill的末尾。
如果BEFORE-P非空，则将STRING插入到kill的开头。
如果`interprogram-cut-function'已设置，则将生成的kill传递给它。"
  (kill-new (if before-p
                (concat string (car kill-ring))
              (concat (car kill-ring) string))
            t))
@end ignore

@noindent
@code{kill-append} 函数非常直观。它使用了稍后我们将详细讨论的 @code{kill-new} 函数。

（此外，该函数提供了一个可选的参数叫做 @code{yank-handler}；当调用时，此参数告诉函数如何处理添加到文本的属性，比如粗体或斜体。）

@c !!! GNU Emacs 22版本中 kill-append 函数的bug？
它使用 @code{let*} 函数将kill环的第一个元素的值设置为 @code{cur}。（我不知道为什么函数不使用 @code{let} 替代；表达式中只设置了一个值。也许这是一个不会产生问题的bug？）

考虑到条件语句是 @code{kill-new} 的两个参数之一。它使用 @code{concat} 将新文本连接到kill环的 @sc{car}（第一个元素）。无论是插入还是追加文本，都取决于 @code{if} 表达式的结果：

@smallexample
@group
(if before-p                            ; @r{if-part}
    (concat string cur)                 ; @r{then-part}
  (concat cur string))                  ; @r{else-part}
@end group
@end smallexample

@noindent
如果要删除的区域位于上一次命令中删除的区域之前，那么它应该插入到之前保存的文本之前；反之，如果删除的文本跟随刚刚删除的文本，它应该追加到先前的文本之后。 @code{if} 表达式依赖于谓词 @code{before-p} 来决定新保存的文本是应该放在先前保存的文本之前还是之后。

符号 @code{before-p} 是 @code{kill-append} 函数的参数之一的名称。当评估 @code{kill-append} 函数时，它被绑定到通过评估实际参数返回的值。在这种情况下，这是表达式 @code{(< end beg)}。此表达式不直接确定此命令中删除的文本是在上次命令中删除的文本之前还是之后；它的作用是确定变量 @code{end} 的值是否小于变量 @code{beg} 的值。如果是，这意味着用户很可能朝着缓冲区的开头前进。此外，谓词表达式 @code{(< end beg)} 的评估结果将为真，文本将在先前文本之前插入。另一方面，如果变量 @code{end} 的值大于变量 @code{beg} 的值，则文本将在先前文本之后追加。

@need 800
当新保存的文本将被插入时，字符串与新文本将被连接到旧文本之前：

@smallexample
(concat string cur)
@end smallexample

@need 1200
@noindent
但如果文本将被追加，它将在旧文本之后连接：

@smallexample
(concat cur string))
@end smallexample

为了理解这是如何工作的，我们首先需要复习一下 @code{concat} 函数。@code{concat} 函数将两个文本字符串链接或合并在一起。结果是一个字符串。例如：

@smallexample
@group
(concat "abc" "def")
     @result{} "abcdef"
@end group

@group
(concat "new "
        (car '("first element" "second element")))
     @result{} "new first element"

(concat (car
        '("first element" "second element")) " modified")
     @result{} "first element modified"
@end group
@end smallexample

现在我们可以理解 @code{kill-append}：它修改了kill环的内容。kill环是一个列表，其中每个元素都是保存的文本。@code{kill-append} 函数使用 @code{kill-new} 函数，后者又使用 @code{setcar} 函数。

@node kill-new 函数
@unnumberedsubsubsec @code{kill-new} 函数
@findex kill-new

@need 1200
在版本22中，@code{kill-new} 函数的定义如下：

@smallexample
@group
(defun kill-new (string &optional replace yank-handler)
  "将STRING设为kill环中的最新kill。
将`kill-ring-yank-pointer'设为指向它。

如果`interprogram-cut-function'非nil，则将其应用于STRING。
可选的第二个参数REPLACE非nil表示STRING将替换
kill环的最前面，而不是被添加到列表中。
@dots{}"
@end group
@group
  (if (> (length string) 0)
      (if yank-handler
          (put-text-property 0 (length string)
                             'yank-handler yank-handler string))
    (if yank-handler
        (signal 'args-out-of-range
                (list string "yank-handler specified for empty string"))))
@end group
@group
  (if (fboundp 'menu-bar-update-yank-menu)
      (menu-bar-update-yank-menu string (and replace (car kill-ring))))
@end group
@group
  (if (and replace kill-ring)
      (setcar kill-ring string)
    (push string kill-ring)
    (if (> (length kill-ring) kill-ring-max)
        (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
@end group
@group
  (setq kill-ring-yank-pointer kill-ring)
  (if interprogram-cut-function
      (funcall interprogram-cut-function string (not replace))))
@end group
@end smallexample
@ignore
原先的定义：
(defun kill-new (string &optional replace)
  "将STRING设为kill环中的最新kill。
将kill-ring-yank指针设为指向它。
如果`interprogram-cut-function'非nil，则将其应用于STRING。
可选的第二个参数REPLACE非nil表示STRING将替换
kill环的最前面，而不是被添加到列表中。"
  (and (fboundp 'menu-bar-update-yank-menu)
       (menu-bar-update-yank-menu string (and replace (car kill-ring))))
  (if (and replace kill-ring)
      (setcar kill-ring string)
    (setq kill-ring (cons string kill-ring))
    (if (> (length kill-ring) kill-ring-max)
        (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
  (setq kill-ring-yank-pointer kill-ring)
  (if interprogram-cut-function
      (funcall interprogram-cut-function string (not replace))))
@end ignore

（注意，此函数不是交互式的。）

和往常一样，我们可以将这个函数分为几个部分来看。

函数定义有一个可选的@code{yank-handler}参数，
当调用时告诉函数如何处理添加到文本中的属性，比如粗体或斜体。我们将跳过这一点。

@need 1200
文档的第一行有意义：

@smallexample
将STRING设为kill环中的最新kill。
@end smallexample

@noindent
让我们暂时跳过文档的其余部分。

@noindent
同样，让我们跳过初始的@code{if}表达式以及涉及@code{menu-bar-update-yank-menu}的那些行代码。我们将在下面解释它们。

@need 1200
关键的代码在这里：

@smallexample
@group
  (if (and replace kill-ring)
      ;; @r{然后}
      (setcar kill-ring string)
@end group
@group
    ;; @r{否则}
    (push string kill-ring)
@end group
@group
    (if (> (length kill-ring) kill-ring-max)
        ;; @r{避免kill环过长}
        (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
@end group
@group
  (setq kill-ring-yank-pointer kill-ring)
  (if interprogram-cut-function
      (funcall interprogram-cut-function string (not replace))))
@end group
@end smallexample

条件测试是 @w{@code{(and replace kill-ring)}}。
当满足两个条件时，这将为真：kill环中有内容，并且@code{replace}变量为真。

@need 1250
当@code{kill-append}函数将@code{replace}设置为真时，且kill环中至少有一项时，将执行@code{setcar}表达式：

@smallexample
(setcar kill-ring string)
@end smallexample

@code{setcar}函数实际上将@code{kill-ring}列表的第一个元素更改为@code{string}的值。它替换第一个元素。

@need 1250
另一方面，如果kill环为空，或者replace为假，则执行条件的else部分：

@smallexample
(push string kill-ring)
@end smallexample

@noindent
@need 1250
@code{push}将其第一个参数推入第二个参数。它类似于较旧的

@smallexample
(setq kill-ring (cons string kill-ring))
@end smallexample

@noindent
@need 1250
或者较新的

@smallexample
(add-to-list kill-ring string)
@end smallexample

@noindent
当为假时，表达式首先通过将要被杀死的字符串作为新元素添加到旧kill环中构造了新版本的kill环（这就是@code{push}的作用）。然后它执行第二个@code{if}子句。这第二个@code{if}子句防止kill环变得过长。

让我们按顺序查看这两个表达式。

@code{push} else-part的行将新的kill环的值设置为将要被杀死的字符串添加到旧kill环中得到的值。

通过以下示例，我们可以看到它是如何工作的。

@need 800
首先，

@smallexample
(setq example-list '("here is a clause" "another clause"))
@end smallexample

@need 1200
@noindent
通过使用@kbd{C-x C-e}评估此表达式后，您可以评估@code{example-list}并查看其返回值：

@smallexample
@group
example-list
     @result{} ("here is a clause" "another clause")
@end group
@end smallexample

@need 1200
@noindent
现在，我们可以通过评估以下表达式将一个新元素添加到此列表中：
@findex push@r{, example}

@smallexample
(push "a third clause" example-list)
@end smallexample

@need 800
@noindent
当我们评估@code{example-list}时，我们发现其值为：

@smallexample
@group
example-list
     @result{} ("a third clause" "here is a clause" "another clause")
@end group
@end smallexample

@noindent
因此，通过@code{push}添加了第三个子句。

@need 1200
现在是@code{if}子句的第二部分。此表达式防止kill环变得过长。它看起来是这样的：

@smallexample
@group
(if (> (length kill-ring) kill-ring-max)
    (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil))
@end group
@end smallexample

代码检查kill环的长度是否大于允许的最大长度。这是@code{kill-ring-max}（默认为120）的值。如果kill环的长度太长，则此代码将最后一个元素设置为@code{nil}。它通过使用两个函数@code{nthcdr}和@code{setcdr}来实现。

我们之前看过@code{setcdr}（@pxref{setcdr, , @code{setcdr}}）。它设置列表的@sc{cdr}，就像@code{setcar}设置列表的@sc{car}一样。但是，在这种情况下，@code{setcdr}不会设置整个kill环的@sc{cdr}；@code{nthcdr}函数用于使其设置kill环的倒数第二个元素的@sc{cdr}——这意味着由于倒数第二个元素的@sc{cdr}是kill环的最后一个元素，它将设置kill环的最后一个元素。

@findex nthcdr@r{, example}
@code{nthcdr}函数通过重复获取列表的@sc{cdr}来工作——它获取@sc{cdr}的@sc{cdr}的@sc{cdr}等等。它这样做@var{N}次并返回结果。(@xref{nthcdr, , @code{nthcdr}}.)

@findex setcdr@r{, example}
因此，如果我们有一个应该是三个元素长的四个元素列表，我们可以将倒数第二个元素的@sc{cdr}设置为@code{nil}，从而缩短列表。（如果将最后一个元素设置为除@code{nil}之外的其他值，您可以这样做，那么您将不会缩短列表。@xref{setcdr, , @code{setcdr}}.）

通过依次评估以下三个表达式，您可以看到缩短的效果。首先将@code{trees}的值设置为@code{(maple oak pine birch)}，然后将其第二个@sc{cdr}的@sc{cdr}设置为@code{nil}，然后找到@code{trees}的值：

@smallexample
@group
(setq trees (list 'maple 'oak 'pine 'birch))
     @result{} (maple oak pine birch)
@end group

@group
(setcdr (nthcdr 2 trees) nil)
     @result{} nil

trees
     @result{} (maple oak pine)
@end group
@end smallexample

@noindent
(@code{setcdr}表达式返回的值为@code{nil}，因为它将@sc{cdr}设置为@code{nil}。)

重申一下，在@code{kill-new}中，@code{nthcdr}函数取kill环的最大允许大小减一的次数，@code{setcdr}函数将其@sc{cdr}设置为那个元素（这意味着由于倒数第二个元素的@sc{cdr}是kill环的最后一个元素，它将设置kill环的最后一个元素）。这样可以防止kill环变得过长。

@need 800
@code{kill-new}函数中倒数第二个表达式是

@smallexample
(setq kill-ring-yank-pointer kill-ring)
@end smallexample

@code{kill-ring-yank-pointer}是一个全局变量，被设置为@code{kill-ring}。

尽管@code{kill-ring-yank-pointer}被称为@samp{指针}，但它和kill环一样是一个变量。但是，为了帮助人们理解该变量的用法，选择了这个名称。

@need 1200
现在，回到函数体中的早期表达式：

@smallexample
@group
  (if (fboundp 'menu-bar-update-yank-menu)
       (menu-bar-update-yank-menu string (and replace (car kill-ring))))
@end group
@end smallexample

@noindent
它以一个@code{if}表达式开始

在这种情况下，该表达式首先测试@code{menu-bar-update-yank-menu}是否存在作为函数，并且如果存在，则调用它。@code{fboundp}函数返回true，如果它测试的符号具有非空的函数定义。如果符号的函数定义为空，我们将收到错误消息，就像我们故意创建错误一样（@pxref{Making Errors, , 生成错误消息}）。

@noindent
然后部分包含一个表达式，其第一个元素是@code{and}函数。

@findex and
特殊形式 @code{and} 对其每个参数进行求值，直到其中一个参数返回值为 @code{nil} 为止，此时 @code{and} 表达式返回 @code{nil}；然而，如果没有任何参数返回 @code{nil}，则返回最后一个参数的求值结果。 （由于这样的值不是 @code{nil}，在Emacs Lisp中被视为真值。）换句话说，只有当所有参数都为真时，@code{and} 表达式才返回真值。(@xref{第二缓冲区相关复习}.)

该表达式确定了 @code{menu-bar-update-yank-menu} 的第二个参数是否为真。
@ignore
    ;; 如果我们应该扩展现有字符串，并且该字符串确实位于菜单的前面，则原地更新它。
@end ignore

@code{menu-bar-update-yank-menu} 是使得可以在菜单条的编辑项目的“选择和粘贴”菜单中使用的函数之一；使用鼠标，您可以查看已保存的各种文本片段，并选择一个片段进行粘贴。

@code{kill-new} 函数中的最后一个表达式将新复制的字符串添加到用于在窗口系统中运行的不同程序之间复制和粘贴的任何设施中。例如，在X Windowing系统中，@code{x-select-text} 函数将字符串存储在由X操作的内存中。您可以在另一个程序中粘贴该字符串，例如Xterm。

@need 1200
该表达式如下：

@smallexample
@group
  (if interprogram-cut-function
      (funcall interprogram-cut-function string (not replace))))
@end group
@end smallexample

如果存在 @code{interprogram-cut-function}，则Emacs执行 @code{funcall}，它又调用其第一个参数作为函数，并将其余参数传递给它。 （顺便说一下，就我所看到的，此 @code{if} 表达式可以被类似于函数第一部分的 @code{and} 表达式替代。）

我们不打算进一步讨论窗口系统和其他程序，只是注意到这是一种使GNU Emacs能够轻松而有效地与其他程序协同工作的机制。

这段代码用于将文本放入kill环中，可以是与现有元素连接，也可以是作为新元素。这引导我们进入了从缓冲区中删除文本的代码——yank命令。但在讨论yank命令之前，最好先了解计算机中列表是如何实现的。这将解释“指针”一词的使用。但在此之前，我们将离题讨论C。

@ignore
@c 这在Emacs 22中是真的吗？似乎不是

  （如果表达式 @w{@code{(< end beg))}} 为真，则 @code{kill-append} 将字符串前置到刚刚剪切的文本之前。有关详细讨论，请参阅 @ref{kill-append function, , The @code{kill-append} function}.）

如果然后将文本还原，即粘贴它，则可以同时获得两个文本片段。这样，如果您连续删除两个单词，然后将它们还原，您将以正确的顺序获得两个单词，一次性粘贴。（表达式 @w{@code{(< end beg))}} 确保顺序正确。）

另一方面，如果前一个命令不是 @code{kill-region}，那么将调用 @code{kill-new} 函数，该函数将文本添加到kill环中作为最新的项，并将 @code{kill-ring-yank-pointer} 变量设置为指向它。
@end ignore
@ignore

@c 显然，Emacs 22有所更改。zap-to-char命令不使用delete-and-extract-region函数

2006年10月26日，C离题现在可以了，但应该在copy-region-as-kill和filter-buffer-substring之后

2006年10月24日
在Emacs 22中，
copy-region-as-kill很短，12行，使用
filter-buffer-substring，它更长，有39行
并包含其中的delete-and-extract-region。
delete-and-extract-region是用C编写的。

参见使用 @code{defvar} 初始化变量
@end ignore

@node 进入C的插曲
@section 进入C的插曲
@findex delete-and-extract-region
@cindex C，进入C的插曲
@cindex 进入C的插曲

@code{copy-region-as-kill} 函数（参见@pxref{copy-region-as-kill, , @code{copy-region-as-kill}}）使用了 @code{filter-buffer-substring} 函数，而该函数又使用了 @code{delete-and-extract-region} 函数。它会删除区域的内容，而且一旦删除就无法还原。

与这里讨论的其他代码不同，@code{delete-and-extract-region} 函数不是用Emacs Lisp编写的；它是用C编写的，是GNU Emacs系统的原语之一。由于它非常简单，我将简要离开Lisp并在这里描述它。

@need 1500
与许多其他Emacs原语一样，@code{delete-and-extract-region} 作为C宏的实例编写，宏是代码的模板。完整的宏如下：

@c 这是editfns.c中用于delete-and-extract-region的DEFUN的副本。
@smallexample
@group
DEFUN ("delete-and-extract-region", Fdelete_and_extract_region,
       Sdelete_and_extract_region, 2, 2, 0,
       doc: /* 删除START和END之间的文本并返回它。 */)
  (Lisp_Object start, Lisp_Object end)
@{
  validate_region (&start, &end);
  if (XFIXNUM (start) == XFIXNUM (end))
    return empty_unibyte_string;
  return del_range_1 (XFIXNUM (start), XFIXNUM (end), 1, 1);
@}
@end group
@end smallexample

在不深入宏编写过程的细节的情况下，让我指出该宏以单词 @code{DEFUN} 开头。选择单词 @code{DEFUN} 是因为该代码与Lisp中的 @code{defun} 具有相同的目的。（@code{DEFUN} C宏在@file{emacs/src/lisp.h}中定义。）

单词 @code{DEFUN} 后面跟着括号内的七个部分：

@itemize @bullet
@item
第一个部分是Lisp中给定的函数名称，@code{delete-and-extract-region}。

@item
第二部分是C中的函数名称，@code{Fdelete_and_extract_region}。按照惯例，它以 @samp{F} 开头。由于C中不使用连字符，而是使用下划线。

@item
第三部分是记录此函数信息以供内部使用的C常量结构的名称。它是C中函数的名称，但以 @samp{S} 开头而不是 @samp{F}。

@item
第四和第五部分指定函数可以有的参数的最小和最大数量。此函数要求精确地有2个参数。

@item
第六部分几乎与在Lisp中编写的函数中的 @code{interactive} 声明后面的参数相似：一个字母，然后是一个提示，也许还有一个数字。与Lisp不同的是，当使用零参数调用宏时。然后你写一个 @code{0}（它是一个空字符串），就像这个宏一样。

如果要指定参数，你会将它们放在引号之间。用于 @code{goto-char} 的C宏包括在此位置添加 @code{"NGoto char: "} 以指示该函数期望一个原始前缀，这种情况下是缓冲区中的数值位置，并提供提示。

@item
第七部分是文档字符串，就像Emacs Lisp中的函数的文档字符串一样。这是以C注释的形式编写的。（构建Emacs时，程序@command{lib-src/make-docfile}提取这些注释并用它们制作文档。）
@end itemize

@need 1200
在C宏中，接下来是形式参数，包括对象类型的说明，然后是宏的主体。对于 @code{delete-and-extract-region}，主体包括以下四行：

@smallexample
@group
validate_region (&start, &end);
if (XFIXNUM (start) == XFIXNUM (end))
  return empty_unibyte_string;
return del_range_1 (XFIXNUM (start), XFIXNUM (end), 1, 1);
@end group
@end smallexample

@code{validate_region} 函数检查作为区域开始和结束传递的值是否是正确的类型并且是否在范围内。如果开始和结束位置相同，则返回一个空字符串。

@code{del_range_1} 函数实际上删除文本。这是一个复杂的函数，我们不会深入研究。它更新缓冲区并执行其他操作。但是，值得注意的是传递给 @code{del_range_1} 的两个参数。这些是 @w{@code{XFIXNUM (start)}} 和 @w{@code{XFIXNUM (end)}}。

就C语言而言，@code{start} 和 @code{end} 是标记要删除的区域的开始和结束的两个不透明的值。更准确地说，需要更多专业知识才能理解，这两个值的类型是 @code{Lisp_Object}，它可能是C指针、C整数或C结构；C代码通常不应关心 @code{Lisp_Object} 的实现方式。

@samp{XFIXNUM} 是一个C宏，从较长的比特集中提取相关整数；类型比特被丢弃。

@need 800
@code{delete-and-extract-region} 中的命令如下：

@smallexample
del_range_1 (XFIXNUM (start), XFIXNUM (end), 1, 1);
@end smallexample

@noindent
它删除开始位置 @code{start} 和结束位置 @code{end} 之间的区域。

从编写Lisp的人的角度来看，Emacs非常简单；但是在底层隐藏着大量的复杂性，以使一切正常工作。

@node defvar
@section 使用 @code{defvar} 初始化变量
@findex defvar
@cindex 初始化变量
@cindex 变量初始化

@ignore
2006年10月24日
在Emacs 22中，
copy-region-as-kill 很短，有12行，使用了
filter-buffer-substring，它更长，有39行
并且其中包含了delete-and-extract-region。
delete-and-extract-region是用C语言编写的。

见 使用 @code{defvar} 初始化变量

@end ignore

@code{copy-region-as-kill} 函数是用Emacs Lisp编写的。其中的两个函数，@code{kill-append} 和 @code{kill-new}，复制缓冲区中的一段区域并将其保存在一个名为 @code{kill-ring} 的变量中。本节描述了如何使用 @code{defvar} 特殊形式创建和初始化 @code{kill-ring} 变量。

（再次注意，术语 @code{kill-ring} 是不准确的。从缓冲区中剪切出来的文本可以被还原；它不是一个尸体环，而是一个可以复活的文本环。）

在Emacs Lisp中，诸如 @code{kill-ring} 这样的变量是通过使用 @code{defvar} 特殊形式创建并赋予初始值的。其名称来自于“定义变量”。

@code{defvar} 特殊形式类似于 @code{setq}，因为它设置变量的值。但与 @code{setq} 不同的有两点：首先，它仅在变量尚未具有值时设置变量的值。如果变量已经有值，@code{defvar} 就不会覆盖现有值。其次，@code{defvar} 具有文档字符串。

（有一个相关的宏，@code{defcustom}，用于用户自定义的变量。它比 @code{defvar} 更强大。
（@xref{defcustom, , 使用 @code{defcustom} 设置变量}。）

@menu
* 查看变量当前值::
* defvar 和星号::
@end menu

@ifnottex
@node 查看变量当前值
@unnumberedsubsec 查看变量的当前值
@end ifnottex

您可以使用 @code{describe-variable} 函数查看任何变量的当前值，通常通过键入 @kbd{C-h v} 调用。如果在提示时键入 @kbd{C-h v} 然后键入 @code{kill-ring}（然后按 @key{RET}），您将看到当前剪切环中的内容，这可能很多！相反，如果在本次Emacs会话中除了阅读本文档之外什么都没有做，那么可能什么都没有。此外，您将看到 @code{kill-ring} 的文档：

@smallexample
@group
文档：
已删除文本序列的列表。
由于剪切环应该与窗口系统提供的剪切和粘贴功能良好地交互，因此应使用此变量
@end group
@group
与`interprogram-cut-function'和
`interprogram-paste-function'良好交互。 函数`kill-new'，
`kill-append'和`current-kill'应实现此交互；
您可能希望使用它们而不是直接操作剪切环。
@end group
@end smallexample

@need 800
剪切环的定义如下：

@smallexample
@group
(defvar kill-ring nil
  "已删除文本序列的列表。
@dots{}")
@end group
@end smallexample

@noindent
在此变量定义中，变量被赋予初始值 @code{nil}，这是有道理的，因为如果您没有保存任何内容，那么在执行 @code{yank} 命令时您希望得到空白。文档字符串的写法与 @code{defun} 的文档字符串相同。与 @code{defun} 的文档字符串一样，文档的第一行应该是一个完整的句子，因为一些命令（如 @code{apropos}）仅打印文档的第一行。后续行不应缩进，否则在使用 @kbd{C-h v}（@code{describe-variable}）时会显得奇怪。

@node defvar 和星号
@subsection @code{defvar} 和星号
@findex defvar @r{用于用户可定制的变量}
@findex defvar @r{带有星号}

过去，Emacs 在内部变量和用户可能更改的变量上都使用了 @code{defvar} 特殊形式。尽管您仍然可以使用 @code{defvar} 来定义用户可定制的变量，请改用 @code{defcustom}，因为它提供了进入定制命令的路径。
（@xref{defcustom, , 使用 @code{defcustom} 指定变量}。）

当使用 @code{defvar} 特殊形式指定变量时，您可以通过在其文档字符串的第一列键入星号（@samp{*}）来区分用户可能想更改的变量和其他变量。例如：

@smallexample
@group
(defvar shell-command-default-error-buffer nil
  "*'shell-command' @dots{}错误输出的缓冲区名称。
@dots{} ")
@end group
@end smallexample

@findex set-variable
@noindent
您可以（仍然可以）使用 @code{set-variable} 命令临时更改 @code{shell-command-default-error-buffer} 的值。但是，使用 @code{set-variable} 设置的选项仅在编辑会话期间设置。新值在会话之间不会保存。每次Emacs启动时，它都会读取原始值，除非您在 @file{.emacs} 文件中更改了该值，要么手动设置它，要么使用 @code{customize}。
@xref{Emacs Initialization, , 您的 @file{.emacs} 文件}。

对我来说，@code{set-variable} 命令的主要用途是建议我可能希望在 @file{.emacs} 文件中设置的变量。现在有700多个这样的变量，太多了，记不住。幸运的是，在调用 @code{M-x set-variable} 命令后，您可以按 @key{TAB} 键查看变量的列表。
（@xref{Examining, , 检查和设置变量, emacs, GNU Emacs手册}。）

@need 1250
@node cons & search-fwd Review
@section Review

这里是一些最近引入的函数的简要概述。

@table @code
@item car
@itemx cdr
@code{car} 返回列表的第一个元素；@code{cdr} 返回列表的第二个及后续元素。

@need 1250
例如：

@smallexample
@group
(car '(1 2 3 4 5 6 7))
     @result{} 1
(cdr '(1 2 3 4 5 6 7))
     @result{} (2 3 4 5 6 7)
@end group
@end smallexample

@item cons
@code{cons}通过将其第一个参数添加到其第二个参数前构造一个列表。

@need 1250
例如：

@smallexample
@group
(cons 1 '(2 3 4))
     @result{} (1 2 3 4)
@end group
@end smallexample

@item funcall
@code{funcall} 将其第一个参数作为函数求值，并将其余参数传递给其第一个参数。

@item nthcdr
返回在列表上对 @sc{cdr} 进行 @var{n} 次操作的结果。
@iftex
这是
@tex
$n^{th}$
@end tex
@code{cdr}。
@end iftex
可以看作是“剩下的剩下”。

@need 1250
例如：

@smallexample
@group
(nthcdr 3 '(1 2 3 4 5 6 7))
     @result{} (4 5 6 7)
@end group
@end smallexample

@item setcar
@itemx setcdr
@code{setcar} 改变列表的第一个元素；@code{setcdr} 改变列表的第二个及后续元素。

@need 1250
例如：

@smallexample
@group
(setq triple (list 1 2 3))

(setcar triple '37)

triple
     @result{} (37 2 3)

(setcdr triple '("foo" "bar"))

triple
     @result{} (37 "foo" "bar")
@end group
@end smallexample

@item progn
按顺序评估每个参数，然后返回最后一个的值。

@need 1250
例如：

@smallexample
@group
(progn 1 2 3 4)
     @result{} 4
@end group
@end smallexample

@item save-restriction
记录当前缓冲区中生效的任何缩小范围，并在评估参数后恢复该缩小。

@item search-forward
搜索字符串，如果找到，移动点。使用正则表达式时，请使用类似的 @code{re-search-forward}。
(@xref{正则表达式搜索, , 正则表达式搜索}，了解正则表达式模式和搜索的解释。)

@need 1250
@noindent
@code{search-forward} 和 @code{re-search-forward} 需要四个参数：

@enumerate
@item
要搜索的字符串或正则表达式。

@item
可选地，搜索的限制。

@item
可选地，如果搜索失败，返回 @code{nil} 或错误消息。

@item
可选地，重复搜索的次数；如果为负数，则向后搜索。
@end enumerate

@item kill-region
@itemx delete-and-extract-region
@itemx copy-region-as-kill

@code{kill-region} 剪切点和标记之间的文本，并将该文本存储在kill ring中，因此您可以通过粘贴将其取回。

@code{copy-region-as-kill} 将点和标记之间的文本复制到kill ring中，可以通过粘贴获取。该函数不会从缓冲区中删除文本。

@end table

@code{delete-and-extract-region} 从缓冲区中移除点和标记之间的文本并将其丢弃。您无法再获取它。 (这不是一个交互式命令。)

@need 1500
@node search Exercises
@section 搜索练习

@itemize @bullet
@item
编写一个交互式函数，用于搜索字符串。如果搜索找到字符串，将光标放在字符串后面并显示消息：“找到了！”（请勿使用@code{search-forward}作为此函数的名称；如果这样做，将覆盖Emacs自带的@code{search-forward}版本。请使用诸如@code{test-search}的名称。）

@item
编写一个函数，在回显区域打印剪切环的第三个元素（如果存在）；如果剪切环不包含第三个元素，则打印相应的消息。
@end itemize

@node 列表实现
@chapter 如何实现列表
@cindex 计算机中的列表

在Lisp中，原子以一种直截了当的方式记录；如果在实践中实现不够直截了当，理论上仍然是直截了当的。例如，原子 @samp{rose} 被记录为四个连续的字母 @samp{r}、@samp{o}、@samp{s}、@samp{e}。然而，列表的存储方式不同。机制同样简单，但需要一些时间来适应这个概念。列表使用一系列指针对来维护。在这个系列中，每对中的第一个指针指向一个原子或另一个列表，而每对中的第二个指针指向下一对，或者指向表示列表结束的符号 @code{nil}。

指针本身就是指向所指对象的电子地址。因此，列表被保存为一系列电子地址。

@menu
* 列表示意图::
* 符号作为箱子::       探索一个强有力的隐喻。
* 列表练习::
@end menu

@ifnottex
@node 列表示意图
@unnumberedsec 列表示意图
@end ifnottex

例如，列表 @code{(rose violet buttercup)} 有三个元素，@samp{rose}、@samp{violet} 和 @samp{buttercup}。在计算机中，@samp{rose} 的电子地址记录在称为 @dfn{cons cell}（因为它实际上是函数 @code{cons} 创建的东西）的计算机内存段中。该 cons cell 还保存了指向第二个 cons cell 的地址，其 @sc{car} 是原子 @samp{violet}；而该地址（指示如何找到 @samp{violet} 的地址）与保存原子 @samp{buttercup} 的地址一起保存在第三个 cons cell 的地址中。

@need 1200
这听起来比实际上更复杂，但在图表中更容易理解：

@c 清除打印后期图形
@c !!! cons-cell-diagram #1
@ifnottex
@smallexample
@group
    ___ ___      ___ ___      ___ ___
   |___|___|--> |___|___|--> |___|___|--> nil
     |            |            |
     |            |            |
      --> rose     --> violet   --> buttercup
@end group
@end smallexample
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-1}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
    ___ ___      ___ ___      ___ ___
   |___|___|--> |___|___|--> |___|___|--> nil
     |            |            |
     |            |            |
      --> rose     --> violet   --> buttercup
@end group
@end smallexample
@end iftex
@end ifclear

@noindent
在图表中，每个框表示计算机内存中的一个字，通常以内存地址的形式保存一个Lisp对象。框，即地址，是成对出现的。每个箭头指向地址所指的内容，要么是一个原子，要么是另一对地址。第一个框是 @samp{rose} 的电子地址，箭头指向 @samp{rose}；第二个框是下一对框的地址，其第一部分是 @samp{violet} 的地址，第二部分是下一对的地址。最后一个框指向符号 @code{nil}，表示列表的结束。

@need 1200
当变量使用诸如 @code{setq} 这样的操作设置为列表时，它将存储在变量中的第一个框的地址。因此，表达式的求值

@smallexample
(setq bouquet '(rose violet buttercup))
@end smallexample

@need 1250
@noindent
会创建这样的情况：

@c cons-cell-diagram #2
@ifnottex
@smallexample
@group
bouquet
     |
     |     ___ ___      ___ ___      ___ ___
      --> |___|___|--> |___|___|--> |___|___|--> nil
            |            |            |
            |            |            |
             --> rose     --> violet   --> buttercup
@end group
@end smallexample
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-2}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
bouquet
     |
     |     ___ ___      ___ ___      ___ ___
      --> |___|___|--> |___|___|--> |___|___|--> nil
            |            |            |
            |            |            |
             --> rose     --> violet   --> buttercup
@end group
@end smallexample
@end iftex
@end ifclear

@noindent
在此示例中，符号 @code{bouquet} 持有第一对框的地址。

@need 1200
相同的列表可以用不同类型的框符号表示，如下所示：

@c cons-cell-diagram #2a
@ifnottex
@smallexample
@group
bouquet
 |
 |    --------------       ---------------       ----------------
 |   | car   | cdr  |     | car    | cdr  |     | car     | cdr  |
  -->| rose  |   o------->| violet |   o------->| butter- |  nil |
     |       |      |     |        |      |     | cup     |      |
      --------------       ---------------       ----------------
@end group
@end smallexample
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-2a}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
bouquet
 |
 |    --------------       ---------------       ----------------
 |   | car   | cdr  |     | car    | cdr  |     | car     | cdr  |
  -->| rose  |   o------->| violet |   o------->| butter- |  nil |
     |       |      |     |        |      |     | cup     |      |
      --------------       ---------------       ----------------
@end group
@end smallexample
@end iftex
@end ifclear

（符号由不仅仅是地址对组成，但符号的结构由地址组成。实际上，符号 @code{bouquet} 由一组地址框组成，其中一个是打印字 @samp{bouquet} 的地址，第二个是附加到符号的函数定义的地址（如果有的话），第三个是列表 @code{(rose violet buttercup)} 的地址的第一对地址框，依此类推。这里我们显示符号的第三个地址框指向列表的第一对地址框。）

如果将符号设置为列表的 @sc{cdr}，列表本身不会改变；符号只是具有列表中更远地址的地址。 （在行话中，@sc{car} 和 @sc{cdr} 是“非破坏性的”）因此，对以下表达式的求值

@smallexample
(setq flowers (cdr bouquet))
@end smallexample

@need 800
@noindent
会产生：

@c cons-cell-diagram #3
@ifnottex
@sp 1
@smallexample
@group
bouquet        flowers
  |              |
  |     ___ ___  |     ___ ___      ___ ___
   --> |   |   |  --> |   |   |    |   |   |
       |___|___|----> |___|___|--> |___|___|--> nil
         |              |            |
         |              |            |
          --> rose       --> violet   --> buttercup
@end group
@end smallexample
@sp 1
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-3}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@sp 1
@smallexample
@group
bouquet        flowers
  |              |
  |     ___ ___  |     ___ ___      ___ ___
   --> |   |   |  --> |   |   |    |   |   |
       |___|___|----> |___|___|--> |___|___|--> nil
         |              |            |
         |              |            |
          --> rose       --> violet   --> buttercup
@end group
@end smallexample
@sp 1
@end iftex
@end ifclear

@need 1200
@noindent
变量 @code{flowers} 的值是 @code{(violet buttercup)}，也就是说，符号 @code{flowers} 持有地址的对应的框，其中第一个框持有 @code{violet} 的地址，第二个框持有 @code{buttercup} 的地址。

@cindex 点对
@cindex cons cell
一对地址框称为 @dfn{cons cell} 或 @dfn{点对}。有关 cons cell 和点对的更多信息，请参见 @xref{Cons Cell Type, , Cons Cell and List Types, elisp, The GNU Emacs Lisp Reference Manual}，以及 @ref{Dotted Pair Notation, , Dotted Pair Notation, elisp, The GNU Emacs Lisp Reference Manual}。

@need 1200
函数 @code{cons} 将一个新的地址对添加到上面所示的地址系列的前面。例如，对以下表达式的求值

@smallexample
(setq bouquet (cons 'lily bouquet))
@end smallexample

@need 1500
@noindent
产生：

@c cons-cell-diagram #4
@ifnottex
@sp 1
@smallexample
@group
bouquet                       flowers
  |                             |
  |     ___ ___        ___ ___  |     ___ ___       ___ ___
   --> |   |   |      |   |   |  --> |   |   |     |   |   |
       |___|___|----> |___|___|----> |___|___|---->|___|___|--> nil
         |              |              |             |
         |              |              |             |
          --> lily      --> rose       --> violet    --> buttercup
@end group
@end smallexample
@sp 1
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-4}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@sp 1
@smallexample
@group
bouquet                       flowers
  |                             |
  |     ___ ___        ___ ___  |     ___ ___       ___ ___
   --> |   |   |      |   |   |  --> |   |   |     |   |   |
       |___|___|----> |___|___|----> |___|___|---->|___|___|--> nil
         |              |              |             |
         |              |              |             |
          --> lily      --> rose       --> violet    --> buttercup
@end group
@end smallexample
@sp 1
@end iftex
@end ifclear

@need 1200
@noindent
然而，这并不会改变符号 @code{flowers} 的值，可以通过求值以下表达式来查看：

@smallexample
(eq (cdr (cdr bouquet)) flowers)
@end smallexample

@noindent
这会返回 @code{t}，表示为真。

在被重新设置之前，@code{flowers} 仍然具有值 @code{(violet buttercup)}；也就是说，它持有第一个框的地址，该框的第一个地址是 @code{violet}。

总而言之，在Lisp中，要获得列表的 @sc{cdr}，只需获取系列中下一个 cons cell 的地址；要获取列表的 @sc{car}，只需获取列表的第一个元素的地址；要在列表前面添加新元素，只需在列表的前面添加一个新的 cons cell。就是这样！Lisp的底层结构非常简单！

而在一系列 cons 单元中，最后一个地址指向什么呢？它指向空列表，即 @code{nil} 的地址。

总之，当一个 Lisp 变量被设置为某个值时，它会被赋予指向该变量所引用的列表的地址。

@node 符号作为抽屉
@section 符号作为抽屉式储物柜
@cindex 符号作为抽屉式储物柜
@cindex 抽屉式储物柜，作为符号的隐喻
@cindex 抽屉，抽屉式储物柜，作为符号的隐喻

在早期的一节中，我建议你将符号想象成一个抽屉式储物柜。一个抽屉放置函数定义，另一个抽屉放置值，依此类推。放在存放值的抽屉中的内容可以更改，而不影响放置函数定义的抽屉中的内容，反之亦然。

实际上，放在每个抽屉中的是值或函数定义的地址。就好像你在阁楼上发现了一只旧箱子，在其中一个抽屉里找到了一张地图，指引你找到埋藏的宝藏的地方。

（除了名称、符号定义和变量值之外，符号还有一个用于记录其他信息的@dfn{属性列表}抽屉。这里不讨论属性列表；请参阅@ref{Property Lists, , Property Lists, elisp，GNU Emacs Lisp参考手册}。）

@need 1500
这里是一个幻想的表示：

@c 抽屉式储物柜图表
@ifnottex
@sp 1
@smallexample
@group
            抽屉式储物柜            抽屉的内容

            __   o0O0o   __
          /                 \
         ---------------------
        |    符号名称的方向    |            [指向地图]
        |                     |             花束
        +---------------------+
        |    符号定义的方向    |
        |                     |             [无]
        +---------------------+
        |    变量值的方向      |            [指向地图]
        |                     |             (玫瑰 紫罗兰 毛茛)
        +---------------------+
        |    属性列表的方向    |             [这里不描述]
        |                     |
        +---------------------+
        |/                   \|
@end group
@end smallexample
@sp 1
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{drawers}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@sp 1
@smallexample
@group
            抽屉式储物柜            抽屉的内容

            __   o0O0o   __
          /                 \
         ---------------------
        |    符号名称的方向    |            [指向地图]
        |                     |             花束
        +---------------------+
        |    符号定义的方向    |
        |                     |             [无]
        +---------------------+
        |    变量值的方向      |            [指向地图]
        |                     |             (玫瑰 紫罗兰 毛茛)
        +---------------------+
        |    属性列表的方向    |             [这里不描述]
        |                     |
        +---------------------+
        |/                   \|
@end group
@end smallexample
@sp 1
@end iftex
@end ifclear

@node 列表练习
@section 练习

将@code{flowers}设置为@code{violet}和@code{buttercup}。在这个列表上再连接两朵花，并将这个新列表设置为@code{more-flowers}。将@code{flowers}的@sc{car}设置为一条鱼。现在，@code{more-flowers}列表包含什么？

@node 插入文本
@chapter 插入文本
@findex 插入
@cindex 文本检索
@cindex 检索文本
@cindex 粘贴文本

在GNU Emacs中，每当你使用一个kill命令从缓冲区中剪切文本，你都可以使用yank命令将其还原。从缓冲区中剪切出的文本被放入kill环中，而yank命令则将kill环的相应内容插入到缓冲区中（不一定是原始缓冲区）。

一个简单的@kbd{C-y}（@code{yank}）命令将kill环中的第一个条目插入到当前缓冲区中。如果@kbd{C-y}命令后面紧跟着@kbd{M-y}，那么第一个元素将被第二个元素替换。随后的@kbd{M-y}命令将第二个元素替换为第三个、第四个或第五个元素，依此类推。当达到kill环中的最后一个元素时，它将被第一个元素替换，然后循环重复。（因此，kill环被称为“环”而不仅仅是一个“列表”。然而，实际保存文本的数据结构是一个列表。@xref{Kill Ring, , 处理Kill环}，了解如何将列表作为环处理的详细信息。）

@menu
* Kill环概述::
* kill-ring-yank-pointer::      Kill环是一个列表。
* yank nthcdr 练习::           @code{kill-ring-yank-pointer}变量。
@end menu

@node 剪切环概述
@section 剪切环概述
@cindex 剪切环概述

剪切环是一组文本字符串的列表。它的结构如下所示：

@smallexample
("一些文本" "不同的文本片段" "更多文本")
@end smallexample

如果这是我的剪切环的内容，并且我按下 @kbd{C-y} 键，那么包含字符串 @samp{一些文本} 的部分将被插入到我的光标所在位置。

@code{yank} 命令还用于通过复制来复制文本。复制的文本并未从缓冲区中删除，而是将其副本放入剪切环，并通过粘贴将其插入。

有三个函数用于从剪切环中恢复文本：@code{yank}，通常绑定到 @kbd{C-y}；@code{yank-pop}，通常绑定到 @kbd{M-y}；以及由这两个函数使用的 @code{rotate-yank-pointer}。

这些函数通过一个称为 @code{kill-ring-yank-pointer} 的变量引用剪切环。实际上，@code{yank} 和 @code{yank-pop} 函数的插入代码为：

@smallexample
(insert (car kill-ring-yank-pointer))
@end smallexample

@noindent
（好了，不再是这样了。在 GNU Emacs 22 中，该函数已被 @code{insert-for-yank} 替代，它会为每个 @code{yank-handler} 段重复调用 @code{insert-for-yank-1}。转而，@code{insert-for-yank-1} 根据 @code{yank-excluded-properties} 从插入的文本中去除文本属性。否则，它就像 @code{insert} 一样。我们将继续使用纯粹的 @code{insert}，因为它更容易理解。）

要开始理解 @code{yank} 和 @code{yank-pop} 如何工作，首先需要查看 @code{kill-ring-yank-pointer} 变量。

@node kill-ring-yank-pointer
@section 变量 @code{kill-ring-yank-pointer}

@code{kill-ring-yank-pointer} 是一个变量，就像 @code{kill-ring} 一样是一个变量。它通过绑定到它所指向的值来指向某个东西，就像任何其他 Lisp 变量一样。

@need 1000
因此，如果 kill 环的值为：

@smallexample
("一些文本" "另一段文本" "更多文本")
@end smallexample

@need 1250
@noindent
而 @code{kill-ring-yank-pointer} 指向第二个元素，那么 @code{kill-ring-yank-pointer} 的值就是：

@smallexample
("另一段文本" "更多文本")
@end smallexample

如前一章节所解释的（@pxref{列表实现}），计算机并不保留被 @code{kill-ring} 和 @code{kill-ring-yank-pointer} 指向的文本的两个不同副本。"另一段文本"和"更多文本"这两个词不会被复制。相反，这两个 Lisp 变量指向相同的文本片段。以下是一个图示：

@c cons-cell-diagram #5
@ifnottex
@smallexample
@group
kill-ring     kill-ring-yank-pointer
    |               |
    |      ___ ___  |     ___ ___      ___ ___
     ---> |   |   |  --> |   |   |    |   |   |
          |___|___|----> |___|___|--> |___|___|--> nil
            |              |            |
            |              |            |
            |              |             --> "更多文本"
            |              |
            |               --> "另一段文本"
            |
             --> "一些文本"
@end group
@end smallexample
@sp 1
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-5}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
kill-ring     kill-ring-yank-pointer
    |               |
    |      ___ ___  |     ___ ___      ___ ___
     ---> |   |   |  --> |   |   |    |   |   |
          |___|___|----> |___|___|--> |___|___|--> nil
            |              |            |
            |              |            |
            |              |             --> "更多文本"
            |              |
            |               --> "另一段文本"
            |
             --> "一些文本"
@end group
@end smallexample
@sp 1
@end iftex
@end ifclear

变量 @code{kill-ring} 和变量 @code{kill-ring-yank-pointer} 都是指针。但是 kill 环本身通常被描述成它实际由什么组成。@code{kill-ring} 通常被视为保存最近从 Emacs 缓冲区中剪切的信息的完整数据结构。另一方面，@code{kill-ring-yank-pointer} 用于指示——即指向——kill 环的哪一部分将被插入。

@ignore
在 GNU Emacs 22 中，@code{kill-new} 函数调用：

@code{(setq kill-ring-yank-pointer kill-ring)}

(defun rotate-yank-pointer (arg)
  "旋转 kill 环的插入点。
带有参数时，向前旋转（如果是负数则向后旋转）那么多个插入点。"
  (interactive "p")
  (current-kill arg))

(defun current-kill (n &optional do-not-move)
  "将插入点旋转 N 个位置，然后返回该插入点的值。
如果 N 为零，`interprogram-paste-function' 被设置，并且调用它返回一个字符串，
则将该字符串添加到 kill 环的前面，并作为最新的插入点返回。
如果可选参数 DO-NOT-MOVE 非空，则不要实际移动插入点；只返回向前第 N 个插入点。"
  (let ((interprogram-paste (and (= n 0)
                                 interprogram-paste-function
                                 (funcall interprogram-paste-function))))
    (if interprogram-paste
        (progn
          ;; 在我们将新文本添加到 kill 环时禁用 interprogram cut 函数，
          ;; 以便 Emacs 不尝试拥有相同的文本选择。
          (let ((interprogram-cut-function nil))
            (kill-new interprogram-paste))
          interprogram-paste)
      (or kill-ring (error "Kill ring is empty"))
      (let ((ARGth-kill-element
             (nthcdr (mod (- n (length kill-ring-yank-pointer))
                          (length kill-ring))
                     kill-ring)))
        (or do-not-move
            (setq kill-ring-yank-pointer ARGth-kill-element))
        (car ARGth-kill-element)))))

@end ignore

@need 1500
@node yank nthcdr 练习
@section 使用 @code{yank} 和 @code{nthcdr} 的练习

@itemize @bullet
@item
使用 @kbd{C-h v} (@code{describe-variable})，查看你的kill ring的值。向kill ring中添加几个项，再次查看其值。使用 @kbd{M-y} (@code{yank-pop})，在kill ring中循环移动。你的kill ring中有多少项？找到 @code{kill-ring-max} 的值。你的kill ring是满的吗，还是可以保存更多文本块？

@item
使用 @code{nthcdr} 和 @code{car}，构建一系列表达式，返回列表的第一、第二、第三和第四个元素。
@end itemize

@node 循环与递归
@chapter 循环和递归
@cindex 循环和递归
@cindex 递归和循环
@cindex 重复（循环）

Emacs Lisp 有两种主要的方式来使一个表达式或一系列表达式被重复地评估：一种使用 @code{while} 循环，另一种使用 @dfn{递归}。

重复可以是非常有价值的。例如，要前进四个句子，你只需要编写一个程序，该程序将前进一句，然后重复这个过程四次。由于计算机不会感到无聊或疲劳，这种重复的动作不会像对人类可能有害的过度或错误的重复那样产生不良影响。

大多数人使用 @code{while} 循环及其类似物来编写 Emacs Lisp 函数；但你也可以使用递归，它提供了一种非常强大的思考和解决问题的方式@footnote{你可以编写递归函数，让其在使用心智或计算资源时既节俭又浪费；实际上，人们发现易于使用——对心智资源节俭的方法——有时会使用相当多的计算资源。Emacs 设计用于运行在我们现在认为有限的机器上，其默认设置是保守的。你可能需要增加 @code{max-lisp-eval-depth} 的值。在我的 @file{.emacs} 文件中，我将其设置为默认值的30倍。}。

@menu
* while::                       导致代码段重复执行。
* dolist dotimes::
* Recursion::                   导致函数调用自身。
* Looping exercise::
@end menu

@node while
@section @code{while}
@cindex 循环
@findex while

特殊形式 @code{while} 用于测试通过评估其第一个参数返回的值是否为真或假。这类似于Lisp解释器对 @code{if} 的处理方式；然而，解释器接下来的操作有所不同。

在 @code{while} 表达式中，如果通过评估第一个参数返回的值为假，Lisp解释器将跳过表达式的其余部分（表达式的 @dfn{主体}）并不予以评估。然而，如果该值为真，则Lisp解释器将评估表达式的主体，然后再次测试 @code{while} 的第一个参数是真还是假。如果通过评估第一个参数返回的值再次为真，Lisp解释器将再次评估表达式的主体。

@need 1200
@code{while} 表达式的模板如下：

@smallexample
@group
(while @var{true-or-false-test}
  @var{body}@dots{})
@end group
@end smallexample

@menu
* 使用 while 循环::          当测试返回 true 时重复执行。
* 循环示例::                  使用列表的 @code{while} 循环。
* print-elements-of-list::    使用 @code{while}、@code{car}、@code{cdr}。
* 增量循环::                  带有递增计数器的循环。
* 增量循环详解::
* 递减循环::                  带有递减计数器的循环。
@end menu

@ifnottex
@node 使用 while 循环
@unnumberedsubsec 使用 @code{while} 循环
@end ifnottex

只要 @code{while} 表达式的 true-or-false-test 在评估时返回真值，就会重复评估主体。这个过程称为循环，因为Lisp解释器一遍又一遍地重复相同的操作，就像一架飞机做环形飞行一样。当评估 true-or-false-test 的结果为假时，Lisp解释器将不再评估 @code{while} 的其余部分并退出循环。

显然，如果通过评估 @code{while} 的第一个参数返回的值始终为真，那么接下来的主体将一遍又一遍地被评估……而且永远都是如此。相反，如果返回的值从不为真，主体中的表达式将永远不会被评估。编写 @code{while} 循环的技巧在于选择一种机制，使得 true-or-false-test 仅在您希望后续表达式被评估的次数返回真，然后使测试返回假。

通过评估 @code{while} 的返回值是 true-or-false-test 的值。这样做的一个有趣的结果是，如果 @code{while} 循环评估成功且没有错误，它将始终返回 @code{nil} 或 false，无论它循环了1次还是100次，甚至一次都没有循环。成功评估的 @code{while} 表达式永远不返回真值！这意味着 @code{while} 总是被评估为其副作用，也就是评估循环体内表达式的后果。这是有道理的。人们追求的不仅仅是循环的行为，更是循环体内表达式反复评估时产生的后果。

@node 循环示例
@subsection 使用 @code{while} 循环和列表

控制 @code{while} 循环的常见方法是测试列表是否包含任何元素。如果包含元素，则循环将继续；但如果不包含元素，则循环结束。由于这是一种重要的技术，我们将创建一个简短的示例来说明它。

测试列表是否包含元素的一种简单方法是评估列表：如果没有元素，它是一个空列表，将返回空列表 @code{()}，这是 @code{nil} 或 false 的同义词。另一方面，具有元素的列表在评估时将返回这些元素。由于Emacs Lisp认为任何非 @code{nil} 的值都为真，因此返回元素的列表在 @code{while} 循环中将测试为真。

@need 1200
例如，您可以通过评估以下 @code{setq} 表达式将变量 @code{empty-list} 设置为 @code{nil}：

@smallexample
(setq empty-list ())
@end smallexample

@noindent
在评估了 @code{setq} 表达式之后，您可以以通常的方式评估变量 @code{empty-list}，即将光标放在符号后面，然后键入 @kbd{C-x C-e}；在您的回显区域中将显示 @code{nil}：

@smallexample
empty-list
@end smallexample

另一方面，如果将变量设置为具有元素的列表，则在评估变量时将显示该列表，如通过评估以下两个表达式所示：

@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))

animals
@end group
@end smallexample

因此，要创建一个 @code{while} 循环，测试列表 @code{animals} 中是否有任何项，循环的第一部分将被编写为：

@smallexample
@group
(while animals
       @dots{}
@end group
@end smallexample

@noindent
当 @code{while} 测试其第一个参数时，变量 @code{animals} 被评估。它返回一个列表。只要列表具有元素，@code{while} 将认为测试的结果为真；但当列表为空时，它将认为测试的结果为假。

为防止 @code{while} 循环无限运行，需要提供某种机制以最终清空列表。一个常用的技术是在 @code{while} 表达式的后续形式中之一将列表的值设置为列表的 @sc{cdr}。每次评估 @code{cdr} 函数时，列表都会变得更短，直到最终只剩下空列表。此时，@code{while} 循环的测试将返回假，@code{while} 的参数将不再被评估。

例如，将绑定到变量 @code{animals} 的动物列表可以通过以下表达式设置为原始列表的 @sc{cdr}：

@smallexample
(setq animals (cdr animals))
@end smallexample

@noindent
如果您已经评估了前面的表达式，然后评估此表达式，您将在回显区域中看到 @code{(giraffe lion tiger)}。如果再次评估表达式，将显示 @code{(lion tiger)}。如果再次评估它，@code{(tiger)} 将出现，然后是空列表，由 @code{nil} 表示。

使用 @code{cdr} 反复使真或假测试最终测试为假的 @code{while} 循环的模板如下：

@smallexample
@group
(while @var{test-whether-list-is-empty}
  @var{body}@dots{}
  @var{set-list-to-cdr-of-list})
@end group
@end smallexample

这个测试和使用 @code{cdr} 的功能可以放在一起，形成一个函数，该函数遍历列表并在各自的行上打印列表的每个元素。

@node print-elements-of-list
@subsection 示例：@code{print-elements-of-list} 函数
@findex print-elements-of-list

@code{print-elements-of-list} 函数演示了使用列表的 @code{while} 循环。

@cindex @file{*scratch*} 缓冲区
该函数需要多行输出。如果您正在使用最近版本的 GNU Emacs 阅读此文档，您可以像往常一样在 Info 中评估以下表达式。

如果您使用较早版本的 Emacs，则需要将必要的表达式复制到 @file{*scratch*} 缓冲区并在那里进行评估。这是因为早期版本的回显区只有一行。

您可以通过使用 @kbd{C-@key{SPC}}（@code{set-mark-command}）标记区域的开头，将光标移动到区域的末尾，然后使用 @kbd{M-w}（@code{kill-ring-save}，它调用 @code{copy-region-as-kill} 并提供视觉反馈）来复制区域。在 @file{*scratch*} 缓冲区中，您可以通过键入 @kbd{C-y}（@code{yank}）将表达式还原。

在将表达式复制到 @file{*scratch*} 缓冲区后，逐个评估每个表达式。确保通过键入 @kbd{C-u C-x C-e} 评估最后一个表达式 @code{(print-elements-of-list animals)}，即通过给 @code{eval-last-sexp} 提供参数。这将导致评估的结果在 @file{*scratch*} 缓冲区中打印，而不是在回显区中打印（否则您将在回显区中看到类似于这样的内容：@code{^Jgazelle^J^Jgiraffe^J^Jlion^J^Jtiger^Jnil}，其中每个 @samp{^J} 代表一个换行符）。

@need 1500
您可以直接在 Info 缓冲区中评估这些表达式，回显区将增大以显示结果。

@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))

(defun print-elements-of-list (list)
  "逐行打印 LIST 的每个元素。"
  (while list
    (print (car list))
    (setq list (cdr list))))

(print-elements-of-list animals)
@end group
@end smallexample

@need 1200
@noindent
当您按顺序评估这三个表达式时，将看到以下结果：

@smallexample
@group
gazelle

giraffe

lion

tiger
nil
@end group
@end smallexample

列表的每个元素都打印在自己的一行上（这是函数 @code{print} 的作用），然后打印函数的返回值。由于函数中的最后一个表达式是 @code{while} 循环，而且由于 @code{while} 循环总是返回 @code{nil}，因此在列表的最后一个元素后打印了一个 @code{nil}。

@node 增量循环
@subsection 具有增量计数器的循环

循环如果没有在应该停止的时候停止，就毫无用处。除了使用列表控制循环外，另一种常见的停止循环的方式是将第一个参数写为一个测试，当正确的重复次数完成时返回false。这意味着循环必须有一个计数器，即一个表达式，用于计算循环重复的次数。

@ifnottex
@node 增量循环细节
@unnumberedsubsec 增量循环的细节
@end ifnottex

具有增量计数器的循环的测试可以是诸如 @code{(< count desired-number)} 的表达式，如果 @code{count} 的值小于 @code{desired-number}，则返回 @code{t} 为true，如果 @code{count} 的值等于或大于 @code{desired-number}，则返回 @code{nil} 为false。增加计数的表达式可以是一个简单的 @code{setq}，例如 @code{(setq count (1+ count))}，其中 @code{1+} 是Emacs Lisp中的内置函数，将1添加到其参数。 (表达式 @w{@code{(1+ count)}} 的结果与 @w{@code{(+ count 1)}} 相同，但对于人类来说更容易阅读。)

@need 1250
由增量计数器控制的 @code{while} 循环的模板如下：

@smallexample
@group
@var{set-count-to-initial-value}
(while (< count desired-number)         ; @r{true-or-false-test}
  @var{body}@dots{}
  (setq count (1+ count)))              ; @r{incrementer}
@end group
@end smallexample

@noindent
请注意，您需要设置 @code{count} 的初始值；通常将其设置为1。

@menu
* 增量示例::        计算三角形中的鹅卵石。
* 增量示例部分::   函数定义的各个部分。
* 增量示例完整::   将函数定义组合在一起。
@end menu

@node 增量示例
@unnumberedsubsubsec  具有增量计数器的示例

假设您正在沙滩上玩耍，决定做一个鹅卵石三角形，第一排放一个鹅卵石，第二排放两个，第三排放三个，依此类推，如下所示：

@sp 1
@c 鹅卵石图示
@ifnottex
@smallexample
@group
               *
              * *
             * * *
            * * * *
@end group
@end smallexample
@end ifnottex
@iftex
@smallexample
@group
               @bullet{}
              @bullet{} @bullet{}
             @bullet{} @bullet{} @bullet{}
            @bullet{} @bullet{} @bullet{} @bullet{}
@end group
@end smallexample
@end iftex
@sp 1

@noindent
(大约2500年前，毕达哥拉斯等人通过考虑这类问题发展了数论的开端。)

假设您想知道要制作一个有7排的三角形需要多少鹅卵石？

显然，您需要做的是将从1到7的数字相加。有两种方法可以做到这一点：从最小的数字开始，即1，按顺序相加列表中的数字1、2、3、4等；或者从最大的数字开始，按列表向下相加：7、6、5、4等。由于这两种机制都说明了编写 @code{while} 循环的常见方法，我们将创建两个示例，一个是递增计数，另一个是递减计数。在这个第一个示例中，我们将从1开始，然后添加2、3、4等。

如果您只是在一个短列表中相加一些数字，最简单的方法是一次将所有数字相加。但是，如果您不知道列表将有多少数字，或者如果您希望为一个非常长的列表做好准备，那么您需要设计加法，以便您重复一个简单的过程多次，而不是一次执行更复杂的过程。

例如，与其一次性将所有鹅卵石相加，不如将第一排的鹅卵石数，即1，加到第二排的鹅卵石数2中，然后将这两排的总数加到第三排的鹅卵石数3中。然后，将第四排的鹅卵石数4加到前三排的总数中，依此类推。

这个过程的关键特征是每个重复的动作都很简单。在这种情况下，在每一步中，我们只添加两个数字，即排中的鹅卵石数和已找到的总数。这个添加两个数字的过程一遍又一遍地重复，直到最后一排的鹅卵石被添加到所有前排的总数中。在更复杂的循环中，重复的动作可能不那么简单，但它将比一次性做所有事情更简单。

@node 函数定义的组成部分
@unnumberedsubsubsec 函数定义的各部分

前面的分析为我们的函数定义提供了骨架：首先，我们需要一个变量，我们可以称之为 @code{total}，它将是函数返回的总的鹅卵石数量。这将是函数返回的值。

其次，我们知道函数将需要一个参数：这个参数将是三角形中的总行数。它可以被称为 @code{number-of-rows}。

最后，我们需要一个作为计数器的变量。我们可以称这个变量为 @code{counter}，但更好的名字是 @code{row-number}。这是因为在这个函数中，计数器的作用是计算行数，而程序应该尽可能易于理解。

当Lisp解释器首次开始评估函数中的表达式时，@code{total}的值应该设置为零，因为我们还没有向其中添加任何东西。然后，函数应该将第一行中的鹅卵石数量添加到总数中，然后将第二行的数量添加到总数中，然后将第三行的数量添加到总数中，依此类推，直到没有更多的行可以添加。

@code{total}和@code{row-number}都仅在函数内部使用，因此它们可以被声明为局部变量，并用@code{let}给予初始值。显然，@code{total}的初始值应为0。@code{row-number}的初始值应为1，因为我们从第一行开始。这意味着@code{let}语句将如下所示：

@smallexample
@group
  (let ((total 0)
        (row-number 1))
    @var{body}@dots{})
@end group
@end smallexample

在内部变量被声明并绑定到它们的初始值之后，我们可以开始@code{while}循环。作为测试的表达式应该在@code{row-number}小于或等于@code{number-of-rows}时返回true。如果表达式仅在行号小于三角形行数的情况下为true，最后一行将永远不会添加到总数中；因此行号必须小于或等于行数。

@need 1500
@findex <= @r{(小于或等于)}
Lisp提供了@code{<=}函数，如果其第一个参数的值小于或等于其第二个参数的值，则返回true，否则返回false。因此，@code{while}将评估为测试的表达式应如下所示：

@smallexample
(<= row-number number-of-rows)
@end smallexample

鹅卵石的总数量可以通过重复将一行中的鹅卵石数量添加到已找到的总数中来找到。由于一行中的鹅卵石数量等于行号，因此可以通过将行号添加到总数中来找到总数。

@smallexample
(setq total (+ total row-number))
@end smallexample

@noindent
这做的是将@code{total}的新值设置为将鹅卵石数量添加到先前总数的和。

在设置了@code{total}的值之后，需要建立下一次循环的条件，如果有的话。这是通过增加@code{row-number}变量的值来完成的，它充当计数器。在增加@code{row-number}变量之后，@code{while}循环开头的true-or-false测试会测试其值是否仍然小于或等于@code{number-of-rows}的值，如果是，将新值添加到先前循环的@code{total}中。

@need 1200
内置的Emacs Lisp函数@code{1+}将1添加到一个数字，因此可以使用以下表达式递增@code{row-number}变量：

@smallexample
(setq row-number (1+ row-number))
@end smallexample

@node Inc Example altogether
@unnumberedsubsubsec Putting the function definition together
@need 800

我们已经创建了函数定义的各个部分；现在需要将它们组合起来。

首先，@code{while} 表达式的内容：

@smallexample
@group
(while (<= 行号 总行数)   ; @r{真或假的测试}
  (setq 总和 (+ 总和 行号))
  (setq 行号 (1+ 行号)))    ; @r{增量器}
@end group
@end smallexample

连同 @code{let} 表达式的变量列表，这几乎完成了函数定义的主体。但是，还需要一个微妙的最后要素。

最后的一步是将变量 @code{总和} 单独放在 @code{while} 表达式之后的一行上。否则，整个函数返回的值将是在 @code{let} 主体中最后一个表达式的值，而这是由 @code{while} 评估得到的，其值始终为 @code{nil}。

这一点乍一看可能不明显。它几乎看起来好像增量表达式是整个函数的最后一个表达式。但是该表达式是 @code{while} 主体的一部分；它是以符号 @code{while} 开始的列表的最后一个元素。此外，整个 @code{while} 循环是 @code{let} 主体内的列表。

@need 1250

概述来说，函数将如下所示：

@smallexample
@group
(defun @var{函数名} (@var{参数列表})
  "@var{文档}@dots{}"
  (let (@var{变量列表})
    (while (@var{真或假的测试})
      @var{while的主体}@dots{} )
    @dots{} ))                    ; @r{这里需要最后的表达式。}
@end group
@end smallexample

评估 @code{let} 的结果将是由 @code{defun} 返回的结果，因为 @code{let} 不嵌套在任何包含列表中，除了整个 @code{defun}。然而，如果 @code{while} 是 @code{let} 表达式的最后一个元素，函数将始终返回 @code{nil}。这不是我们想要的！相反，我们想要的是变量 @code{总和} 的值。通过简单地将该符号作为以 @code{let} 开始的列表的最后一个元素放置在列表中，它将在之前的元素被评估之后被评估，这意味着在为总和赋予正确值之后才被评估。

通过将以 @code{let} 开始的列表打印在一行上，可能更容易看到这一点。这种格式使得显而易见，@var{变量列表} 和 @code{while} 表达式是以 @code{let} 开始的列表的第二和第三个元素，而 @code{总和} 是最后一个元素：

@smallexample
@group
(let (@var{变量列表}) (while (@var{真或假的测试}) @var{while的主体}@dots{} ) 总和)
@end group
@end smallexample

@need 1200

将所有内容放在一起，@code{triangle} 函数定义如下：

@smallexample
@group
(defun triangle (总行数)    ; @r{带有}
                                    ; @r{  增量计数器的版本。}
  "将三角形中的鹅卵石数量相加。
第一行有一个鹅卵石，第二行有两个鹅卵石，
第三行有三个鹅卵石，依此类推。
参数为总行数。"
@end group
@group
  (let ((总和 0)
        (行号 1))
    (while (<= 行号 总行数)
      (setq 总和 (+ 总和 行号))
      (setq 行号 (1+ 行号)))
    总和))
@end group
@end smallexample

@need 1200

安装 @code{triangle} 后，您可以尝试它。以下是两个示例：

@smallexample
@group
(triangle 4)

(triangle 7)
@end group
@end smallexample

@noindent
前四个数字的总和是10，前七个数字的总和是28。

@node 递减循环
@subsection 带有递减计数器的循环

另一种常见的编写 @code{while} 循环的方式是编写测试，使其确定计数器是否大于零。只要计数器大于零，循环就会重复。但当计数器等于或小于零时，循环停止。为使此方法有效，计数器必须从大于零开始，然后通过一个可重复评估的形式逐渐减小。

测试将是诸如 @code{(> counter 0)} 的表达式，如果 @code{counter} 的值大于零，则返回 @code{t} 为 true，如果 @code{counter} 的值等于或小于零，则返回 @code{nil} 为 false。使数字逐渐减小的表达式可以是一个简单的 @code{setq}，例如 @code{(setq counter (1- counter))}，其中 @code{1-} 是 Emacs Lisp 中减去其参数的内置函数。

@need 1250
递减 @code{while} 循环的模板如下：

@smallexample
@group
(while (> counter 0)                    ; @r{真或假测试}
  @var{body}@dots{}
  (setq counter (1- counter)))          ; @r{递减器}
@end group
@end smallexample

@menu
* 递减示例::        海滩上更多的小石子。
* 递减示例部分::    函数定义的各个部分。
* 整体递减示例::    将函数定义组合在一起。
@end menu

@node 递减示例
@unnumberedsubsubsec 带有递减计数器的示例

为了说明带有递减计数器的循环，我们将重写 @code{triangle} 函数，使计数器递减到零。

这是该函数早期版本的反转。在这种情况下，要找出构成 3 行三角形所需的小石子数量，将第三行的小石子数量（3）与前一行的数量（2）相加，然后将这两行的总和添加到它们之前的行，即第一行（1）。

同样，要找出具有 7 行的三角形中的小石子数量，将第七行的小石子数量（7）与前一行的数量（6）相加，然后将这两行的总和添加到它们之前的行，即第五行（5），依此类推。与前一个示例一样，每次添加仅涉及两个数字的相加，已经添加的行的总和以及正在添加到总和的行的小石子数量。这个加法的过程一遍又一遍地重复，直到没有更多的小石子可添加。

我们知道从哪里开始有多少小石子：最后一行中的小石子数量等于行数。如果三角形有七行，最后一行中的小石子数量为 7。同样，我们知道前一行中有多少小石子：它比该行中的数量少一个。

@node Dec 示例部分
@unnumberedsubsubsec 函数定义的各部分

我们从三个变量开始：三角形中的总行数；每行中的小石子数；以及我们想要计算的小石子的总数。这些变量可以分别命名为 @code{number-of-rows}、@code{number-of-pebbles-in-row} 和 @code{total}。

@code{total} 和 @code{number-of-pebbles-in-row} 都仅在函数内部使用，并使用 @code{let} 进行声明。显然，@code{total} 的初始值应为零。然而，@code{number-of-pebbles-in-row} 的初始值应等于三角形中的行数，因为加法将从最长的行开始。

@need 1250
这意味着 @code{let} 表达式的开头将如下所示：

@smallexample
@group
(let ((total 0)
      (number-of-pebbles-in-row number-of-rows))
  @var{body}@dots{})
@end group
@end smallexample

小石子的总数可以通过重复将每行的小石子数加到已找到的总数中来找到，即通过反复评估以下表达式：

@smallexample
(setq total (+ total number-of-pebbles-in-row))
@end smallexample

@noindent
在将 @code{number-of-pebbles-in-row} 添加到 @code{total} 后，@code{number-of-pebbles-in-row} 应减一，因为下次循环重复时将添加前一行到总数中。

前一行中的小石子数比当前行中的小石子数少一个，因此可以使用内置的 Emacs Lisp 函数 @code{1-} 来计算前一行中的小石子数。可以使用以下表达式完成：

@smallexample
@group
(setq number-of-pebbles-in-row
      (1- number-of-pebbles-in-row))
@end group
@end smallexample

最后，我们知道 @code{while} 循环应在一行中没有小石子时停止重复添加。因此，@code{while} 循环的测试简单地是：

@smallexample
(while (> number-of-pebbles-in-row 0)
@end smallexample

@node Dec 示例整体
@unnumberedsubsubsec 将函数定义组合在一起

我们可以将这些表达式组合在一起以创建一个有效的函数定义。然而，在检查时，我们发现其中一个局部变量是不必要的！

@need 1250
函数定义如下：

@smallexample
@group
;;; @r{第一个减法版本。}
(defun triangle (number-of-rows)
  "将三角形中小石子的数量相加。"
  (let ((total 0)
        (number-of-pebbles-in-row number-of-rows))
    (while (> number-of-pebbles-in-row 0)
      (setq total (+ total number-of-pebbles-in-row))
      (setq number-of-pebbles-in-row
            (1- number-of-pebbles-in-row)))
    total))
@end group
@end smallexample

按照写法，这个函数是有效的。

然而，我们不需要 @code{number-of-pebbles-in-row}。

@cindex 参数作为局部变量
当评估 @code{triangle} 函数时，符号 @code{number-of-rows} 将绑定到一个数字，给它一个初始值。该数字可以在函数体内部像局部变量一样更改，而无需担心这样的更改会影响函数外部的变量值。这是 Lisp 的一个非常有用的特性；这意味着变量 @code{number-of-rows} 可以在函数中任何使用 @code{number-of-pebbles-in-row} 的地方使用。

@need 800
以下是稍微更清晰地编写的函数的第二个版本：

@smallexample
@group
(defun triangle (number)                ; @r{第二个版本。}
  "返回 1 到 NUMBER（包括）的数字的总和。"
  (let ((total 0))
    (while (> number 0)
      (setq total (+ total number))
      (setq number (1- number)))
    total))
@end group
@end smallexample

简而言之，一个正确编写的 @code{while} 循环将包含三个部分：

@enumerate
@item
一个测试，循环重复正确次数后将返回 false。

@item
一个表达式，其评估在重复评估后将返回所需值。

@item
一个表达式，用于更改传递给真假测试的值，以便在循环重复正确次数后测试返回 false。
@end enumerate

@node dolist dotimes
@section 节省时间：@code{dolist} 和 @code{dotimes}

除了 @code{while} 之外，@code{dolist} 和 @code{dotimes} 都提供了循环的功能。有时候，它们比等效的 @code{while} 循环更容易编写。两者都是Lisp宏。(@xref{宏, , 宏, elisp, GNU Emacs Lisp参考手册}.)

@code{dolist} 像一个 @code{while} 循环，不断地对列表进行 @sc{cdr} 操作：@code{dolist} 每次循环都会自动缩短列表---获取列表的 @sc{cdr}---并将每个缩短版本的列表的 @sc{car} 绑定到其第一个参数。

@code{dotimes} 循环指定的次数：您需要指定次数。

@menu
* dolist::
* dotimes::
@end menu

@node dolist
@unnumberedsubsec @code{dolist} 宏
@findex dolist

例如，假设您想反转一个列表，使得``first'' ``second'' ``third'' 变成 ``third'' ``second'' ``first''。

@need 1250
实际上，您可以使用 @code{reverse} 函数，如下所示：

@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))

(reverse animals)
@end group
@end smallexample

@need 800
@noindent
以下是使用 @code{while} 循环反转列表的方法：

@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))

(defun reverse-list-with-while (list)
  "使用while循环反转LIST的顺序。"
  (let (value)  ; 确保列表从空开始
    (while list
      (setq value (cons (car list) value))
      (setq list (cdr list)))
    value))

(reverse-list-with-while animals)
@end group
@end smallexample

@need 800
@noindent
以下是使用 @code{dolist} 宏的方法：

@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))

(defun reverse-list-with-dolist (list)
  "使用dolist宏反转LIST的顺序。"
  (let (value)  ; 确保列表从空开始
    (dolist (element list value)
      (setq value (cons element value)))))

(reverse-list-with-dolist animals)
@end group
@end smallexample

@need 1250
@noindent
在Info中，您可以将光标放在每个表达式的右括号后，然后键入 @kbd{C-x C-e}; 在每种情况下，您应该在回显区域看到

@smallexample
(tiger lion giraffe gazelle)
@end smallexample

@noindent
对于此示例，现有的 @code{reverse} 函数显然是最好的选择。
@code{while} 循环就像我们的第一个示例一样(@pxref{循环示例, , 一个@code{while}循环和一个列表})。@code{while} 首先检查列表是否有元素；如果有，它通过将列表的第一个元素添加到现有列表（在循环的第一次迭代中是 @code{nil}）来构造一个新列表。由于第二个元素在第一个元素的前面添加，第三个元素在第二个元素的前面添加，因此列表被反转。

在使用 @code{while} 循环的表达式中，
@w{@code{(setq list (cdr list))}}
表达式缩短了列表，因此 @code{while} 循环最终停止。此外，它通过在每次循环重复时创建一个新的更短的列表，为 @code{cons} 表达式提供了一个新的第一个元素。

@code{dolist} 表达式的工作方式与 @code{while} 表达式非常相似，不同之处在于，@code{dolist} 宏执行了在编写 @code{while} 表达式时必须执行的一些工作。

像 @code{while} 循环一样，@code{dolist} 循环。不同之处在于，它每次循环都会自动缩短列表---它会对列表进行 @sc{cdr} 操作---并且会自动将每个较短版本的列表的 @sc{car} 绑定到其第一个参数。

在此示例中，较短版本的列表的 @sc{car} 由符号 @samp{element} 引用，列表本身称为 @samp{list}，返回的值称为 @samp{value}。@code{dolist} 表达式的其余部分是主体。

@code{dolist} 表达式将较短版本的列表的 @sc{car} 绑定到 @code{element}，然后评估表达式的主体；然后重复循环。结果在 @code{value} 中返回。

@node dotimes
@unnumberedsubsec @code{dotimes} 宏
@findex dotimes

@code{dotimes} 宏类似于 @code{dolist}，但它循环特定次数。

@code{dotimes} 的第一个参数在每次循环时被赋予数字 0、1、2 等等。你需要提供第二个参数的值，该值表示宏循环的次数。

@need 1250
例如，下面的代码将数字从 0 到 3（不包括 3）绑定到第一个参数 @var{number}，然后构建包含这三个数字的列表。（第一个数字是 0，第二个数字是 1，第三个数字是 2；总共有三个数字，以零为起始。）

@smallexample
@group
(let (value)      ; 否则 value 是一个未定义变量
  (dotimes (number 3)
    (setq value (cons number value)))
  value)

@result{} (2 1 0)
@end group
@end smallexample

@noindent
使用 @code{dotimes} 的方法是对某个表达式 @var{number} 进行操作，重复操作 @var{number} 次，然后返回结果，可以是列表或原子。

@need 1250
以下是一个使用 @code{dotimes} 的 @code{defun} 示例，用于计算三角形中鹅卵石的总数。

@smallexample
@group
(defun triangle-using-dotimes (number-of-rows)
  "使用 `dotimes'，计算三角形中鹅卵石的总数。"
(let ((total 0))  ; 否则 total 是一个未定义变量
  (dotimes (number number-of-rows)
    (setq total (+ total (1+ number))))
  total))

(triangle-using-dotimes 4)
@end group
@end smallexample

@node 递归
@section 递归
@cindex 递归

一个递归函数包含代码，告诉Lisp解释器调用一个与自身完全相同但具有略有不同参数的程序。代码运行完全相同，因为它具有相同的名称。然而，即使程序具有相同的名称，它也不是相同的实体。它是不同的。在行话中，它是一个不同的“实例”。

最终，如果程序被正确编写，稍微不同的参数将与第一个参数足够不同，以至于最终的实例将停止。

@menu
* 构建机器人::             相同的模型，不同的序列号...
* 递归定义的部分::         走到停下来...
* 使用列表的递归::         将列表用作判断是否递归的测试。
* 递归三角函数::
* 使用cond的递归::
* 递归模式::               经常使用的模板。
* 无推迟::                  不要存储工作...
* 无推迟解决方案::
@end menu

@node 构建机器人
@subsection 构建机器人：扩展隐喻
@cindex 构建机器人
@cindex 机器人，构建

有时将运行的程序看作是执行任务的机器人是有帮助的。在执行其任务时，递归函数调用第二个机器人来帮助它。第二个机器人与第一个机器人在每个方面都是相同的，除了第二个机器人帮助第一个机器人并传递了不同于第一个机器人的参数。

在递归函数中，第二个机器人可能调用第三个；第三个可能调用第四个，依此类推。每个都是一个不同的实体；但都是克隆体。

由于每个机器人都有略有不同的指令——参数将从一个机器人到另一个机器人不同——最后一个机器人应该知道何时停止。

让我们扩展一下计算机程序是机器人的隐喻。

函数定义提供了一个机器人的蓝图。当您安装函数定义时，也就是当您评估@code{defun}宏时，您安装了构建机器人所需的设备。这就好像您在工厂中设置了一个装配线。具有相同名称的机器人是根据相同的蓝图构建的。因此，它们具有相同的型号，但不同的序列号。

我们经常说一个递归函数“调用自身”。我们的意思是递归函数中的指令导致Lisp解释器运行一个具有相同名称且执行与第一个相同的工作的不同函数，但具有不同参数。

参数从一个实例到下一个必须不同；否则，这个过程将永远不会停止。

@node 递归定义的部分
@subsection 递归定义的组成部分
@cindex 递归定义的部分
@cindex 递归定义的组成部分

一个递归函数通常包含一个条件表达式，该表达式有三个部分：

@enumerate
@item
一个判断函数是否再次调用的真假测试，这里称为@dfn{再次执行测试}。

@item
函数的名称。当调用此名称时，将创建一个函数的新实例，也可以看作是创建一个新的机器人，并告诉它要做什么。

@item
一个表达式，每次调用函数时都返回不同的值，这里称为@dfn{下一步表达式}。因此，传递给函数的新实例的参数（或参数）将与传递给上一个实例的参数不同。这导致条件表达式，即@dfn{再次执行测试}在正确的重复次数后返回false。
@end enumerate

递归函数可能比其他类型的函数简单得多。实际上，当人们首次开始使用它们时，它们经常看起来如此神秘简单，以至于难以理解。就像骑自行车一样，阅读递归函数定义需要一定的技巧，起初很难，但后来似乎很简单。

@need 1200
有几种常见的递归模式。一个非常简单的模式如下：

@smallexample
@group
(defun @var{name-of-recursive-function} (@var{argument-list})
  "@var{documentation}@dots{}"
  (if @var{do-again-test}
    @var{body}@dots{}
    (@var{name-of-recursive-function}
         @var{next-step-expression})))
@end group
@end smallexample

每次评估递归函数时，都会创建它的一个新实例，并告诉它要做什么。参数告诉实例要做什么。

参数被绑定到下一步表达式的值。每个实例以不同的下一步表达式的值运行。

下一步表达式中的值在再次执行测试中使用。

由下一步表达式返回的值被传递给函数的新实例，该实例评估它（或它的某些转化）以确定是否继续还是停止。下一步表达式被设计成当函数不再需要重复时再次执行测试返回false。

再次执行测试有时被称为@dfn{停止条件}，因为它在测试为false时停止重复。

@node 递归与列表
@subsection 列表递归

一个用@code{while}循环打印数字列表元素的例子可以用递归的方式重写。下面是代码，包括一个表达式，将变量@code{animals}的值设置为一个列表。

如果你在Emacs的Info中阅读此内容，你可以直接在Info中评估这个表达式。否则，你必须将示例复制到@file{*scratch*}缓冲区，并在那里逐个评估每个表达式。使用@kbd{C-u C-x C-e}来评估@code{(print-elements-recursively animals)}表达式，以便结果打印在缓冲区中；否则，Lisp解释器将尝试将结果压缩成回显区域的一行。

此外，在@code{print-elements-recursively}函数的最后一个闭合括号之后，在注释之前将光标放置在此处。否则，Lisp解释器将尝试评估注释。

@findex print-elements-recursively
@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))

(defun print-elements-recursively (list)
  "将LIST的每个元素单独打印到一行上。
使用递归。"
  (when list                            ; @r{do-again-test}
        (print (car list))              ; @r{body}
        (print-elements-recursively     ; @r{recursive call}
         (cdr list))))                  ; @r{next-step-expression}

(print-elements-recursively animals)
@end group
@end smallexample

@code{print-elements-recursively}函数首先测试列表中是否有内容；如果有，函数将打印列表的第一个元素，即列表的@sc{car}。然后，函数调用自身，但将自身作为参数传递，而不是整个列表，而是列表的第二个及后续元素，即列表的@sc{cdr}。

换句话说，如果列表不为空，函数调用另一个与初始代码相似但是不同执行线程的代码实例，其参数与第一个实例不同。

再换一种说法，如果列表不为空，第一个机器人组装第二个机器人并告诉它该做什么；第二个机器人是第一个机器人之外的另一个个体，但是是相同型号。

当进行第二次评估时，@code{when}表达式将被评估，如果为真，则打印作为其参数接收到的列表的第一个元素（这是原始列表的第二个元素）。然后，函数使用它调用的列表的@sc{cdr}调用自身，这是原始列表的@sc{cdr}的@sc{cdr}（第二次调用时）。

请注意，尽管我们说函数“调用自身”，但我们的意思是Lisp解释器将装配并指导程序的新实例。新实例是第一个的克隆，但是是独立的个体。

每次函数调用自身时，它都是在原始列表的较短版本上进行的。它创建一个在较短列表上运行的新实例。

最终，函数在空列表上调用自身。它创建一个参数为@code{nil}的新实例。条件表达式测试@code{list}的值。由于@code{list}的值是@code{nil}，@code{when}表达式测试为假，因此不会评估then部分。因此，整个函数返回@code{nil}。

@need 1200
当在@file{*scratch*}缓冲区中评估表达式@code{(print-elements-recursively animals)}时，你将看到以下结果：

@smallexample
@group
gazelle

giraffe

lion

tiger
nil
@end group
@end smallexample

@need 2000
@node 递归三角形函数
@subsection 使用递归替代计数器
@findex triangle-recursively

@need 1200
在前一节中描述的 @code{triangle} 函数也可以使用递归方式编写。它的代码如下：

@smallexample
@group
(defun triangle-recursively (number)
  "返回从1到NUMBER（包括NUMBER）的数字之和，使用递归。"
  (if (= number 1)                    ; @r{再做一次测试}
      1                               ; @r{然后部分}
    (+ number                         ; @r{否则部分}
       (triangle-recursively          ; @r{递归调用}
        (1- number)))))               ; @r{下一步表达式}

(triangle-recursively 7)
@end group
@end smallexample

@noindent
你可以通过评估这个函数来安装它，并通过评估 @code{(triangle-recursively 7)} 来尝试它。（记得把光标放在函数定义的最后一个括号之后，注释之前。）这个函数的值为28。

为了理解这个函数的工作原理，让我们考虑当函数的参数值为1、2、3或4时发生的各种情况。

@menu
* 参数为1或2的递归示例::
* 参数为3或4的递归示例::
@end menu

@ifnottex
@node 参数为1或2的递归示例
@unnumberedsubsubsec 参数为1或2
@end ifnottex

首先，如果参数值为1会发生什么？

在文档字符串之后，函数有一个 @code{if} 表达式。它测试 @code{number} 的值是否等于1；如果是，Emacs 将评估 @code{if} 表达式的 then-部分，将1作为函数的值返回。（一个只有一行的三角形中有一个小石子。）

然而，假设参数值为2。在这种情况下，Emacs 将评估 @code{if} 表达式的 else-部分。

@need 1200
else-部分由一个加法、对 @code{triangle-recursively} 的递归调用和一个递减操作组成；它看起来像这样：

@smallexample
(+ number (triangle-recursively (1- number)))
@end smallexample

当Emacs评估这个表达式时，首先评估最内层的表达式；然后按顺序评估其他部分。以下是详细的步骤：

@table @i
@item 步骤1 @w{  } 评估最内层的表达式。

最内层的表达式是 @code{(1- number)}，因此Emacs将 @code{number} 的值从2递减到1。

@item 步骤2 @w{  } 评估 @code{triangle-recursively} 函数。

Lisp解释器创建了 @code{triangle-recursively} 的一个单独实例。这个函数包含在它自己的内部并不重要。Emacs将步骤1的结果作为这个 @code{triangle-recursively} 函数实例使用的参数传递。

在这种情况下，Emacs使用参数1评估 @code{triangle-recursively}。这意味着这次评估返回1。

@item 步骤3 @w{  } 评估 @code{number} 的值。

变量 @code{number} 是以 @code{+} 开头的列表的第二个元素；它的值为2。

@item 步骤4 @w{  } 评估 @code{+} 表达式。

@code{+} 表达式接收两个参数，第一个来自 @code{number} 的评估（步骤3），第二个来自 @code{triangle-recursively} 的评估（步骤2）。

加法的结果是2加1的和，返回数字3，这是正确的。一个有两行的三角形中有三颗小石子。
@end table

@node 递归示例参数为3或4的情况
@unnumberedsubsubsec 参数为3或4的情况

假设调用 @code{triangle-recursively} 时参数为3。

@table @i
@item 步骤 1 @w{  } 评估再次执行测试。

首先评估 @code{if} 表达式。这是再次执行测试，并返回false，因此 @code{if} 表达式的else部分将被评估。（请注意，在此示例中，再次执行测试在测试false时导致函数调用自身，而不是在测试true时。）

@item 步骤 2 @w{  } 评估else部分的最内层表达式。

评估else部分的最内层表达式，将3减少到2。这是下一步表达式。

@item 步骤 3 @w{  } 评估 @code{triangle-recursively} 函数。

将数字2传递给 @code{triangle-recursively} 函数。

我们已经知道当Emacs使用参数2评估 @code{triangle-recursively} 时会发生什么。在经历了前面描述的一系列动作后，它将返回值3。因此，在这里也将发生这种情况。

@item 步骤 4 @w{  } 评估加法。

3将作为参数传递给加法，并将被添加到调用函数的数字中，该数字为3。
@end table

@noindent
函数整体返回的值将为6。

现在我们知道当 @code{triangle-recursively} 使用参数3调用时会发生什么，那么如果使用参数4调用它会发生什么就显而易见了：

@quotation
@need 800
在递归调用中，评估

@smallexample
(triangle-recursively (1- 4))
@end smallexample

@need 800
@noindent
将返回评估的值

@smallexample
(triangle-recursively 3)
@end smallexample

@noindent
这是6，此值将通过第三行的加法添加到4中。
@end quotation

@noindent
函数整体返回的值将为10。

每次评估 @code{triangle-recursively} 时，它都会评估它自己的版本---一个具有较小参数的不同实例，直到参数足够小以使其不再评估自身。

请注意，这种递归函数的特定设计要求推迟操作。

在 @code{(triangle-recursively 7)} 可以计算其答案之前，它必须调用 @code{(triangle-recursively 6)}；在 @code{(triangle-recursively 6)} 可以计算其答案之前，它必须调用 @code{(triangle-recursively 5)}；依此类推。也就是说，@code{(triangle-recursively 7)} 进行的计算必须推迟，直到 @code{(triangle-recursively 6)} 进行其计算为止；而 @code{(triangle-recursively 6)} 必须推迟，直到 @code{(triangle-recursively 5)} 完成为止；依此类推。

如果将 @code{triangle-recursively} 的每个实例都视为不同的机器人，第一个机器人必须等待第二个完成其工作，第二个必须等待第三个完成，依此类推。

有一种绕过这种等待的方法，我们将在 @ref{不推迟的递归, , 无推迟的递归} 中讨论。

@node 用 cond 进行递归
@subsection 使用 @code{cond} 进行递归的例子
@findex cond

先前描述的 @code{triangle-recursively} 版本是用 @code{if} 特殊形式编写的。它也可以使用另一种特殊形式称为 @code{cond} 来编写。特殊形式 @code{cond} 的名称是单词 @samp{conditional} 的缩写。

尽管在 Emacs Lisp 源代码中并不像 @code{if} 那样经常使用 @code{cond} 特殊形式，但它被足够频繁地使用，以便解释它是有道理的。

@need 800
@code{cond} 表达式的模板如下：

@smallexample
@group
(cond
 @var{body}@dots{})
@end group
@end smallexample

@noindent
其中 @var{body} 是一系列列表。

@need 800
更详细地写出来，模板如下：

@smallexample
@group
(cond
 (@var{first-true-or-false-test} @var{first-consequent})
 (@var{second-true-or-false-test} @var{second-consequent})
 (@var{third-true-or-false-test} @var{third-consequent})
  @dots{})
@end group
@end smallexample

当 Lisp 解释器评估 @code{cond} 表达式时，它评估第一个元素（即第一个表达式中的 @sc{car} 或 true-or-false-test）。

如果 true-or-false-test 返回 @code{nil}，则跳过该表达式的其余部分，即 consequent，并评估下一个表达式的 true-or-false-test。当找到一个表达式，其 true-or-false-test 返回非 @code{nil} 的值时，将评估该表达式的 consequent。consequent 可以是一个或多个表达式。如果 consequent 包含多个表达式，则按顺序评估这些表达式，并返回最后一个的值。如果表达式没有 consequent，则返回 true-or-false-test 的值。

如果没有一个 true-or-false-test 测试为真，@code{cond} 表达式返回 @code{nil}。

@need 1250
使用 @code{cond} 编写的 @code{triangle} 函数如下：

@smallexample
@group
(defun triangle-using-cond (number)
  (cond ((<= number 0) 0)
        ((= number 1) 1)
        ((> number 1)
         (+ number (triangle-using-cond (1- number))))))
@end group
@end smallexample

@noindent
在这个例子中，如果数字小于等于 0，则 @code{cond} 返回 0；如果数字为 1，则返回 1；如果数字大于 1，则评估 @code{(+
number (triangle-using-cond (1- number)))}。

@node 递归模式
@subsection 递归模式
@cindex 递归模式

以下是三种常见的递归模式，每一种都涉及到列表。递归不一定需要涉及列表，但Lisp是为列表设计的，这展示了其原始功能的一种感觉。

@menu
* 每个元素::
* 累积::
* 保留::
@end menu

@node 每个元素
@unnumberedsubsubsec 递归模式：@emph{每个元素}
@cindex 每个元素，递归模式类型
@cindex 递归模式 - 每个元素

在@code{every}递归模式中，对列表的每个元素执行一个操作。

@need 1500
基本模式如下：

@itemize @bullet
@item
如果列表为空，则返回@code{nil}。
@item
否则，对列表的开头（列表的@sc{car}）执行操作
    @itemize @minus
    @item
    通过对列表的其余部分（@sc{cdr}）进行函数的递归调用，
    @item
    并且可以选择地将执行操作的元素与对其余部分进行递归调用的结果使用@code{cons}结合。
    @end itemize
@end itemize

@need 1500
以下是一个例子：

@smallexample
@group
(defun square-each (numbers-list)
  "递归地计算NUMBERS LIST中的每个数字的平方。"
  (if (not numbers-list)                ; do-again-test
      nil
    (cons
     (* (car numbers-list) (car numbers-list))
     (square-each (cdr numbers-list))))) ; next-step-expression
@end group

@group
(square-each '(1 2 3))
    @result{} (1 4 9)
@end group
@end smallexample

@need 1200
@noindent
如果@code{numbers-list}为空，则不执行任何操作。但如果它包含内容，则构造一个列表，其中包含第一个数字的平方与递归调用的结果的结合。

（该示例完全遵循该模式：如果数字列表为空，则返回@code{nil}。在实践中，您会编写条件语句，以便在数字列表不为空时执行操作。）

@code{print-elements-recursively}函数（@pxref{递归与列表, , Recursion with a List}）是@code{every}模式的另一个示例，不同之处在于，我们不使用@code{cons}将结果组合在一起，而是逐个打印输出的每个元素。

@need 1250
@code{print-elements-recursively}函数如下：

@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))
@end group

@group
(defun print-elements-recursively (list)
  "逐行打印LIST中的每个元素。使用递归。"
  (when list                            ; @r{do-again-test}
        (print (car list))              ; @r{body}
        (print-elements-recursively     ; @r{recursive call}
         (cdr list))))                  ; @r{next-step-expression}

(print-elements-recursively animals)
@end group
@end smallexample

@need 1500
@code{print-elements-recursively}的模式如下：

@itemize @bullet
@item
当列表为空时，不执行任何操作。
@item
但是当列表至少有一个元素时，
    @itemize @minus
    @item
    对列表的开头（列表的@sc{car}）执行操作，
    @item
    并对列表的其余部分（@sc{cdr}）进行递归调用。
    @end itemize
@end itemize

@node 累积
@unnumberedsubsubsec 递归模式：@emph{累积}
@cindex 累积，一种递归模式
@cindex 递归模式 - 累积

另一种递归模式称为@code{累积}模式。在@code{累积}递归模式中，对列表的每个元素执行一个操作，并将该操作的结果与对其他元素执行的操作的结果累积在一起。

这与使用@code{cons}的@code{每个}模式非常相似，只是不使用@code{cons}，而是使用其他某个组合器。

@need 1500
该模式如下：

@itemize @bullet
@item
如果列表为空，则返回零或其他常数。
@item
否则，对列表的开头（列表的@sc{car}）进行操作，
    @itemize @minus
    @item
    将该操作的元素与
    @item
    通过对列表的其余部分（@sc{cdr}）进行递归调用的函数进行组合，使用@code{+}或其他组合函数。
    @end itemize
@end itemize

@need 1500
以下是一个示例：

@smallexample
@group
(defun add-elements (numbers-list)
  "将NUMBERS-LIST的元素相加。"
  (if (not numbers-list)
      0
    (+ (car numbers-list) (add-elements (cdr numbers-list)))))
@end group

@group
(add-elements '(1 2 3 4))
    @result{} 10
@end group
@end smallexample

@xref{Files List, , 制作文件列表}，以获取累积模式的示例。

@node 保留
@unnumberedsubsubsec 递归模式：@emph{保留}
@cindex 保留，一种递归模式
@cindex 递归模式 - 保留

第三种递归模式称为@code{保留}模式。
在@code{保留}递归模式中，测试列表的每个元素；
只有在元素满足条件时，对该元素进行操作并仅保留结果。

同样，这与@code{每个}模式非常相似，只是除非元素满足条件，否则将跳过该元素。

@need 1500
该模式有三个部分：

@itemize @bullet
@item
如果列表为空，则返回@code{nil}。
@item
否则，如果列表的开头（列表的@sc{car}）通过
        一个测试
    @itemize @minus
    @item
    对该元素进行操作并使用@code{cons}与
    @item
    通过对列表的其余部分（@sc{cdr}）进行递归调用的函数进行组合。
    @end itemize
@item
否则，如果列表的开头（列表的@sc{car}）未通过
测试
    @itemize @minus
    @item
    跳过该元素，
    @item
    并以对列表的其余部分（@sc{cdr}）进行递归调用的方式进行递归调用。
    @end itemize
@end itemize

@need 1500
以下是一个使用@code{cond}的示例：

@smallexample
@group
(defun keep-three-letter-words (word-list)
  "保留WORD-LIST中的三个字母的单词。"
  (cond
   ;; 第一个再次测试：停止条件
   ((not word-list) nil)

   ;; 第二个再次测试：何时操作
   ((eq 3 (length (symbol-name (car word-list))))
    ;; 将已操作的元素与对较短列表进行递归调用的结果组合
    (cons (car word-list) (keep-three-letter-words (cdr word-list))))

   ;; 第三个再次测试：何时跳过元素；
   ;;   以下一步表达式对较短列表进行递归调用
   (t (keep-three-letter-words (cdr word-list)))))
@end group

@group
(keep-three-letter-words '(one two three four five six))
    @result{} (one two six)
@end group
@end smallexample

毫无疑问，您无需使用@code{nil}作为停止测试的条件；当然，您可以组合这些模式。

@node 不推迟的递归
@subsection 无推迟的递归
@cindex 递归中的推迟
@cindex 无推迟的递归

让我们再次考虑一下@code{triangle-recursively}函数的运行情况。我们会发现中间计算被推迟，直到所有计算都可以完成。

@need 800
以下是函数定义：

@smallexample
@group
(defun triangle-recursively (number)
  "返回从1加到NUMBER（包括）的数字的和。
使用递归。"
  (if (= number 1)                    ; @r{do-again-test}
      1                               ; @r{then-part}
    (+ number                         ; @r{else-part}
       (triangle-recursively          ; @r{recursive call}
        (1- number)))))               ; @r{next-step-expression}
@end group
@end smallexample

当我们使用参数7调用此函数时会发生什么？

第一次调用@code{triangle-recursively}函数会将数字7与第二个
@code{triangle-recursively}实例的返回值相加，该实例已被传递了一个
参数为6。也就是说，第一次计算是：

@smallexample
(+ 7 (triangle-recursively 6))
@end smallexample

@noindent
第一次调用@code{triangle-recursively}---你可以把它想象成一个小机器人---无法完成它的工作。它必须将@code{(triangle-recursively 6)}的计算委托给程序的第二个实例，即第二个机器人。这第二个个体与第一个完全不同；它是，按行话来说，一个“不同的实例”。“换句话说，它是一个不同的机器人。它与第一个相同；它递归地计算三角形数；但它有一个不同的序列号。

那么@code{(triangle-recursively 6)}返回什么呢？它返回数字6加上评估带有参数5的
@code{triangle-recursively}的返回值。使用机器人的隐喻，它要求另一个机器人帮助它。

@need 800
现在总数是：

@smallexample
(+ 7 6 (triangle-recursively 5))
@end smallexample

@need 800
接下来会发生什么？

@smallexample
(+ 7 6 5 (triangle-recursively 4))
@end smallexample

每次调用@code{triangle-recursively}，除了最后一次外，它都会创建程序的另一个实例---另一个机器人---并要求它进行计算。

@need 800
最终，完整的加法被设置并执行：

@smallexample
(+ 7 6 5 4 3 2 1)
@end smallexample

这个函数的设计推迟了第一步的计算，直到第二步可以完成，然后推迟到第三步可以完成，依此类推。每个推迟都意味着计算机必须记住正在等待什么。在这个例子中，当步骤很少时，这不是问题。但当步骤更多时，这可能会成为问题。

@node 无推迟解决方案
@subsection 无推迟解决方案
@cindex 无推迟解决方案
@cindex 无推迟的解决方案

解决推迟操作的问题的方法是以不推迟操作的方式编写代码@footnote{术语@dfn{尾递归}用来描述这种使用常量空间的过程。}。这需要编写一个不同的模式，通常涉及编写两个函数定义，一个初始化函数和一个辅助函数。

初始化函数设置任务；辅助函数执行工作。

@need 1200
以下是两个求和的函数定义。它们非常简单，我发现它们很难理解。

@smallexample
@group
(defun triangle-initialization (number)
  "返回从1加到NUMBER（包括）的数字的和。
这是使用递归的两个函数对的初始化组件。"
  (triangle-recursive-helper 0 0 number))
@end group
@end smallexample

@smallexample
@group
(defun triangle-recursive-helper (sum counter number)
  "使用COUNTER返回SUM，通过NUMBER（包括）。
这是使用递归的两个函数对的辅助组件。"
  (if (> counter number)
      sum
    (triangle-recursive-helper (+ sum counter)  ; @r{sum}
                               (1+ counter)     ; @r{counter}
                               number)))        ; @r{number}
@end group
@end smallexample

@need 1250
通过评估这两个函数定义来安装它们，然后使用2行调用@code{triangle-initialization}：

@smallexample
@group
(triangle-initialization 2)
    @result{} 3
@end group
@end smallexample

初始化函数使用三个参数调用辅助函数的第一个实例：零，零，以及三角形中的行数。

传递给辅助函数的前两个参数是初始化值。这些值在@code{triangle-recursive-helper}调用新实例时会更改。@footnote{术语有点混乱：@code{triangle-recursive-helper}在递归的过程中使用迭代的方式，因为计算机只需记录三个值@code{sum}、@code{counter}和@code{number}；而该过程在递归的过程中使用递归的方式，因为函数调用了自身。另一方面，@code{triangle-recursively}使用的过程和过程都被称为递归。在这两种情况下，“递归”这个词在两个上下文中有不同的含义。}

让我们看看当我们有一个只有一行的三角形时会发生什么。（这个三角形将有一个小石子！）

@need 1200
@code{triangle-initialization}将使用参数@w{@code{0 0 1}}调用它的辅助函数。该函数将运行条件测试，即@code{(> counter number)}：

@smallexample
(> 0 1)
@end smallexample

@need 1200
@noindent
并发现结果为假，因此它将调用@code{if}子句的else部分：

@smallexample
@group
    (triangle-recursive-helper
     (+ sum counter)  ; @r{sum加counter} @result{} @r{sum}
     (1+ counter)     ; @r{增加counter} @result{} @r{counter}
     number)          ; @r{number保持不变}
@end group
@end smallexample

@need 800
@noindent
这将首先计算：

@smallexample
@group
(triangle-recursive-helper (+ 0 0)  ; @r{sum}
                           (1+ 0)   ; @r{counter}
                           1)       ; @r{number}
@exdent 即：

(triangle-recursive-helper 0 1 1)
@end group
@end smallexample

再次，@code{(> counter number)}将为假，因此Lisp解释器将评估@code{triangle-recursive-helper}，创建一个新实例并传递新参数。

@need 800
这个新实例将是：

@smallexample
@group
    (triangle-recursive-helper
     (+ sum counter)  ; @r{sum加counter} @result{} @r{sum}
     (1+ counter)     ; @r{增加counter} @result{} @r{counter}
     number)          ; @r{number保持不变}

@exdent 即：

(triangle-recursive-helper 1 2 1)
@end group
@end smallexample

在这种情况下，@code{(> counter number)}测试将为真！因此，该实例将返回@code{sum}的值，该值将是1，符合预期。

现在，让我们将@code{triangle-initialization}的参数设置为2，以查看具有两行的三角形中有多少个小石子。

该函数调用@code{(triangle-recursive-helper 0 0 2)}。

@need 800
分阶段，被调用的实例将是：

@smallexample
@group
                          @r{sum counter number}
(triangle-recursive-helper 0    1       2)

(triangle-recursive-helper 1    2       2)

(triangle-recursive-helper 3    3       2)
@end group
@end smallexample

当调用最后一个实例时，@code{(> counter number)}测试将为真，因此该实例将返回@code{sum}的值，该值将是3。

这种模式在编写可能使用计算机中的许多资源的函数时很有帮助。

@need 1500
@node 循环练习
@section 循环练习

@itemize @bullet
@item
编写一个类似于 @code{triangle} 的函数，其中每一行的值是该行号的平方。使用 @code{while} 循环。

@item
编写一个类似于 @code{triangle} 的函数，但是它将值相乘而不是相加。

@item
递归地重写这两个函数。使用 @code{cond} 重写这些函数。

@c 在标题中的逗号会导致 Info 交叉引用问题
@item
为 Texinfo 模式编写一个函数，在段落开头为每个段落中的 @samp{@@dfn} 创建一个索引条目。
（在 Texinfo 文件中，@samp{@@dfn} 标记一个定义。本书是用 Texinfo 编写的。）

你将需要用到前两章中的许多函数，@ref{剪切与存储文本, , 剪切与存储文本} 和 @ref{插入文本, , Yanking Text Back} 中有它们的描述。如果使用 @code{forward-paragraph} 将索引条目放在段落开头，您将需要使用 @w{@kbd{C-h f}}（@code{describe-function}）查找如何使命令向后执行。

更多信息，请参见
@ifinfo
@ref{Indicating, , Indicating Definitions, texinfo}。
@end ifinfo
@ifhtml
@ref{Indicating, , Indicating, texinfo, Texinfo Manual}，其中会跳转到当前目录中的 Texinfo 手册。或者，如果您在互联网上，参见
@uref{https://www.gnu.org/software/texinfo/manual/texinfo/}
@end ifhtml
@iftex
``Indicating Definitions, Commands, etc.''@: in @cite{Texinfo, The GNU
Documentation Format}。
@end iftex
@end itemize

@node 正则表达式搜索
@chapter 正则表达式搜索
@cindex 搜索，演示
@cindex 正则表达式搜索
@cindex 模式，搜索
@cindex 通过句子和段落进行移动
@cindex 通过句子进行移动
@cindex 通过段落进行移动

正则表达式搜索在GNU Emacs中被广泛使用。两个函数，@code{forward-sentence}和@code{forward-paragraph}，很好地说明了这些搜索的用法。它们使用正则表达式来确定点应该移动到哪里。短语“正则表达式”通常写作“regexp”。

正则表达式搜索在@ref{Regexp Search, , Regular Expression Search, emacs, The GNU Emacs Manual}中有详细描述，以及在@ref{Regular Expressions, , , elisp, The GNU Emacs Lisp Reference Manual}中也有描述。在撰写本章时，我假定您至少对它们有一些了解。需要记住的主要观点是正则表达式允许您搜索模式以及字符字面上的字符串。例如，@code{forward-sentence}函数中的代码搜索可能标记句子结束的字符模式，并将点移动到该位置。

在查看@code{forward-sentence}函数的代码之前，值得考虑一下标记句子结束的模式是什么。该模式将在下一节中讨论；随后是正则表达式搜索函数@code{re-search-forward}的描述。@code{forward-sentence}函数在其后的部分中描述。最后，本章的最后一节描述了@code{forward-paragraph}函数。@code{forward-paragraph}是一个复杂的函数，引入了一些新功能。

@menu
* sentence-end::                @code{sentence-end}的正则表达式。
* re-search-forward::           与@code{search-forward}非常相似。
* forward-sentence::            正则表达式搜索的简单示例。
* forward-paragraph::           一个相对复杂的示例。
* 正则表达式回顾::
* re-search 练习::
@end menu

@node sentence-end
@section 关于 @code{sentence-end} 的正则表达式
@findex sentence-end

符号 @code{sentence-end} 被绑定到标记句子结束的模式。这个正则表达式应该是什么呢？

显然，句子可以以句点、问号或感叹号结束。实际上，在英语中，只有以这三个字符之一结尾的从句才应被视为句子的结束。这意味着模式应包括字符集：

@smallexample
[.?!]
@end smallexample

然而，我们不希望 @code{forward-sentence} 只是简单地跳到句点、问号或感叹号，因为这样的字符可能在句子中间使用。例如，句点在缩写后使用。因此，需要其他信息。

按照约定，你在每个句子后面键入两个空格，但在句子中间的句点、问号或感叹号后只键入一个空格。因此，句点、问号或感叹号后跟两个空格是句子结束的良好指示器。然而，在文件中，这两个空格可能被制表符或行尾替代。这意味着正则表达式应包括这三个项作为备选项。

@need 800
这组备选项将如下所示：

@smallexample
@group
\\($\\| \\|  \\)
       ^   ^^
      TAB  SPC
@end group
@end smallexample

@noindent
这里，@samp{$} 表示行尾，我标出了制表符和两个空格在表达式中的位置。两者都是通过将实际字符放入表达式中插入的。

在括号和竖线前需要两个反斜杠，@samp{\\}：第一个反斜杠引用 Emacs 中的后续反斜杠；第二个指示后面的字符（括号或竖线）是特殊的。

@need 1000
另外，句子后面可能跟着一个或多个回车，就像这样：

@smallexample
@group
[
]*
@end group
@end smallexample

@noindent
与制表符和空格一样，通过将其直接插入正则表达式，回车就会插入其中。星号表示 @key{RET} 重复零次或多次。

但句子结尾不仅仅包括句点、问号或感叹号后跟适当的空格：可能有一个闭合引号或某种括号在空格之前。事实上，可能有一个以上这样的引号或括号在空格之前。这需要一个如下所示的表达式：

@smallexample
[]\"')@}]*
@end smallexample

在这个表达式中，第一个 @samp{]} 是表达式中的第一个字符；第二个字符是 @samp{"}，它前面有一个 @samp{\}，告诉 Emacs @samp{"} 不是特殊字符。最后三个字符是 @samp{'}, @samp{)} 和 @samp{@}}。

所有这些都暗示了匹配句子结尾的正则表达式模式，确实，如果我们评估 @code{sentence-end}，我们会发现它返回以下值：

@smallexample
@group
sentence-end
     @result{} "[.?!][]\"')@}]*\\($\\|     \\|  \\)[
]*"
@end group
@end smallexample

@noindent
（好吧，在 GNU Emacs 22 中不是这样；这是因为为了使过程更简单并处理更多的字形和语言而做的努力。当 @code{sentence-end} 的值为 @code{nil} 时，使用函数 @code{sentence-end} 定义的值。 （这是 Emacs Lisp 中值和函数之间差异的使用示例。）该函数返回由变量 @code{sentence-end-base}、@code{sentence-end-double-space}、@code{sentence-end-without-period} 和 @code{sentence-end-without-space} 构造的值。关键变量是 @code{sentence-end-base}；它的全局值类似于上述描述的值，但还包含两个额外的引号。这些引号的弯曲程度不同。当 @code{sentence-end-without-period} 变量为真时，告诉 Emacs 句子可以在没有句点的情况下结束，例如泰语文本。）

@ignore
@noindent
（注意，在这里 @key{TAB}、两个空格和 @key{RET} 在模式中都是以字面形式显示的。）

这个正则表达式可以这样解读：

@table @code
@item [.?!]
模式的第一部分是三个字符，一个句点、一个问号和一个感叹号，都在方括号内。模式必须以这些字符中的一个开始。

@item []\"')@}]*
模式的第二部分是闭合括号和引号组成的组，可以出现零次或多次。这些可以跟在句点、问号或感叹号后。在正则表达式中，反斜杠 @samp{\} 后面跟着双引号 @samp{"} 表示字符串引号字符类。通常，双引号是该类中唯一的字符。星号 @samp{*} 表示前面组（由方括号 @samp{[]} 包围的组）中的项可以重复零次或多次。

@item \\($\\|   \\|  \\)
模式的第三部分是下列情况之一：行尾、两个空格或一个制表符。双反斜杠用于防止 Emacs 将括号和竖线读取为搜索模式的一部分；括号用于标记组，竖线用于表示它们两侧的模式是备选项。美元符号用于表示行尾，两个空格和制表符分别插入以指示它们的存在。

@item [@key{RET}]*
最后，模式的最后部分表示行尾或句点、问号或感叹号后的空格后可能跟随零个或多个回车，但不一定。在模式中，回车作为实际回车插入，但这里显示为 @key{RET}。
@end table
@end ignore

@node re-search-forward
@section @code{re-search-forward} 函数
@findex re-search-forward

@code{re-search-forward} 函数与 @code{search-forward} 函数非常相似。(@xref{search-forward, , @code{search-forward} 函数}.)

@code{re-search-forward} 用于搜索正则表达式。如果搜索成功，它将把光标立即放在目标的最后一个字符之后。如果是反向搜索，它将把光标放在目标的第一个字符之前。您可以告诉 @code{re-search-forward} 在搜索成功时返回 @code{t}。 (移动光标因此是一个副作用。)

与 @code{search-forward} 一样，@code{re-search-forward} 函数接受四个参数：

@enumerate
@item
第一个参数是要搜索的正则表达式。正则表达式将是双引号之间的字符串。

@item
可选的第二个参数限制函数搜索的范围；它是一个界限，指定为缓冲区中的位置。

@item
可选的第三个参数指定函数对失败的响应方式：当搜索失败时，第三个参数为 @code{nil} 会导致函数发出错误信号（并打印一条消息）；任何其他值会导致在搜索失败时返回 @code{nil}，在搜索成功时返回 @code{t}。

@item
可选的第四个参数是重复计数。负重复计数会导致 @code{re-search-forward} 进行向后搜索。
@end enumerate

@need 800
@code{re-search-forward} 的模板如下：

@smallexample
@group
(re-search-forward "@var{正则表达式}"
                @var{搜索限制}
                @var{失败时的操作}
                @var{重复计数})
@end group
@end smallexample

第二、第三和第四个参数是可选的。但是，如果您想向最后两个参数之一或两者都传递一个值，您还必须向所有前面的参数传递一个值。否则，Lisp 解释器将混淆您正在传递值的参数。

@need 1200
在 @code{forward-sentence} 函数中，正则表达式将是变量 @code{sentence-end} 的值。简单形式如下：

@smallexample
@group
"[.?!][]\"')@}]*\\($\\|  \\|  \\)[
]*"
@end group
@end smallexample

@noindent
搜索的限制将是段落的末尾（因为句子不能超过段落）。如果搜索失败，函数将返回 @code{nil}；而重复计数将由 @code{forward-sentence} 函数的参数提供。

@node forward-sentence
@section @code{forward-sentence}
@findex forward-sentence

将光标向前移动到下一个句子末尾的命令是如何在Emacs Lisp中使用正则表达式搜索的一个直观例子。实际上，该函数看起来比实际复杂得多；这是因为该函数旨在向前和向后移动；而且，可选地，可以跨越多个句子。该函数通常绑定到键命令@kbd{M-e}。

@menu
* Complete forward-sentence::
* fwd-sentence while loops::    两个 @code{while} 循环。
* fwd-sentence re-search::      正则表达式搜索。
@end menu

@ifnottex
@node Complete forward-sentence
@unnumberedsubsec 完整的 @code{forward-sentence} 函数定义
@end ifnottex

@need 1250
以下是@code{forward-sentence}的代码：

@c 在 GNU Emacs 22 中
@smallexample
@group
(defun forward-sentence (&optional arg)
  "向前移动到下一个句子末尾。带有参数时重复。带有负数参数时，反复向后移动到句子开头。

变量 `sentence-end' 是一个正则表达式，用于匹配句子的末尾。此外，每个段落边界也会终止句子。"
@end group
@group
  (interactive "p")
  (or arg (setq arg 1))
  (let ((opoint (point))
        (sentence-end (sentence-end)))
    (while (< arg 0)
      (let ((pos (point))
            (par-beg (save-excursion (start-of-paragraph-text) (point))))
       (if (and (re-search-backward sentence-end par-beg t)
                (or (< (match-end 0) pos)
                    (re-search-backward sentence-end par-beg t)))
           (goto-char (match-end 0))
         (goto-char par-beg)))
      (setq arg (1+ arg)))
@end group
@group
    (while (> arg 0)
      (let ((par-end (save-excursion (end-of-paragraph-text) (point))))
       (if (re-search-forward sentence-end par-end t)
           (skip-chars-backward " \t\n")
         (goto-char par-end)))
      (setq arg (1- arg)))
    (constrain-to-field nil opoint t)))
@end group
@end smallexample

@ignore
GNU Emacs 21
@smallexample
@group
(defun forward-sentence (&optional arg)
  "向前移动到下一个句子末尾。带有参数时重复。带有负数参数时，反复向后移动到句子开头。句子的末尾由 `sentence-end' 的值标识，被视为正则表达式。此外，每个段落边界也会终止句子。"
@end group
@group
  (interactive "p")
  (or arg (setq arg 1))
  (while (< arg 0)
    (let ((par-beg
           (save-excursion (start-of-paragraph-text) (point))))
      (if (re-search-backward
           (concat sentence-end "[^ \t\n]") par-beg t)
          (goto-char (1- (match-end 0)))
        (goto-char par-beg)))
    (setq arg (1+ arg)))
  (while (> arg 0)
    (let ((par-end
           (save-excursion (end-of-paragraph-text) (point))))
      (if (re-search-forward sentence-end par-end t)
          (skip-chars-backward " \t\n")
        (goto-char par-end)))
    (setq arg (1- arg))))
@end group
@end smallexample
@end ignore

这个函数乍一看似乎很长，最好先看它的骨架，然后再看它的实现。看骨架的方法是查看从最左列开始的表达式：

@smallexample
@group
(defun forward-sentence (&optional arg)
  "@var{documentation}@dots{}"
  (interactive "p")
  (or arg (setq arg 1))
  (let ((opoint (point)) (sentence-end (sentence-end)))
    (while (< arg 0)
      (let ((pos (point))
            (par-beg (save-excursion (start-of-paragraph-text) (point))))
       @var{向后移动时 while 循环的其余部分的主体}
    (while (> arg 0)
      (let ((par-end (save-excursion (end-of-paragraph-text) (point))))
       @var{向前移动时 while 循环的其余部分的主体}
    @var{处理表单和等价物的表达式}
@end group
@end smallexample

这看起来简单得多！函数定义由文档、一个@code{interactive}表达式、一个@code{or}表达式、一个@code{let}表达式和@code{while}循环组成。

让我们逐个查看这些部分。

我们注意到文档写得很详细且易懂。

函数有一个@code{interactive "p"}声明。这意味着处理过的前缀参数（如果有）将作为函数的参数传递。 （这将是一个数字。）如果函数未以参数形式调用（它是可选的），则参数@code{arg}将绑定为1。

当以非交互方式调用@code{forward-sentence}且没有参数时，@code{arg}绑定为@code{nil}。@code{or}表达式处理这一点。它的作用是仅在@code{arg}绑定到一个值时保持@code{arg}的值不变；或者在@code{arg}绑定到@code{nil}时将@code{arg}的值设置为1。

接下来是一个@code{let}。它指定了两个局部变量@code{opoint}和@code{sentence-end}的值。从搜索之前的点的局部值用于@code{constrain-to-field}函数，该函数处理表单和等价物。@code{sentence-end}变量由@code{sentence-end}函数设置。

@node fwd-sentence while loops
@unnumberedsubsec The @code{while} loops

接下来是两个@code{while}循环。第一个@code{while}具有一个真假测试，如果@code{forward-sentence}的前缀参数是负数，则测试为真。这是用于向后移动的情况。该循环的主体类似于第二个@code{while}子句的主体，但不完全相同。我们将跳过这个@code{while}循环，专注于第二个@code{while}循环。

@need 1500
第二个@code{while}循环是用于向前移动点的。它的框架如下：

@smallexample
@group
(while (> arg 0)            ; @r{真假测试}
  (let @var{varlist}
    (if (@var{真假测试})
        @var{then-part}
      @var{else-part}
  (setq arg (1- arg))))     ; @code{while} @r{循环递减器}
@end group
@end smallexample

该@code{while}循环是递减型的。
(@xref{递减循环, , A Loop with a Decrementing Counter}.) 它有一个真假测试，只要计数器（在这种情况下是变量@code{arg}）大于零，测试就为真；并且有一个递减器，每次循环重复时从计数器的值中减去1。

如果没有给@code{forward-sentence}提供前缀参数，这是该命令最常用的方式，那么这个@code{while}循环将运行一次，因为@code{arg}的值将为1。

@code{while}循环的主体包含一个@code{let}表达式，该表达式创建和绑定一个局部变量，并且其主体是一个@code{if}表达式。

@need 1250
@code{while}循环的主体如下：

@smallexample
@group
(let ((par-end
       (save-excursion (end-of-paragraph-text) (point))))
  (if (re-search-forward sentence-end par-end t)
      (skip-chars-backward " \t\n")
    (goto-char par-end)))
@end group
@end smallexample

@code{let}表达式创建并绑定局部变量@code{par-end}。正如我们将看到的，此局部变量旨在为正则表达式搜索提供一个边界或限制。如果搜索未能在段落中找到适当的句子结束，它将在达到段落末尾时停止。

但首先，让我们查看@code{par-end}如何绑定到段落末尾的值。发生的是@code{let}将@code{par-end}的值设置为Lisp解释器评估表达式时返回的值

@smallexample
@group
(save-excursion (end-of-paragraph-text) (point))
@end group
@end smallexample

@noindent
在此表达式中，@code{(end-of-paragraph-text)}将point移动到段落末尾，@code{(point)}返回point的值，然后@code{save-excursion}将point恢复到其原始位置。因此，@code{let}将@code{par-end}绑定到由@code{save-excursion}表达式返回的值，即段落末尾的位置。 (@code{end-of-paragraph-text}函数使用@code{forward-paragraph}，我们将很快讨论。)

@need 1200
接下来，Emacs评估@code{let}的主体，这是一个@code{if}表达式，如下所示：

@smallexample
@group
(if (re-search-forward sentence-end par-end t) ; @r{if部分}
    (skip-chars-backward " \t\n")              ; @r{then部分}
  (goto-char par-end)))                        ; @r{else部分}
@end group
@end smallexample

@code{if}测试其第一个参数是否为真，如果是，则评估其then部分；否则，Emacs Lisp解释器将评估else部分。@code{if}表达式的真假测试是正则表达式搜索。

可能看起来奇怪的是，在这里埋藏看起来像是@code{forward-sentence}函数的实际工作，但这是Lisp中执行此类操作的常见方式。

@node fwd-sentence re-search
@unnumberedsubsec 正则表达式搜索

函数 @code{re-search-forward} 用于搜索句子的结尾，即由 @code{sentence-end} 正则表达式定义的模式。如果找到模式——也就是找到了句子的结尾——那么 @code{re-search-forward} 函数会执行两个操作：

@enumerate
@item
@code{re-search-forward} 函数执行一个副作用，即将点移动到找到的出现的结尾。

@item
@code{re-search-forward} 函数返回 true 的值。这是由 @code{if} 接收的值，并表示搜索成功。
@end enumerate

@noindent
副作用，即点的移动，在 @code{if} 函数接收到搜索成功的返回值之前完成。

当 @code{if} 函数从成功调用 @code{re-search-forward} 接收到 true 的值时，@code{if} 会评估 then 部分，即表达式 @code{(skip-chars-backward " \t\n")}。这个表达式向后移动任何空格、制表符或回车，直到找到一个打印字符，然后将点留在字符之后。由于点已经被移动到标记句子结尾的模式的末尾，这个操作将点留在句子的结束字符后，通常是一个句点。

另一方面，如果 @code{re-search-forward} 函数未能找到标记句子结束的模式，则该函数返回 false。然后 false 导致 @code{if} 评估其第三个参数，即 @code{(goto-char par-end)}：将点移动到段落的末尾。

（如果文本处于表单或等效状态，且点可能无法完全移动，则会调用 @code{constrain-to-field} 函数。）

正则表达式搜索非常有用，而由 @code{re-search-forward} 展示的模式，其中搜索是 @code{if} 表达式的测试，非常方便。你会经常看到或编写包含这个模式的代码。

@node forward-paragraph
@section @code{forward-paragraph}：一个丰富的功能集合
@findex forward-paragraph

@ignore
@c 在 GNU Emacs 22 中
(defun forward-paragraph (&optional arg)
  "向前移动至段落末尾。
带有参数 ARG 时，执行 ARG 次；
负参数 ARG = -N 表示向后移动 N 段落。

`paragraph-start' 匹配的行要么分隔段落
（如果 `paragraph-separate' 也匹配它），要么是段落的第一行。
段落末尾是前一行的结束不属于同一段落的行，或缓冲区的结束。
返回剩余要移动的段落数量。"
  (interactive "p")
  (or arg (setq arg 1))
  (let* ((opoint (point))
         (fill-prefix-regexp
          (and fill-prefix (not (equal fill-prefix ""))
               (not paragraph-ignore-fill-prefix)
               (regexp-quote fill-prefix)))
         ;; 如果在 paragraph-start 和 paragraph-sep 的开头有 ^，则移除它们。
         ;; 这些正则表达式不应该是锚定的，因为我们从左边距开始查找它们。
         ;; 这允许段落命令在缩进的文本中正常工作。
         ;; 此 hack 将无法找到问题案例，例如 "whatever\\|^something"。
         (parstart (if (and (not (equal "" paragraph-start))
                            (equal ?^ (aref paragraph-start 0)))
                       (substring paragraph-start 1)
                     paragraph-start))
         (parsep (if (and (not (equal "" paragraph-separate))
                          (equal ?^ (aref paragraph-separate 0)))
                     (substring paragraph-separate 1)
                   paragraph-separate))
         (parsep
          (if fill-prefix-regexp
              (concat parsep "\\|"
                      fill-prefix-regexp "[ \t]*$")
            parsep))
         ;; 用于搜索的变量。
         (sp-parstart (concat "^[ \t]*\\(?:" parstart "\\|" parsep "\\)"))
         start found-start)
    (while (and (< arg 0) (not (bobp)))
      (if (and (not (looking-at parsep))
               (re-search-backward "^\n" (max (1- (point)) (point-min)) t)
               (looking-at parsep))
          (setq arg (1+ arg))
        (setq start (point))
        ;; 向后移动超过分隔段落的行。
        (forward-char -1) (beginning-of-line)
        (while (and (not (bobp))
                    (progn (move-to-left-margin)
                           (looking-at parsep)))
          (forward-line -1))
        (if (bobp)
            nil
          (setq arg (1+ arg))
          ;; 移动至前一行的结束（非分隔）。
          (end-of-line)
          ;; 向后搜索以找到开始或分隔段落的行。
          (if (if fill-prefix-regexp
                  ;; 存在填充前缀；它覆盖了 parstart。
                  (let (multiple-lines)
                    (while (and (progn (beginning-of-line) (not (bobp)))
                                (progn (move-to-left-margin)
                                       (not (looking-at parsep)))
                                (looking-at fill-prefix-regexp))
                      (unless (= (point) start)
                        (setq multiple-lines t))
                      (forward-line -1))
                    (move-to-left-margin)
                    ;; 这段已删除的代码导致长悬挂缩进行无法与后续行一起填充。
                    ;; ;; 不要向后移动一个段落之前的行，除非它不以 fill-prefix 开头，
                    ;; ;; 并且那是我们移动的唯一行。
                    ;; (and (not (looking-at fill-prefix-regexp))
                    ;;      multiple-lines
                    ;;      (forward-line 1))
                    (not (bobp)))
                (while (and (re-search-backward sp-parstart nil 1)
                            (setq found-start t)
                            ;; 找到一个候选项，但需要检查它是否是真正的 parstart。
                            (progn (setq start (point))
                                   (move-to-left-margin)
                                   (not (looking-at parsep)))
                            (not (and (looking-at parstart)
                                      (or (not use-hard-newlines)
                                          (bobp)
                                          (get-text-property
                                           (1- start) 'hard)))))
                  (setq found-start nil)
                  (goto-char start))
                found-start)
              ;; 找到一个。
              (progn
                ;; 向前移动超过分隔符。
                ;; 我们知道这不可能达到我们开始的地方，
                ;; 因为我们知道我们向后移动超过了非分隔符。
                (while (and (not (eobp))
                            (progn (move-to-left-margin)
                                   (looking-at parsep)))
                  (forward-line 1))
                ;; 如果段落前一行只是边距，后退到那里。
                (end-of-line 0)
                (if (> (current-column) (current-left-margin))
                    (forward-char 1)
                  (skip-chars-backward " \t")
                  (if (not (bolp))
                      (forward-line 1))))
            ;; 没有启动器或分隔符行 => 使用缓冲区开头。
            (goto-char (point-min))))))

    (while (and (> arg 0) (not (eobp)))
      ;; 向前移动超过分隔符行...
      (while (and (not (eobp))
                  (progn (move-to-left-margin) (not (eobp)))
                  (looking-at parsep))
        (forward-line 1))
      (unless (eobp) (setq arg (1- arg)))
      ;; ... 还有一行。
      (forward-line 1)
      (if fill-prefix-regexp
          ;; 存在填充前缀；它覆盖了 parstart。
          (while (and (not (eobp))
                      (progn (move-to-left-margin) (not (eobp)))
                      (not (looking-at parsep))
                      (looking-at fill-prefix-regexp))
            (forward-line 1))
        (while (and (re-search-forward sp-parstart nil 1)
                    (progn (setq start (match-beginning 0))
                           (goto-char start)
                           (not (eobp)))
                    (progn (move-to-left-margin)
                           (not (looking-at parsep)))
                    (or (not (looking-at parstart))
                        (and use-hard-newlines
                             (not (get-text-property (1- start) 'hard)))))
          (forward-char 1))
        (if (< (point) (point-max))
            (goto-char start))))
    (constrain-to-field nil opoint t)
    ;; 返回无法完成的步骤数。
    arg))
@end ignore

@code{forward-paragraph} 函数将点（point）向前移动到段落末尾。通常绑定到 @kbd{M-@}}，并且使用一些重要的函数，包括@code{let*}、@code{match-beginning} 和 @code{looking-at}。

@code{forward-paragraph} 的函数定义比 @code{forward-sentence} 的函数定义长得多，因为它处理一个段落，其中每一行可能以填充前缀开始。

填充前缀由一串在每一行开头重复的字符组成。例如，在 Lisp 代码中，通常使用 @samp{;;; } 开始段落长注释的每一行。在文本模式中，四个空格组成了另一种常见的填充前缀，创建一个缩进的段落。（有关填充前缀的更多信息，请参阅 @xref{Fill Prefix, , ,emacs, The GNU Emacs Manual}。）

存在填充前缀意味着除了能够找到以最左列开始的段落的末尾之外，@code{forward-paragraph} 函数还必须能够找到在缓冲区中所有或许多行都以填充前缀开头的段落的末尾。

此外，有时忽略存在的填充前缀是切实可行的，特别是在空白行分隔段落时。这是一个额外的复杂性。

@menu
* forward-paragraph in brief::  函数定义的关键部分。
* fwd-para let::                @code{let*} 表达式。
* fwd-para while::              前进运动的 @code{while} 循环。
@end menu

@ifnottex
@node forward-paragraph in brief
@unnumberedsubsec Shortened @code{forward-paragraph} function definition
@end ifnottex

与其打印整个 @code{forward-paragraph} 函数，我们只打印其中的部分。如果毫无准备地阅读，这个函数可能令人生畏！

@need 800
简而言之，该函数的轮廓如下：

@smallexample
@group
(defun forward-paragraph (&optional arg)
  "@var{文档}@dots{}"
  (interactive "p")
  (or arg (setq arg 1))
  (let*
      @var{变量列表}
    (while (and (< arg 0) (not (bobp)))     ; @r{向后移动的代码}
      @dots{}
    (while (and (> arg 0) (not (eobp)))     ; @r{向前移动的代码}
      @dots{}
@end group
@end smallexample

函数的前部分很常规：函数的参数列表包含一个可选参数。文档随后。

在 @code{interactive} 声明中的小写 @samp{p} 表示处理后的前缀参数（如果有）将传递给函数。这将是一个数字，是光标将移动的段落数的重复计数。下一行的 @code{or} 表达式处理了未向函数传递参数的常见情况，即如果函数是从其他代码中调用而不是交互式调用时发生的情况。此情况在之前已经描述过。(@xref{forward-sentence, The @code{forward-sentence} function}.) 现在我们到达了这个函数的熟悉部分的末尾。

@node fwd-para let
@unnumberedsubsec The @code{let*} expression

@findex let*
@code{forward-paragraph} 函数的下一行开始了一个 @code{let*} 表达式 (@pxref{let* introduced,,@code{let*} introduced})，在其中 Emacs 绑定了七个变量：@code{opoint}、@code{fill-prefix-regexp}、@code{parstart}、@code{parsep}、@code{sp-parstart}、@code{start} 和 @code{found-start}。

变量 @code{parsep} 出现两次，首先是为了去除 @samp{^} 的实例，其次是为了处理填充前缀。

变量 @code{opoint} 只是 @code{point} 的值。正如你可以猜到的，它在一个 @code{constrain-to-field} 表达式中使用，就像在 @code{forward-sentence} 中一样。

变量 @code{fill-prefix-regexp} 被设置为通过评估以下列表返回的值：

@smallexample
@group
(and fill-prefix
     (not (equal fill-prefix ""))
     (not paragraph-ignore-fill-prefix)
     (regexp-quote fill-prefix))
@end group
@end smallexample

@noindent
这是一个表达式，其第一个元素是 @code{and} 特殊形式。

正如我们之前学到的(@pxref{kill-new 函数, , @code{kill-new} 函数})，@code{and} 特殊形式评估其每个参数，直到其中一个参数返回 @code{nil} 的值，此时 @code{and} 表达式返回 @code{nil}；然而，如果没有任何参数返回 @code{nil} 的值，则评估最后一个参数产生的值将被返回。 (由于这样的值不是 @code{nil}，在 Lisp 中被视为真值。) 换句话说，只有当 @code{and} 表达式的所有参数都为真时，它才返回真值。

在这种情况下，只有当以下四个表达式在评估时产生真值（即非 @code{nil} 值）时，变量 @code{fill-prefix-regexp} 才绑定到非 @code{nil} 值；否则，@code{fill-prefix-regexp} 被绑定到 @code{nil}。

@table @code
@item fill-prefix
评估此变量时，返回填充前缀的值（如果有的话）。如果没有填充前缀，则此变量返回 @code{nil}。

@item (not (equal fill-prefix ""))
此表达式检查现有填充前缀是否为空字符串，即不包含任何字符的字符串。空字符串不是有用的填充前缀。

@item (not paragraph-ignore-fill-prefix)
如果变量 @code{paragraph-ignore-fill-prefix} 被设置为真值，如 @code{t}，则此表达式返回 @code{nil}。

@item (regexp-quote fill-prefix)
这是 @code{and} 特殊形式的最后一个参数。如果 @code{and} 的所有参数都为真，则通过评估此表达式产生的值将被 @code{and} 表达式返回，并绑定到变量 @code{fill-prefix-regexp}，
@end table

@findex regexp-quote
@noindent
成功评估此 @code{and} 表达式的结果是，@code{fill-prefix-regexp} 将绑定到由 @code{regexp-quote} 函数修改的 @code{fill-prefix} 的值。 @code{regexp-quote} 做的是读取一个字符串并返回一个正则表达式，该正则表达式将精确匹配该字符串且不匹配其他任何内容。这意味着如果存在填充前缀，@code{fill-prefix-regexp} 将被设置为一个精确匹配填充前缀的值。否则，该变量将被设置为 @code{nil}。

@code{let*} 表达式中的下两个局部变量旨在从 @code{parstart} 和 @code{parsep} 中删除 @samp{^} 的实例。接下来的表达式再次设置 @code{parsep}。这是为了处理填充前缀。

这是定义调用 @code{let*} 而不是 @code{let} 的设置。 @code{if} 表达式的真假测试取决于变量 @code{fill-prefix-regexp} 是否评估为 @code{nil} 或其他值。

如果 @code{fill-prefix-regexp} 没有值，Emacs 评估 @code{if} 表达式的 else-部分，并将 @code{parsep} 绑定到其局部值。 (@code{parsep} 是一个匹配段落之间分隔符的正则表达式。)

但是，如果 @code{fill-prefix-regexp} 有值，Emacs 将评估 @code{if} 表达式的 then-部分，并将 @code{parsep} 绑定到一个正则表达式，该正则表达式包含 @code{fill-prefix-regexp} 作为模式的一部分。

具体而言，@code{parsep} 被设置为段落分隔正则表达式的原始值，后面跟着一个可选的空白到行尾的替代表达式，由 @w{@code{"[ \t]*$"}} 定义。) @samp{\\|} 定义了正则表达式的这一部分作为 @code{parsep} 的替代项。

根据代码中的注释，接下来的局部变量，@code{sp-parstart}，用于搜索，然后最后两个，@code{start} 和 @code{found-start}，被设置为 @code{nil}。

现在我们进入了 @code{let*} 的主体。 @code{let*} 的主体的第一部分处理函数被给予负参数且因此向后移动的情况。我们将跳过这一部分。

@node fwd-para while
@unnumberedsubsec 前进动作 @code{while} 循环

@code{let*} 的第二部分处理前进动作。它是一个 @code{while} 循环，只要 @code{arg} 的值大于零就重复执行。在函数的最常见用法中，参数的值为 1，因此 @code{while} 循环的主体只被评估一次，光标向前移动一个段落。

@ignore
(while (and (> arg 0) (not (eobp)))

  ;; 向前移动过分隔行…
  (while (and (not (eobp))
              (progn (move-to-left-margin) (not (eobp)))
              (looking-at parsep))
    (forward-line 1))
  (unless (eobp) (setq arg (1- arg)))
  ;; …再多移动一行。
  (forward-line 1)

  (if fill-prefix-regexp
      ;; 存在填充前缀；它覆盖了 parstart；
      (while (and (not (eobp))
                  (progn (move-to-left-margin) (not (eobp)))
                  (not (looking-at parsep))
                  (looking-at fill-prefix-regexp))
        (forward-line 1))

    (while (and (re-search-forward sp-parstart nil 1)
                (progn (setq start (match-beginning 0))
                       (goto-char start)
                       (not (eobp)))
                (progn (move-to-left-margin)
                       (not (looking-at parsep)))
                (or (not (looking-at parstart))
                    (and use-hard-newlines
                         (not (get-text-property (1- start) 'hard)))))
      (forward-char 1))

    (if (< (point) (point-max))
        (goto-char start))))
@end ignore

这部分处理三种情况：当光标在段落之间时，当存在填充前缀时，当不存在填充前缀时。

@need 800
@code{while} 循环如下：

@smallexample
@group
;; @r{向前移动且不在缓冲区末尾}
(while (and (> arg 0) (not (eobp)))

  ;; @r{在段落之间}
  ;; 向前移动过分隔行…
  (while (and (not (eobp))
              (progn (move-to-left-margin) (not (eobp)))
              (looking-at parsep))
    (forward-line 1))
  ;;  @r{这减少了循环计数}
  (unless (eobp) (setq arg (1- arg)))
  ;; …再多移动一行。
  (forward-line 1)
@end group

@group
  (if fill-prefix-regexp
      ;; 存在填充前缀；它覆盖了 parstart；
      ;; 我们逐行向前移动
      (while (and (not (eobp))
                  (progn (move-to-left-margin) (not (eobp)))
                  (not (looking-at parsep))
                  (looking-at fill-prefix-regexp))
        (forward-line 1))
@end group

@group
    ;; 不存在填充前缀；
    ;; 我们逐字符向前移动
    (while (and (re-search-forward sp-parstart nil 1)
                (progn (setq start (match-beginning 0))
                       (goto-char start)
                       (not (eobp)))
                (progn (move-to-left-margin)
                       (not (looking-at parsep)))
                (or (not (looking-at parstart))
                    (and use-hard-newlines
                         (not (get-text-property (1- start) 'hard)))))
      (forward-char 1))
@end group

@group
    ;; 如果没有填充前缀且不在末尾，
    ;;     则转到在正则表达式搜索 sp-parstart 中找到的内容
    (if (< (point) (point-max))
        (goto-char start))))
@end group
@end smallexample

@findex eobp
我们可以看到这是一个递减计数器的 @code{while} 循环，使用表达式 @code{(setq arg (1- arg))} 作为递减器。该表达式并不远离 @code{while}，但被隐藏在另一个 Lisp 宏中，即 @code{unless} 宏。除非我们在缓冲区末尾——这是 @code{eobp} 函数确定的；它是 @samp{End Of Buffer P} 的缩写——否则我们会将 @code{arg} 的值减小一。

（如果我们在缓冲区末尾，我们无法再向前移动，由于测试是与 @code{(not (eobp))} 的 @code{and}，下一个循环的表达式将测试为假，因为 @code{not} 函数的作用与您期望的完全相同；它是 @code{null} 的另一个名称，当其参数为假时返回真。）

有趣的是，循环计数器在我们离开段落之间之前并未递减，除非我们到达缓冲区的末尾或停止看到段落分隔符的本地值。

这第二个 @code{while} 也有一个 @code{(move-to-left-margin)} 表达式。该函数是不言自明的。它在一个 @code{progn} 表达式中，并且不是其主体的最后一个元素，因此它仅被调用以产生其移动到当前行左边缘的副作用。

@findex looking-at
@code{looking-at} 函数同样不言自明；如果点之后的文本与其参数给定的正则表达式匹配，则返回真。

在理解的过程中，循环体的其余部分起初看起来可能有些困难，但随着理解，它会变得合理。

@need 800
首先考虑如果存在填充前缀时会发生什么：

@smallexample
@group
  (if fill-prefix-regexp
      ;; 存在填充前缀；它覆盖了 parstart；
      ;; 我们逐行向前移动
      (while (and (not (eobp))
                  (progn (move-to-left-margin) (not (eobp)))
                  (not (looking-at parsep))
                  (looking-at fill-prefix-regexp))
        (forward-line 1))
@end group
@end smallexample

@noindent
这个表达式会使点逐行向前移动，只要四个条件都为真：

@enumerate
@item
点不在缓冲区末尾。

@item
我们可以移动到文本的左边缘且不在缓冲区末尾。

@item
点之后的文本不分隔段落。

@item
点之后的模式是填充前缀正则表达式。
@end enumerate

最后一个条件可能令人困惑，直到您记住点在 @code{forward-paragraph} 函数中早期被移动到行的开头。这意味着如果文本有填充前缀，@code{looking-at} 函数将会看到它。

@need 1250
考虑当没有填充前缀时会发生什么。

@smallexample
@group
    (while (and (re-search-forward sp-parstart nil 1)
                (progn (setq start (match-beginning 0))
                       (goto-char start)
                       (not (eobp)))
                (progn (move-to-left-margin)
                       (not (looking-at parsep)))
                (or (not (looking-at parstart))
                    (and use-hard-newlines
                         (not (get-text-property (1- start) 'hard)))))
      (forward-char 1))
@end group
@end smallexample

@noindent
这个 @code{while} 循环让我们向前搜索 @code{sp-parstart}，它是可能的空白字符与段落或段落分隔符的本地值的组合。 （后两者都在以 @code{\(?:} 开头的表达式中，以便它们不被 @code{match-beginning} 函数引用。）

@need 800
这两个表达式，

@smallexample
@group
(setq start (match-beginning 0))
(goto-char start)
@end group
@end smallexample

@noindent
意味着转到由正则表达式搜索匹配的文本的开头。

@code{(match-beginning 0)} 表达式是新的。它返回一个指定由最近的搜索匹配的文本的开头位置的数字。

@findex match-beginning
当给定参数 0 时，@code{match-beginning} 返回最近搜索匹配的文本的开头位置。在这种情况下，最近的搜索寻找 @code{sp-parstart}。@code{(match-beginning 0)} 表达式返回该模式的开头位置，而不是该模式的结束位置。

（顺便说一下，当作为参数传递一个正数时，@code{match-beginning} 函数返回最后一次搜索中括号表达式的位置，除非该括号表达式以 @code{\(?:} 开头。我不知道为什么这里出现 @code{\(?:}，因为参数是 0。）

@need 1250
当没有填充前缀时的最后一个表达式是

@smallexample
@group
(if (< (point) (point-max))
    (goto-char start))))
@end group
@end smallexample

@noindent
这表示如果没有填充前缀且不在末尾，点应该移动到由正则表达式搜索 @code{sp-parstart} 找到的内容的开头。

@code{forward-paragraph} 函数的完整定义不仅包括前进的代码，还包括后退的代码。

如果您在 GNU Emacs 中阅读此内容并想查看整个函数，请键入 @kbd{C-h f}（@code{describe-function}）和函数的名称。这会给您函数文档和包含函数源代码的库的名称。将点放在库的名称上，然后按 @key{RET} 键；您将直接转到源代码。（确保安装了源代码！没有源代码，您就像闭着眼睛开车的人一样！）

@node 正则表达式复习
@section 复习

以下是一些最近引入的函数的简要概述。

@table @code
@item while
重复评估表达式体的主体，只要体的第一个元素测试为真。然后返回@code{nil}。（仅为了其副作用而评估表达式。）

@need 1250
例如：

@smallexample
@group
(let ((foo 2))
  (while (> foo 0)
    (insert (format "foo is %d.\n" foo))
    (setq foo (1- foo))))

     @result{}      foo is 2.
             foo is 1.
             nil
@end group
@end smallexample

@noindent
（@code{insert}函数在光标处插入其参数；@code{format}函数根据其参数的方式返回一个字符串，就像@code{message}格式化其参数一样；@code{\n}产生一个新行。）

@item re-search-forward
搜索模式，如果找到模式，则将光标移动到其后。

@noindent
与@code{search-forward}相似，接受四个参数：

@enumerate
@item
一个正则表达式，指定要搜索的模式。（记得在这个参数周围加上引号！）

@item
可选的搜索限制。

@item
可选的，如果搜索失败，返回@code{nil}或错误消息。

@item
可选的，重复搜索的次数；如果为负数，则进行反向搜索。
@end enumerate

@item let*
在本地将一些变量绑定到特定值，然后评估其余参数，返回最后一个的值。在绑定本地变量时，使用先前绑定的变量的本地值（如果有）。

@need 1250
例如：

@smallexample
@group
(let* ((foo 7)
       (bar (* 3 foo)))
  (message "`bar' is %d." bar))
     @result{} ‘bar’ is 21.
@end group
@end smallexample

@item match-beginning
返回由上一次正则表达式搜索找到的文本的起始位置。

@item looking-at
如果光标后的文本与参数匹配（应为正则表达式），则返回@code{t}为真。

@item eobp
如果光标位于缓冲区的可访问部分的末尾，则返回@code{t}为真。如果缓冲区没有缩小，则可访问部分的末尾是缓冲区的末尾；如果缓冲区已经缩小，则可访问部分的末尾是缩小部分的末尾。
@end table

@need 1500
@node re-search Exercises
@section 使用@code{re-search-forward}的练习

@itemize @bullet
@item
编写一个函数来搜索与正则表达式匹配的两个或更多空白行。

@item
编写一个函数来搜索重复的单词，例如“the the”。有关如何编写匹配由两个相同部分组成的字符串的正则表达式（regexp）的信息，请参阅@xref{Regexps, , Syntax of Regular Expressions, emacs, The GNU Emacs Manual}。您可以设计几个正则表达式；有些比其他的好。我使用的函数在附录中有描述，以及几个正则表达式。@xref{the-the, , @code{the-the} Duplicated Words Function}。
@end itemize

@node 统计单词数
@chapter 通过重复和正则表达式进行统计
@cindex 通过重复统计单词
@cindex 通过正则表达式统计单词

重复和正则表达式搜索是在编写Emacs Lisp代码时经常使用的强大工具。本章通过使用 @code{while} 循环和递归构建单词计数命令来说明正则表达式搜索的使用。

@menu
* 为什么统计单词::         
* @value{COUNT-WORDS}::          使用正则表达式，但遇到问题。
* recursive-count-words::       从区域中没有单词的情况开始。
* 统计练习::
@end menu

@ifnottex
@node 为什么统计单词
@unnumberedsec 统计单词
@end ifnottex

标准的Emacs发行版包含用于计算区域内行数和单词数的函数。

某些类型的写作要求你统计单词数。因此，如果你写一篇文章，你可能被限制在800个单词；如果你写一本小说，你可能自律地每天写1000个单词。这似乎有些奇怪，但很长一段时间，Emacs缺乏一个统计单词数的命令。也许人们主要使用Emacs编写代码或一些不需要统计单词数的文档；或者他们局限于使用操作系统的单词计数命令 @code{wc}。另外，人们可能按照出版商的习惯，通过将文档中的字符数除以五来计算单词数。

有许多实现统计单词数的方法。以下是一些例子，您可能希望与标准Emacs命令 @code{count-words-region} 进行比较。

@node @value{COUNT-WORDS}
@section 函数 @code{@value{COUNT-WORDS}}
@findex @value{COUNT-WORDS}

一个单词计数命令可以在行、段落、区域或缓冲区中计算单词数。这个命令应该覆盖什么范围？你可以设计命令来计算整个缓冲区中的单词数。然而，Emacs 传统鼓励灵活性——你可能只想计算一个部分中的单词，而不是整个缓冲区。因此，更有意义的是设计命令来计算区域中的单词数。一旦你有一个计算区域中单词数的命令，如果愿意，可以通过使用@w{@kbd{C-x h}}（@code{mark-whole-buffer}）标记整个缓冲区来计算单词数。

显然，计算单词是一个重复的动作：从区域的开头开始，计算第一个单词，然后是第二个单词，依此类推，直到达到区域的末尾。这意味着单词计数理想情况下适合使用递归或@code{while}循环。

@menu
* 设计 @value{COUNT-WORDS}::  使用@code{while}循环进行定义。
* 空白符号错误::  @code{@value{COUNT-WORDS}}中的空白符号错误。
@end menu

@ifnottex
@node 设计 @value{COUNT-WORDS}
@unnumberedsubsec 设计 @code{@value{COUNT-WORDS}}
@end ifnottex

首先，我们将使用@code{while}循环实现单词计数命令，然后再使用递归。当然，该命令将是交互式的。

@need 800
交互式函数定义的模板如下：

@smallexample
@group
(defun @var{name-of-function} (@var{argument-list})
  "@var{documentation}@dots{}"
  (@var{interactive-expression}@dots{})
  @var{body}@dots{})
@end group
@end smallexample

我们需要填写这些位置。

函数的名称应该是不言自明且容易记忆的。@code{count-words-region}是显而易见的选择。由于该名称已用于标准的Emacs命令以计算单词数，我们将为我们的实现命名为@code{@value{COUNT-WORDS}}。

该函数计算区域中的单词数。这意味着参数列表必须包含绑定到区域的两个位置的符号，即起始和结束。这两个位置可以分别称为@samp{beginning}和@samp{end}。文档的第一行应该是一个简单的句子，因为这是由@code{apropos}等命令打印的所有文档。交互表达式将采用形式@samp{(interactive "r")}，因为这将导致Emacs将区域的起始和结束传递给函数的参数列表。所有这些都是例行公事。

函数的主体需要编写三个任务：首先，设置@code{while}循环可以计算单词的条件；其次，运行@code{while}循环；最后，向用户发送消息。

当用户调用@code{@value{COUNT-WORDS}}时，点可能位于区域的开头或末尾。然而，计数过程必须从区域的开头开始。这意味着如果点尚未在那里，我们将希望将点放在那里。执行@code{(goto-char beginning)}可以确保这一点。当函数完成其工作时，当然我们希望将点返回到其预期的位置。因此，主体必须包含在@code{save-excursion}表达式中。

函数主体的核心部分包含一个@code{while}循环，其中一个表达式按单词向前跳转点，另一个表达式计算这些跳转。@code{while}循环的真假测试应该在点应该向前跳转时返回true，在点在区域末尾时返回false。

我们可以使用@code{(forward-word 1)}作为将点逐个单词向前移动的表达式，但如果使用正则表达式搜索，可以更容易地看到Emacs将其识别为“单词”的内容。

一个正则表达式搜索找到其正在搜索的模式后，将点留在匹配的最后一个字符之后。这意味着一系列成功的单词搜索将点逐个单词向前移动。

实际上，我们希望正则表达式搜索跳过单词之间的空白符和标点符号，以及单词本身。一个拒绝跳过单词之间空白符的正则表达式搜索永远不会跳过一个以上的单词！这意味着正则表达式应包括单词之后（如果有的话）的空白符和标点符号，以及单词本身。 （一个单词可能结束于缓冲区，而没有任何后续空白符或标点符号，因此该正则表达式的这一部分必须是可选的。）

因此，我们希望正则表达式的模式是定义一个或多个单词成分字符，后面跟着可选的一个或多个不是单词成分字符的字符。这个正则表达式的模式如下：

@smallexample
\w+\W*
@end smallexample

@noindent
缓冲区的语法表决定了哪些字符是单词成分字符，哪些不是。有关语法的更多信息，请参见@pxref{Syntax Tables, , Syntax Tables, elisp, The GNU Emacs Lisp Reference Manual}。

@need 800
搜索表达式看起来像这样：

@smallexample
(re-search-forward "\\w+\\W*")
@end smallexample

@noindent
（请注意，斜杠前面有@samp{w}和@samp{W}。单个斜杠对Emacs Lisp解释器有特殊含义。它表示以下字符的解释方式与通常不同。例如，两个字符@samp{\n}代表@samp{newline}，而不是反斜杠后跟@samp{n}。两个连续的斜杠表示一个普通的、非特殊的反斜杠，因此Emacs Lisp解释器最终会看到一个后面跟着一个字母的单个反斜杠。因此，它发现这个字母是特殊的。）

我们需要一个计数器来计算有多少个单词；这个变量必须首先设置为0，然后在Emacs循环@code{while}中的每一次都递增。递增表达式很简单：

@smallexample
(setq count (1+ count))
@end smallexample

最后，我们想告诉用户区域中有多少个单词。@code{message}函数适用于向用户呈现这种类型的信息。消息必须以这样的方式构造，以便不管区域中有多少个单词，它都能正确阅读：我们不想说“区域中有1个单词”。单数和复数之间的冲突是不合语法的。我们可以通过使用条件表达式来解决此问题，该表达式根据区域中的单词数评估不同的消息。有三种可能性：区域中没有单词，区域中有一个单词，以及区域中有多个单词。这意味着@code{cond}特殊形式是适当的。

@need 1500
所有这些导致以下函数定义：

@smallexample
@group
;;; @r{第一个版本；存在错误！}
(defun @value{COUNT-WORDS} (beginning end)
  "打印区域中的单词数。
单词被定义为至少一个单词成分字符，后跟至少一个不是单词成分字符的字符。
缓冲区的语法表决定了这些字符是什么。"
  (interactive "r")
  (message "正在计算区域中的单词数... ")
@end group

@group
;;; @r{1. 设置适当的条件。}
  (save-excursion
    (goto-char beginning)
    (let ((count 0))
@end group

@group
;;; @r{2. 运行} while @r{循环。}
      (while (< (point) end)
        (re-search-forward "\\w+\\W*")
        (setq count (1+ count)))
@end group

@group
;;; @r{3. 向用户发送消息。}
      (cond ((zerop count)
             (message
              "区域中没有单词。"))
            ((= 1 count)
             (message
              "区域中有1个单词。"))
            (t
             (message
              "区域中有%d个单词。" count))))))
@end group
@end smallexample

@noindent
按照目前的编写方式，该函数能够工作，但在某些情况下不完全正确。

@node 空白字符错误
@subsection @code{@value{COUNT-WORDS}} 中的空白字符错误

在前面的章节中描述的 @code{@value{COUNT-WORDS}} 命令有两个错误，或者更确切地说，有一个带有两个表现形式的错误。首先，如果你标记一个仅包含中间某些文本的空白区域，@code{@value{COUNT-WORDS}} 命令会告诉你该区域包含一个单词！其次，如果你标记一个仅包含位于缓冲区末尾或缩小缓冲区的可访问部分的空白字符的区域，该命令会显示一个错误消息，看起来像这样：

@smallexample
搜索失败："\\w+\\W*"
@end smallexample

如果你是在GNU Emacs的Info中阅读本文，你可以自行测试这些错误。

首先，按照通常的方式评估该函数以安装它。
@ifinfo
这是定义的一个副本。将光标放在括号结束后，然后键入 @kbd{C-x C-e} 以安装它。

@smallexample
@group
;; @r{第一个版本; 存在错误!}
(defun @value{COUNT-WORDS} (beginning end)
  "打印区域内的单词数。
单词定义为至少一个单词构成字符，后面跟着至少一个不是单词构成字符的字符。缓冲区的语法表确定这些字符。"
@end group
@group
  (interactive "r")
  (message "正在计算区域内的单词数 ... ")
@end group

@group
;;; @r{1. 设置适当的条件。}
  (save-excursion
    (goto-char beginning)
    (let ((count 0))
@end group

@group
;;; @r{2. 运行} while @r{循环。}
      (while (< (point) end)
        (re-search-forward "\\w+\\W*")
        (setq count (1+ count)))
@end group

@group
;;; @r{3. 向用户发送消息。}
      (cond ((zerop count)
             (message "该区域不包含任何单词。"))
            ((= 1 count) (message "该区域包含1个单词。"))
            (t (message "该区域包含%d个单词。" count))))))
@end group
@end smallexample
@end ifinfo

@need 1000
如果愿意，也可以通过评估以下绑定来安装此键绑定：

@smallexample
(global-set-key "\C-c=" '@value{COUNT-WORDS})
@end smallexample

进行第一个测试，将标记和点设置到以下行的开始和结束，然后键入 @kbd{C-c =}（或如果未绑定 @kbd{C-c =}，则为 @kbd{M-x @value{COUNT-WORDS}}）：

@smallexample
    一个  两个  三
@end smallexample

@noindent
Emacs 将告诉你，该区域有三个单词，这是正确的。

重复测试，但将标记放在该行的开头，并将点放在单词 @samp{一个} 之前。再次输入命令 @kbd{C-c =}（或 @kbd{M-x @value{COUNT-WORDS}}）。Emacs 应该告诉你该区域没有单词，因为它仅由该行开头的空白字符组成。但是，Emacs却告诉你该区域有一个单词！

对于第三个测试，将示例行复制到 @file{*scratch*} 缓冲区的末尾，然后在该行的末尾输入多个空格。将标记放在单词 @samp{三} 之后，将点放在行末。 （行末将是缓冲区的末尾。）像之前一样，输入 @kbd{C-c =}（或 @kbd{M-x @value{COUNT-WORDS}}）。再次，Emacs 应该告诉你该区域没有单词，因为它仅由该行末尾的空白字符组成。但是，相反，Emacs 显示一个错误消息，其中显示 @samp{Search failed}。

这两个错误源于同一个问题。

考虑错误的第一个表现形式，在该表现形式中，该命令告诉你该行开头的空白字符包含一个单词。发生的情况是：@code{M-x @value{COUNT-WORDS}} 命令将点移动到区域的开头。@code{while} 测试点的值是否小于 @code{end} 的值，它是的。因此，正则表达式搜索寻找并找到第一个单词。它将点放在单词之后。 @code{count} 设置为一。@code{while} 循环重复; 但是这次点的值大于 @code{end} 的值，循环退出；函数显示一条消息，其中包含区域中的单词数为一。简而言之，尽管标记区域外的单词，但正则表达式搜索却寻找并找到了该单词。

在错误的第二个表现形式中，该区域是位于缓冲区末尾的空白字符。Emacs 显示 @samp{Search failed}。发生的情况是，在 @code{while} 循环中的真假测试中，测试为真，因此执行搜索表达式。但由于缓冲区中没有更多的单词，搜索失败。

在错误的两个表现形式中，搜索都会扩展或尝试扩展到区域之外。

解决方案是限制搜索到该区域，这是一个相当简单的操作，但正如你可能期望的那样，它并不像你想象的那么简单。

正如我们所见，@code{re-search-forward} 函数将搜索模式作为其第一个参数。但除了这第一个，强制性的参数外，它还接受三个可选参数。可选的第二个参数限制了搜索。可选的第三个参数，如果是 @code{t}，则使函数在搜索失败时返回 @code{nil} 而不是引发错误。可选的第四个参数是重复计数。（在Emacs中，可以通过键入 @kbd{C-h f}，函数的名称，然后 @key{RET} 来查看函数的文档。）

在 @code{@value{COUNT-WORDS}} 的定义中，区域末尾的值由传递给函数的变量 @code{end} 持有。因此，我们可以将 @code{end} 添加为正则表达式搜索表达式的参数：

@smallexample
(re-search-forward "\\w+\\W*" end)
@end smallexample

然而，如果你只对 @code{@value{COUNT-WORDS}} 定义进行这个更改，然后在一段空白区域上测试新版本的定义，你将收到一条错误消息，其中显示 @samp{Search failed}。

发生的情况是：搜索限制为该区域，因为在该区域中没有单词构成字符，所以搜索失败，正如你所期望的那样。由于失败，我们收到了一条错误消息。但在这种情况下，我们不希望收到错误消息；我们希望收到消息“该区域不包含任何单词”。

解决此问题的方法是向 @code{re-search-forward} 提供第三个参数 @code{t}，这将导致函数在搜索失败时返回 @code{nil} 而不是引发错误。

然而，如果你进行此更改并尝试运行它，你将看到消息“计算区域内的单词数 ...”，等等，你将继续看到该消息...，直到你键入 @kbd{C-g}（@code{keyboard-quit}）。

发生的情况是：搜索限制为该区域，与之前一样失败，因为该区域中没有单词构成字符，正如预期的那样。因此，@code{re-search-forward} 表达式返回 @code{nil}。它仅仅返回 @code{nil}。特别地，如果找到了搜索目标，它不会移动点，这是它的副作用之一。在 @code{re-search-forward} 表达式返回 @code{nil} 后，@code{while} 循环中的下一个表达式将被评估。该表达式递增计数。然后循环重复。由于 @code{re-search-forward} 表达式没有移动点，所以 @code{while} 循环的真假测试测试为真，因为点的值仍然小于 @code{end} 的值。...循环重复...

@code{@value{COUNT-WORDS}} 定义需要进行另一个修改，以使 @code{while} 循环的真假测试在搜索失败时测试为假。换句话说，在增加单词计数变量之前，必须同时满足两个条件：点必须仍然在区域内，并且搜索表达式必须找到一个要计数的单词。

由于第一个条件和第二个条件必须一起为真，所以这两个表达式，区域测试和搜索表达式，可以用 @code{and} 特殊形式连接，并嵌入到 @code{while} 循环中作为真假测试，如下所示：

@smallexample
(and (< (point) end) (re-search-forward "\\w+\\W*" end t))
@end smallexample

@c 在打印的章节标题中的冒号会导致Info交叉引用问题
@c 在Info交叉引用中也存在问题
@iftex
@noindent
（有关 @code{and} 的信息，请参见 @ref{kill-new function, , The @code{kill-new} function}。）
@end iftex
@ifinfo
@noindent
（关于 @code{and} 的信息，请参见 @ref{kill-new function, , The @code{kill-new} function}。）
@end ifinfo

@code{re-search-forward} 表达式在搜索成功时返回 @code{t}，并作为副作用移动点。因此，随着找到单词，点通过区域移动。当搜索表达式未能找到另一个单词，或当点达到区域的末尾时，真假测试失败，@code{while} 循环退出，@code{@value{COUNT-WORDS}} 函数显示其消息之一。

在加入这些最终更改后，@code{@value{COUNT-WORDS}} 就没有错误了（或者至少，我没有找到错误！）。以下是它的最终版本：

@smallexample
@group
;;; @r{最终版本：} @code{while}
(defun @value{COUNT-WORDS} (beginning end)
  "打印区域内的单词数。"
  (interactive "r")
  (message "计算区域内的单词数 ... ")
@end group

@group
;;; @r{1. 设置适当的条件。}
  (save-excursion
    (let ((count 0))
      (goto-char beginning)
@end group

@group
;;; @r{2. 运行} while @r{循环。}
      (while (and (< (point) end)
                  (re-search-forward "\\w+\\W*" end t))
        (setq count (1+ count)))
@end group

@group
;;; @r{3. 向用户发送消息。}
      (cond ((zerop count)
             (message
              "该区域不包含任何单词。"))
            ((= 1 count)
             (message
              "该区域包含一个单词。"))
            (t
             (message
              "该区域包含 %d 个单词。" count))))))
@end group
@end smallexample

@node recursive-count-words
@section 递归计算单词数
@cindex 递归计算单词数
@cindex 递归单词计数
@cindex 单词，递归计数

你可以编写递归方式和使用 @code{while} 循环的函数来计算单词数。让我们看看如何实现。

首先，我们需要认识到 @code{@value{COUNT-WORDS}} 函数有三个任务：它设置适当的条件来进行计数；它计算区域内的单词数；并向用户发送一条消息，告诉有多少个单词。

如果我们写一个单一的递归函数来执行所有这些任务，我们将为每个递归调用都收到一条消息。如果区域包含13个单词，我们将接收到十三条消息，依次排列。我们不想要这样！相反，我们必须编写两个函数来完成工作，其中一个（递归函数）将在另一个内部使用。一个函数将设置条件并显示消息；另一个将返回单词数。

让我们从引起消息显示的函数开始。我们可以继续称之为 @code{@value{COUNT-WORDS}}。

这是用户将调用的函数。它将是交互式的。实际上，它将类似于我们先前版本的这个函数，只是它将调用 @code{recursive-count-words} 来确定区域中有多少个单词。

@need 1250
我们可以基于先前的版本轻松构造这个函数的模板：

@smallexample
@group
;; @r{递归版本；使用正则表达式搜索}
(defun @value{COUNT-WORDS} (beginning end)
  "@var{documentation}@dots{}"
  (@var{interactive-expression}@dots{})
@end group
@group

;;; @r{1. 设置适当的条件。}
  (@var{explanatory message})
  (@var{set-up functions}@dots{}
@end group
@group

;;; @r{2. 计算单词数。}
    @var{recursive call}
@end group
@group

;;; @r{3. 向用户发送消息。}
    @var{message providing word count}))
@end group
@end smallexample

定义看起来很简单，只是要注意递归调用返回的计数如何传递给显示单词计数的消息。经过一点思考，我们可以利用 @code{let} 表达式来实现：我们可以在 @code{let} 表达式的 varlist 中将一个变量绑定到区域内的单词数，由递归调用返回；然后 @code{cond} 表达式可以使用绑定来向用户显示该值。

通常，人们将 @code{let} 表达式内的绑定视为函数的主要工作的某种次要部分。但在这种情况下，您可能认为函数的主要工作，即计算单词数，是在 @code{let} 表达式内完成的。

@need 1250
使用 @code{let}，函数定义如下：

@smallexample
@group
(defun @value{COUNT-WORDS} (beginning end)
  "打印区域内的单词数。"
  (interactive "r")
@end group

@group
;;; @r{1. 设置适当的条件。}
  (message "正在计算区域内的单词数... ")
  (save-excursion
    (goto-char beginning)
@end group

@group
;;; @r{2. 计算单词数。}
    (let ((count (recursive-count-words end)))
@end group

@group
;;; @r{3. 向用户发送消息。}
      (cond ((zerop count)
             (message
              "该区域没有任何单词。"))
            ((= 1 count)
             (message
              "该区域有1个单词。"))
            (t
             (message
              "该区域有 %d 个单词。" count))))))
@end group
@end smallexample

接下来，我们需要编写递归计数函数。

递归函数至少有三个部分：再次执行测试，下一步表达式和递归调用。

再次执行测试确定函数是否将再次调用。由于我们在区域中计算单词数并可以使用一个每个单词都向前移动指针的函数，再次执行测试可以检查点是否仍然在区域内。再次执行测试应该找到点的值，并确定点是在区域结束的值之前，与之相等还是之后。我们可以使用 @code{point} 函数来定位点。显然，必须将区域结束的值作为参数传递给递归计数函数。

此外，再次执行测试还应该测试搜索是否找到了单词。如果没有找到，函数不应再次调用自身。

下一步表达式更改一个值，以便当递归函数应该停止调用自身时，它停止。更准确地说，下一步表达式更改一个值，以便在正确的时间，再次执行测试停止递归函数再次调用自身。在这种情况下，下一步表达式可以是将点按单词向前移动的表达式。

递归函数的第三部分是递归调用。

还需要一个执行函数工作的部分，一个执行计数的重要部分！

@need 1250
但是，我们已经有了递归计数函数的大纲：

@smallexample
@group
(defun recursive-count-words (region-end)
  "@var{documentation}@dots{}"
   @var{do-again-test}
   @var{next-step-expression}
   @var{recursive call})
@end group
@end smallexample

现在我们需要填充这些槽。让我们从最简单的情况开始：如果点在区域结束的位置或之后，那么区域中不能有任何单词，因此函数应返回零。同样，如果搜索失败，就没有单词可计数，因此函数应返回零。

另一方面，如果点在区域内且搜索成功，则函数应再次调用自身。

@need 800
因此，再次执行测试应如下所示：

@smallexample
@group
(and (< (point) region-end)
     (re-search-forward "\\w+\\W*" region-end t))
@end group
@end smallexample

请注意，搜索表达式是再次执行测试的一部分——如果其搜索成功，则函数返回 @code{t}，如果失败，则返回 @code{nil}。(@xref{空白字符错误, , @code{@value{COUNT-WORDS}} 中的空白字符错误}，了解 @code{re-search-forward} 的工作原理的解释。)

再次执行测试是 @code{if} 子句的真值测试。显然，如果再次执行测试成功，则 @code{if} 子句的 then-部分应该再次调用函数；但如果失败，则 else-部分应该返回零，因为要么点在区域外，要么搜索失败，因为找不到单词。

但在考虑递归调用之前，我们需要考虑下一步表达式。这是什么？有趣的是，它就是do-again-test的搜索部分。

除了为do-again-test返回@code{t}或@code{nil}外，@code{re-search-forward}在成功搜索时会作为副作用移动点。这是改变点值的操作，使得递归函数停止调用自身，当点通过区域完成移动。因此，@code{re-search-forward}表达式就是next-step-expression。

@need 1200
概述来看，@code{recursive-count-words}函数的主体如下：

@smallexample
@group
(if @var{do-again-test-and-next-step-combined}
    ;; @r{then}
    @var{recursive-call-returning-count}
  ;; @r{else}
  @var{return-zero})
@end group
@end smallexample

如何融入计数机制？

如果你不习惯编写递归函数，这样的问题可能会让人头疼。但应该以系统的方式来解决。

我们知道计数机制应该以某种方式与递归调用关联起来。确实，由于next-step-expression通过一个单词将点向前移动，并且由于每个单词都会进行递归调用，计数机制必须是一个表达式，该表达式将一个添加到由@code{recursive-count-words}调用返回的值。

@need 800
考虑几种情况：

@itemize @bullet
@item
如果区域中有两个单词，则函数应该返回一个值，该值是在计算第一个单词时添加到该值的值，再加上计算区域中剩余单词时返回的数字，这在这种情况下为一。

@item
如果区域中只有一个单词，则函数应该返回一个值，该值是在计算该单词时添加到该值的值，再加上计算区域中剩余单词时返回的数字，这在这种情况下为零。

@item
如果区域中没有单词，则函数应该返回零。
@end itemize

从草图中我们可以看到，@code{if}的else部分对于没有单词的情况返回零。这意味着@code{if}的then部分必须返回一个值，该值是通过递归调用的返回值添加一的结果。

@need 1200
表达式将如下所示，其中@code{1+}是一个将一个添加到其参数的函数。

@smallexample
(1+ (recursive-count-words region-end))
@end smallexample

@need 1200
整个@code{recursive-count-words}函数将如下所示：

@smallexample
@group
(defun recursive-count-words (region-end)
  "@var{documentation}@dots{}"

;;; @r{1. do-again-test}
  (if (and (< (point) region-end)
           (re-search-forward "\\w+\\W*" region-end t))
@end group

@group
;;; @r{2. then-part: the recursive call}
      (1+ (recursive-count-words region-end))

;;; @r{3. else-part}
    0))
@end group
@end smallexample

@need 1250
让我们看看这是如何工作的：

如果区域中没有单词，则@code{if}表达式的else部分被求值，因此函数返回零。

如果区域中有一个单词，则点的值小于@code{region-end}的值，并且搜索成功。在这种情况下，@code{if}表达式的true-or-false-test为true，将求值@code{if}表达式的then部分。计数表达式将被求值。该表达式返回一个值（这将是整个函数返回的值），即加一到递归调用返回的值。

同时，next-step-expression导致点跳过区域中的第一个（在这种情况下是唯一的）单词。这意味着当@code{(recursive-count-words region-end)}第二次求值时，由于递归调用的结果，点的值将等于或大于region end的值。因此，这次，@code{recursive-count-words}将返回零。零将添加到一，原始的@code{recursive-count-words}的求值将返回一加零，即一，这是正确的数量。

显然，如果区域中有两个单词，则第一次调用@code{recursive-count-words}将返回一个添加到调用@code{recursive-count-words}的区域剩余单词的值，即它添加到一，产生两个，这是正确的数量。

同样地，如果区域中有三个单词，则第一次调用@code{recursive-count-words}将返回一个添加到调用@code{recursive-count-words}的区域剩余两个单词的值，依此类推。

@need 1250
@noindent
具有完整文档的两个函数如下：

@need 1250
@noindent
递归函数：

@findex recursive-count-words
@smallexample
@group
(defun recursive-count-words (region-end)
  "在点和REGION-END之间的单词数。"
@end group

@group
;;; @r{1. do-again-test}
  (if (and (< (point) region-end)
           (re-search-forward "\\w+\\W*" region-end t))
@end group

@group
;;; @r{2. then-part: the recursive call}
      (1+ (recursive-count-words region-end))

;;; @r{3. else-part}
    0))
@end group
@end smallexample

@need 800
@noindent
包装器：

@smallexample
@group
;;; @r{递归版本}
(defun @value{COUNT-WORDS} (beginning end)
  "打印区域中的单词数。"
@end group

@group
单词被定义为至少一个单词构成字符，后面跟着至少一个不是单词构成字符的字符。缓冲区的语法表决定了这些字符是哪些。"
@end group
@group
  (interactive "r")
  (message "正在计算区域中的单词数...")
  (save-excursion
    (goto-char beginning)
    (let ((count (recursive-count-words end)))
@end group
@group
      (cond ((zerop count)
             (message
              "该区域没有任何单词。"))
@end group
@group
            ((= 1 count)
             (message "该区域有1个单词。"))
            (t
             (message
              "该区域有%d个单词。" count))))))
@end group
@end smallexample

@node 计数练习
@section 练习：计算标点符号

使用 @code{while} 循环，编写一个函数来计算区域内标点符号的数量---句号、逗号、分号、冒号、感叹号和问号。然后使用递归方式完成相同的任务。

@node 在 defun 中计算单词数
@chapter 在 @code{defun} 中计算单词数
@cindex 在 @code{defun} 中计算单词数
@cindex 在 @code{defun} 中的单词计数

我们下一个项目是计算函数定义中的单词数。显然，这可以通过一些 @code{@value{COUNT-WORDS}} 的变体来完成。参见 @xref{统计单词数, ,通过重复和正则表达式计数}。如果我们只想计算一个定义中的单词数，那么可以使用 @kbd{C-M-h} (@code{mark-defun}) 命令标记定义，然后调用 @code{@value{COUNT-WORDS}}。

然而，我更有雄心壮志：我想要计算 Emacs 源代码中每个定义中的单词和符号的数量，然后打印一个图表，显示每个长度的函数有多少个：包含 40 到 49 个单词或符号的有多少个函数，包含 50 到 59 个单词或符号的有多少个，依此类推。我常常好奇一个典型函数有多长，这将给出答案。

@menu
* 分而治之::
* 单词和符号::           应该计数什么？
* 语法::                  什么构成一个单词或符号？
* count-words-in-defun:: 与 @code{@value{COUNT-WORDS}} 非常相似。
* 多个 defuns::           计算文件中的多个定义。
* 查找文件::              想要查看一个文件吗？
* lengths-list-file::     许多定义长度的列表。
* 多个文件::              在不同文件中计数定义。
* 递归计数多个文件::      递归在不同文件中计数。
* 准备数据::              为在图表中显示准备数据。
@end menu

@ifnottex
@node 分而治之
@unnumberedsec 分而治之
@end ifnottex

用一句话描述，直方图项目是艰巨的；但是，将其分解为许多小步骤，我们可以一次解决一个，项目就变得不那么可怕了。让我们考虑这些步骤应该是什么：

@itemize @bullet
@item
首先，编写一个函数来计算一个定义中的单词数。这包括处理符号以及单词的问题。

@item
其次，编写一个函数来列出文件中每个函数中的单词数。这个函数可以使用 @code{count-words-in-defun} 函数。

@item
第三，编写一个函数来列出每个文件中每个函数中的单词数。这涉及到自动找到不同文件，切换到它们，并计算其中定义的单词数。

@item
第四，编写一个函数将我们在第三步中创建的数字列表转换为适合打印为图表的形式。

@item
第五，编写一个函数将结果打印为图表。
@end itemize

这是一个相当庞大的项目！但是，如果我们慢慢来，它并不难。

@node 单词和符号
@section 如何计数？
@cindex defun 中的单词和符号

当我们首次考虑如何计算函数定义中的单词时，第一个问题是（或者应该是）我们要计数什么？当我们谈到与 Lisp 函数定义相关的“单词”时，实际上在很大程度上我们是在谈论符号。例如，下面的 @code{multiply-by-seven} 函数包含五个符号：@code{defun}、@code{multiply-by-seven}、@code{number}、@code{*} 和 @code{7}。此外，在文档字符串中，它包含四个单词：@samp{Multiply}、@samp{NUMBER}、@samp{by} 和 @samp{seven}。符号 @samp{number} 被重复使用，因此定义包含总共十个单词和符号。

@smallexample
@group
(defun multiply-by-seven (number)
  "Multiply NUMBER by seven."
  (* 7 number))
@end group
@end smallexample

@noindent
然而，如果我们使用 @kbd{C-M-h}（@code{mark-defun}）标记 @code{multiply-by-seven} 定义，然后调用 @code{@value{COUNT-WORDS}}，我们会发现 @code{@value{COUNT-WORDS}} 声称该定义有十一个单词，而不是十个！有些地方出错了！

问题有两个方面：@code{@value{COUNT-WORDS}} 不将 @samp{*} 视为一个单词，而将单个符号 @code{multiply-by-seven} 视为包含三个单词。连字符被视为单词间的空格而不是单词内的连接符：@samp{multiply-by-seven} 被计算为如果它被写成 @samp{multiply by seven}。

混淆的原因在于 @code{@value{COUNT-WORDS}} 定义中的正则表达式搜索，该搜索按单词向前移动点。在 @code{@value{COUNT-WORDS}} 的典型版本中，正则表达式为：

@smallexample
"\\w+\\W*"
@end smallexample

@noindent
该正则表达式是一个模式，定义了一个或多个单词构成字符，后面可能跟着一个或多个不是单词构成字符的字符。关于“单词构成字符”是什么，这就引出了语法问题，值得单独讨论一节。

@node 语法
@section 何为单词或符号的组成部分？
@cindex 语法类别和表

Emacs将不同的字符视为属于不同的@dfn{语法类别}。例如，正则表达式@samp{\\w+}是一个模式，指定一个或多个@emph{单词组成}字符。单词组成字符属于一个语法类别。其他语法类别包括标点字符类，如句点和逗号，以及空白字符类，如空格和制表符。（更多信息，请参阅@pxref{Syntax Tables, , Syntax Tables, elisp, The GNU Emacs Lisp Reference Manual}。）

语法表指定哪些字符属于哪些类别。通常，连字符不被指定为单词组成字符。相反，它被指定为符号名称中的字符类，但不是单词。这意味着@code{@value{COUNT-WORDS}}函数以与单词间空格相同的方式处理它，这就是为什么@code{@value{COUNT-WORDS}}将@samp{multiply-by-seven}计为三个单词的原因。

有两种方法可以使Emacs将@samp{multiply-by-seven}计为一个符号：修改语法表或修改正则表达式。

我们可以通过修改Emacs为每种模式保留的语法表来重新定义连字符为单词组成字符。这个动作将满足我们的目的，除了连字符仅仅是符号中最常见的不是单词组成字符的字符；还有其他字符。

或者，我们可以重新定义@code{@value{COUNT-WORDS}}定义中使用的正则表达式，以包括符号。这个过程具有清晰的优点，但任务有点棘手。

@need 1200
第一部分相当简单：模式必须匹配至少一个是单词或符号组成字符的字符。因此：

@smallexample
"\\(\\w\\|\\s_\\)+"
@end smallexample

@noindent
@samp{\\(}是包含@samp{\\w}和@samp{\\s_}作为选择项的分组结构的第一部分，由@samp{\\|}分隔。@samp{\\w}匹配任何单词组成字符，而@samp{\\s_}匹配任何是符号名称但不是单词组成字符的字符。组后面的@samp{+}表示单词或符号组成字符必须至少匹配一次。

然而，正则表达式的第二部分设计更难。我们希望第一部分后面可以选择跟随零个或多个不是单词或符号组成字符的字符。起初，我认为可以用以下方式定义这个：

@smallexample
"\\(\\W\\|\\S_\\)*"
@end smallexample

@noindent
大写的@samp{W}和@samp{S}匹配@emph{不是}单词或符号组成字符的字符。不幸的是，这个表达式匹配任何不是单词组成字符或符号组成字符的字符。这匹配任何字符！

我然后注意到我的测试区域中的每个单词或符号后面都跟着空白（空格、制表符或换行符）。所以我尝试在匹配一个或多个单词或符号组成字符的模式之后放置一个匹配一个或多个空格的模式。这也失败了。单词和符号通常由空白分隔，但在实际代码中，括号可能跟随符号，标点可能跟随单词。因此最后，我设计了一个模式，其中单词或符号组成字符后面可以选择跟随不是空白字符的字符，然后可以选择跟随空白字符。

@need 800
以下是完整的正则表达式：

@smallexample
"\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"
@end smallexample

@node count-words-in-defun
@section @code{count-words-in-defun} 函数
@cindex 在 @code{defun} 中计算单词数

我们已经看到有几种编写 @code{count-words-region} 函数的方法。为了编写 @code{count-words-in-defun}，我们只需调整其中一种版本即可。

使用 @code{while} 循环的版本很容易理解，因此我将对其进行调整。由于 @code{count-words-in-defun} 将成为一个更复杂的程序的一部分，它不需要是交互式的，也不需要显示消息，只需返回计数即可。这些考虑稍微简化了定义。

另一方面，@code{count-words-in-defun} 将在包含函数定义的缓冲区中使用。因此，合理的要求是，该函数确定在调用时点是否位于函数定义内，并且如果是，则返回该定义的计数。这增加了定义的复杂性，但省去了需要将参数传递给函数的需要。

@need 1250
这些考虑引导我们准备以下模板：

@smallexample
@group
(defun count-words-in-defun ()
  "@var{documentation}@dots{}"
  (@var{set up}@dots{}
     (@var{while loop}@dots{})
   @var{return count})
@end group
@end smallexample

@noindent
像往常一样，我们的任务是填写这些槽。

首先，设置。

我们假设该函数将在包含函数定义的缓冲区中调用。点要么在函数定义内，要么不在。为了使 @code{count-words-in-defun} 起作用，点必须移动到定义的开头，一个计数器必须从零开始，而计数循环必须在点达到定义的末尾时停止。

@code{beginning-of-defun} 函数向后搜索开头为 @samp{(}（例如在行首）的分隔符，并将点移动到该位置，否则移到搜索的限制位置。在实践中，这意味着 @code{beginning-of-defun} 将点移到封闭或前置函数定义的开头，或者移到缓冲区的开头。我们可以使用 @code{beginning-of-defun} 将点放置在我们想要开始的位置。

@code{while} 循环需要一个计数器来跟踪要计数的单词或符号。可以使用 @code{let} 表达式创建一个用于此目的的局部变量，并将其绑定到零的初始值。

@code{end-of-defun} 函数与 @code{beginning-of-defun} 类似，除了它将点移动到定义的末尾。@code{end-of-defun} 可以作为确定定义末尾位置的表达式的一部分使用。

@code{count-words-in-defun} 的设置迅速形成：首先将点移动到定义的开头，然后创建一个本地变量以保存计数，最后记录定义的末尾位置，以便 @code{while} 循环知道何时停止循环。

@need 1250
代码如下：

@smallexample
@group
(beginning-of-defun)
(let ((count 0)
      (end (save-excursion (end-of-defun) (point))))
@end group
@end smallexample

@noindent
代码很简单。唯一的小复杂性可能涉及到 @code{end}：它被绑定到通过 @code{save-excursion} 表达式返回的点的位置，该表达式在 @code{end-of-defun} 暂时将其移动到定义的末尾后返回其值。

@code{count-words-in-defun} 的第二部分，在设置之后，是 @code{while} 循环。

该循环必须包含一个表达式，该表达式按单词和符号前进并且另一个表达式用于计数跳跃。@code{while} 循环的真假测试应该在点应该前进时为真，而在点位于定义末尾时为假。我们已经重新定义了这个正则表达式，所以循环很简单：

@smallexample
@group
(while (and (< (point) end)
            (re-search-forward
             "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*" end t))
  (setq count (1+ count)))
@end group
@end smallexample

该函数定义的第三部分返回单词和符号的计数。这一部分是 @code{let} 表达式体内的最后一个表达式，可以非常简单地是局部变量 @code{count}，在评估时返回计数。

@need 1250
将这些部分组合起来，@code{count-words-in-defun} 的定义如下：

@findex count-words-in-defun
@smallexample
@group
(defun count-words-in-defun ()
  "返回 defun 中的单词和符号数。"
  (beginning-of-defun)
  (let ((count 0)
        (end (save-excursion (end-of-defun) (point))))
@end group
@group
    (while
        (and (< (point) end)
             (re-search-forward
              "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"
              end t))
      (setq count (1+ count)))
    count))
@end group
@end smallexample

如何测试这个函数？虽然函数不是交互式的，但很容易在其周围添加包装器使其变为交互式；我们可以使用几乎与递归版本的 @code{@value{COUNT-WORDS}} 相同的代码：

@smallexample
@group
;;; @r{交互版本。}
(defun count-words-defun ()
  "函数定义中的单词和符号数。"
  (interactive)
  (message
   "正在计算函数定义中的单词和符号数... ")
@end group
@group
  (let ((count (count-words-in-defun)))
    (cond
     ((zerop count)
      (message
       "该定义没有任何单词或符号。"))
@end group
@group
     ((= 1 count)
      (message
       "该定义有 1 个单词或符号。"))
     (t
      (message
       "该定义有 %d 个单词或符号。" count)))))
@end group
@end smallexample

@need 800
@noindent
让我们重新使用 @kbd{C-c =} 作为一个方便的键绑定：

@smallexample
(global-set-key "\C-c=" 'count-words-defun)
@end smallexample

现在我们可以尝试 @code{count-words-defun}：安装 @code{count-words-in-defun} 和 @code{count-words-defun}，并设置键绑定。然后将以下内容复制到 Emacs Lisp 缓冲区（例如，@file{*scratch*}），将光标放在定义内，并使用 @kbd{C-c =} 命令。

@smallexample
@group
(defun multiply-by-seven (number)
  "将 NUMBER 乘以七。"
  (* 7 number))
     @result{} 10
@end group
@end smallexample

@noindent
成功！该定义有 10 个单词和符号。

下一个问题是计算单个文件中多个定义中的单词和符号数。

@node 多个 defuns
@section 统计文件中的多个 @code{defun}

一个文件，比如 @file{simple.el}，可能包含一百个或更多的函数定义。我们的长期目标是收集许多文件的统计信息，但作为第一步，我们的即时目标是在一个文件中收集统计信息。

信息将是一系列数字，每个数字代表一个函数定义的长度。我们可以将这些数字存储在一个列表中。

我们知道我们将要将关于一个文件的信息与许多其他文件的信息结合起来；这意味着在一个文件中计算定义长度的函数只需要返回长度列表，而不需要也不应该显示任何消息。

字数统计命令包含一个表达式，用于逐个单词向前跳转，以及另一个表达式，用于计算跳转的次数。用于返回定义长度的函数可以被设计成以相同的方式工作，其中一个表达式用于逐个定义向前跳转，另一个表达式用于构造长度列表。

问题的陈述使编写函数定义变得非常基础。显然，我们将从文件的开头开始计数，因此第一个命令将是 @code{(goto-char (point-min))}。接下来，我们启动 @code{while} 循环；循环的真假测试可以是对下一个函数定义进行正则表达式搜索---只要搜索成功，点就向前移动，然后评估循环体。循环体需要一个表达式，用于构造长度列表。列表构造命令 @code{cons} 可以用来创建列表。就是这样简单。

@need 800
以下是这段代码片段的样子：

@smallexample
@group
(goto-char (point-min))
(while (re-search-forward "^(defun" nil t)
  (setq lengths-list
        (cons (count-words-in-defun) lengths-list)))
@end group
@end smallexample

我们遗漏的是找到包含函数定义的文件的机制。

在以前的例子中，我们要么使用当前文件，Info 文件，要么在其他缓冲区之间切换，比如 @file{*scratch*} 缓冲区。

找到文件是我们尚未讨论的一个新过程。

@node 查找文件
@section 查找文件
@cindex 查找文件

在Emacs中查找文件，您可以使用@kbd{C-x C-f}（@code{find-file}）命令。这个命令几乎完全符合长度问题，但还需要稍作调整。

@need 1200
让我们看一下@code{find-file}的源代码：

@smallexample
@group
(defun find-file (filename)
  "编辑文件 FILENAME。
切换到访问文件 FILENAME 的缓冲区，如果不存在则创建一个。"
  (interactive "FFind file: ")
  (switch-to-buffer (find-file-noselect filename)))
@end group
@end smallexample

@noindent
（@code{find-file}函数定义的最新版本允许您指定可选的通配符以访问多个文件；这使得定义更加复杂，我们在这里不讨论，因为这与问题无关。您可以使用@kbd{M-.}（@code{xref-find-definitions}）或@kbd{C-h f}（@code{describe-function}）查看其源代码。）

@ignore
在Emacs 22
(defun find-file (filename &optional wildcards)
  "编辑文件 FILENAME。
切换到访问文件 FILENAME 的缓冲区，如果不存在则创建一个。
在交互模式下，如果只是按 @key{RET} 键，它会默认到当前目录，但可以通过迷你缓冲区历史记录访问文件名：输入 M-n 将其拉入迷你缓冲区。

在交互模式下，或者在Lisp调用中WILDCARDS为非nil时，展开通配符（如果有的话）并访问多个文件。您可以通过将`find-file-wildcards'设置为nil来禁止通配符展开。

要访问文件而不进行任何类型的转换并且不自动选择主模式，请使用 \\[find-file-literally]。"
  (interactive (find-file-read-args "Find file: " nil))
  (let ((value (find-file-noselect filename nil nil wildcards)))
    (if (listp value)
        (mapcar 'switch-to-buffer (nreverse value))
      (switch-to-buffer value))))
@end ignore

我展示的定义具有简短但完整的文档和交互规范，在您以交互方式使用命令时会提示您输入文件名。定义的主体包含两个函数，@code{find-file-noselect} 和 @code{switch-to-buffer}。

根据@kbd{C-h f}（@code{describe-function}命令）显示的文档，@code{find-file-noselect}函数将指定的文件读入缓冲区并返回该缓冲区。（其最新版本还包括一个可选的@var{wildcards}参数，以及另一个以文本方式读取文件和另一个以抑制警告消息的参数。这些可选参数与问题无关。）

然而，@code{find-file-noselect}函数不会选择放置文件的缓冲区。Emacs不会切换其注意力（或者如果您正在使用@code{find-file-noselect}，那么是您的注意力）到选定的缓冲区。这就是@code{switch-to-buffer}的作用：它切换Emacs关注的缓冲区；并且将窗口中显示的缓冲区切换到新的缓冲区。我们已经在其他地方讨论了缓冲区切换。 （@xref{切换缓冲区}。）

在这个直方图项目中，我们不需要在屏幕上显示每个文件，因为程序确定其中每个定义的长度。我们可以使用@code{set-buffer}而不是@code{switch-to-buffer}，后者会将屏幕上的缓冲区重新显示。因此，我们不必调用@code{find-file}来执行这项任务，而是必须编写我们自己的表达式。

任务很简单：使用@code{find-file-noselect}和@code{set-buffer}。

@node lengths-list-file
@section @code{lengths-list-file} 详解

@code{lengths-list-file} 函数的核心是一个包含 @code{while} 循环的结构，其中包含一个函数来逐个 defun 地将 point 前进，以及一个函数来计算每个 defun 中的单词和符号数。这个核心必须被包裹在执行各种其他任务的函数中，包括查找文件并确保 point 位于文件的开头。该函数定义如下：
@findex lengths-list-file

@smallexample
@group
(defun lengths-list-file (filename)
  "返回 FILE 中定义长度的列表。
返回的列表是数字的列表。
每个数字是一个函数定义中的单词或符号的数量。"
@end group
@group
  (message "正在处理 `%s' ... " filename)
  (save-excursion
    (let ((buffer (find-file-noselect filename))
          (lengths-list))
      (set-buffer buffer)
      (setq buffer-read-only t)
      (widen)
      (goto-char (point-min))
      (while (re-search-forward "^(defun" nil t)
        (setq lengths-list
              (cons (count-words-in-defun) lengths-list)))
      (kill-buffer buffer)
      lengths-list)))
@end group
@end smallexample

@noindent
该函数接受一个参数，即它将操作的文件的名称。它有四行文档，但没有交互规范。由于人们担心如果他们看不到任何操作就会认为计算机出了问题，函数体的第一行是一个消息。

接下来的一行包含一个 @code{save-excursion}，在函数完成时将 Emacs 的注意力返回到当前缓冲区。这对于嵌套在假设 point 被恢复到原始缓冲区的另一个函数中的情况是有用的。

在 @code{let} 表达式的变量列表中，Emacs 找到文件并将局部变量 @code{buffer} 绑定到包含文件的缓冲区。同时，Emacs 创建了 @code{lengths-list} 作为局部变量。

接下来，Emacs 将注意力切换到缓冲区。

在接下来的一行中，Emacs 将缓冲区设置为只读。理想情况下，这一行是不必要的。在计算函数定义中的单词和符号数的函数中，缓冲区不应该发生更改。此外，即使更改了缓冲区，它也不会被保存。这一行完全是对极度谨慎的后果。对谨慎的原因是，这个函数及其调用的函数处理 Emacs 的源代码，并且如果它们被意外修改，则会很不方便。不用说，在一个实验出现问题并开始修改我的 Emacs 源文件之前，我并没有意识到需要这一行 @dots{}

接下来是调用扩展缓冲区的函数，如果它被缩小了的话。通常情况下，这个函数是不需要的 - Emacs 如果还没有存在缓冲区，就会创建一个新的；但是如果已经存在了一个访问文件的缓冲区，Emacs 就返回那个缓冲区。在这种情况下，缓冲区可能被缩小，必须被扩展。如果我们想要完全用户友好，我们会安排保存约束和 point 的位置，但我们不会这样做。

@code{(goto-char (point-min))} 表达式将 point 移动到缓冲区的开头。

然后是一个 @code{while} 循环，在循环中执行函数的工作。在循环中，Emacs 确定每个定义的长度并构造包含该信息的长度列表。

在处理完缓冲区后，Emacs 将其关闭。这是为了在 Emacs 中保存空间。我使用的 GNU Emacs 19 版本包含了 300 多个感兴趣的源文件；GNU Emacs 22 包含了一千多个源文件。另一个函数将应用 @code{lengths-list-file} 到每个文件。

最后，在 @code{let} 表达式中的最后一个表达式是 @code{lengths-list} 变量；其值作为整个函数的值返回。

你可以通过通常的方式安装这个函数并尝试它。然后，将光标放在以下表达式之后，键入 @kbd{C-x C-e} (@code{eval-last-sexp}).

@c !!! 22.1.1 lisp 源文件的位置在这里
@smallexample
(lengths-list-file
 "/usr/local/share/emacs/22.1/lisp/emacs-lisp/debug.el")
@end smallexample

@noindent
你可能需要更改文件的路径名；这里的路径是适用于 GNU Emacs 版本 22.1 的。要更改表达式，将其复制到 @file{*scratch*} 缓冲区并进行编辑。

@need 1200
@noindent
此外，为了看到列表的完整长度，而不是截断版本，你可能需要评估以下内容：
@c 我们不想插入，所以不要提及零前缀参数。

@smallexample
(custom-set-variables '(eval-expression-print-length nil))
@end smallexample

@noindent
(@xref{defcustom, , 使用 @code{defcustom} 指定变量}。
然后评估 @code{lengths-list-file} 表达式。)

@need 1200
@file{debug.el} 的长度列表在 GNU Emacs 22 中不到一秒钟就产生了，看起来像这样：

@smallexample
(83 113 105 144 289 22 30 97 48 89 25 52 52 88 28 29 77 49 43 290 232 587)
@end smallexample

@need 1500
(在我的旧机器上，版本 19 的 @file{debug.el} 长度列表花费了七秒钟并且看起来像这样：

@smallexample
(75 41 80 62 20 45 44 68 45 12 34 235)
@end smallexample

@noindent
新版本的 @file{debug.el} 包含比早期版本更多的 defuns；而我的新机器比旧机器要快得多。)
请注意，文件中的最后一个定义的长度在列表中是最先的。

@node 多个文件
@section 统计不同文件中 @code{defuns} 的词数

在前一节中，我们创建了一个函数，该函数返回文件中每个定义的长度的列表。现在，我们想要定义一个函数，返回一个包含多个文件中定义长度的主列表。

处理文件列表中的每个文件是一个重复的操作，因此我们可以使用 @code{while} 循环或递归。

@menu
* lengths-list-many-files::     返回 @code{defuns} 长度的列表。
* append::                      将一个列表附加到另一个列表。
@end menu

@ifnottex
@node lengths-list-many-files
@unnumberedsubsec 确定 @code{defuns} 的长度
@end ifnottex

使用 @code{while} 循环的设计是常规的。传递给函数的参数是一个文件列表。正如我们之前看到的 (@pxref{循环示例})，可以编写一个 @code{while} 循环，使得在列表包含元素的情况下计算循环体，但在列表为空时退出循环。为了使此设计工作，循环体必须包含一个表达式，该表达式在每次计算循环体时缩短列表，以便最终列表为空。通常的技术是在每次计算循环体时将列表的值设置为列表的 @sc{cdr} 的值。

@need 800
模板如下：

@smallexample
@group
(while @var{测试列表是否为空}
  @var{循环体}@dots{}
  @var{设置列表为列表的cdr})
@end group
@end smallexample

此外，我们要记住，@code{while} 循环返回 @code{nil}（真假测试的计算结果），而不是循环体内任何评估的结果。（循环体内的评估是为了它们的副作用。）然而，设置长度列表的表达式是循环体的一部分，这是我们希望整个函数返回的值。为了实现这一点，我们将 @code{while} 循环封装在一个 @code{let} 表达式内，并安排 @code{let} 表达式的最后一个元素包含长度列表的值。(@xref{增量示例, , 带有增量计数器的循环示例}。)

@findex lengths-list-many-files
@need 1250
这些考虑直接引导我们到函数本身：

@smallexample
@group
;;; @r{使用 @code{while} 循环。}
(defun lengths-list-many-files (list-of-files)
  "返回 LIST-OF-FILES 中 @code{defuns} 的长度列表。"
@end group
@group
  (let (lengths-list)

;;; @r{真假测试}
    (while list-of-files
      (setq lengths-list
            (append
             lengths-list

;;; @r{生成长度列表。}
             (lengths-list-file
              (expand-file-name (car list-of-files)))))
@end group

@group
;;; @r{使文件列表变短。}
      (setq list-of-files (cdr list-of-files)))

;;; @r{返回长度列表的最终值。}
    lengths-list))
@end group
@end smallexample

@code{expand-file-name} 是一个内置函数，将文件名转换为绝对路径形式。该函数使用调用函数所在目录的名称。

@c !!! 22.1.1 lisp 源代码位置在这里
@need 1500
因此，如果在 Emacs 访问 @file{/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/} 目录时，对 @code{debug.el} 调用 @code{expand-file-name}，

@smallexample
debug.el
@end smallexample

@need 800
@noindent
变成了

@c !!! 22.1.1 lisp 源代码位置在这里
@smallexample
/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/debug.el
@end smallexample

该函数定义的另一个新元素是尚未学习的 @code{append} 函数，它值得有一个专门的小节。

@node append
@subsection @code{append} 函数

@need 800
@code{append} 函数将一个列表附加到另一个列表。因此，

@smallexample
(append '(1 2 3 4) '(5 6 7 8))
@end smallexample

@need 800
@noindent
产生了列表

@smallexample
(1 2 3 4 5 6 7 8)
@end smallexample

这正是我们希望将 @code{lengths-list-file} 生成的两个长度列表附加到一起的方式。与 @code{cons} 的结果形成对比，

@smallexample
(cons '(1 2 3 4) '(5 6 7 8))
@end smallexample

@need 1250
@noindent
它构造一个新列表，其中 @code{cons} 的第一个参数成为新列表的第一个元素：

@smallexample
((1 2 3 4) 5 6 7 8)
@end smallexample

@node Several files recursively
@section Recursively Count Words in Different Files

Besides a @code{while} loop, you can work on each of a list of files
with recursion.  A recursive version of @code{lengths-list-many-files}
is short and simple.

The recursive function has the usual parts: the do-again-test, the
next-step-expression, and the recursive call.  The do-again-test
determines whether the function should call itself again, which it
will do if the @code{list-of-files} contains any remaining elements;
the next-step-expression resets the @code{list-of-files} to the
@sc{cdr} of itself, so eventually the list will be empty; and the
recursive call calls itself on the shorter list.  The complete
function is shorter than this description!
@findex recursive-lengths-list-many-files

@smallexample
@group
(defun recursive-lengths-list-many-files (list-of-files)
  "Return list of lengths of each defun in LIST-OF-FILES."
  (if list-of-files                     ; @r{do-again-test}
      (append
       (lengths-list-file
        (expand-file-name (car list-of-files)))
       (recursive-lengths-list-many-files
        (cdr list-of-files)))))
@end group
@end smallexample

@noindent
In a sentence, the function returns the lengths' list for the first of
the @code{list-of-files} appended to the result of calling itself on
the rest of the @code{list-of-files}.

Here is a test of @code{recursive-lengths-list-many-files}, along with
the results of running @code{lengths-list-file} on each of the files
individually.

Install @code{recursive-lengths-list-many-files} and
@code{lengths-list-file}, if necessary, and then evaluate the
following expressions.  You may need to change the files' pathnames;
those here work when this Info file and the Emacs sources are located
in their customary places.  To change the expressions, copy them to
the @file{*scratch*} buffer, edit them, and then evaluate them.

The results are shown after the @samp{@result{}}.  (These results are
for files from Emacs version 22.1.1; files from other versions of
Emacs may produce different results.)

@c !!! 22.1.1 lisp sources location here
@smallexample
@group
(cd "/usr/local/share/emacs/22.1.1/")

(lengths-list-file "./lisp/macros.el")
     @result{} (283 263 480 90)
@end group

@group
(lengths-list-file "./lisp/mail/mailalias.el")
     @result{} (38 32 29 95 178 180 321 218 324)
@end group

@group
(lengths-list-file "./lisp/hex-util.el")
     @result{} (82 71)
@end group

@group
  (recursive-lengths-list-many-files
   '("./lisp/macros.el"
     "./lisp/mail/mailalias.el"
     "./lisp/hex-util.el"))
       @result{} (283 263 480 90 38 32 29 95 178 180 321 218 324 82 71)
@end group
@end smallexample

The @code{recursive-lengths-list-many-files} function produces the
output we want.

The next step is to prepare the data in the list for display in a graph.

@node Prepare the data
@section Prepare the Data for Display in a Graph

The @code{recursive-lengths-list-many-files} function returns a list
of numbers.  Each number records the length of a function definition.
What we need to do now is transform this data into a list of numbers
suitable for generating a graph.  The new list will tell how many
functions definitions contain less than 10 words and
symbols, how many contain between 10 and 19 words and symbols, how
many contain between 20 and 29 words and symbols, and so on.

In brief, we need to go through the lengths' list produced by the
@code{recursive-lengths-list-many-files} function and count the number
of defuns within each range of lengths, and produce a list of those
numbers.

@menu
* Data for Display in Detail::
* Sorting::                     Sorting lists.
* Files List::                  Making a list of files.
* Counting function definitions::
@end menu

@ifnottex
@node Data for Display in Detail
@unnumberedsubsec The Data for Display in Detail
@end ifnottex

Based on what we have done before, we can readily foresee that it
should not be too hard to write a function that @sc{cdr}s down the
lengths' list, looks at each element, determines which length range it
is in, and increments a counter for that range.

However, before beginning to write such a function, we should consider
the advantages of sorting the lengths' list first, so the numbers are
ordered from smallest to largest.  First, sorting will make it easier
to count the numbers in each range, since two adjacent numbers will
either be in the same length range or in adjacent ranges.  Second, by
inspecting a sorted list, we can discover the highest and lowest
number, and thereby determine the largest and smallest length range
that we will need.

@node Sorting
@subsection Sorting Lists
@findex sort

Emacs contains a function to sort lists, called (as you might guess)
@code{sort}.  The @code{sort} function takes two arguments, the list
to be sorted, and a predicate that determines whether the first of
two list elements is less than the second.

As we saw earlier (@pxref{错误类型的参数, , 使用错误类型的对象作为参数}), a predicate is a function that
determines whether some property is true or false.  The @code{sort}
function will reorder a list according to whatever property the
predicate uses; this means that @code{sort} can be used to sort
non-numeric lists by non-numeric criteria---it can, for example,
alphabetize a list.

@need 1250
The @code{<} function is used when sorting a numeric list.  For example,

@smallexample
(sort '(4 8 21 17 33 7 21 7) '<)
@end smallexample

@need 800
@noindent
produces this:

@smallexample
(4 7 7 8 17 21 21 33)
@end smallexample

@noindent
(Note that in this example, both the arguments are quoted so that the
symbols are not evaluated before being passed to @code{sort} as
arguments.)

Sorting the list returned by the
@code{recursive-lengths-list-many-files} function is straightforward;
it uses the @code{<} function:

@smallexample
@group
(sort
 (recursive-lengths-list-many-files
  '("./lisp/macros.el"
    "./lisp/mailalias.el"
    "./lisp/hex-util.el"))
 '<)
@end group
@end smallexample

@need 800
@noindent
which produces:

@smallexample
(29 32 38 71 82 90 95 178 180 218 263 283 321 324 480)
@end smallexample

@noindent
(Note that in this example, the first argument to @code{sort} is not
quoted, since the expression must be evaluated so as to produce the
list that is passed to @code{sort}.)

@node Files List
@subsection Making a List of Files

The @code{recursive-lengths-list-many-files} function requires a list
of files as its argument.  For our test examples, we constructed such
a list by hand; but the Emacs Lisp source directory is too large for
us to do for that.  Instead, we will write a function to do the job
for us.  In this function, we will use both a @code{while} loop and a
recursive call.

@findex directory-files
We did not have to write a function like this for older versions of
GNU Emacs, since they placed all the @samp{.el} files in one
directory.  Instead, we were able to use the @code{directory-files}
function, which lists the names of files that match a specified
pattern within a single directory.

However, recent versions of Emacs place Emacs Lisp files in
sub-directories of the top level @file{lisp} directory.  This
re-arrangement eases navigation.  For example, all the mail related
files are in a @file{lisp} sub-directory called @file{mail}.  But at
the same time, this arrangement forces us to create a file listing
function that descends into the sub-directories.

@findex files-in-below-directory
We can create this function, called @code{files-in-below-directory},
using familiar functions such as @code{car}, @code{nthcdr}, and
@code{substring} in conjunction with an existing function called
@code{directory-files-and-attributes}.  This latter function not only
lists all the filenames in a directory, including the names
of sub-directories, but also their attributes.

To restate our goal: to create a function that will enable us
to feed filenames to @code{recursive-lengths-list-many-files}
as a list that looks like this (but with more elements):

@smallexample
@group
("./lisp/macros.el"
 "./lisp/mail/rmail.el"
 "./lisp/hex-util.el")
@end group
@end smallexample

The @code{directory-files-and-attributes} function returns a list of
lists.  Each of the lists within the main list consists of 13
elements.  The first element is a string that contains the name of the
file---which, in GNU/Linux, may be a @dfn{directory file}, that is to
say, a file with the special attributes of a directory.  The second
element of the list is @code{t} for a directory, a string
for symbolic link (the string is the name linked to), or @code{nil}.

For example, the first @samp{.el} file in the @file{lisp/} directory
is @file{abbrev.el}.  Its name is
@file{/usr/local/share/emacs/22.1.1/lisp/abbrev.el} and it is not a
directory or a symbolic link.

@need 1000
This is how @code{directory-files-and-attributes} lists that file and
its attributes:

@smallexample
@group
("abbrev.el"
nil
1
1000
100
@end group
@group
(20615 27034 579989 697000)
(17905 55681 0 0)
(20615 26327 734791 805000)@footnote{If @code{current-time-list} is
@code{nil} the three timestamps are @code{(1351051674579989697
. 1000000000)}, @code{(1173477761000000000 . 1000000000)}, and
@code{(1351050967734791805 . 1000000000)}, respectively.}
13188
"-rw-r--r--"
@end group
@group
t
2971624
773)
@end group
@end smallexample

@need 1200
On the other hand, @file{mail/} is a directory within the @file{lisp/}
directory.  The beginning of its listing looks like this:

@smallexample
@group
("mail"
t
@dots{}
)
@end group
@end smallexample

(To learn about the different attributes, look at the documentation of
@code{file-attributes}.  Bear in mind that the @code{file-attributes}
function does not list the filename, so its first element is
@code{directory-files-and-attributes}'s second element.)

We will want our new function, @code{files-in-below-directory}, to
list the @samp{.el} files in the directory it is told to check, and in
any directories below that directory.

This gives us a hint on how to construct
@code{files-in-below-directory}:  within a directory, the function
should add @samp{.el} filenames to a list; and if, within a directory,
the function comes upon a sub-directory, it should go into that
sub-directory and repeat its actions.

However, we should note that every directory contains a name that
refers to itself, called @file{.} (``dot''), and a name that refers to
its parent directory, called @file{..} (``dot dot'').  (In
@file{/}, the root directory, @file{..} refers to itself, since
@file{/} has no parent.)  Clearly, we do not want our
@code{files-in-below-directory} function to enter those directories,
since they always lead us, directly or indirectly, to the current
directory.

Consequently, our @code{files-in-below-directory} function must do
several tasks:

@itemize @bullet
@item
Check to see whether it is looking at a filename that ends in
@samp{.el}; and if so, add its name to a list.

@item
Check to see whether it is looking at a filename that is the name of a
directory; and if so,

@itemize @minus
@item
Check to see whether it is looking at @file{.}  or @file{..}; and if
so skip it.

@item
Or else, go into that directory and repeat the process.
@end itemize
@end itemize

Let's write a function definition to do these tasks.  We will use a
@code{while} loop to move from one filename to another within a
directory, checking what needs to be done; and we will use a recursive
call to repeat the actions on each sub-directory.  The recursive
pattern is Accumulate
(@pxref{累积}),
using @code{append} as the combiner.

@ignore
(directory-files "/usr/local/src/emacs/lisp/" t "\\.el$")
(shell-command "find /usr/local/src/emacs/lisp/ -name '*.el'")

(directory-files "/usr/local/share/emacs/22.1.1/lisp/" t "\\.el$")
(shell-command "find /usr/local/share/emacs/22.1.1/lisp/ -name '*.el'")
@end ignore

@c  /usr/local/share/emacs/22.1.1/lisp/

@need 800
Here is the function:

@smallexample
@group
(defun files-in-below-directory (directory)
  "List the .el files in DIRECTORY and in its sub-directories."
  ;; Although the function will be used non-interactively,
  ;; it will be easier to test if we make it interactive.
  ;; The directory will have a name such as
  ;;  "/usr/local/share/emacs/22.1.1/lisp/"
  (interactive "DDirectory name: ")
@end group
@group
  (let (el-files-list
        (current-directory-list
         (directory-files-and-attributes directory t)))
    ;; while we are in the current directory
    (while current-directory-list
@end group
@group
      (cond
       ;; check to see whether filename ends in '.el'
       ;; and if so, add its name to a list.
       ((equal ".el" (substring (car (car current-directory-list)) -3))
        (setq el-files-list
              (cons (car (car current-directory-list)) el-files-list)))
@end group
@group
       ;; check whether filename is that of a directory
       ((eq t (car (cdr (car current-directory-list))))
        ;; decide whether to skip or recurse
        (if
            (equal "."
                   (substring (car (car current-directory-list)) -1))
            ;; then do nothing since filename is that of
            ;;   current directory or parent, "." or ".."
            ()
@end group
@group
          ;; else descend into the directory and repeat the process
          (setq el-files-list
                (append
                 (files-in-below-directory
                  (car (car current-directory-list)))
                 el-files-list)))))
      ;; move to the next filename in the list; this also
      ;; shortens the list so the while loop eventually comes to an end
      (setq current-directory-list (cdr current-directory-list)))
    ;; return the filenames
    el-files-list))
@end group
@end smallexample

@c (files-in-below-directory "/usr/local/src/emacs/lisp/")
@c (files-in-below-directory "/usr/local/share/emacs/22.1.1/lisp/")

The @code{files-in-below-directory} @code{directory-files} function
takes one argument, the name of a directory.

@need 1250
Thus, on my system,

@c (length (files-in-below-directory "/usr/local/src/emacs/lisp/"))

@c !!! 22.1.1 lisp sources location here
@smallexample
@group
(length
 (files-in-below-directory "/usr/local/share/emacs/22.1.1/lisp/"))
@end group
@end smallexample

@noindent
tells me that in and below my Lisp sources directory are 1031
@samp{.el} files.

@code{files-in-below-directory} returns a list in reverse alphabetical
order.  An expression to sort the list in alphabetical order looks
like this:

@smallexample
@group
(sort
 (files-in-below-directory "/usr/local/share/emacs/22.1.1/lisp/")
 'string-lessp)
@end group
@end smallexample

@ignore
(defun test ()
  "Test how long it takes to find lengths of all sorted elisp defuns."
  (insert "\n" (current-time-string) "\n")
  (sit-for 0)
  (sort
   (recursive-lengths-list-many-files
    (files-in-below-directory "/usr/local/src/emacs/lisp/"))
   '<)
  (insert (current-time-string)))
@end ignore

@node Counting function definitions
@subsection Counting function definitions

Our immediate goal is to generate a list that tells us how many
function definitions contain fewer than 10 words and symbols, how many
contain between 10 and 19 words and symbols, how many contain between
20 and 29 words and symbols, and so on.

With a sorted list of numbers, this is easy: count how many elements
of the list are smaller than 10, then, after moving past the numbers
just counted, count how many are smaller than 20, then, after moving
past the numbers just counted, count how many are smaller than 30, and
so on.  Each of the numbers, 10, 20, 30, 40, and the like, is one
larger than the top of that range.  We can call the list of such
numbers the @code{top-of-ranges} list.

@need 1200
If we wished, we could generate this list automatically, but it is
simpler to write a list manually.  Here it is:
@vindex top-of-ranges

@smallexample
@group
(defvar top-of-ranges
 '(10  20  30  40  50
   60  70  80  90 100
  110 120 130 140 150
  160 170 180 190 200
  210 220 230 240 250
  260 270 280 290 300)
 "List specifying ranges for `defuns-per-range'.")
@end group
@end smallexample

To change the ranges, we edit this list.

Next, we need to write the function that creates the list of the
number of definitions within each range.  Clearly, this function must
take the @code{sorted-lengths} and the @code{top-of-ranges} lists
as arguments.

The @code{defuns-per-range} function must do two things again and
again: it must count the number of definitions within a range
specified by the current top-of-range value; and it must shift to the
next higher value in the @code{top-of-ranges} list after counting the
number of definitions in the current range.  Since each of these
actions is repetitive, we can use @code{while} loops for the job.
One loop counts the number of definitions in the range defined by the
current top-of-range value, and the other loop selects each of the
top-of-range values in turn.

Several entries of the @code{sorted-lengths} list are counted for each
range; this means that the loop for the @code{sorted-lengths} list
will be inside the loop for the @code{top-of-ranges} list, like a
small gear inside a big gear.

The inner loop counts the number of definitions within the range.  It
is a simple counting loop of the type we have seen before.
(@xref{增量循环, , A loop with an incrementing counter}.)
The true-or-false test of the loop tests whether the value from the
@code{sorted-lengths} list is smaller than the current value of the
top of the range.  If it is, the function increments the counter and
tests the next value from the @code{sorted-lengths} list.

@need 1250
The inner loop looks like this:

@smallexample
@group
(while @var{length-element-smaller-than-top-of-range}
  (setq number-within-range (1+ number-within-range))
  (setq sorted-lengths (cdr sorted-lengths)))
@end group
@end smallexample

The outer loop must start with the lowest value of the
@code{top-of-ranges} list, and then be set to each of the succeeding
higher values in turn.  This can be done with a loop like this:

@smallexample
@group
(while top-of-ranges
  @var{body-of-loop}@dots{}
  (setq top-of-ranges (cdr top-of-ranges)))
@end group
@end smallexample

@need 1200
Put together, the two loops look like this:

@smallexample
@group
(while top-of-ranges

  ;; @r{Count the number of elements within the current range.}
  (while @var{length-element-smaller-than-top-of-range}
    (setq number-within-range (1+ number-within-range))
    (setq sorted-lengths (cdr sorted-lengths)))

  ;; @r{Move to next range.}
  (setq top-of-ranges (cdr top-of-ranges)))
@end group
@end smallexample

In addition, in each circuit of the outer loop, Emacs should record
the number of definitions within that range (the value of
@code{number-within-range}) in a list.  We can use @code{cons} for
this purpose.  (@xref{cons, , @code{cons}}.)

The @code{cons} function works fine, except that the list it
constructs will contain the number of definitions for the highest
range at its beginning and the number of definitions for the lowest
range at its end.  This is because @code{cons} attaches new elements
of the list to the beginning of the list, and since the two loops are
working their way through the lengths' list from the lower end first,
the @code{defuns-per-range-list} will end up largest number first.
But we will want to print our graph with smallest values first and the
larger later.  The solution is to reverse the order of the
@code{defuns-per-range-list}.  We can do this using the
@code{nreverse} function, which reverses the order of a list.
@findex nreverse

@need 800
For example,

@smallexample
(nreverse '(1 2 3 4))
@end smallexample

@need 800
@noindent
produces:

@smallexample
(4 3 2 1)
@end smallexample

Note that the @code{nreverse} function is destructive---that is,
it changes the list to which it is applied; this contrasts with the
@code{car} and @code{cdr} functions, which are non-destructive.  In
this case, we do not want the original @code{defuns-per-range-list},
so it does not matter that it is destroyed.  (The @code{reverse}
function provides a reversed copy of a list, leaving the original list
as is.)
@findex reverse

@need 1250
Put all together, the @code{defuns-per-range} looks like this:

@smallexample
@group
(defun defuns-per-range (sorted-lengths top-of-ranges)
  "SORTED-LENGTHS defuns in each TOP-OF-RANGES range."
  (let ((top-of-range (car top-of-ranges))
        (number-within-range 0)
        defuns-per-range-list)
@end group

@group
    ;; @r{Outer loop.}
    (while top-of-ranges
@end group

@group
      ;; @r{Inner loop.}
      (while (and
              ;; @r{Need number for numeric test.}
              (car sorted-lengths)
              (< (car sorted-lengths) top-of-range))
@end group

@group
        ;; @r{Count number of definitions within current range.}
        (setq number-within-range (1+ number-within-range))
        (setq sorted-lengths (cdr sorted-lengths)))

      ;; @r{Exit inner loop but remain within outer loop.}
@end group

@group
      (setq defuns-per-range-list
            (cons number-within-range defuns-per-range-list))
      (setq number-within-range 0)      ; @r{Reset count to zero.}
@end group

@group
      ;; @r{Move to next range.}
      (setq top-of-ranges (cdr top-of-ranges))
      ;; @r{Specify next top of range value.}
      (setq top-of-range (car top-of-ranges)))
@end group

@group
    ;; @r{Exit outer loop and count the number of defuns larger than}
    ;; @r{  the largest top-of-range value.}
    (setq defuns-per-range-list
          (cons
           (length sorted-lengths)
           defuns-per-range-list))
@end group

@group
    ;; @r{Return a list of the number of definitions within each range,}
    ;; @r{  smallest to largest.}
    (nreverse defuns-per-range-list)))
@end group
@end smallexample

@need 1200
@noindent
The function is straightforward except for one subtle feature.  The
true-or-false test of the inner loop looks like this:

@smallexample
@group
(and (car sorted-lengths)
     (< (car sorted-lengths) top-of-range))
@end group
@end smallexample

@need 800
@noindent
instead of like this:

@smallexample
(< (car sorted-lengths) top-of-range)
@end smallexample

The purpose of the test is to determine whether the first item in the
@code{sorted-lengths} list is less than the value of the top of the
range.

The simple version of the test works fine unless the
@code{sorted-lengths} list has a @code{nil} value.  In that case, the
@code{(car sorted-lengths)} expression function returns
@code{nil}.  The @code{<} function cannot compare a number to
@code{nil}, which is an empty list, so Emacs signals an error and
stops the function from attempting to continue to execute.

The @code{sorted-lengths} list always becomes @code{nil} when the
counter reaches the end of the list.  This means that any attempt to
use the @code{defuns-per-range} function with the simple version of
the test will fail.

We solve the problem by using the @code{(car sorted-lengths)}
expression in conjunction with the @code{and} expression.  The
@code{(car sorted-lengths)} expression returns a non-@code{nil}
value so long as the list has at least one number within it, but
returns @code{nil} if the list is empty.  The @code{and} expression
first evaluates the @code{(car sorted-lengths)} expression, and
if it is @code{nil}, returns false @emph{without} evaluating the
@code{<} expression.  But if the @code{(car sorted-lengths)}
expression returns a non-@code{nil} value, the @code{and} expression
evaluates the @code{<} expression, and returns that value as the value
of the @code{and} expression.

@c colon in printed section title causes problem in Info cross reference
This way, we avoid an error.
@iftex
@noindent
(For information about @code{and}, see
@ref{kill-new function, , The @code{kill-new} function}.)
@end iftex
@ifinfo
@noindent
(@xref{kill-new function, , The @code{kill-new} function}, for
information about @code{and}.)
@end ifinfo

Here is a short test of the @code{defuns-per-range} function.  First,
evaluate the expression that binds (a shortened)
@code{top-of-ranges} list to the list of values, then evaluate the
expression for binding the @code{sorted-lengths} list, and then
evaluate the @code{defuns-per-range} function.

@smallexample
@group
;; @r{(Shorter list than we will use later.)}
(setq top-of-ranges
 '(110 120 130 140 150
   160 170 180 190 200))

(setq sorted-lengths
      '(85 86 110 116 122 129 154 176 179 200 265 300 300))

(defuns-per-range sorted-lengths top-of-ranges)
@end group
@end smallexample

@need 800
@noindent
The list returned looks like this:

@smallexample
(2 2 2 0 0 1 0 2 0 0 4)
@end smallexample

@noindent
Indeed, there are two elements of the @code{sorted-lengths} list
smaller than 110, two elements between 110 and 119, two elements
between 120 and 129, and so on.  There are four elements with a value
of 200 or larger.

@c The next step is to turn this numbers' list into a graph.
@node Readying a Graph
@chapter Readying a Graph
@cindex Readying a graph
@cindex Graph prototype
@cindex Prototype graph
@cindex Body of graph

Our goal is to construct a graph showing the numbers of function
definitions of various lengths in the Emacs lisp sources.

As a practical matter, if you were creating a graph, you would
probably use a program such as @code{gnuplot} to do the job.
(@code{gnuplot} is nicely integrated into GNU Emacs.)  In this case,
however, we create one from scratch, and in the process we will
re-acquaint ourselves with some of what we learned before and learn
more.

In this chapter, we will first write a simple graph printing function.
This first definition will be a @dfn{prototype}, a rapidly written
function that enables us to reconnoiter this unknown graph-making
territory.  We will discover dragons, or find that they are myth.
After scouting the terrain, we will feel more confident and enhance
the function to label the axes automatically.

@menu
* Columns of a graph::
* graph-body-print::            How to print the body of a graph.
* recursive-graph-body-print::
* Printed Axes::
* Line Graph Exercise::
@end menu

@ifnottex
@node Columns of a graph
@unnumberedsec Printing the Columns of a Graph
@end ifnottex

Since Emacs is designed to be flexible and work with all kinds of
terminals, including character-only terminals, the graph will need to
be made from one of the typewriter symbols.  An asterisk will do; as
we enhance the graph-printing function, we can make the choice of
symbol a user option.

We can call this function @code{graph-body-print}; it will take a
@code{numbers-list} as its only argument.  At this stage, we will not
label the graph, but only print its body.

The @code{graph-body-print} function inserts a vertical column of
asterisks for each element in the @code{numbers-list}.  The height of
each line is determined by the value of that element of the
@code{numbers-list}.

Inserting columns is a repetitive act; that means that this function can
be written either with a @code{while} loop or recursively.

Our first challenge is to discover how to print a column of asterisks.
Usually, in Emacs, we print characters onto a screen horizontally,
line by line, by typing.  We have two routes we can follow: write our
own column-insertion function or discover whether one exists in Emacs.

To see whether there is one in Emacs, we can use the @kbd{M-x apropos}
command.  This command is like the @kbd{C-h a} (@code{command-apropos})
command, except that the latter finds only those functions that are
commands.  The @kbd{M-x apropos} command lists all symbols that match
a regular expression, including functions that are not interactive.
@findex apropos

What we want to look for is some command that prints or inserts
columns.  Very likely, the name of the function will contain either
the word ``print'' or the word ``insert'' or the word ``column''.
Therefore, we can simply type @kbd{M-x apropos @key{RET}
print\|insert\|column @key{RET}} and look at the result.  On my system, this
command once took quite some time, and then produced a list of 79
functions and variables.  Now it does not take much time at all and
produces a list of 211 functions and variables.  Scanning down the
list, the only function that looks as if it might do the job is
@code{insert-rectangle}.

@need 1200
Indeed, this is the function we want; its documentation says:

@smallexample
@group
insert-rectangle:
Insert text of RECTANGLE with upper left corner at point.
RECTANGLE's first line is inserted at point,
its second line is inserted at a point vertically under point, etc.
RECTANGLE should be a list of strings.
After this command, the mark is at the upper left corner
and point is at the lower right corner.
@end group
@end smallexample

We can run a quick test, to make sure it does what we expect of it.

Here is the result of placing the cursor after the
@code{insert-rectangle} expression and typing @kbd{C-u C-x C-e}
(@code{eval-last-sexp}).  The function inserts the strings
@samp{"first"}, @samp{"second"}, and @samp{"third"} at and below
point.  Also the function returns @code{nil}.

@smallexample
@group
(insert-rectangle '("first" "second" "third"))first
                                              second
                                              thirdnil
@end group
@end smallexample

@noindent
Of course, we won't be inserting the text of the
@code{insert-rectangle} expression itself into the buffer in which we
are making the graph, but will call the function from our program.  We
shall, however, have to make sure that point is in the buffer at the
place where the @code{insert-rectangle} function will insert its
column of strings.

If you are reading this in Info, you can see how this works by
switching to another buffer, such as the @file{*scratch*} buffer,
placing point somewhere in the buffer, typing @kbd{M-:}, typing the
@code{insert-rectangle} expression into the minibuffer at the prompt,
and then typing @key{RET}.  This causes Emacs to evaluate the
expression in the minibuffer, but to use as the value of point the
position of point in the @file{*scratch*} buffer.  (@kbd{M-:}  is the
key binding for @code{eval-expression}. Also, @code{nil} does not
appear in the @file{*scratch*} buffer since the expression is
evaluated in the minibuffer.)

We find when we do this that point ends up at the end of the last
inserted line---that is to say, this function moves point as a
side-effect.  If we were to repeat the command, with point at this
position, the next insertion would be below and to the right of the
previous insertion.  We don't want this!  If we are going to make a
bar graph, the columns need to be beside each other.

So we discover that each cycle of the column-inserting @code{while}
loop must reposition point to the place we want it, and that place
will be at the top, not the bottom, of the column.  Moreover, we
remember that when we print a graph, we do not expect all the columns
to be the same height.  This means that the top of each column may be
at a different height from the previous one.  We cannot simply
reposition point to the same line each time, but moved over to the
right---or perhaps we can@dots{}

We are planning to make the columns of the bar graph out of asterisks.
The number of asterisks in the column is the number specified by the
current element of the @code{numbers-list}.  We need to construct a
list of asterisks of the right length for each call to
@code{insert-rectangle}.  If this list consists solely of the requisite
number of asterisks, then we will have to position point the right number
of lines above the base for the graph to print correctly.  This could
be difficult.

Alternatively, if we can figure out some way to pass
@code{insert-rectangle} a list of the same length each time, then we
can place point on the same line each time, but move it over one
column to the right for each new column.  If we do this, however, some
of the entries in the list passed to @code{insert-rectangle} must be
blanks rather than asterisks.  For example, if the maximum height of
the graph is 5, but the height of the column is 3, then
@code{insert-rectangle} requires an argument that looks like this:

@smallexample
(" " " " "*" "*" "*")
@end smallexample

This last proposal is not so difficult, so long as we can determine
the column height.  There are two ways for us to specify the column
height: we can arbitrarily state what it will be, which would work
fine for graphs of that height; or we can search through the list of
numbers and use the maximum height of the list as the maximum height
of the graph.  If the latter operation were difficult, then the former
procedure would be easiest, but there is a function built into Emacs
that determines the maximum of its arguments.  We can use that
function.  The function is called @code{max} and it returns the
largest of all its arguments, which must be numbers.  Thus, for
example,

@smallexample
(max  3 4 6 5 7 3)
@end smallexample

@noindent
returns 7.  (A corresponding function called @code{min} returns the
smallest of all its arguments.)
@findex max
@findex min

However, we cannot simply call @code{max} on the @code{numbers-list};
the @code{max} function expects numbers as its argument, not a list of
numbers.  Thus, the following expression,

@smallexample
(max  '(3 4 6 5 7 3))
@end smallexample

@need 800
@noindent
produces the following error message;

@smallexample
Wrong type of argument:  number-or-marker-p, (3 4 6 5 7 3)
@end smallexample

@findex apply
We need a function that passes a list of arguments to a function.
This function is @code{apply}.  This function applies its first
argument (a function) to its remaining arguments, the last of which
may be a list.

@need 1250
For example,

@smallexample
(apply 'max 3 4 7 3 '(4 8 5))
@end smallexample

@noindent
returns 8.

(Incidentally, I don't know how you would learn of this function
without a book such as this.  It is possible to discover other
functions, like @code{search-forward} or @code{insert-rectangle}, by
guessing at a part of their names and then using @code{apropos}.  Even
though its base in metaphor is clear---apply its first argument to
the rest---I doubt a novice would come up with that particular word
when using @code{apropos} or other aid.  Of course, I could be wrong;
after all, the function was first named by someone who had to invent
it.)

The second and subsequent arguments to @code{apply} are optional, so
we can use @code{apply} to call a function and pass the elements of a
list to it, like this, which also returns 8:

@smallexample
(apply 'max '(4 8 5))
@end smallexample

This latter way is how we will use @code{apply}.  The
@code{recursive-lengths-list-many-files} function returns a numbers'
list to which we can apply @code{max} (we could also apply @code{max} to
the sorted numbers' list; it does not matter whether the list is
sorted or not.)

@need 800
Hence, the operation for finding the maximum height of the graph is this:

@smallexample
(setq max-graph-height (apply 'max numbers-list))
@end smallexample

Now we can return to the question of how to create a list of strings
for a column of the graph.  Told the maximum height of the graph
and the number of asterisks that should appear in the column, the
function should return a list of strings for the
@code{insert-rectangle} command to insert.

Each column is made up of asterisks or blanks.  Since the function is
passed the value of the height of the column and the number of
asterisks in the column, the number of blanks can be found by
subtracting the number of asterisks from the height of the column.
Given the number of blanks and the number of asterisks, two
@code{while} loops can be used to construct the list:

@smallexample
@group
;;; @r{First version.}
(defun column-of-graph (max-graph-height actual-height)
  "Return list of strings that is one column of a graph."
  (let ((insert-list nil)
        (number-of-top-blanks
         (- max-graph-height actual-height)))
@end group

@group
    ;; @r{Fill in asterisks.}
    (while (> actual-height 0)
      (setq insert-list (cons "*" insert-list))
      (setq actual-height (1- actual-height)))
@end group

@group
    ;; @r{Fill in blanks.}
    (while (> number-of-top-blanks 0)
      (setq insert-list (cons " " insert-list))
      (setq number-of-top-blanks
            (1- number-of-top-blanks)))
@end group

@group
    ;; @r{Return whole list.}
    insert-list))
@end group
@end smallexample

If you install this function and then evaluate the following
expression you will see that it returns the list as desired:

@smallexample
(column-of-graph 5 3)
@end smallexample

@need 800
@noindent
returns

@smallexample
(" " " " "*" "*" "*")
@end smallexample

As written, @code{column-of-graph} contains a major flaw: the symbols
used for the blank and for the marked entries in the column are
hard-coded as a space and asterisk.  This is fine for a prototype,
but you, or another user, may wish to use other symbols.  For example,
in testing the graph function, you may want to use a period in place
of the space, to make sure the point is being repositioned properly
each time the @code{insert-rectangle} function is called; or you might
want to substitute a @samp{+} sign or other symbol for the asterisk.
You might even want to make a graph-column that is more than one
display column wide.  The program should be more flexible.  The way to
do that is to replace the blank and the asterisk with two variables
that we can call @code{graph-blank} and @code{graph-symbol} and define
those variables separately.

Also, the documentation is not well written.  These considerations
lead us to the second version of the function:

@smallexample
@group
(defvar graph-symbol "*"
  "String used as symbol in graph, usually an asterisk.")
@end group

@group
(defvar graph-blank " "
  "String used as blank in graph, usually a blank space.
graph-blank must be the same number of columns wide
as graph-symbol.")
@end group
@end smallexample

@noindent
(For an explanation of @code{defvar}, see
@ref{defvar, , Initializing a Variable with @code{defvar}}.)

@smallexample
@group
;;; @r{Second version.}
(defun column-of-graph (max-graph-height actual-height)
  "Return MAX-GRAPH-HEIGHT strings; ACTUAL-HEIGHT are graph-symbols.

@end group
@group
The graph-symbols are contiguous entries at the end
of the list.
The list will be inserted as one column of a graph.
The strings are either graph-blank or graph-symbol."
@end group

@group
  (let ((insert-list nil)
        (number-of-top-blanks
         (- max-graph-height actual-height)))
@end group

@group
    ;; @r{Fill in @code{graph-symbols}.}
    (while (> actual-height 0)
      (setq insert-list (cons graph-symbol insert-list))
      (setq actual-height (1- actual-height)))
@end group

@group
    ;; @r{Fill in @code{graph-blanks}.}
    (while (> number-of-top-blanks 0)
      (setq insert-list (cons graph-blank insert-list))
      (setq number-of-top-blanks
            (1- number-of-top-blanks)))

    ;; @r{Return whole list.}
    insert-list))
@end group
@end smallexample

If we wished, we could rewrite @code{column-of-graph} a third time to
provide optionally for a line graph as well as for a bar graph.  This
would not be hard to do.  One way to think of a line graph is that it
is no more than a bar graph in which the part of each bar that is
below the top is blank.  To construct a column for a line graph, the
function first constructs a list of blanks that is one shorter than
the value, then it uses @code{cons} to attach a graph symbol to the
list; then it uses @code{cons} again to attach the top blanks to
the list.

It is easy to see how to write such a function, but since we don't
need it, we will not do it.  But the job could be done, and if it were
done, it would be done with @code{column-of-graph}.  Even more
important, it is worth noting that few changes would have to be made
anywhere else.  The enhancement, if we ever wish to make it, is
simple.

Now, finally, we come to our first actual graph printing function.
This prints the body of a graph, not the labels for the vertical and
horizontal axes, so we can call this @code{graph-body-print}.

@node graph-body-print
@section The @code{graph-body-print} Function
@findex graph-body-print

After our preparation in the preceding section, the
@code{graph-body-print} function is straightforward.  The function
will print column after column of asterisks and blanks, using the
elements of a numbers' list to specify the number of asterisks in each
column.  This is a repetitive act, which means we can use a
decrementing @code{while} loop or recursive function for the job.  In
this section, we will write the definition using a @code{while} loop.

The @code{column-of-graph} function requires the height of the graph
as an argument, so we should determine and record that as a local variable.

This leads us to the following template for the @code{while} loop
version of this function:

@smallexample
@group
(defun graph-body-print (numbers-list)
  "@var{documentation}@dots{}"
  (let ((height  @dots{}
         @dots{}))
@end group

@group
    (while numbers-list
      @var{insert-columns-and-reposition-point}
      (setq numbers-list (cdr numbers-list)))))
@end group
@end smallexample

@noindent
We need to fill in the slots of the template.

Clearly, we can use the @code{(apply 'max numbers-list)} expression to
determine the height of the graph.

The @code{while} loop will cycle through the @code{numbers-list} one
element at a time.  As it is shortened by the @code{(setq numbers-list
(cdr numbers-list))} expression, the @sc{car} of each instance of the
list is the value of the argument for @code{column-of-graph}.

At each cycle of the @code{while} loop, the @code{insert-rectangle}
function inserts the list returned by @code{column-of-graph}.  Since
the @code{insert-rectangle} function moves point to the lower right of
the inserted rectangle, we need to save the location of point at the
time the rectangle is inserted, move back to that position after the
rectangle is inserted, and then move horizontally to the next place
from which @code{insert-rectangle} is called.

If the inserted columns are one character wide, as they will be if
single blanks and asterisks are used, the repositioning command is
simply @code{(forward-char 1)}; however, the width of a column may be
greater than one.  This means that the repositioning command should be
written @code{(forward-char symbol-width)}.  The @code{symbol-width}
itself is the length of a @code{graph-blank} and can be found using
the expression @code{(length graph-blank)}.  The best place to bind
the @code{symbol-width} variable to the value of the width of graph
column is in the varlist of the @code{let} expression.

@need 1250
These considerations lead to the following function definition:

@smallexample
@group
(defun graph-body-print (numbers-list)
  "Print a bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values."

  (let ((height (apply 'max numbers-list))
        (symbol-width (length graph-blank))
        from-position)
@end group

@group
    (while numbers-list
      (setq from-position (point))
      (insert-rectangle
       (column-of-graph height (car numbers-list)))
      (goto-char from-position)
      (forward-char symbol-width)
@end group
@group
      ;; @r{Draw graph column by column.}
      (sit-for 0)
      (setq numbers-list (cdr numbers-list)))
@end group
@group
    ;; @r{Place point for X axis labels.}
    (forward-line height)
    (insert "\n")
))
@end group
@end smallexample

@noindent
The one unexpected expression in this function is the
@w{@code{(sit-for 0)}} expression in the @code{while} loop.  This
expression makes the graph printing operation more interesting to
watch than it would be otherwise.  The expression causes Emacs to
@dfn{sit} or do nothing for a zero length of time and then redraw the
screen.  Placed here, it causes Emacs to redraw the screen column by
column.  Without it, Emacs would not redraw the screen until the
function exits.

We can test @code{graph-body-print} with a short list of numbers.

@enumerate
@item
Install @code{graph-symbol}, @code{graph-blank},
@code{column-of-graph}, which are in
@iftex
@ref{Readying a Graph, , Readying a Graph},
@end iftex
@ifnottex
@ref{Columns of a graph},
@end ifnottex
and @code{graph-body-print}.

@need 800
@item
Copy the following expression:

@smallexample
(graph-body-print '(1 2 3 4 6 4 3 5 7 6 5 2 3))
@end smallexample

@item
Switch to the @file{*scratch*} buffer and place the cursor where you
want the graph to start.

@item
Type @kbd{M-:} (@code{eval-expression}).

@item
Yank the @code{graph-body-print} expression into the minibuffer
with @kbd{C-y} (@code{yank)}.

@item
Press @key{RET} to evaluate the @code{graph-body-print} expression.
@end enumerate

@need 800
Emacs will print a graph like this:

@smallexample
@group
                    *
                *   **
                *  ****
               *** ****
              ********* *
             ************
            *************
@end group
@end smallexample

@node recursive-graph-body-print
@section The @code{recursive-graph-body-print} Function
@findex recursive-graph-body-print

The @code{graph-body-print} function may also be written recursively.
The recursive solution is divided into two parts: an outside wrapper
that uses a @code{let} expression to determine the values of several
variables that need only be found once, such as the maximum height of
the graph, and an inside function that is called recursively to print
the graph.

@need 1250
The wrapper is uncomplicated:

@smallexample
@group
(defun recursive-graph-body-print (numbers-list)
  "Print a bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values."
  (let ((height (apply 'max numbers-list))
        (symbol-width (length graph-blank))
        from-position)
    (recursive-graph-body-print-internal
     numbers-list
     height
     symbol-width)))
@end group
@end smallexample

The recursive function is a little more difficult.  It has four parts:
the do-again-test, the printing code, the recursive call, and the
next-step-expression.  The do-again-test is a @code{when}
expression that determines whether the @code{numbers-list} contains
any remaining elements; if it does, the function prints one column of
the graph using the printing code and calls itself again.  The
function calls itself again according to the value produced by the
next-step-expression which causes the call to act on a shorter
version of the @code{numbers-list}.

@smallexample
@group
(defun recursive-graph-body-print-internal
  (numbers-list height symbol-width)
  "Print a bar graph.
Used within recursive-graph-body-print function."
@end group

@group
  (when numbers-list
        (setq from-position (point))
        (insert-rectangle
         (column-of-graph height (car numbers-list)))
@end group
@group
        (goto-char from-position)
        (forward-char symbol-width)
        (sit-for 0)     ; @r{Draw graph column by column.}
        (recursive-graph-body-print-internal
         (cdr numbers-list) height symbol-width)))
@end group
@end smallexample

@need 1250
After installation, this expression can be tested; here is a sample:

@smallexample
(recursive-graph-body-print '(3 2 5 6 7 5 3 4 6 4 3 2 1))
@end smallexample

@need 800
Here is what @code{recursive-graph-body-print} produces:

@smallexample
@group
                *
               **   *
              ****  *
              **** ***
            * *********
            ************
            *************
@end group
@end smallexample

Either of these two functions, @code{graph-body-print} or
@code{recursive-graph-body-print}, create the body of a graph.

@node Printed Axes
@section Need for Printed Axes

A graph needs printed axes, so you can orient yourself.  For a do-once
project, it may be reasonable to draw the axes by hand using Emacs's
Picture mode; but a graph drawing function may be used more than once.

For this reason, I have written enhancements to the basic
@code{print-graph-body} function that automatically print labels for
the horizontal and vertical axes.  Since the label printing functions
do not contain much new material, I have placed their description in
an appendix.  @xref{Full Graph, , A Graph with Labeled Axes}.

@node Line Graph Exercise
@section Exercise

Write a line graph version of the graph printing functions.

@node Emacs Initialization
@chapter Your @file{.emacs} File
@cindex @file{.emacs} file
@cindex Customizing your @file{.emacs} file
@cindex Initialization file

``You don't have to like Emacs to like it''---this seemingly
paradoxical statement is the secret of GNU Emacs.  The plain, out-of-the-box
Emacs is a generic tool.  Most people who use it customize
it to suit themselves.

GNU Emacs is mostly written in Emacs Lisp; this means that by writing
expressions in Emacs Lisp you can change or extend Emacs.

@menu
* Default Configuration::
* Site-wide Init::              You can write site-wide init files.
* defcustom::                   Emacs will write code for you.
* Beginning init File::         How to write a @file{.emacs} init file.
* Text and Auto-fill::          Automatically wrap lines.
* Mail Aliases::                Use abbreviations for email addresses.
* Indent Tabs Mode::            Don't use tabs with @TeX{}
* Key Bindings::                Create some personal key bindings.
* Keymaps::                     More about key binding.
* Loading Files::               Load (i.e., evaluate) files automatically.
* Autoload::                    Make functions available.
* Simple Extension::            Define a function; bind it to a key.
* X11 Colors::                  Colors in X.
* Miscellaneous::
* Mode Line::                   How to customize your mode line.
@end menu

@ifnottex
@node Default Configuration
@unnumberedsec Emacs's Default Configuration
@end ifnottex

There are those who appreciate Emacs's default configuration.  After
all, Emacs starts you in C mode when you edit a C file, starts you in
Fortran mode when you edit a Fortran file, and starts you in
Fundamental mode when you edit an unadorned file.  This all makes
sense, if you do not know who is going to use Emacs.  Who knows what a
person hopes to do with an unadorned file?  Fundamental mode is the
right default for such a file, just as C mode is the right default for
editing C code.  (Enough programming languages have syntaxes
that enable them to share or nearly share features, so C mode is
now provided by CC mode, the C Collection.)

But when you do know who is going to use Emacs---you,
yourself---then it makes sense to customize Emacs.

For example, I seldom want Fundamental mode when I edit an
otherwise undistinguished file; I want Text mode.  This is why I
customize Emacs: so it suits me.

You can customize and extend Emacs by writing or adapting a
@file{~/.emacs} file.  This is your personal initialization file; its
contents, written in Emacs Lisp, tell Emacs what to do.@footnote{You
may also add @file{.el} to @file{~/.emacs} and call it a
@file{~/.emacs.el} file.  In the past, you were forbidden to type the
extra keystrokes that the name @file{~/.emacs.el} requires, but now
you may.  The new format is consistent with the Emacs Lisp file
naming conventions; the old format saves typing.}

A @file{~/.emacs} file contains Emacs Lisp code.  You can write this
code yourself; or you can use Emacs's @code{customize} feature to write
the code for you.  You can combine your own expressions and
auto-written Customize expressions in your @file{.emacs} file.

(I myself prefer to write my own expressions, except for those,
particularly fonts, that I find easier to manipulate using the
@code{customize} command.  I combine the two methods.)

Most of this chapter is about writing expressions yourself.  It
describes a simple @file{.emacs} file; for more information, see
@ref{Init File, , The Init File, emacs, The GNU Emacs Manual}, and
@ref{Init File, , The Init File, elisp, The GNU Emacs Lisp Reference
Manual}.

@node Site-wide Init
@section Site-wide Initialization Files

@cindex @file{default.el} init file
@cindex @file{site-init.el} init file
@cindex @file{site-load.el} init file
In addition to your personal initialization file, Emacs automatically
loads various site-wide initialization files, if they exist.  These
have the same form as your @file{.emacs} file, but are loaded by
everyone.

Two site-wide initialization files, @file{site-load.el} and
@file{site-init.el}, are loaded into Emacs and then dumped if a
dumped version of Emacs is created, as is most common.  (Dumped
copies of Emacs load more quickly.  However, once a file is loaded and
dumped, a change to it does not lead to a change in Emacs unless you
load it yourself or re-dump Emacs.  @xref{Building Emacs, , Building
Emacs, elisp, The GNU Emacs Lisp Reference Manual}, and the
@file{INSTALL} file.)

Three other site-wide initialization files are loaded automatically
each time you start Emacs, if they exist.  These are
@file{site-start.el}, which is loaded @emph{before} your @file{.emacs}
file, and @file{default.el}, and the terminal type file, which are both
loaded @emph{after} your @file{.emacs} file.

Settings and definitions in your @file{.emacs} file will overwrite
conflicting settings and definitions in a @file{site-start.el} file,
if it exists; but the settings and definitions in a @file{default.el}
or terminal type file will overwrite those in your @file{.emacs} file.
(You can prevent interference from a terminal type file by setting
@code{term-file-prefix} to @code{nil}.  @xref{Simple Extension, , A
Simple Extension}.)

@c Rewritten to avoid overfull hbox.
The @file{INSTALL} file that comes in the distribution contains
descriptions of the @file{site-init.el} and @file{site-load.el} files.

The @file{loadup.el}, @file{startup.el}, and @file{loaddefs.el} files
control loading.  These files are in the @file{lisp} directory of the
Emacs distribution and are worth perusing.

The @file{loaddefs.el} file contains a good many suggestions as to
what to put into your own @file{.emacs} file, or into a site-wide
initialization file.

@node defcustom
@section Specifying Variables using @code{defcustom}
@findex defcustom

You can specify variables using @code{defcustom} so that you and
others can then use Emacs's @code{customize} feature to set their
values.  (You cannot use @code{customize} to write function
definitions; but you can write @code{defuns} in your @file{.emacs}
file.  Indeed, you can write any Lisp expression in your @file{.emacs}
file.)

The @code{customize} feature depends on the @code{defcustom} macro.
Although you can use @code{defvar} or @code{setq} for variables that
users set, the @code{defcustom} macro is designed for the job.

You can use your knowledge of @code{defvar} for writing the
first three arguments for @code{defcustom}.  The first argument to
@code{defcustom} is the name of the variable.  The second argument is
the variable's initial value, if any; and this value is set only if
the value has not already been set.  The third argument is the
documentation.

The fourth and subsequent arguments to @code{defcustom} specify types
and options; these are not featured in @code{defvar}.  (These
arguments are optional.)

Each of these arguments consists of a keyword followed by a value.
Each keyword starts with the colon character @samp{:}.

@need 1250
For example, the customizable user option variable
@code{text-mode-hook} looks like this:

@smallexample
@group
(defcustom text-mode-hook nil
  "Normal hook run when entering Text mode and many related modes."
  :type 'hook
  :options '(turn-on-auto-fill flyspell-mode)
  :group 'wp)
@end group
@end smallexample

@noindent
The name of the variable is @code{text-mode-hook}; it has no default
value; and its documentation string tells you what it does.

The @code{:type} keyword tells Emacs the kind of data to which
@code{text-mode-hook} should be set and how to display the value in a
Customization buffer.

The @code{:options} keyword specifies a suggested list of values for
the variable.  Usually, @code{:options} applies to a hook.
The list is only a suggestion; it is not exclusive; a person who sets
the variable may set it to other values; the list shown following the
@code{:options} keyword is intended to offer convenient choices to a
user.

Finally, the @code{:group} keyword tells the Emacs Customization
command in which group the variable is located.  This tells where to
find it.

The @code{defcustom} macro recognizes more than a dozen keywords.
For more information, see @ref{Customization, , Writing Customization
Definitions, elisp, The GNU Emacs Lisp Reference Manual}.

Consider @code{text-mode-hook} as an example.

There are two ways to customize this variable.  You can use the
customization command or write the appropriate expressions yourself.

@need 800
Using the customization command,  you can type:

@smallexample
M-x customize
@end smallexample

@noindent
and find that the group for editing files of text is called ``Text''.
Enter that group.  Text Mode Hook is the first member.  You can click
on its various options, such as @code{turn-on-auto-fill}, to set the
values.  After you click on the button to

@smallexample
Save for Future Sessions
@end smallexample

@noindent
Emacs will write an expression into your @file{.emacs} file.
It will look like this:

@smallexample
@group
(custom-set-variables
  ;; custom-set-variables was added by Custom.
  ;; If you edit it by hand, you could mess it up, so be careful.
  ;; Your init file should contain only one such instance.
  ;; If there is more than one, they won't work right.
 '(text-mode-hook '(turn-on-auto-fill text-mode-hook-identify)))
@end group
@end smallexample

@noindent
(The @code{text-mode-hook-identify} function tells
@code{toggle-text-mode-auto-fill} which buffers are in Text mode.
It comes on automatically.)

The @code{custom-set-variables} function works somewhat differently
than a @code{setq}.  While I have never learned the differences, I
modify the @code{custom-set-variables} expressions in my @file{.emacs}
file by hand:  I make the changes in what appears to me to be a
reasonable manner and have not had any problems.  Others prefer to use
the Customization command and let Emacs do the work for them.

Another @code{custom-set-@dots{}} function is @code{custom-set-faces}.
This function sets the various font faces.  Over time, I have set a
considerable number of faces.  Some of the time, I re-set them using
@code{customize}; other times, I simply edit the
@code{custom-set-faces} expression in my @file{.emacs} file itself.

The second way to customize your @code{text-mode-hook} is to set it
yourself in your @file{.emacs} file using code that has nothing to do
with the @code{custom-set-@dots{}} functions.

@need 800
When you do this, and later use @code{customize}, you will see a
message that says

@smallexample
CHANGED outside Customize; operating on it here may be unreliable.
@end smallexample

@need 800
This message is only a warning.  If you click on the button to

@smallexample
Save for Future Sessions
@end smallexample

@noindent
Emacs will write a @code{custom-set-@dots{}} expression near the end
of your @file{.emacs} file that will be evaluated after your
hand-written expression.  It will, therefore, overrule your
hand-written expression.  No harm will be done.  When you do this,
however, be careful to remember which expression is active; if you
forget, you may confuse yourself.

So long as you remember where the values are set, you will have no
trouble.  In any event, the values are always set in your
initialization file, which is usually called @file{.emacs}.

I myself use @code{customize} for hardly anything.  Mostly, I write
expressions myself.

@findex defsubst
@findex defconst
Incidentally, to be more complete concerning defines:  @code{defsubst}
defines an inline function.  The syntax is just like that of
@code{defun}.  @code{defconst} defines a symbol as a constant.  The
intent is that neither programs nor users should ever change a value
set by @code{defconst}.  (You can change it; the value set is a
variable; but please do not.)

@node Beginning init File
@section Beginning a @file{.emacs} File
@cindex @file{.emacs} file, beginning of

When you start Emacs, it loads your @file{.emacs} file unless you tell
it not to by specifying @samp{-q} on the command line.  (The
@code{emacs -q} command gives you a plain, out-of-the-box Emacs.)

A @file{.emacs} file contains Lisp expressions.  Often, these are no
more than expressions to set values; sometimes they are function
definitions.

@xref{Init File, , The Init File @file{~/.emacs}, emacs, The GNU Emacs
Manual}, for a short description of initialization files.

This chapter goes over some of the same ground, but is a walk among
extracts from a complete, long-used @file{.emacs} file---my own.

The first part of the file consists of comments: reminders to myself.
By now, of course, I remember these things, but when I started, I did
not.

@need 1200
@smallexample
@group
;;;; Bob's .emacs file
; Robert J. Chassell
; 26 September 1985
@end group
@end smallexample

@noindent
Look at that date!  I started this file a long time ago.  I have been
adding to it ever since.

@smallexample
@group
; Each section in this file is introduced by a
; line beginning with four semicolons; and each
; entry is introduced by a line beginning with
; three semicolons.
@end group
@end smallexample

@noindent
This describes the usual conventions for comments in Emacs Lisp.
Everything on a line that follows a semicolon is a comment.  Two,
three, and four semicolons are used as subsection and section markers.
(@xref{Comments, ,, elisp, The GNU Emacs Lisp Reference Manual}, for
more about comments.)

@smallexample
@group
;;;; The Help Key
; Control-h is the help key;
; after typing control-h, type a letter to
; indicate the subject about which you want help.
; For an explanation of the help facility,
; type control-h two times in a row.
@end group
@end smallexample

@noindent
Just remember: type @kbd{C-h} two times for help.

@smallexample
@group
; To find out about any mode, type control-h m
; while in that mode.  For example, to find out
; about mail mode, enter mail mode and then type
; control-h m.
@end group
@end smallexample

@noindent
``Mode help'', as I call this, is very helpful.  Usually, it tells you
all you need to know.

Of course, you don't need to include comments like these in your
@file{.emacs} file.  I included them in mine because I kept forgetting
about Mode help or the conventions for comments---but I was able to
remember to look here to remind myself.

@node Text and Auto-fill
@section Text and Auto Fill Mode

Now we come to the part that turns on Text mode and
Auto Fill mode.

@smallexample
@group
;;; Text mode and Auto Fill mode
;; The next two lines put Emacs into Text mode
;; and Auto Fill mode, and are for writers who
;; want to start writing prose rather than code.
(setq-default major-mode 'text-mode)
(add-hook 'text-mode-hook 'turn-on-auto-fill)
@end group
@end smallexample

Here is the first part of this @file{.emacs} file that does something
besides remind a forgetful human!

The first of the two lines in parentheses tells Emacs to turn on Text
mode when you find a file, @emph{unless} that file should go into some
other mode, such as C mode.

@cindex Per-buffer, local variables list
@cindex Local variables list, per-buffer,
@cindex Automatic mode selection
@cindex Mode selection, automatic
When Emacs reads a file, it looks at the extension to the file name,
if any.  (The extension is the part that comes after a @samp{.}.)  If
the file ends with a @samp{.c} or @samp{.h} extension then Emacs turns
on C mode.  Also, Emacs looks at first nonblank line of the file; if
the line says @w{@samp{-*- C -*-}}, Emacs turns on C mode.  Emacs
possesses a list of extensions and specifications that it uses
automatically.  In addition, Emacs looks near the last page for a
per-buffer, local variables list, if any.

@ifinfo
@xref{Choosing Modes, , How Major Modes are Chosen, emacs, The GNU
Emacs Manual}.

@xref{File Variables, , Local Variables in Files, emacs, The GNU Emacs
Manual}.
@end ifinfo
@iftex
See sections ``How Major Modes are Chosen'' and ``Local Variables in
Files'' in @cite{The GNU Emacs Manual}.
@end iftex

Now, back to the @file{.emacs} file.

@need 800
Here is the line again; how does it work?

@cindex Text Mode turned on
@smallexample
(setq major-mode 'text-mode)
@end smallexample

@noindent
This line is a short, but complete Emacs Lisp expression.

We are already familiar with @code{setq}.  It sets the following variable,
@code{major-mode}, to the subsequent value, which is @code{text-mode}.
The single-quote before @code{text-mode} tells Emacs to deal directly
with the @code{text-mode} symbol, not with whatever it might stand for.
@xref{set & setq, , Setting the Value of a Variable},
for a reminder of how @code{setq} works.
The main point is that there is no difference between the procedure you
use to set a value in your @file{.emacs} file and the procedure you use
anywhere else in Emacs.

@need 800
Here is the next line:

@cindex Auto Fill mode turned on
@findex add-hook
@smallexample
(add-hook 'text-mode-hook 'turn-on-auto-fill)
@end smallexample

@noindent
In this line, the @code{add-hook} command adds
@code{turn-on-auto-fill} to the variable.

@code{turn-on-auto-fill} is the name of a program, that, you guessed
it!, turns on Auto Fill mode.

Every time Emacs turns on Text mode, Emacs runs the commands hooked
onto Text mode.  So every time Emacs turns on Text mode, Emacs also
turns on Auto Fill mode.

In brief, the first line causes Emacs to enter Text mode when you edit a
file, unless the file name extension, a first non-blank line, or local
variables to tell Emacs otherwise.

Text mode among other actions, sets the syntax table to work
conveniently for writers.  In Text mode, Emacs considers an apostrophe
as part of a word like a letter; but Emacs does not consider a period
or a space as part of a word.  Thus, @kbd{M-f} moves you over
@samp{it's}.  On the other hand, in C mode, @kbd{M-f} stops just after
the @samp{t} of @samp{it's}.

The second line causes Emacs to turn on Auto Fill mode when it turns
on Text mode.  In Auto Fill mode, Emacs automatically breaks a line
that is too wide and brings the excessively wide part of the line down
to the next line.  Emacs breaks lines between words, not within them.

When Auto Fill mode is turned off, lines continue to the right as you
type them.  Depending on how you set the value of
@code{truncate-lines}, the words you type either disappear off the
right side of the screen, or else are shown, in a rather ugly and
unreadable manner, as a continuation line on the screen.

@need 1250
In addition, in this part of my @file{.emacs} file, I tell the Emacs
fill commands to insert two spaces after a colon:

@smallexample
(setq colon-double-space t)
@end smallexample

@node Mail Aliases
@section Mail Aliases

Here is a @code{setq} that turns on mail aliases, along with more
reminders.

@smallexample
@group
;;; Message mode
; To enter message mode, type 'C-x m'
; To enter RMAIL (for reading mail),
; type 'M-x rmail'
(setq mail-aliases t)
@end group
@end smallexample

@cindex Mail aliases
@noindent
This @code{setq} sets the value of the variable
@code{mail-aliases} to @code{t}.  Since @code{t} means true, the line
says, in effect, ``Yes, use mail aliases.''

Mail aliases are convenient short names for long email addresses or
for lists of email addresses.  The file where you keep your aliases
is @file{~/.mailrc}.  You write an alias like this:

@smallexample
alias geo george@@foobar.wiz.edu
@end smallexample

@noindent
When you write a message to George, address it to @samp{geo}; the
mailer will automatically expand @samp{geo} to the full address.

@node Indent Tabs Mode
@section Indent Tabs Mode
@cindex Tabs, preventing
@findex indent-tabs-mode

By default, Emacs inserts tabs in place of multiple spaces when it
formats a region.  (For example, you might indent many lines of text
all at once with the @code{indent-region} command.)  Tabs look fine on
a terminal or with ordinary printing, but they produce badly indented
output when you use @TeX{} or Texinfo since @TeX{} ignores tabs.

@need 1250
The following turns off Indent Tabs mode:

@smallexample
@group
;;; Prevent Extraneous Tabs
(setq-default indent-tabs-mode nil)
@end group
@end smallexample

Note that this line uses @code{setq-default} rather than the
@code{setq} that we have seen before; @code{setq-default}
sets values only in buffers that do not have their own local
values for the variable.

@ifinfo
@xref{Just Spaces, , Tabs vs.@: Spaces, emacs, The GNU Emacs Manual}.

@xref{File Variables, , Local Variables in Files, emacs, The GNU Emacs
Manual}.
@end ifinfo
@iftex
See sections ``Tabs vs.@: Spaces'' and ``Local Variables in
Files'' in @cite{The GNU Emacs Manual}.
@end iftex

@need 1700
@node Key Bindings
@section Some Key Bindings

Now for some personal key bindings:

@smallexample
@group
;;; Compare windows
(global-set-key "\C-cw" 'compare-windows)
@end group
@end smallexample

@findex compare-windows
@code{compare-windows} is a nifty command that compares the text in
your current window with text in the next window.  It makes the
comparison by starting at point in each window, moving over text in
each window as far as they match.  I use this command all the time.

This also shows how to set a key globally, for all modes.

@cindex Setting a key globally
@cindex Global set key
@cindex Key setting globally
@findex global-set-key
The command is @code{global-set-key}.  It is followed by the
key binding.  In a @file{.emacs} file, the keybinding is written as
shown: @code{\C-c} stands for Control-C, which means to press the
control key and the @kbd{c} key at the same time.  The @code{w} means
to press the @kbd{w} key.  The key binding is surrounded by double
quotation marks.  In documentation, you would write this as
@w{@kbd{C-c w}}.  (If you were binding a @key{META} key, such as
@kbd{M-c}, rather than a @key{CTRL} key, you would write
@w{@code{\M-c}} in your @file{.emacs} file.  @xref{Init Rebinding, ,
Rebinding Keys in Your Init File, emacs, The GNU Emacs Manual}, for
details.)

The command invoked by the keys is @code{compare-windows}.  Note that
@code{compare-windows} is preceded by a single-quote; otherwise, Emacs
would first try to evaluate the symbol to determine its value.

These three things, the double quotation marks, the backslash before
the @samp{C}, and the single-quote are necessary parts of
key binding that I tend to forget.  Fortunately, I have come to
remember that I should look at my existing @file{.emacs} file, and
adapt what is there.

As for the key binding itself: @kbd{C-c w}.  This combines the prefix
key, @kbd{C-c}, with a single character, in this case, @kbd{w}.  This
set of keys, @kbd{C-c} followed by a single character, is strictly
reserved for individuals' own use.  (I call these @dfn{own} keys, since
these are for my own use.)  You should always be able to create such a
key binding for your own use without stomping on someone else's
key binding.  If you ever write an extension to Emacs, please avoid
taking any of these keys for public use.  Create a key like @kbd{C-c
C-w} instead.  Otherwise, we will run out of own keys.

@need 1250
Here is another key binding, with a comment:

@smallexample
@group
;;; Key binding for 'occur'
; I use occur a lot, so let's bind it to a key:
(global-set-key "\C-co" 'occur)
@end group
@end smallexample

@findex occur
The @code{occur} command shows all the lines in the current buffer
that contain a match for a regular expression.  When the region is
active, @code{occur} restricts matches to such region.  Otherwise it
uses the entire buffer.
Matching lines are shown in a buffer called @file{*Occur*}.
That buffer serves as a menu to jump to occurrences.

@findex global-unset-key
@cindex Unbinding key
@cindex Key unbinding
@need 1250
Here is how to unbind a key, so it does not
work:

@smallexample
@group
;;; Unbind 'C-x f'
(global-unset-key "\C-xf")
@end group
@end smallexample

There is a reason for this unbinding: I found I inadvertently typed
@w{@kbd{C-x f}} when I meant to type @kbd{C-x C-f}.  Rather than find a
file, as I intended, I accidentally set the width for filled text,
almost always to a width I did not want.  Since I hardly ever reset my
default width, I simply unbound the key.

@findex list-buffers@r{, rebound}
@findex buffer-menu@r{, bound to key}
@need 1250
The following rebinds an existing key:

@smallexample
@group
;;; Rebind 'C-x C-b' for 'buffer-menu'
(global-set-key "\C-x\C-b" 'buffer-menu)
@end group
@end smallexample

By default, @kbd{C-x C-b} runs the
@code{list-buffers} command.  This command lists
your buffers in @emph{another} window.  Since I
almost always want to do something in that
window, I prefer the  @code{buffer-menu}
command, which not only lists the buffers,
but moves point into that window.

@node Keymaps
@section Keymaps
@cindex Keymaps
@cindex Rebinding keys

Emacs uses @dfn{keymaps} to record which keys call which commands.
When you use @code{global-set-key} to set the key binding for a single
command in all parts of Emacs, you are specifying the key binding in
@code{current-global-map}.

Specific modes, such as C mode or Text mode, have their own keymaps;
the mode-specific keymaps override the global map that is shared by
all buffers.

The @code{global-set-key} function binds, or rebinds, the global
keymap.  For example, the following binds the key @kbd{C-x C-b} to the
function @code{buffer-menu}:

@smallexample
(global-set-key "\C-x\C-b" 'buffer-menu)
@end smallexample

Mode-specific keymaps are bound using the @code{define-key} function,
which takes a specific keymap as an argument, as well as the key and
the command.  For example, my @file{.emacs} file contains the
following expression to bind the @code{texinfo-insert-@@group} command
to @kbd{C-c C-c g}:

@smallexample
@group
(define-key texinfo-mode-map "\C-c\C-cg" 'texinfo-insert-@@group)
@end group
@end smallexample

@noindent
The @code{texinfo-insert-@@group} function itself is a little extension
to Texinfo mode that inserts @samp{@@group} into a Texinfo file.  I
use this command all the time and prefer to type the three strokes
@kbd{C-c C-c g} rather than the six strokes @kbd{@@ g r o u p}.
(@samp{@@group} and its matching @samp{@@end group} are commands that
keep all enclosed text together on one page; many multi-line examples
in this book are surrounded by @samp{@@group @dots{} @@end group}.)

@need 1250
Here is the @code{texinfo-insert-@@group} function definition:

@smallexample
@group
(defun texinfo-insert-@@group ()
  "Insert the string @@group in a Texinfo buffer."
  (interactive)
  (beginning-of-line)
  (insert "@@group\n"))
@end group
@end smallexample

(Of course, I could have used Abbrev mode to save typing, rather than
write a function to insert a word; but I prefer key strokes consistent
with other Texinfo mode key bindings.)

You will see numerous @code{define-key} expressions in
@file{loaddefs.el} as well as in the various mode libraries, such as
@file{cc-mode.el} and @file{lisp-mode.el}.

@xref{Key Bindings, , Customizing Key Bindings, emacs, The GNU Emacs
Manual}, and @ref{Keymaps, , Keymaps, elisp, The GNU Emacs Lisp
Reference Manual}, for more information about keymaps.

@node Loading Files
@section Loading Files
@cindex Loading files
@c findex load

Many people in the GNU Emacs community have written extensions to
Emacs.  As time goes by, these extensions are often included in new
releases.  For example, the Calendar and Diary packages are now part
of the standard GNU Emacs, as is Calc.

You can use a @code{load} command to evaluate a complete file and
thereby install all the functions and variables in the file into Emacs.
For example:

@c (auto-compression-mode t)

@smallexample
(load "~/emacs/slowsplit")
@end smallexample

This evaluates, i.e., loads, the @file{slowsplit.el} file or if it
exists, the faster, byte compiled @file{slowsplit.elc} file from the
@file{emacs} sub-directory of your home directory.  The file contains
the function @code{split-window-quietly}, which John Robinson wrote in
1989.

The @code{split-window-quietly} function splits a window with the
minimum of redisplay.  I installed it in 1989 because it worked well
with the slow 1200 baud terminals I was then using.  Nowadays, I only
occasionally come across such a slow connection, but I continue to use
the function because I like the way it leaves the bottom half of a
buffer in the lower of the new windows and the top half in the upper
window.

@need 1250
To replace the key binding for the default
@code{split-window-vertically}, you must also unset that key and bind
the keys to @code{split-window-quietly}, like this:

@smallexample
@group
(global-unset-key "\C-x2")
(global-set-key "\C-x2" 'split-window-quietly)
@end group
@end smallexample

@vindex load-path
If you load many extensions, as I do, then instead of specifying the
exact location of the extension file, as shown above, you can specify
that directory as part of Emacs's @code{load-path}.  Then, when Emacs
loads a file, it will search that directory as well as its default
list of directories.  (The default list is specified in @file{paths.h}
when Emacs is built.)

@need 1250
The following command adds your @file{~/emacs} directory to the
existing load path:

@smallexample
@group
;;; Emacs Load Path
(setq load-path (cons "~/emacs" load-path))
@end group
@end smallexample

Incidentally, @code{load-library} is an interactive interface to the
@code{load} function.  The complete function looks like this:

@findex load-library
@smallexample
@group
(defun load-library (library)
  "Load the Emacs Lisp library named LIBRARY.
This is an interface to the function `load'.  LIBRARY is searched
for in `load-path', both with and without `load-suffixes' (as
well as `load-file-rep-suffixes').

See Info node `(emacs)Lisp Libraries' for more details.
See `load-file' for a different interface to `load'."
  (interactive
   (list (completing-read "Load library: "
                          (apply-partially 'locate-file-completion-table
                                           load-path
                                           (get-load-suffixes)))))
  (load library))
@end group
@end smallexample

The name of the function, @code{load-library}, comes from the use of
``library'' as a conventional synonym for ``file''.  The source for the
@code{load-library} command is in the @file{files.el} library.

Another interactive command that does a slightly different job is
@code{load-file}.  @xref{Lisp Libraries, , Libraries of Lisp Code for
Emacs, emacs, The GNU Emacs Manual}, for information on the
distinction between @code{load-library} and this command.

@node Autoload
@section Autoloading
@findex autoload

Instead of installing a function by loading the file that contains it,
or by evaluating the function definition, you can make the function
available but not actually install it until it is first called.  This
is called @dfn{autoloading}.

When you execute an autoloaded function, Emacs automatically evaluates
the file that contains the definition, and then calls the function.

Emacs starts quicker with autoloaded functions, since their libraries
are not loaded right away; but you need to wait a moment when you
first use such a function, while its containing file is evaluated.

Rarely used functions are frequently autoloaded.  The
@file{loaddefs.el} library contains thousands of autoloaded functions,
from @code{5x5} to @code{zone}.  Of course, you may
come to use a rare function frequently.  When you do, you should
load that function's file with a @code{load} expression in your
@file{.emacs} file.

In my @file{.emacs} file, I load 14 libraries that contain functions
that would otherwise be autoloaded.  (Actually, it would have been
better to include these files in my dumped Emacs, but I forgot.
@xref{Building Emacs, , Building Emacs, elisp, The GNU Emacs Lisp
Reference Manual}, and the @file{INSTALL} file for more about
dumping.)

You may also want to include autoloaded expressions in your @file{.emacs}
file.  @code{autoload} is a built-in function that takes up to five
arguments, the final three of which are optional.  The first argument
is the name of the function to be autoloaded; the second is the name
of the file to be loaded.  The third argument is documentation for the
function, and the fourth tells whether the function can be called
interactively.  The fifth argument tells what type of
object---@code{autoload} can handle a keymap or macro as well as a
function (the default is a function).

@need 800
Here is a typical example:

@smallexample
@group
(autoload 'html-helper-mode
  "html-helper-mode" "Edit HTML documents" t)
@end group
@end smallexample

@noindent
(@code{html-helper-mode} is an older alternative to @code{html-mode},
which is a standard part of the distribution.)

@noindent
This expression autoloads the @code{html-helper-mode} function.  It
takes it from the @file{html-helper-mode.el} file (or from the byte
compiled version @file{html-helper-mode.elc}, if that exists.)  The
file must be located in a directory specified by @code{load-path}.
The documentation says that this is a mode to help you edit documents
written in the HyperText Markup Language.  You can call this mode
interactively by typing @kbd{M-x html-helper-mode}.  (You need to
duplicate the function's regular documentation in the autoload
expression because the regular function is not yet loaded, so its
documentation is not available.)

@xref{Autoload, , Autoload, elisp, The GNU Emacs Lisp Reference
Manual}, for more information.

@node Simple Extension
@section A Simple Extension: @code{line-to-top-of-window}
@findex line-to-top-of-window
@cindex Simple extension in @file{.emacs} file

Here is a simple extension to Emacs that moves the line that point is
on to the top of the window.  I use this all the time, to make text
easier to read.

You can put the following code into a separate file and then load it
from your @file{.emacs} file, or you can include it within your
@file{.emacs} file.

@need 1250
Here is the definition:

@smallexample
@group
;;; Line to top of window;
;;; replace three keystroke sequence  C-u 0 C-l
(defun line-to-top-of-window ()
  "Move the line that point is on to top of window."
  (interactive)
  (recenter 0))
@end group
@end smallexample

@need 1250
Now for the key binding.

Function keys as well as mouse button events and non-@sc{ascii}
characters are written within square brackets, without quotation
marks.

I bind @code{line-to-top-of-window} to my @key{F6} function key like
this:

@smallexample
(global-set-key [f6] 'line-to-top-of-window)
@end smallexample

For more information, see @ref{Init Rebinding, , Rebinding Keys in
Your Init File, emacs, The GNU Emacs Manual}.

@cindex Conditional 'twixt two versions of Emacs
@cindex Version of Emacs, choosing
@cindex Emacs version, choosing
If you run two versions of GNU Emacs, such as versions 27 and 28, and
use one @file{.emacs} file, you can select which code to evaluate with
the following conditional:

@smallexample
@group
(cond
 ((= 27 emacs-major-version)
  ;; evaluate version 27 code
  ( @dots{} ))
 ((= 28 emacs-major-version)
  ;; evaluate version 28 code
  ( @dots{} )))
@end group
@end smallexample

For example, recent versions blink
their cursors by default.  I hate such blinking, as well as other
features, so I placed the following in my @file{.emacs}
file@footnote{When I start instances of Emacs that do not load my
@file{.emacs} file or any site file, I also turn off blinking:

@smallexample
emacs -q --no-site-file -eval '(blink-cursor-mode nil)'

@exdent Or nowadays, using an even more sophisticated set of options,

emacs -Q -D
@end smallexample
}:

@smallexample
@group
(when (>= emacs-major-version 21)
  (blink-cursor-mode 0)
  ;; Insert newline when you press 'C-n' (next-line)
  ;; at the end of the buffer
  (setq next-line-add-newlines t)
@end group
@group
  ;; Turn on image viewing
  (auto-image-file-mode t)
@end group
@group
  ;; Turn on menu bar (this bar has text)
  ;; (Use numeric argument to turn on)
  (menu-bar-mode 1)
@end group
@group
  ;; Turn off tool bar (this bar has icons)
  ;; (Use numeric argument to turn on)
  (tool-bar-mode nil)
@end group
@group
  ;; Turn off tooltip mode for tool bar
  ;; (This mode causes icon explanations to pop up)
  ;; (Use numeric argument to turn on)
  (tooltip-mode nil)
  ;; If tooltips turned on, make tips appear promptly
  (setq tooltip-delay 0.1)  ; default is 0.7 second
   )
@end group
@end smallexample

@node X11 Colors
@section X11 Colors

You can specify colors when you use Emacs with the MIT X Windowing
system.

I dislike the default colors and specify my own.

@need 1250
Here are the expressions in my @file{.emacs}
file that set values:

@smallexample
@group
;; Set cursor color
(set-cursor-color "white")

;; Set mouse color
(set-mouse-color "white")

;; Set foreground and background
(set-foreground-color "white")
(set-background-color "darkblue")
@end group

@group
;;; Set highlighting colors for isearch and drag
(set-face-foreground 'highlight "white")
(set-face-background 'highlight "blue")
@end group

@group
(set-face-foreground 'region "cyan")
(set-face-background 'region "blue")
@end group

@group
(set-face-foreground 'secondary-selection "skyblue")
(set-face-background 'secondary-selection "darkblue")
@end group

@group
;; Set calendar highlighting colors
(with-eval-after-load 'calendar
  (set-face-foreground 'diary   "skyblue")
  (set-face-background 'holiday "slate blue")
  (set-face-foreground 'holiday "white"))
@end group
@end smallexample

The various shades of blue soothe my eye and prevent me from seeing
the screen flicker.

Alternatively, I could have set my specifications in various X
initialization files.  For example, I could set the foreground,
background, cursor, and pointer (i.e., mouse) colors in my
@file{~/.Xresources} file like this:

@smallexample
@group
Emacs*foreground:   white
Emacs*background:   darkblue
Emacs*cursorColor:  white
Emacs*pointerColor: white
@end group
@end smallexample

In any event, since it is not part of Emacs, I set the root color of
my X window in my @file{~/.xinitrc} file, like this@footnote{I also
run more modern window managers, such as Enlightenment, Gnome, or KDE;
in those cases, I often specify an image rather than a plain color.}:

@smallexample
xsetroot -solid Navy -fg white &
@end smallexample

@need 1700
@node Miscellaneous
@section Miscellaneous Settings for a @file{.emacs} File

@need 1250
Here are a few miscellaneous settings:
@sp 1

@itemize @minus
@item
Set the shape and color of the mouse cursor:

@smallexample
@group
; Cursor shapes are defined in
; '/usr/include/X11/cursorfont.h';
; for example, the 'target' cursor is number 128;
; the 'top_left_arrow' cursor is number 132.
@end group

@group
(let ((mpointer (x-get-resource "*mpointer"
                                "*emacs*mpointer")))
  ;; If you have not set your mouse pointer
  ;;     then set it, otherwise leave as is:
  (if (eq mpointer nil)
      (setq mpointer "132")) ; top_left_arrow
@end group
@group
  (setq x-pointer-shape (string-to-number mpointer))
  (set-mouse-color "white"))
@end group
@end smallexample

@item
Or you can set the values of a variety of features in an alist, like
this:

@smallexample
@group
(setq-default
 default-frame-alist
 '((cursor-color . "white")
   (mouse-color . "white")
   (foreground-color . "white")
   (background-color . "DodgerBlue4")
   ;; (cursor-type . bar)
   (cursor-type . box)
@end group
@group
   (tool-bar-lines . 0)
   (menu-bar-lines . 1)
   (width . 80)
   (height . 58)
   (font .
         "-Misc-Fixed-Medium-R-Normal--20-200-75-75-C-100-ISO8859-1")
   ))
@end group
@end smallexample

@item
Convert @kbd{@key{CTRL}-h} into @key{DEL} and @key{DEL}
into @kbd{@key{CTRL}-h}.@*
(Some older keyboards needed this, although I have not seen the
problem recently.)

@smallexample
@group
;; Translate 'C-h' to <DEL>.
; (keyboard-translate ?\C-h ?\C-?)

;; Translate <DEL> to 'C-h'.
(keyboard-translate ?\C-? ?\C-h)
@end group
@end smallexample

@item Turn off a blinking cursor!

@smallexample
@group
(if (fboundp 'blink-cursor-mode)
    (blink-cursor-mode -1))
@end group
@end smallexample

@noindent
or start GNU Emacs with the command @code{emacs -nbc}.

@need 1250
@item When using @command{grep}@*
@samp{-i}@w{  }   Ignore case distinctions@*
@samp{-n}@w{  }   Prefix each line of output with line number@*
@samp{-H}@w{  }   Print the filename for each match.@*
@samp{-e}@w{  }   Protect patterns beginning with a hyphen character, @samp{-}

@smallexample
(setq grep-command "grep -i -nH -e ")
@end smallexample

@item Find an existing buffer, even if it has a different name@*
This avoids problems with symbolic links.

@smallexample
(setq find-file-existing-other-name t)
@end smallexample

@item Set your language environment and default input method

@smallexample
@group
(set-language-environment "latin-1")
;; Remember you can enable or disable multilingual text input
;; with the @code{toggle-input-method'} (@kbd{C-\}) command
(setq default-input-method "latin-1-prefix")
@end group
@end smallexample

If you want to write with Chinese GB characters, set this instead:

@smallexample
@group
(set-language-environment "Chinese-GB")
(setq default-input-method "chinese-tonepy")
@end group
@end smallexample
@end itemize

@subsubheading Fixing Unpleasant Key Bindings
@cindex Key bindings, fixing
@cindex Bindings, key, fixing unpleasant

Some systems bind keys unpleasantly.  Sometimes, for example, the
@key{CTRL} key appears in an awkward spot rather than at the far left
of the home row.

Usually, when people fix these sorts of key bindings, they do not
change their @file{~/.emacs} file.  Instead, they bind the proper keys
on their consoles with the @code{loadkeys} or @code{install-keymap}
commands in their boot script and then include @code{xmodmap} commands
in their @file{.xinitrc} or @file{.Xsession} file for X Windows.

@need 1250
@noindent
For a boot script:

@smallexample
@group
loadkeys /usr/share/keymaps/i386/qwerty/emacs2.kmap.gz
@exdent or
install-keymap emacs2
@end group
@end smallexample

@need 1250
@noindent
For a @file{.xinitrc} or @file{.Xsession} file when the @key{Caps
Lock} key is at the far left of the home row:

@smallexample
@group
# Bind the key labeled 'Caps Lock' to 'Control'
# (Such a broken user interface suggests that keyboard manufacturers
# think that computers are typewriters from 1885.)

xmodmap -e "clear Lock"
xmodmap -e "add Control = Caps_Lock"
@end group
@end smallexample

@need 1250
@noindent
In a @file{.xinitrc} or @file{.Xsession} file, to convert an @key{ALT}
key to a @key{META} key:

@smallexample
@group
# Some ill designed keyboards have a key labeled ALT and no Meta
xmodmap -e "keysym Alt_L = Meta_L Alt_L"
@end group
@end smallexample

@need 1700
@node Mode Line
@section A Modified Mode Line
@vindex mode-line-format
@cindex Mode line format

Finally, a feature I really like: a modified mode line.

When I work over a network, I forget which machine I am using.  Also,
I tend to lose track of where I am, and which line point is on.

So I reset my mode line to look like this:

@smallexample
-:-- foo.texi   rattlesnake:/home/bob/  Line 1  (Texinfo Fill) Top
@end smallexample

I am visiting a file called @file{foo.texi}, on my machine
@file{rattlesnake} in my @file{/home/bob} buffer.  I am on line 1, in
Texinfo mode, and am at the top of the buffer.

@need 1200
My @file{.emacs} file has a section that looks like this:

@smallexample
@group
;; Set a Mode Line that tells me which machine, which directory,
;; and which line I am on, plus the other customary information.
(setq-default mode-line-format
 (quote
  (#("-" 0 1
     (help-echo
      "mouse-1: select window, mouse-2: delete others ..."))
   mode-line-mule-info
   mode-line-modified
   mode-line-frame-identification
   "    "
@end group
@group
   mode-line-buffer-identification
   "    "
   (:eval (substring
           (system-name) 0 (string-match "\\..+" (system-name))))
   ":"
   default-directory
   #(" " 0 1
     (help-echo
      "mouse-1: select window, mouse-2: delete others ..."))
   (line-number-mode " Line %l ")
   global-mode-string
@end group
@group
   #("   %[(" 0 6
     (help-echo
      "mouse-1: select window, mouse-2: delete others ..."))
   (:eval (format-time-string "%F"))
   mode-line-process
   minor-mode-alist
   #("%n" 0 2 (help-echo "mouse-2: widen" local-map (keymap ...)))
   ")%] "
   (-3 . "%P")
   ;;   "-%-"
   )))
@end group
@end smallexample

@noindent
Here, I redefine the default mode line.  Most of the parts are from
the original; but I make a few changes.  I set the @emph{default} mode
line format so as to permit various modes, such as Info, to override
it.

Many elements in the list are self-explanatory:
@code{mode-line-modified} is a variable that tells whether the buffer
has been modified, @code{mode-name} tells the name of the mode, and so
on.  However, the format looks complicated because of two features we
have not discussed.

@cindex Properties, in mode line example
The first string in the mode line is a dash or hyphen, @samp{-}.  In
the old days, it would have been specified simply as @code{"-"}.  But
nowadays, Emacs can add properties to a string, such as highlighting
or, as in this case, a help feature.  If you place your mouse cursor
over the hyphen, some help information appears (By default, you must
wait seven-tenths of a second before the information appears.  You can
change that timing by changing the value of @code{tooltip-delay}.)

@need 1000
The new string format has a special syntax:

@smallexample
#("-" 0 1 (help-echo "mouse-1: select window, ..."))
@end smallexample

@noindent
The @code{#(} begins a list.  The first element of the list is the
string itself, just one @samp{-}.  The second and third
elements specify the range over which the fourth element applies.  A
range starts @emph{after} a character, so a zero means the range
starts just before the first character; a 1 means that the range ends
just after the first character.  The third element is the property for
the range.  It consists of a property list,  a
property name, in this case, @samp{help-echo}, followed by a value, in this
case, a string.  The second, third, and fourth elements of this new
string format can be repeated.

@xref{Text Properties, , Text Properties, elisp, The GNU Emacs Lisp
Reference Manual}, and see @ref{Mode Line Format, , Mode Line Format,
elisp, The GNU Emacs Lisp Reference Manual}, for more information.

@code{mode-line-buffer-identification}
displays the current buffer name.  It is a list
beginning @code{(#("%12b" 0 4 @dots{}}.
The @code{#(} begins the list.

The @samp{"%12b"} displays the current buffer name, using the
@code{buffer-name} function with which we are familiar; the @samp{12}
specifies the maximum number of characters that will be displayed.
When a name has fewer characters, whitespace is added to fill out to
this number.  (Buffer names can and often should be longer than 12
characters; this length works well in a typical 80 column wide
window.)

@code{:eval} says to evaluate the following form and use the result as
a string to display.  In this case, the expression displays the first
component of the full system name.  The end of the first component is
a @samp{.} (period), so I use the @code{string-match} function to
tell me the length of the first component.  The substring from the
zeroth character to that length is the name of the machine.

@need 1250
This is the expression:

@smallexample
@group
(:eval (substring
        (system-name) 0 (string-match "\\..+" (system-name))))
@end group
@end smallexample

@samp{%[} and @samp{%]} cause a pair of square brackets
to appear for each recursive editing level.  @samp{%n} says ``Narrow''
when narrowing is in effect.  @samp{%P} tells you the percentage of
the buffer that is above the bottom of the window, or ``Top'', ``Bottom'',
or ``All''.  (A lower case @samp{p} tell you the percentage above the
@emph{top} of the window.)  @samp{%-} inserts enough dashes to fill
out the line.

Remember, you don't have to like Emacs to like it---your own
Emacs can have different colors, different commands, and different
keys than a default Emacs.

On the other hand, if you want to bring up a plain out-of-the-box
Emacs, with no customization, type:

@smallexample
emacs -q
@end smallexample

@noindent
This will start an Emacs that does @emph{not} load your
@file{~/.emacs} initialization file.  A plain, default Emacs.  Nothing
more.

@node Debugging
@chapter Debugging
@cindex debugging

GNU Emacs has two debuggers, @code{debug} and @code{edebug}.  The
first is built into the internals of Emacs and is always with you;
the second requires that you instrument a function before you can use it.

Both debuggers are described extensively in @ref{Debugging, ,
Debugging Lisp Programs, elisp, The GNU Emacs Lisp Reference Manual}.
In this chapter, I will walk through a short example of each.

@menu
* debug::                       How to use the built-in debugger.
* debug-on-entry::              Start debugging when you call a function.
* debug-on-quit::               Start debugging when you quit with @kbd{C-g}.
* edebug::                      How to use Edebug, a source level debugger.
* Debugging Exercises::
@end menu

@node debug
@section @code{debug}
@findex debug

Suppose you have written a function definition that is intended to
return the sum of the numbers 1 through a given number.  (This is the
@code{triangle} function discussed earlier.  @xref{递减示例, , Example with Decrementing Counter}, for a discussion.)
@c xref{递减循环,, Loop with a Decrementing Counter}, for a discussion.)

However, your function definition has a bug.  You have mistyped
@samp{1=} for @samp{1-}.  Here is the broken definition:

@findex triangle-bugged
@smallexample
@group
(defun triangle-bugged (number)
  "Return sum of numbers 1 through NUMBER inclusive."
  (let ((total 0))
    (while (> number 0)
      (setq total (+ total number))
      (setq number (1= number)))      ; @r{Error here.}
    total))
@end group
@end smallexample

If you are reading this in Info, you can evaluate this definition in
the normal fashion.  You will see @code{triangle-bugged} appear in the
echo area.

@need 1250
Now evaluate the @code{triangle-bugged} function with an
argument of 4:

@smallexample
(triangle-bugged 4)
@end smallexample

@noindent
This will create and enter a @file{*Backtrace*} buffer that says:

@noindent
@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function 1=)
  (1= number)
  (setq number (1= number))
  (while (> number 0) (setq total (+ total number))
        (setq number (1= number)))
  (let ((total 0)) (while (> number 0) (setq total ...)
    (setq number ...)) total)
  triangle-bugged(4)
@end group
@group
  eval((triangle-bugged 4) nil)
  eval-expression((triangle-bugged 4) nil nil 127)
  funcall-interactively(eval-expression (triangle-bugged 4) nil nil 127)
  call-interactively(eval-expression nil nil)
  command-execute(eval-expression)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@noindent
(I have reformatted this example slightly; the debugger does not fold
long lines.  As usual, you can quit the debugger by typing @kbd{q} in
the @file{*Backtrace*} buffer.)

In practice, for a bug as simple as this, the Lisp error line will
tell you what you need to know to correct the definition.  The
function @code{1=} is void.

However, suppose you are not quite certain what is going on?
You can read the complete backtrace.

Emacs automatically starts the debugger that puts you in the
@file{*Backtrace*} buffer.  You can also start the debugger manually
as described below.

Read the @file{*Backtrace*} buffer from the bottom up; it tells you
what Emacs did that led to the error.  Emacs made an interactive call
to @kbd{C-x C-e} (@code{eval-last-sexp}), which led to the evaluation
of the @code{triangle-bugged} expression.  Each line above tells you
what the Lisp interpreter evaluated next.

@need 1250
The third line from the top of the buffer is

@smallexample
(setq number (1= number))
@end smallexample

@noindent
Emacs tried to evaluate this expression; in order to do so, it tried
to evaluate the inner expression shown on the second line from the
top:

@smallexample
(1= number)
@end smallexample

@need 1250
@noindent
This is where the error occurred; as the top line says:

@smallexample
Debugger entered--Lisp error: (void-function 1=)
@end smallexample

@noindent
You can correct the mistake, re-evaluate the function definition, and
then run your test again.

@node debug-on-entry
@section @code{debug-on-entry}
@findex debug-on-entry

Emacs starts the debugger automatically when your function has an
error.

Incidentally, you can start the debugger manually for all versions of
Emacs; the advantage is that the debugger runs even if you do not have
a bug in your code.  Sometimes your code will be free of bugs!

You can enter the debugger when you call the function by calling
@code{debug-on-entry}.

@need 1250
@noindent
Type:

@smallexample
M-x debug-on-entry @key{RET} triangle-bugged @key{RET}
@end smallexample

@need 1250
@noindent
Now, evaluate the following:

@smallexample
(triangle-bugged 5)
@end smallexample

@noindent
All versions of Emacs will create a @file{*Backtrace*} buffer and tell
you that it is beginning to evaluate the @code{triangle-bugged}
function:

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--entering a function:
* triangle-bugged(5)
  eval((triangle-bugged 5) nil)
@end group
@group
  eval-expression((triangle-bugged 5) nil nil 127)
  funcall-interactively(eval-expression (triangle-bugged 5) nil nil 127)
  call-interactively(eval-expression nil nil)
  command-execute(eval-expression)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

In the @file{*Backtrace*} buffer, type @kbd{d}.  Emacs will evaluate
the first expression in @code{triangle-bugged}; the buffer will look
like this:

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--beginning evaluation of function call form:
* (let ((total 0)) (while (> number 0) (setq total ...)
        (setq number ...)) total)
* triangle-bugged(5)
  eval((triangle-bugged 5))
@end group
@group
  eval((triangle-bugged 5) nil)
  eval-expression((triangle-bugged 5) nil nil 127)
  funcall-interactively(eval-expression (triangle-bugged 5) nil nil 127)
  call-interactively(eval-expression nil nil)
  command-execute(eval-expression)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@noindent
Now, type @kbd{d} again, eight times, slowly.  Each time you type
@kbd{d}, Emacs will evaluate another expression in the function
definition.

@need 1750
Eventually, the buffer will look like this:

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--beginning evaluation of function call form:
* (setq number (1= number))
* (while (> number 0) (setq total (+ total number))
        (setq number (1= number)))
@group
@end group
* (let ((total 0)) (while (> number 0) (setq total ...)
        (setq number ...)) total)
* triangle-bugged(5)
  eval((triangle-bugged 5) nil)
@group
@end group
  eval-expression((triangle-bugged 5) nil nil 127)
  funcall-interactively(eval-expression (triangle-bugged 5) nil nil 127)
  call-interactively(eval-expression nil nil)
  command-execute(eval-expression)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@need 1500
@noindent
Finally, after you type @kbd{d} two more times, Emacs will reach the
error, and the top two lines of the @file{*Backtrace*} buffer will look
like this:

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function 1=)
* (1= number)
@dots{}
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

By typing @kbd{d}, you were able to step through the function.

You can quit a @file{*Backtrace*} buffer by typing @kbd{q} in it; this
quits the trace, but does not cancel @code{debug-on-entry}.

@findex cancel-debug-on-entry
To cancel the effect of @code{debug-on-entry}, call
@code{cancel-debug-on-entry} and the name of the function, like this:

@smallexample
M-x cancel-debug-on-entry @key{RET} triangle-bugged @key{RET}
@end smallexample

@noindent
(If you are reading this in Info, cancel @code{debug-on-entry} now.)

@node debug-on-quit
@section @code{debug-on-quit} and @code{(debug)}

In addition to setting @code{debug-on-error} or calling @code{debug-on-entry},
there are two other ways to start @code{debug}.

@findex debug-on-quit
You can start @code{debug} whenever you type @kbd{C-g}
(@code{keyboard-quit}) by setting the variable @code{debug-on-quit} to
@code{t}.  This is useful for debugging infinite loops.

@need 1500
@cindex @code{(debug)} in code
Or, you can insert a line that says @code{(debug)} into your code
where you want the debugger to start, like this:

@smallexample
@group
(defun triangle-bugged (number)
  "Return sum of numbers 1 through NUMBER inclusive."
  (let ((total 0))
    (while (> number 0)
      (setq total (+ total number))
      (debug)                         ; @r{Start debugger.}
      (setq number (1= number)))      ; @r{Error here.}
    total))
@end group
@end smallexample

The @code{debug} function is described in detail in @ref{Debugger, ,
The Lisp Debugger, elisp, The GNU Emacs Lisp Reference Manual}.

@node edebug
@section The @code{edebug} Source Level Debugger
@cindex Source level debugger
@findex edebug

Edebug is a source level debugger.  Edebug normally displays the
source of the code you are debugging, with an arrow at the left that
shows which line you are currently executing.

You can walk through the execution of a function, line by line, or run
quickly until reaching a @dfn{breakpoint} where execution stops.

Edebug is described in @ref{Edebug, , , elisp, The GNU Emacs
Lisp Reference Manual}.

@need 1250
Here is a bugged function definition for @code{triangle-recursively}.
@xref{递归三角形函数, , Recursion in place of a counter},
for a review of it.

@smallexample
@group
(defun triangle-recursively-bugged (number)
  "Return sum of numbers 1 through NUMBER inclusive.
Uses recursion."
  (if (= number 1)
      1
    (+ number
       (triangle-recursively-bugged
        (1= number)))))               ; @r{Error here.}
@end group
@end smallexample

@noindent
Normally, you would install this definition by positioning your cursor
after the function's closing parenthesis and typing @kbd{C-x C-e}
(@code{eval-last-sexp}) or else by positioning your cursor within the
definition and typing @kbd{C-M-x} (@code{eval-defun}).  (By default,
the @code{eval-defun} command works only in Emacs Lisp mode or in Lisp
Interaction mode.)

@need 1500
However, to prepare this function definition for Edebug, you must
first @dfn{instrument} the code using a different command.  You can do
this by positioning your cursor within or just after the definition
and typing

@smallexample
M-x edebug-defun @key{RET}
@end smallexample

@noindent
This will cause Emacs to load Edebug automatically if it is not
already loaded, and properly instrument the function.

After instrumenting the function, place your cursor after the
following expression and type @kbd{C-x C-e} (@code{eval-last-sexp}):

@smallexample
(triangle-recursively-bugged 3)
@end smallexample

@noindent
You will be jumped back to the source for
@code{triangle-recursively-bugged} and the cursor positioned at the
beginning of the @code{if} line of the function.  Also, you will see
an arrowhead at the left hand side of that line.  The arrowhead marks
the line where the function is executing.  (In the following examples,
we show the arrowhead with @samp{=>}; in a windowing system, you may
see the arrowhead as a solid triangle in the window fringe.)

@smallexample
=>@point{}(if (= number 1)
@end smallexample

@noindent
@iftex
In the example, the location of point is displayed with a star,
@samp{@point{}} (in Info, it is displayed as @samp{-!-}).
@end iftex
@ifnottex
In the example, the location of point is displayed as @samp{@point{}}
(in a printed book, it is displayed with a five pointed star).
@end ifnottex

If you now press @key{SPC}, point will move to the next expression to
be executed; the line will look like this:

@smallexample
=>(if @point{}(= number 1)
@end smallexample

@noindent
As you continue to press @key{SPC}, point will move from expression to
expression.  At the same time, whenever an expression returns a value,
that value will be displayed in the echo area.  For example, after you
move point past @code{number}, you will see the following:

@smallexample
Result: 3 (#o3, #x3, ?\C-c)
@end smallexample

@noindent
This means the value of @code{number} is 3, which is octal three,
hexadecimal three, and @sc{ascii} Control-C (the third letter of the
alphabet, in case you need to know this information).

You can continue moving through the code until you reach the line with
the error.  Before evaluation, that line looks like this:

@smallexample
=>        @point{}(1= number)))))               ; @r{Error here.}
@end smallexample

@need 1250
@noindent
When you press @key{SPC} once again, you will produce an error message
that says:

@smallexample
Symbol's function definition is void:@: 1=
@end smallexample

@noindent
This is the bug.

Press @kbd{q} to quit Edebug.

To remove instrumentation from a function definition, simply
re-evaluate it with a command that does not instrument it.
For example, you could place your cursor after the definition's
closing parenthesis and type @kbd{C-x C-e}.

Edebug does a great deal more than walk with you through a function.
You can set it so it races through on its own, stopping only at an
error or at specified stopping points; you can cause it to display the
changing values of various expressions; you can find out how many
times a function is called, and more.

Edebug is described in @ref{Edebug, , , elisp, The GNU Emacs
Lisp Reference Manual}.

@need 1500
@node Debugging Exercises
@section Debugging Exercises

@itemize @bullet
@item
Install the @code{@value{COUNT-WORDS}} function and then cause it to
enter the built-in debugger when you call it.  Run the command on a
region containing two words.  You will need to press @kbd{d} a
remarkable number of times.  On your system, is a hook called after
the command finishes?  (For information on hooks, see @ref{Command
Overview, , Command Loop Overview, elisp, The GNU Emacs Lisp Reference
Manual}.)

@item
Copy @code{@value{COUNT-WORDS}} into the @file{*scratch*} buffer,
instrument the function for Edebug, and walk through its execution.
The function does not need to have a bug, although you can introduce
one if you wish.  If the function lacks a bug, the walk-through
completes without problems.

@item
While running Edebug, type @kbd{?} to see a list of all the Edebug commands.
(The @code{global-edebug-prefix} is usually @kbd{C-x X}, i.e.,
@kbd{@key{CTRL}-x} followed by an upper case @kbd{X}; use this prefix
for commands made outside of the Edebug debugging buffer.)

@item
In the Edebug debugging buffer, use the @kbd{p}
(@code{edebug-bounce-point}) command to see where in the region the
@code{@value{COUNT-WORDS}} is working.

@item
Move point to some spot further down the function and then type the
@kbd{h} (@code{edebug-goto-here}) command to jump to that location.

@item
Use the @kbd{t} (@code{edebug-trace-mode}) command to cause Edebug to
walk through the function on its own; use an upper case @kbd{T} for
@code{edebug-Trace-fast-mode}.

@item
Set a breakpoint, then run Edebug in Trace mode until it reaches the
stopping point.
@end itemize

@node Conclusion
@chapter Conclusion

我们现在已经到达了这个介绍的结尾。您现在已经学到足够的关于在Emacs Lisp中编程的知识，足以设置值、为自己和朋友编写简单的@file{.emacs}文件，以及编写对Emacs进行简单定制和扩展的代码。

这是一个停下来的地方。或者，如果您愿意，现在可以继续前进，自己深入学习。

您已经学到了一些编程的基础知识。但仅仅是一些。有许多容易使用的括号和铰链，我们尚未涉及。

您现在可以追踪GNU Emacs的源代码以及
@ifnotinfo
@cite{The GNU Emacs Lisp Reference Manual}。
@end ifnotinfo
@ifinfo
@ref{Top, , The GNU Emacs Lisp Reference Manual, elisp, The GNU
Emacs Lisp Reference Manual}.
@end ifinfo

Emacs Lisp的源代码是一场冒险。当您阅读源代码并遇到一个陌生的函数或表达式时，您需要弄清楚或找出它的作用。

前往参考手册。它是对Emacs Lisp进行了详尽、完整且相当易读的描述。它不仅是为专家编写的，还为像您一样有一定基础的人编写的。（@cite{参考手册}与标准GNU Emacs发行版一起提供。与本介绍一样，它作为一个Texinfo源文件，因此您可以在计算机上阅读它，并作为排版的印刷书籍阅读。）

查看GNU Emacs的其他内置帮助：所有函数和变量的内置文档，以及
@code{xref-find-definitions}，该程序可以带您转到源代码。

这里是我探索源代码的一个示例。由于其名称，@file{simple.el}是我很久以前首先查看的文件。恰好@file{simple.el}中的一些函数很复杂，或者至少乍一看很复杂。例如，@code{open-line}函数看起来很复杂。

您可能想像这个函数的作用，就像我们之前使用@code{forward-sentence}函数一样慢慢地走一遍。(@xref{forward-sentence, The
@code{forward-sentence} function}.) 或者您可能想跳过该函数，查看另一个函数，比如@code{split-line}。您不需要阅读所有函数。根据
@code{count-words-in-defun}，@code{split-line}函数包含102个单词和符号。

即使很短，@code{split-line}包含我们尚未学习的表达式：@code{skip-chars-forward}，@code{indent-to}，@code{current-column}和@code{insert-and-inherit}。

考虑@code{skip-chars-forward}函数。
在GNU Emacs中，您可以通过键入@kbd{C-h f}（@code{describe-function}）和函数的名称来查找有关@code{skip-chars-forward}的更多信息。这将显示函数文档。

您可能能够猜到一个命名得当的函数（例如@code{indent-to}）的作用；或者您也可以查找它。顺便说一下，@code{describe-function}函数本身位于@file{help.el}中；它是那些很长但可以解读的函数之一。您可以使用@kbd{C-h f}命令查找@code{describe-function}！

在这种情况下，由于代码是Lisp，@file{*Help*}缓冲区包含包含函数源代码的库的名称。您可以将光标放在库的名称上，按下@key{RET}键，在这种情况下它绑定到@code{help-follow}，直接转到源代码，方式类似于@kbd{M-.}（@code{xref-find-definitions}）。

@code{describe-function}的定义说明了如何定制@code{interactive}表达式，而不使用标准字符代码；它还展示了如何创建临时缓冲区。

（@code{indent-to}函数是用C而不是Emacs Lisp编写的；它是一个内置函数。@code{help-follow}会将您带到它的源代码，就像@code{xref-find-definitions}一样，当正确设置时。）

您可以使用@code{xref-find-definitions}查看函数的源代码，它绑定到@kbd{M-.}。最后，您可以查看Reference Manual中关于该函数的内容，方法是在Info中访问手册，然后键入@kbd{i}（@code{Info-index}）和函数的名称，或者在印刷副本的索引中查找该函数。

同样，您可以找出@code{insert-and-inherit}的含义。

其他有趣的源文件包括@file{paragraphs.el}、@file{loaddefs.el}和@file{loadup.el}。@file{paragraphs.el}文件包含简短、易于理解的函数以及较长的函数。@file{loaddefs.el}文件包含许多标准的自动加载和许多按键映射。我从未完全查看过它；只是查看了部分。@file{loadup.el}是加载Emacs标准部分的文件；它告诉您关于Emacs构建方式的很多信息。
(@xref{Building Emacs, , Building Emacs, elisp, The GNU Emacs Lisp
Reference Manual}，了解更多有关构建的信息。)

正如我所说，您已经学到了一些基础知识；但是，非常重要的是，我们几乎没有涉及编程的重要方面；我对如何排序信息一无所知，除了使用预定义的@code{sort}函数之外；我对如何存储信息一无所知，除了使用变量和列表之外；我对如何编写编写程序的程序一无所知。这是另一种、不同类型的书籍、不同类型的学习的主题。

您所做的是学到了足够在GNU Emacs中进行实际工作的知识。您所做的是开始。这是一个开始的结束。

@c ================ Appendix ================

@node the-the
@appendix The @code{the-the} Function
@findex the-the
@cindex Duplicated words function
@cindex Words, duplicated

Sometimes when you you write text, you duplicate words---as with ``you
you'' near the beginning of this sentence.  I find that most
frequently, I duplicate ``the''; hence, I call the function for
detecting duplicated words, @code{the-the}.

@need 1250
As a first step, you could use the following regular expression to
search for duplicates:

@smallexample
\\(\\w+[ \t\n]+\\)\\1
@end smallexample

@noindent
This regexp matches one or more word-constituent characters followed
by one or more spaces, tabs, or newlines.  However, it does not detect
duplicated words on different lines, since the ending of the first
word, the end of the line, is different from the ending of the second
word, a space.  (For more information about regular expressions, see
@ref{正则表达式搜索, , Regular Expression Searches}, as well as
@ref{Regexps, , Syntax of Regular Expressions, emacs, The GNU Emacs
Manual}, and @ref{Regular Expressions, , Regular Expressions, elisp,
The GNU Emacs Lisp Reference Manual}.)

You might try searching just for duplicated word-constituent
characters but that does not work since the pattern detects doubles
such as the two occurrences of ``th'' in ``with the''.

Another possible regexp searches for word-constituent characters
followed by non-word-constituent characters, reduplicated.  Here,
@w{@samp{\\w+}} matches one or more word-constituent characters and
@w{@samp{\\W*}} matches zero or more non-word-constituent characters.

@smallexample
\\(\\(\\w+\\)\\W*\\)\\1
@end smallexample

@noindent
Again, not useful.

Here is the pattern that I use.  It is not perfect, but good enough.
@w{@samp{\\b}} matches the empty string, provided it is at the beginning
or end of a word; @w{@samp{[^@@ \n\t]+}} matches one or more occurrences of
any characters that are @emph{not} an @@-sign, space, newline, or tab.

@smallexample
\\b\\([^@@ \n\t]+\\)[ \n\t]+\\1\\b
@end smallexample

One can write more complicated expressions, but I found that this
expression is good enough, so I use it.

Here is the @code{the-the} function, as I include it in my
@file{.emacs} file, along with a handy global key binding:

@smallexample
@group
(defun the-the ()
  "Search forward for for a duplicated word."
  (interactive)
  (message "Searching for for duplicated words ...")
  (push-mark)
@end group
@group
  ;; This regexp is not perfect
  ;; but is fairly good over all:
  (if (re-search-forward
       "\\b\\([^@@ \n\t]+\\)[ \n\t]+\\1\\b" nil 'move)
      (message "Found duplicated word.")
    (message "End of buffer")))
@end group

@group
;; Bind 'the-the' to  C-c \
(global-set-key "\C-c\\" 'the-the)
@end group
@end smallexample

@sp 1
Here is test text:

@smallexample
@group
one two two three four five
five six seven
@end group
@end smallexample

You can substitute the other regular expressions shown above in the
function definition and try each of them on this list.

@node Kill Ring
@appendix Handling the Kill Ring
@cindex Kill ring handling
@cindex Handling the kill ring
@cindex Ring, making a list like a

The kill ring is a list that is transformed into a ring by the
workings of the @code{current-kill} function.  The @code{yank} and
@code{yank-pop} commands use the @code{current-kill} function.

This appendix describes the @code{current-kill} function as well as
both the @code{yank} and the @code{yank-pop} commands, but first,
consider the workings of the kill ring.

@menu
* What the Kill Ring Does::
* current-kill::
* yank::                        Paste a copy of a clipped element.
* yank-pop::                    Insert element pointed to.
* ring file::
@end menu

@ifnottex
@node What the Kill Ring Does
@unnumberedsec What the Kill Ring Does
@end ifnottex

@need 1250
The kill ring has a default maximum length of sixty items; this number
is too large for an explanation.  Instead, set it to four.  Please
evaluate the following:

@smallexample
@group
(setq old-kill-ring-max kill-ring-max)
(setq kill-ring-max 4)
@end group
@end smallexample

@noindent
Then, please copy each line of the following indented example into the
kill ring.  You may kill each line with @kbd{C-k} or mark it and copy
it with @kbd{M-w}.

@noindent
(In a read-only buffer, such as the @file{*info*} buffer, the kill
command, @kbd{C-k} (@code{kill-line}), will not remove the text,
merely copy it to the kill ring.  However, your machine may beep at
you.  Alternatively, for silence, you may copy the region of each line
with the @kbd{M-w} (@code{kill-ring-save}) command.  You must mark
each line for this command to succeed, but it does not matter at which
end you put point or mark.)

@need 1250
@noindent
Please invoke the calls in order, so that five elements attempt to
fill the kill ring:

@smallexample
@group
first some text
second piece of text
third line
fourth line of text
fifth bit of text
@end group
@end smallexample

@need 1250
@noindent
Then find the value of @code{kill-ring} by evaluating

@smallexample
kill-ring
@end smallexample

@need 800
@noindent
It is:

@smallexample
@group
("fifth bit of text" "fourth line of text"
"third line" "second piece of text")
@end group
@end smallexample

@noindent
The first element, @samp{first some text}, was dropped.

@need 1250
To return to the old value for the length of the kill ring, evaluate:

@smallexample
(setq kill-ring-max old-kill-ring-max)
@end smallexample

@node current-kill
@appendixsec The @code{current-kill} Function
@findex current-kill

The @code{current-kill} function changes the element in the kill ring
to which @code{kill-ring-yank-pointer} points.  (Also, the
@code{kill-new} function sets @code{kill-ring-yank-pointer} to point
to the latest element of the kill ring.  The @code{kill-new}
function is used directly or indirectly by @code{kill-append},
@code{copy-region-as-kill}, @code{kill-ring-save}, @code{kill-line},
and @code{kill-region}.)

@menu
* Code for current-kill::
* Understanding current-kill::
@end menu

@ifnottex
@node Code for current-kill
@unnumberedsubsec The code for @code{current-kill}
@end ifnottex


@need 1500
The @code{current-kill} function is used by @code{yank} and by
@code{yank-pop}.  Here is the code for @code{current-kill}:

@smallexample
@group
(defun current-kill (n &optional do-not-move)
  "Rotate the yanking point by N places, and then return that kill.
If N is zero and `interprogram-paste-function' is set to a
function that returns a string or a list of strings, and if that
function doesn't return nil, then that string (or list) is added
to the front of the kill ring and the string (or first string in
the list) is returned as the latest kill.
@end group
@group
If N is not zero, and if `yank-pop-change-selection' is
non-nil, use `interprogram-cut-function' to transfer the
kill at the new yank point into the window system selection.
@end group
@group
If optional arg DO-NOT-MOVE is non-nil, then don't actually
move the yanking point; just return the Nth kill forward."

  (let ((interprogram-paste (and (= n 0)
                                 interprogram-paste-function
                                 (funcall interprogram-paste-function))))
@end group
@group
    (if interprogram-paste
        (progn
          ;; Disable the interprogram cut function when we add the new
          ;; text to the kill ring, so Emacs doesn't try to own the
          ;; selection, with identical text.
          (let ((interprogram-cut-function nil))
            (if (listp interprogram-paste)
              (mapc 'kill-new (nreverse interprogram-paste))
              (kill-new interprogram-paste)))
          (car kill-ring))
@end group
@group
      (or kill-ring (error "Kill ring is empty"))
      (let ((ARGth-kill-element
             (nthcdr (mod (- n (length kill-ring-yank-pointer))
                          (length kill-ring))
                     kill-ring)))
        (unless do-not-move
          (setq kill-ring-yank-pointer ARGth-kill-element)
          (when (and yank-pop-change-selection
                     (> n 0)
                     interprogram-cut-function)
            (funcall interprogram-cut-function (car ARGth-kill-element))))
        (car ARGth-kill-element)))))
@end group
@end smallexample

Remember also that the @code{kill-new} function sets
@code{kill-ring-yank-pointer} to the latest element of the kill
ring, which means that all the functions that call it set the value
indirectly: @code{kill-append}, @code{copy-region-as-kill},
@code{kill-ring-save}, @code{kill-line}, and @code{kill-region}.

@need 1500
Here is the line in @code{kill-new}, which is explained in
@ref{kill-new 函数, , @code{kill-new} 函数}.

@smallexample
(setq kill-ring-yank-pointer kill-ring)
@end smallexample

@ifnottex
@node Understanding current-kill
@unnumberedsubsec @code{current-kill} in Outline
@end ifnottex

The @code{current-kill} function looks complex, but as usual, it can
be understood by taking it apart piece by piece.  First look at it in
skeletal form:

@smallexample
@group
(defun current-kill (n &optional do-not-move)
  "Rotate the yanking point by N places, and then return that kill."
  (let @var{varlist}
    @var{body}@dots{})
@end group
@end smallexample

This function takes two arguments, one of which is optional.  It has a
documentation string.  It is @emph{not} interactive.

@menu
* Body of current-kill::
* Digression concerning error::  How to mislead humans, but not computers.
* Determining the Element::
@end menu

@ifnottex
@node Body of current-kill
@unnumberedsubsubsec The Body of @code{current-kill}
@end ifnottex

The body of the function definition is a @code{let} expression, which
itself has a body as well as a @var{varlist}.

The @code{let} expression declares a variable that will be only usable
within the bounds of this function.  This variable is called
@code{interprogram-paste} and is for copying to another program.  It
is not for copying within this instance of GNU Emacs.  Most window
systems provide a facility for interprogram pasting.  Sadly, that
facility usually provides only for the last element.  Most windowing
systems have not adopted a ring of many possibilities, even though
Emacs has provided it for decades.

The @code{if} expression has two parts, one if there exists
@code{interprogram-paste} and one if not.

@need 2000
Let us consider the else-part of the @code{current-kill}
function.  (The then-part uses the @code{kill-new} function, which
we have already described.  @xref{kill-new 函数, , @code{kill-new} 函数}.)

@smallexample
@group
(or kill-ring (error "Kill ring is empty"))
(let ((ARGth-kill-element
       (nthcdr (mod (- n (length kill-ring-yank-pointer))
                    (length kill-ring))
               kill-ring)))
  (or do-not-move
      (setq kill-ring-yank-pointer ARGth-kill-element))
  (car ARGth-kill-element))
@end group
@end smallexample

@noindent
The code first checks whether the kill ring has content; otherwise it
signals an error.

@need 1000
Note that the @code{or} expression is very similar to testing length
with an @code{if}:

@findex zerop
@findex error
@smallexample
@group
(if (zerop (length kill-ring))          ; @r{if-part}
    (error "Kill ring is empty"))       ; @r{then-part}
  ;; No else-part
@end group
@end smallexample

@noindent
If there is not anything in the kill ring, its length must be zero and
an error message sent to the user: @samp{Kill ring is empty}.  The
@code{current-kill} function uses an @code{or} expression which is
simpler.  But an @code{if} expression reminds us what goes on.

This @code{if} expression uses the function @code{zerop} which returns
true if the value it is testing is zero.  When @code{zerop} tests
true, the then-part of the @code{if} is evaluated.  The then-part is a
list starting with the function @code{error}, which is a function that
is similar to the @code{message} function
(@pxref{message, , The @code{message} Function}) in that
it prints a one-line message in the echo area.  However, in addition
to printing a message, @code{error} also stops evaluation of the
function within which it is embedded.  This means that the rest of the
function will not be evaluated if the length of the kill ring is zero.

Then the @code{current-kill} function selects the element to return.
The selection depends on the number of places that @code{current-kill}
rotates and on where @code{kill-ring-yank-pointer} points.

Next, either the optional @code{do-not-move} argument is true or the
current value of @code{kill-ring-yank-pointer} is set to point to the
list.  Finally, another expression returns the first element of the
list even if the @code{do-not-move} argument is true.

@ifnottex
@node Digression concerning error
@unnumberedsubsubsec Digression about the word ``error''
@end ifnottex

In my opinion, it is slightly misleading, at least to humans, to use
the term ``error'' as the name of the @code{error} function.  A better
term would be ``cancel''.  Strictly speaking, of course, you cannot
point to, much less rotate a pointer to a list that has no length, so
from the point of view of the computer, the word ``error'' is correct.
But a human expects to attempt this sort of thing, if only to find out
whether the kill ring is full or empty.  This is an act of
exploration.

From the human point of view, the act of exploration and discovery is
not necessarily an error, and therefore should not be labeled as one,
even in the bowels of a computer.  As it is, the code in Emacs implies
that a human who is acting virtuously, by exploring his or her
environment, is making an error.  This is bad.  Even though the computer
takes the same steps as it does when there is an error, a term such as
``cancel'' would have a clearer connotation.

@ifnottex
@node Determining the Element
@unnumberedsubsubsec Determining the Element
@end ifnottex

Among other actions, the else-part of the @code{if} expression sets
the value of @code{kill-ring-yank-pointer} to
@code{ARGth-kill-element} when the kill ring has something in it and
the value of @code{do-not-move} is @code{nil}.

@need 800
The code looks like this:

@smallexample
@group
(nthcdr (mod (- n (length kill-ring-yank-pointer))
             (length kill-ring))
        kill-ring)))
@end group
@end smallexample

This needs some examination.  Unless it is not supposed to move the
pointer, the @code{current-kill} function changes where
@code{kill-ring-yank-pointer} points.
That is what the
@w{@code{(setq kill-ring-yank-pointer ARGth-kill-element))}}
expression does.  Also, clearly, @code{ARGth-kill-element} is being
set to be equal to some @sc{cdr} of the kill ring, using the
@code{nthcdr} function that is described in an earlier section.
(@xref{copy-region-as-kill}.)  How does it do this?

As we have seen before (@pxref{nthcdr}), the @code{nthcdr} function
works by repeatedly taking the @sc{cdr} of a list---it takes the
@sc{cdr} of the @sc{cdr} of the @sc{cdr} @dots{}

@need 800
The two following expressions produce the same result:

@smallexample
@group
(setq kill-ring-yank-pointer (cdr kill-ring))

(setq kill-ring-yank-pointer (nthcdr 1 kill-ring))
@end group
@end smallexample

However, the @code{nthcdr} expression is more complicated.  It uses
the @code{mod} function to determine which @sc{cdr} to select.

(You will remember to look at inner functions first; indeed, we will
have to go inside the @code{mod}.)

The @code{mod} function returns the value of its first argument modulo
the second; that is to say, it returns the remainder after dividing
the first argument by the second.  The value returned has the same
sign as the second argument.

@need 800
Thus,

@smallexample
@group
(mod 12 4)
  @result{} 0  ;; @r{because there is no remainder}
(mod 13 4)
  @result{} 1
@end group
@end smallexample

@need 1250
In this case, the first argument is often smaller than the second.
That is fine.

@smallexample
@group
(mod 0 4)
  @result{} 0
(mod 1 4)
  @result{} 1
@end group
@end smallexample

We can guess what the @code{-} function does.  It is like @code{+} but
subtracts instead of adds; the @code{-} function subtracts its second
argument from its first.  Also, we already know what the @code{length}
function does (@pxref{长度}).  It returns the length of a list.

And @code{n} is the name of the required argument to the
@code{current-kill} function.

@need 1250
So when the first argument to @code{nthcdr} is zero, the @code{nthcdr}
expression returns the whole list, as you can see by evaluating the
following:

@smallexample
@group
;; kill-ring-yank-pointer @r{and} kill-ring @r{have a length of four}
;; @r{and} (mod (- 0 4) 4) @result{} 0
(nthcdr (mod (- 0 4) 4)
        '("fourth line of text"
          "third line"
          "second piece of text"
          "first some text"))
@end group
@end smallexample

@need 1250
When the first argument to the @code{current-kill} function is one,
the @code{nthcdr} expression returns the list without its first
element.

@smallexample
@group
(nthcdr (mod (- 1 4) 4)
        '("fourth line of text"
          "third line"
          "second piece of text"
          "first some text"))
@end group
@end smallexample

@cindex @samp{global variable} defined
@cindex @samp{variable, global}, defined
Incidentally, both @code{kill-ring} and @code{kill-ring-yank-pointer}
are @dfn{global variables}.  That means that any expression in Emacs
Lisp can access them.  They are not like the local variables set by
@code{let} or like the symbols in an argument list.
Local variables can only be accessed
within the @code{let} that defines them or the function that specifies
them in an argument list (and within expressions called by them).

@c texi2dvi fails when the name of the section is within ifnottex ...
@ifnottex
(@xref{避免混淆, , @code{let} 避免混淆}, and
@end ifnottex
@iftex
(@xref{Permanent Installation, , @code{let} Prevents Confusion}, and
@end iftex
@ref{defun, , The @code{defun} Macro}.)

@node yank
@appendixsec @code{yank}
@findex yank

After learning about @code{current-kill}, the code for the
@code{yank} function is almost easy.

The @code{yank} function does not use the
@code{kill-ring-yank-pointer} variable directly.  It calls
@code{insert-for-yank} which calls @code{current-kill} which sets the
@code{kill-ring-yank-pointer} variable.

@need 1250
The code looks like this:

@c in GNU Emacs 22
@smallexample
@group
(defun yank (&optional arg)
  "Reinsert (\"paste\") the last stretch of killed text.
More precisely, reinsert the stretch of killed text most recently
killed OR yanked.  Put point at end, and set mark at beginning.
With just \\[universal-argument] as argument, same but put point at beginning (and mark at end).
With argument N, reinsert the Nth most recently killed stretch of killed
text.

When this command inserts killed text into the buffer, it honors
`yank-excluded-properties' and `yank-handler' as described in the
doc string for `insert-for-yank-1', which see.

See also the command `yank-pop' (\\[yank-pop])."
@end group
@group
  (interactive "*P")
  (setq yank-window-start (window-start))
  ;; If we don't get all the way thru, make last-command indicate that
  ;; for the following command.
  (setq this-command t)
  (push-mark (point))
@end group
@group
  (insert-for-yank (current-kill (cond
                                  ((listp arg) 0)
                                  ((eq arg '-) -2)
                                  (t (1- arg)))))
  (if (consp arg)
      ;; This is like exchange-point-and-mark, but doesn't activate the mark.
      ;; It is cleaner to avoid activation, even though the command
      ;; loop would deactivate the mark because we inserted text.
      (goto-char (prog1 (mark t)
                   (set-marker (mark-marker) (point) (current-buffer)))))
@end group
@group
  ;; If we do get all the way thru, make this-command indicate that.
  (if (eq this-command t)
      (setq this-command 'yank))
  nil)
@end group
@end smallexample

The key expression is @code{insert-for-yank}, which inserts the string
returned by @code{current-kill}, but removes some text properties from
it.

However, before getting to that expression, the function sets the value
of @code{yank-window-start} to the position returned by the
@code{(window-start)} expression, the position at which the display
currently starts.  The @code{yank} function also sets
@code{this-command} and pushes the mark.

After it yanks the appropriate element, if the optional argument is a
@sc{cons} rather than a number or nothing, it puts point at beginning
of the yanked text and mark at its end.

(The @code{prog1} function is like @code{progn} but returns the value
of its first argument rather than the value of its last argument.  Its
first argument is forced to return the buffer's mark as an integer.
You can see the documentation for these functions by placing point
over them in this buffer and then typing @kbd{C-h f}
(@code{describe-function}) followed by a @kbd{RET}; the default is the
function.)

The last part of the function tells what to do when it succeeds.

@node yank-pop
@appendixsec @code{yank-pop}
@findex yank-pop

After understanding @code{yank} and @code{current-kill}, you know how
to approach the @code{yank-pop} function.  Leaving out the
documentation to save space, it looks like this:

@c GNU Emacs 22
@smallexample
@group
(defun yank-pop (&optional arg)
  "@dots{}"
  (interactive "*p")
  (if (not (eq last-command 'yank))
      (error "Previous command was not a yank"))
@end group
@group
  (setq this-command 'yank)
  (unless arg (setq arg 1))
  (let ((inhibit-read-only t)
        (before (< (point) (mark t))))
@end group
@group
    (if before
        (funcall (or yank-undo-function 'delete-region) (point) (mark t))
      (funcall (or yank-undo-function 'delete-region) (mark t) (point)))
    (setq yank-undo-function nil)
@end group
@group
    (set-marker (mark-marker) (point) (current-buffer))
    (insert-for-yank (current-kill arg))
    ;; Set the window start back where it was in the yank command,
    ;; if possible.
    (set-window-start (selected-window) yank-window-start t)
@end group
@group
    (if before
        ;; This is like exchange-point-and-mark,
        ;;     but doesn't activate the mark.
        ;; It is cleaner to avoid activation, even though the command
        ;; loop would deactivate the mark because we inserted text.
        (goto-char (prog1 (mark t)
                     (set-marker (mark-marker)
                                 (point)
                                 (current-buffer))))))
  nil)
@end group
@end smallexample

The function is interactive with a small @samp{p} so the prefix
argument is processed and passed to the function.  The command can
only be used after a previous yank; otherwise an error message is
sent.  This check uses the variable @code{last-command} which is set
by @code{yank} and is discussed elsewhere.
(@xref{copy-region-as-kill}.)

The @code{let} clause sets the variable @code{before} to true or false
depending whether point is before or after mark and then the region
between point and mark is deleted.  This is the region that was just
inserted by the previous yank and it is this text that will be
replaced.

@code{funcall} calls its first argument as a function, passing
remaining arguments to it.  The first argument is whatever the
@code{or} expression returns.  The two remaining arguments are the
positions of point and mark set by the preceding @code{yank} command.

There is more, but that is the hardest part.

@node ring file
@appendixsec The @file{ring.el} File
@cindex @file{ring.el} file

Interestingly, GNU Emacs posses a file called @file{ring.el} that
provides many of the features we just discussed.  But functions such
as @code{kill-ring-yank-pointer} do not use this library, possibly
because they were written earlier.

@node Full Graph
@appendix A Graph with Labeled Axes

Printed axes help you understand a graph.  They convey scale.  In an
earlier chapter (@pxref{Readying a Graph, ,  Readying a Graph}), we
wrote the code to print the body of a graph.  Here we write the code
for printing and labeling vertical and horizontal axes, along with the
body itself.

@menu
* Labeled Example::
* print-graph Varlist::         @code{let} expression in @code{print-graph}.
* print-Y-axis::                Print a label for the vertical axis.
* print-X-axis::                Print a horizontal label.
* Print Whole Graph::           The function to print a complete graph.
@end menu

@ifnottex
@node Labeled Example
@unnumberedsec Labeled Example Graph
@end ifnottex

Since insertions fill a buffer to the right and below point, the new
graph printing function should first print the Y or vertical axis,
then the body of the graph, and finally the X or horizontal axis.
This sequence lays out for us the contents of the function:

@enumerate
@item
Set up code.

@item
Print Y axis.

@item
Print body of graph.

@item
Print X axis.
@end enumerate

@need 800
Here is an example of how a finished graph should look:

@smallexample
@group
    10 -
                  *
                  *  *
                  *  **
                  *  ***
     5 -      *   *******
            * *** *******
            *************
          ***************
     1 - ****************
         |   |    |    |
         1   5   10   15
@end group
@end smallexample

@noindent
In this graph, both the vertical and the horizontal axes are labeled
with numbers.  However, in some graphs, the horizontal axis is time
and would be better labeled with months, like this:

@smallexample
@group
     5 -      *
            * ** *
            *******
          ********** **
     1 - **************
         |    ^      |
         Jan  June   Jan
@end group
@end smallexample

Indeed, with a little thought, we can easily come up with a variety of
vertical and horizontal labeling schemes.  Our task could become
complicated.  But complications breed confusion.  Rather than permit
this, it is better choose a simple labeling scheme for our first
effort, and to modify or replace it later.

@need 1200
These considerations suggest the following outline for the
@code{print-graph} function:

@smallexample
@group
(defun print-graph (numbers-list)
  "@var{documentation}@dots{}"
  (let ((height  @dots{}
        @dots{}))
@end group
@group
    (print-Y-axis height @dots{} )
    (graph-body-print numbers-list)
    (print-X-axis @dots{} )))
@end group
@end smallexample

We can work on each part of the @code{print-graph} function definition
in turn.

@node print-graph Varlist
@appendixsec The @code{print-graph} Varlist
@cindex @code{print-graph} varlist

In writing the @code{print-graph} function, the first task is to write
the varlist in the @code{let} expression.  (We will leave aside for the
moment any thoughts about making the function interactive or about the
contents of its documentation string.)

The varlist should set several values.  Clearly, the top of the label
for the vertical axis must be at least the height of the graph, which
means that we must obtain this information here.  Note that the
@code{print-graph-body} function also requires this information.  There
is no reason to calculate the height of the graph in two different
places, so we should change @code{print-graph-body} from the way we
defined it earlier to take advantage of the calculation.

Similarly, both the function for printing the X axis labels and the
@code{print-graph-body} function need to learn the value of the width of
each symbol.  We can perform the calculation here and change the
definition for @code{print-graph-body} from the way we defined it in the
previous chapter.

The length of the label for the horizontal axis must be at least as long
as the graph.  However, this information is used only in the function
that prints the horizontal axis, so it does not need to be calculated here.

These thoughts lead us directly to the following form for the varlist
in the @code{let} for @code{print-graph}:

@smallexample
@group
(let ((height (apply 'max numbers-list)) ; @r{First version.}
      (symbol-width (length graph-blank)))
@end group
@end smallexample

@noindent
As we shall see, this expression is not quite right.

@need 2000
@node print-Y-axis
@appendixsec The @code{print-Y-axis} Function
@cindex Axis, print vertical
@cindex Y axis printing
@cindex Vertical axis printing
@cindex Print vertical axis

The job of the @code{print-Y-axis} function is to print a label for
the vertical axis that looks like this:

@smallexample
@group
    10 -




     5 -



     1 -
@end group
@end smallexample

@noindent
The function should be passed the height of the graph, and then should
construct and insert the appropriate numbers and marks.

@menu
* print-Y-axis in Detail::
* Height of label::             What height for the Y axis?
* Compute a Remainder::         How to compute the remainder of a division.
* Y Axis Element::              Construct a line for the Y axis.
* Y-axis-column::               Generate a list of Y axis labels.
* print-Y-axis Penultimate::    A not quite final version.
@end menu

@ifnottex
@node print-Y-axis in Detail
@unnumberedsubsec The @code{print-Y-axis} Function in Detail
@end ifnottex

It is easy enough to see in the figure what the Y axis label should
look like; but to say in words, and then to write a function
definition to do the job is another matter.  It is not quite true to
say that we want a number and a tic every five lines: there are only
three lines between the @samp{1} and the @samp{5} (lines 2, 3, and 4),
but four lines between the @samp{5} and the @samp{10} (lines 6, 7, 8,
and 9).  It is better to say that we want a number and a tic mark on
the base line (number 1) and then that we want a number and a tic on
the fifth line from the bottom and on every line that is a multiple of
five.

@ifnottex
@node Height of label
@unnumberedsubsec What height should the label be?
@end ifnottex

The next issue is what height the label should be?  Suppose the maximum
height of tallest column of the graph is seven.  Should the highest
label on the Y axis be @samp{5 -}, and should the graph stick up above
the label?  Or should the highest label be @samp{7 -}, and mark the peak
of the graph?  Or should the highest label be @code{10 -}, which is a
multiple of five, and be higher than the topmost value of the graph?

The latter form is preferred.  Most graphs are drawn within rectangles
whose sides are an integral number of steps long---5, 10, 15, and so
on for a step distance of five.  But as soon as we decide to use a
step height for the vertical axis, we discover that the simple
expression in the varlist for computing the height is wrong.  The
expression is @code{(apply 'max numbers-list)}.  This returns the
precise height, not the maximum height plus whatever is necessary to
round up to the nearest multiple of five.  A more complex expression
is required.

As usual in cases like this, a complex problem becomes simpler if it is
divided into several smaller problems.

First, consider the case when the highest value of the graph is an
integral multiple of five---when it is 5, 10, 15, or some higher
multiple of five.  We can use this value as the Y axis height.

A fairly simply way to determine whether a number is a multiple of
five is to divide it by five and see if the division results in a
remainder.  If there is no remainder, the number is a multiple of
five.  Thus, seven divided by five has a remainder of two, and seven
is not an integral multiple of five.  Put in slightly different
language, more reminiscent of the classroom, five goes into seven
once, with a remainder of two.  However, five goes into ten twice,
with no remainder: ten is an integral multiple of five.

@node Compute a Remainder
@appendixsubsec Side Trip: Compute a Remainder

@findex % @r{(remainder function)}
@cindex Remainder function, @code{%}
In Lisp, the function for computing a remainder is @code{%}.  The
function returns the remainder of its first argument divided by its
second argument.  As it happens, @code{%} is a function in Emacs Lisp
that you cannot discover using @code{apropos}: you find nothing if you
type @kbd{M-x apropos @key{RET} remainder @key{RET}}.  The only way to
learn of the existence of @code{%} is to read about it in a book such
as this or in the Emacs Lisp sources.

You can try the @code{%} function by evaluating the following two
expressions:

@smallexample
@group
(% 7 5)

(% 10 5)
@end group
@end smallexample

@noindent
The first expression returns 2 and the second expression returns 0.

To test whether the returned value is zero or some other number, we
can use the @code{zerop} function.  This function returns @code{t} if
its argument, which must be a number, is zero.

@smallexample
@group
(zerop (% 7 5))
     @result{} nil

(zerop (% 10 5))
     @result{} t
@end group
@end smallexample

Thus, the following expression will return @code{t} if the height
of the graph is evenly divisible by five:

@smallexample
(zerop (% height 5))
@end smallexample

@noindent
(The value of @code{height}, of course, can be found from @code{(apply
'max numbers-list)}.)

On the other hand, if the value of @code{height} is not a multiple of
five, we want to reset the value to the next higher multiple of five.
This is straightforward arithmetic using functions with which we are
already familiar.  First, we divide the value of @code{height} by five
to determine how many times five goes into the number.  Thus, five
goes into twelve twice.  If we add one to this quotient and multiply by
five, we will obtain the value of the next multiple of five that is
larger than the height.  Five goes into twelve twice.  Add one to two,
and multiply by five; the result is fifteen, which is the next multiple
of five that is higher than twelve.  The Lisp expression for this is:

@smallexample
(* (1+ (/ height 5)) 5)
@end smallexample

@noindent
For example, if you evaluate the following, the result is 15:

@smallexample
(* (1+ (/ 12 5)) 5)
@end smallexample

All through this discussion, we have been using 5 as the value
for spacing labels on the Y axis; but we may want to use some other
value.  For generality, we should replace 5 with a variable to
which we can assign a value.  The best name I can think of for this
variable is @code{Y-axis-label-spacing}.

@need 1250
Using this term, and an @code{if} expression, we produce the
following:

@smallexample
@group
(if (zerop (% height Y-axis-label-spacing))
    height
  ;; @r{else}
  (* (1+ (/ height Y-axis-label-spacing))
     Y-axis-label-spacing))
@end group
@end smallexample

@noindent
This expression returns the value of @code{height} itself if the height
is an even multiple of the value of the @code{Y-axis-label-spacing} or
else it computes and returns a value of @code{height} that is equal to
the next higher multiple of the value of the @code{Y-axis-label-spacing}.

We can now include this expression in the @code{let} expression of the
@code{print-graph} function (after first setting the value of
@code{Y-axis-label-spacing}):
@vindex Y-axis-label-spacing

@smallexample
@group
(defvar Y-axis-label-spacing 5
  "Number of lines from one Y axis label to next.")
@end group

@group
@dots{}
(let* ((height (apply 'max numbers-list))
       (height-of-top-line
        (if (zerop (% height Y-axis-label-spacing))
            height
@end group
@group
          ;; @r{else}
          (* (1+ (/ height Y-axis-label-spacing))
             Y-axis-label-spacing)))
       (symbol-width (length graph-blank))))
@dots{}
@end group
@end smallexample

@noindent
(Note use of the  @code{let*} function: the initial value of height is
computed once by the @code{(apply 'max numbers-list)} expression and
then the resulting value of  @code{height} is used to compute its
final value.  @xref{fwd-para let, , The @code{let*} expression}, for
more about @code{let*}.)

@node Y Axis Element
@appendixsubsec Construct a Y Axis Element

When we print the vertical axis, we want to insert strings such as
@w{@samp{5 -}} and @w{@samp{10 - }} every five lines.
Moreover, we want the numbers and dashes to line up, so shorter
numbers must be padded with leading spaces.  If some of the strings
use two digit numbers, the strings with single digit numbers must
include a leading blank space before the number.

@findex number-to-string
To figure out the length of the number, the @code{length} function is
used.  But the @code{length} function works only with a string, not with
a number.  So the number has to be converted from being a number to
being a string.  This is done with the @code{number-to-string} function.
For example,

@smallexample
@group
(length (number-to-string 35))
     @result{} 2

(length (number-to-string 100))
     @result{} 3
@end group
@end smallexample

@noindent
(@code{number-to-string} is also called @code{int-to-string}; you will
see this alternative name in various sources.)

In addition, in each label, each number is followed by a string such
as @w{@samp{ - }}, which we will call the @code{Y-axis-tic} marker.
This variable is defined with @code{defvar}:

@vindex Y-axis-tic
@smallexample
@group
(defvar Y-axis-tic " - "
   "String that follows number in a Y axis label.")
@end group
@end smallexample

The length of the Y label is the sum of the length of the Y axis tic
mark and the length of the number of the top of the graph.

@smallexample
(length (concat (number-to-string height) Y-axis-tic)))
@end smallexample

This value will be calculated by the @code{print-graph} function in
its varlist as @code{full-Y-label-width} and passed on.  (Note that we
did not think to include this in the varlist when we first proposed it.)

To make a complete vertical axis label, a tic mark is concatenated
with a number; and the two together may be preceded by one or more
spaces depending on how long the number is.  The label consists of
three parts: the (optional) leading spaces, the number, and the tic
mark.  The function is passed the value of the number for the specific
row, and the value of the width of the top line, which is calculated
(just once) by @code{print-graph}.

@smallexample
@group
(defun Y-axis-element (number full-Y-label-width)
  "Construct a NUMBERed label element.
A numbered element looks like this `  5 - ',
and is padded as needed so all line up with
the element for the largest number."
@end group
@group
  (let* ((leading-spaces
         (- full-Y-label-width
            (length
             (concat (number-to-string number)
                     Y-axis-tic)))))
@end group
@group
    (concat
     (make-string leading-spaces ? )
     (number-to-string number)
     Y-axis-tic)))
@end group
@end smallexample

The @code{Y-axis-element} function concatenates together the leading
spaces, if any; the number, as a string; and the tic mark.

To figure out how many leading spaces the label will need, the
function subtracts the actual length of the label---the length of the
number plus the length of the tic mark---from the desired label width.

@findex make-string
Blank spaces are inserted using the @code{make-string} function.  This
function takes two arguments: the first tells it how long the string
will be and the second is a symbol for the character to insert, in a
special format.  The format is a question mark followed by a blank
space, like this, @samp{? }.  @xref{Character Type, , Character Type,
elisp, The GNU Emacs Lisp Reference Manual}, for a description of the
syntax for characters.  (Of course, you might want to replace the
blank space by some other character @dots{}  You know what to do.)

The @code{number-to-string} function is used in the concatenation
expression, to convert the number to a string that is concatenated
with the leading spaces and the tic mark.

@node Y-axis-column
@appendixsubsec Create a Y Axis Column

The preceding functions provide all the tools needed to construct a
function that generates a list of numbered and blank strings to insert
as the label for the vertical axis:

@findex Y-axis-column
@smallexample
@group
(defun Y-axis-column (height width-of-label)
  "Construct list of Y axis labels and blank strings.
For HEIGHT of line above base and WIDTH-OF-LABEL."
  (let (Y-axis)
@group
@end group
    (while (> height 1)
      (if (zerop (% height Y-axis-label-spacing))
          ;; @r{Insert label.}
          (setq Y-axis
                (cons
                 (Y-axis-element height width-of-label)
                 Y-axis))
@group
@end group
        ;; @r{Else, insert blanks.}
        (setq Y-axis
              (cons
               (make-string width-of-label ? )
               Y-axis)))
      (setq height (1- height)))
    ;; @r{Insert base line.}
    (setq Y-axis
          (cons (Y-axis-element 1 width-of-label) Y-axis))
    (nreverse Y-axis)))
@end group
@end smallexample

In this function, we start with the value of @code{height} and
repetitively subtract one from its value.  After each subtraction, we
test to see whether the value is an integral multiple of the
@code{Y-axis-label-spacing}.  If it is, we construct a numbered label
using the @code{Y-axis-element} function; if not, we construct a
blank label using the @code{make-string} function.  The base line
consists of the number one followed by a tic mark.

@need 2000
@node print-Y-axis Penultimate
@appendixsubsec The Not Quite Final Version of @code{print-Y-axis}

The list constructed by the @code{Y-axis-column} function is passed to
the @code{print-Y-axis} function, which inserts the list as a column.

@findex print-Y-axis
@smallexample
@group
(defun print-Y-axis (height full-Y-label-width)
  "Insert Y axis using HEIGHT and FULL-Y-LABEL-WIDTH.
Height must be the maximum height of the graph.
Full width is the width of the highest label element."
;; Value of height and full-Y-label-width
;; are passed by print-graph.
@end group
@group
  (let ((start (point)))
    (insert-rectangle
     (Y-axis-column height full-Y-label-width))
    ;; @r{Place point ready for inserting graph.}
    (goto-char start)
    ;; @r{Move point forward by value of} full-Y-label-width
    (forward-char full-Y-label-width)))
@end group
@end smallexample

The @code{print-Y-axis} uses the @code{insert-rectangle} function to
insert the Y axis labels created by the @code{Y-axis-column} function.
In addition, it places point at the correct position for printing the body of
the graph.

You can test @code{print-Y-axis}:

@enumerate
@item
Install

@smallexample
@group
Y-axis-label-spacing
Y-axis-tic
Y-axis-element
Y-axis-column
print-Y-axis
@end group
@end smallexample

@item
Copy the following expression:

@smallexample
(print-Y-axis 12 5)
@end smallexample

@item
Switch to the @file{*scratch*} buffer and place the cursor where you
want the axis labels to start.

@item
Type @kbd{M-:} (@code{eval-expression}).

@item
Yank the @code{graph-body-print} expression into the minibuffer
with @kbd{C-y} (@code{yank)}.

@item
Press @key{RET} to evaluate the expression.
@end enumerate

Emacs will print labels vertically, the top one being @w{@samp{10 -@w{
}}}.  (The @code{print-graph} function will pass the value of
@code{height-of-top-line}, which in this case will end up as 15,
thereby getting rid of what might appear as a bug.)

@need 2000
@node print-X-axis
@appendixsec The @code{print-X-axis} Function
@cindex Axis, print horizontal
@cindex X axis printing
@cindex Print horizontal axis
@cindex Horizontal axis printing

X axis labels are much like Y axis labels, except that the ticks are on a
line above the numbers.  Labels should look like this:

@smallexample
@group
    |   |    |    |
    1   5   10   15
@end group
@end smallexample

The first tic is under the first column of the graph and is preceded by
several blank spaces.  These spaces provide room in rows above for the Y
axis labels.  The second, third, fourth, and subsequent ticks are all
spaced equally, according to the value of @code{X-axis-label-spacing}.

The second row of the X axis consists of numbers, preceded by several
blank spaces and also separated according to the value of the variable
@code{X-axis-label-spacing}.

The value of the variable @code{X-axis-label-spacing} should itself be
measured in units of @code{symbol-width}, since you may want to change
the width of the symbols that you are using to print the body of the
graph without changing the ways the graph is labeled.

@menu
* Similarities differences::    Much like @code{print-Y-axis}, but not exactly.
* X Axis Tic Marks::            Create tic marks for the horizontal axis.
@end menu

@ifnottex
@node Similarities differences
@unnumberedsubsec Similarities and differences
@end ifnottex

The @code{print-X-axis} function is constructed in more or less the
same fashion as the @code{print-Y-axis} function except that it has
two lines: the line of tic marks and the numbers.  We will write a
separate function to print each line and then combine them within the
@code{print-X-axis} function.

This is a three step process:

@enumerate
@item
Write a function to print the X axis tic marks, @code{print-X-axis-tic-line}.

@item
Write a function to print the X numbers, @code{print-X-axis-numbered-line}.

@item
Write a function to print both lines, the @code{print-X-axis} function,
using @code{print-X-axis-tic-line} and
@code{print-X-axis-numbered-line}.
@end enumerate

@node X Axis Tic Marks
@appendixsubsec X Axis Tic Marks

The first function should print the X axis tic marks.  We must specify
the tic marks themselves and their spacing:

@smallexample
@group
(defvar X-axis-label-spacing
  (if (boundp 'graph-blank)
      (* 5 (length graph-blank)) 5)
  "Number of units from one X axis label to next.")
@end group
@end smallexample

@noindent
(Note that the value of @code{graph-blank} is set by another
@code{defvar}.  The @code{boundp} predicate checks whether it has
already been set; @code{boundp} returns @code{nil} if it has not.  If
@code{graph-blank} were unbound and we did not use this conditional
construction, we would enter the debugger and see an error message
saying @samp{@w{Debugger entered--Lisp error:}
@w{(void-variable graph-blank)}}.)

@need 1200
Here is the @code{defvar} for @code{X-axis-tic-symbol}:

@smallexample
@group
(defvar X-axis-tic-symbol "|"
  "String to insert to point to a column in X axis.")
@end group
@end smallexample

@need 1250
The goal is to make a line that looks like this:

@smallexample
       |   |    |    |
@end smallexample

The first tic is indented so that it is under the first column, which is
indented to provide space for the Y axis labels.

A tic element consists of the blank spaces that stretch from one tic to
the next plus a tic symbol.  The number of blanks is determined by the
width of the tic symbol and the @code{X-axis-label-spacing}.

@need 1250
The code looks like this:

@smallexample
@group
;;; X-axis-tic-element
@dots{}
(concat
 (make-string
  ;; @r{Make a string of blanks.}
  (-  (* symbol-width X-axis-label-spacing)
      (length X-axis-tic-symbol))
  ? )
 ;; @r{Concatenate blanks with tic symbol.}
 X-axis-tic-symbol)
@dots{}
@end group
@end smallexample

Next, we determine how many blanks are needed to indent the first tic
mark to the first column of the graph.  This uses the value of
@code{full-Y-label-width} passed it by the @code{print-graph} function.

@need 1250
The code to make @code{X-axis-leading-spaces}
looks like this:

@smallexample
@group
;; X-axis-leading-spaces
@dots{}
(make-string full-Y-label-width ? )
@dots{}
@end group
@end smallexample

We also need to determine the length of the horizontal axis, which is
the length of the numbers list, and the number of ticks in the horizontal
axis:

@smallexample
@group
;; X-length
@dots{}
(length numbers-list)
@end group

@group
;; tic-width
@dots{}
(* symbol-width X-axis-label-spacing)
@end group

@group
;; number-of-X-ticks
(if (zerop (% (X-length tic-width)))
    (/ (X-length tic-width))
  (1+ (/ (X-length tic-width))))
@end group
@end smallexample

@need 1250
All this leads us directly to the function for printing the X axis tic line:

@findex print-X-axis-tic-line
@smallexample
@group
(defun print-X-axis-tic-line
  (number-of-X-tics X-axis-leading-spaces X-axis-tic-element)
  "Print ticks for X axis."
    (insert X-axis-leading-spaces)
    (insert X-axis-tic-symbol)  ; @r{Under first column.}
@end group
@group
    ;; @r{Insert second tic in the right spot.}
    (insert (concat
             (make-string
              (-  (* symbol-width X-axis-label-spacing)
                  ;; @r{Insert white space up to second tic symbol.}
                  (* 2 (length X-axis-tic-symbol)))
              ? )
             X-axis-tic-symbol))
@end group
@group
    ;; @r{Insert remaining ticks.}
    (while (> number-of-X-tics 1)
      (insert X-axis-tic-element)
      (setq number-of-X-tics (1- number-of-X-tics))))
@end group
@end smallexample

The line of numbers is equally straightforward:

@need 1250
First, we create a numbered element with blank spaces before each number:

@findex X-axis-element
@smallexample
@group
(defun X-axis-element (number)
  "Construct a numbered X axis element."
  (let ((leading-spaces
         (-  (* symbol-width X-axis-label-spacing)
             (length (number-to-string number)))))
    (concat (make-string leading-spaces ? )
            (number-to-string number))))
@end group
@end smallexample

Next, we create the function to print the numbered line, starting with
the number 1 under the first column:

@findex print-X-axis-numbered-line
@smallexample
@group
(defun print-X-axis-numbered-line
  (number-of-X-tics X-axis-leading-spaces)
  "Print line of X-axis numbers"
  (let ((number X-axis-label-spacing))
    (insert X-axis-leading-spaces)
    (insert "1")
@end group
@group
    (insert (concat
             (make-string
              ;; @r{Insert white space up to next number.}
              (-  (* symbol-width X-axis-label-spacing) 2)
              ? )
             (number-to-string number)))
@end group
@group
    ;; @r{Insert remaining numbers.}
    (setq number (+ number X-axis-label-spacing))
    (while (> number-of-X-tics 1)
      (insert (X-axis-element number))
      (setq number (+ number X-axis-label-spacing))
      (setq number-of-X-tics (1- number-of-X-tics)))))
@end group
@end smallexample

Finally, we need to write the @code{print-X-axis} that uses
@code{print-X-axis-tic-line} and
@code{print-X-axis-numbered-line}.

The function must determine the local values of the variables used by both
@code{print-X-axis-tic-line} and @code{print-X-axis-numbered-line}, and
then it must call them.  Also, it must print the carriage return that
separates the two lines.

The function consists of a varlist that specifies five local variables,
and calls to each of the two line printing functions:

@findex print-X-axis
@smallexample
@group
(defun print-X-axis (numbers-list)
  "Print X axis labels to length of NUMBERS-LIST."
  (let* ((leading-spaces
          (make-string full-Y-label-width ? ))
@end group
@group
       ;; symbol-width @r{is provided by} graph-body-print
       (tic-width (* symbol-width X-axis-label-spacing))
       (X-length (length numbers-list))
@end group
@group
       (X-tic
        (concat
         (make-string
@end group
@group
          ;; @r{Make a string of blanks.}
          (-  (* symbol-width X-axis-label-spacing)
              (length X-axis-tic-symbol))
          ? )
@end group
@group
         ;; @r{Concatenate blanks with tic symbol.}
         X-axis-tic-symbol))
@end group
@group
       (tic-number
        (if (zerop (% X-length tic-width))
            (/ X-length tic-width)
          (1+ (/ X-length tic-width)))))
@end group
@group
    (print-X-axis-tic-line tic-number leading-spaces X-tic)
    (insert "\n")
    (print-X-axis-numbered-line tic-number leading-spaces)))
@end group
@end smallexample

@need 1250
You can test @code{print-X-axis}:

@enumerate
@item
Install @code{X-axis-tic-symbol}, @code{X-axis-label-spacing},
@code{print-X-axis-tic-line}, as well as @code{X-axis-element},
@code{print-X-axis-numbered-line}, and @code{print-X-axis}.

@item
Copy the following expression:

@smallexample
@group
(progn
 (let ((full-Y-label-width 5)
       (symbol-width 1))
   (print-X-axis
    '(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16))))
@end group
@end smallexample

@item
Switch to the @file{*scratch*} buffer and place the cursor where you
want the axis labels to start.

@item
Type @kbd{M-:} (@code{eval-expression}).

@item
Yank the test expression into the minibuffer
with @kbd{C-y} (@code{yank)}.

@item
Press @key{RET} to evaluate the expression.
@end enumerate

@need 1250
Emacs will print the horizontal axis like this:
@sp 1

@smallexample
@group
     |   |    |    |    |
     1   5   10   15   20
@end group
@end smallexample

@node Print Whole Graph
@appendixsec Printing the Whole Graph
@cindex Printing the whole graph
@cindex Whole graph printing
@cindex Graph, printing all

Now we are nearly ready to print the whole graph.

The function to print the graph with the proper labels follows the
outline we created earlier (@pxref{Full Graph, , A Graph with Labeled
Axes}), but with additions.

@need 1250
Here is the outline:

@smallexample
@group
(defun print-graph (numbers-list)
  "@var{documentation}@dots{}"
  (let ((height  @dots{}
        @dots{}))
@end group
@group
    (print-Y-axis height @dots{} )
    (graph-body-print numbers-list)
    (print-X-axis @dots{} )))
@end group
@end smallexample

@menu
* The final version::           A few changes.
* Test print-graph::            Run a short test.
* Graphing words in defuns::    Executing the final code.
* lambda::                      How to write an anonymous function.
* mapcar::                      Apply a function to elements of a list.
* Another Bug::                 Yet another bug @dots{} most insidious.
* Final printed graph::         The graph itself!
@end menu

@ifnottex
@node The final version
@unnumberedsubsec Changes for the Final Version
@end ifnottex

The final version is different from what we planned in two ways:
first, it contains additional values calculated once in the varlist;
second, it carries an option to specify the labels' increment per row.
This latter feature turns out to be essential; otherwise, a graph may
have more rows than fit on a display or on a sheet of paper.

@need 1500
This new feature requires a change to the @code{Y-axis-column}
function, to add @code{vertical-step} to it.  The function looks like
this:

@findex Y-axis-column @r{Final version.}
@smallexample
@group
;;; @r{Final version.}
(defun Y-axis-column
  (height width-of-label &optional vertical-step)
  "Construct list of labels for Y axis.
HEIGHT is maximum height of graph.
WIDTH-OF-LABEL is maximum width of label.
VERTICAL-STEP, an option, is a positive integer
that specifies how much a Y axis label increments
for each line.  For example, a step of 5 means
that each line is five units of the graph."
@end group
@group
  (let (Y-axis
        (number-per-line (or vertical-step 1)))
    (while (> height 1)
      (if (zerop (% height Y-axis-label-spacing))
@end group
@group
          ;; @r{Insert label.}
          (setq Y-axis
                (cons
                 (Y-axis-element
                  (* height number-per-line)
                  width-of-label)
                 Y-axis))
@end group
@group
        ;; @r{Else, insert blanks.}
        (setq Y-axis
              (cons
               (make-string width-of-label ? )
               Y-axis)))
      (setq height (1- height)))
@end group
@group
    ;; @r{Insert base line.}
    (setq Y-axis (cons (Y-axis-element
                        (or vertical-step 1)
                        width-of-label)
                       Y-axis))
    (nreverse Y-axis)))
@end group
@end smallexample

The values for the maximum height of graph and the width of a symbol
are computed by @code{print-graph} in its @code{let} expression; so
@code{graph-body-print} must be changed to accept them.

@findex graph-body-print @r{Final version.}
@smallexample
@group
;;; @r{Final version.}
(defun graph-body-print (numbers-list height symbol-width)
  "Print a bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values.
HEIGHT is maximum height of graph.
SYMBOL-WIDTH is number of each column."
@end group
@group
  (let (from-position)
    (while numbers-list
      (setq from-position (point))
      (insert-rectangle
       (column-of-graph height (car numbers-list)))
      (goto-char from-position)
      (forward-char symbol-width)
@end group
@group
      ;; @r{Draw graph column by column.}
      (sit-for 0)
      (setq numbers-list (cdr numbers-list)))
    ;; @r{Place point for X axis labels.}
    (forward-line height)
    (insert "\n")))
@end group
@end smallexample

@need 1250
Finally, the code for the @code{print-graph} function:

@findex print-graph @r{Final version.}
@smallexample
@group
;;; @r{Final version.}
(defun print-graph
  (numbers-list &optional vertical-step)
  "Print labeled bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values.
@end group

@group
Optionally, VERTICAL-STEP, a positive integer,
specifies how much a Y axis label increments for
each line.  For example, a step of 5 means that
each row is five units."
@end group
@group
  (let* ((symbol-width (length graph-blank))
         ;; @code{height} @r{is both the largest number}
         ;; @r{and the number with the most digits.}
         (height (apply 'max numbers-list))
@end group
@group
         (height-of-top-line
          (if (zerop (% height Y-axis-label-spacing))
              height
            ;; @r{else}
            (* (1+ (/ height Y-axis-label-spacing))
               Y-axis-label-spacing)))
@end group
@group
         (vertical-step (or vertical-step 1))
         (full-Y-label-width
          (length
@end group
@group
           (concat
            (number-to-string
             (* height-of-top-line vertical-step))
            Y-axis-tic))))
@end group

@group
    (print-Y-axis
     height-of-top-line full-Y-label-width vertical-step)
@end group
@group
    (graph-body-print
     numbers-list height-of-top-line symbol-width)
    (print-X-axis numbers-list)))
@end group
@end smallexample

@node Test print-graph
@appendixsubsec Testing @code{print-graph}

@need 1250
We can test the @code{print-graph} function with a short list of numbers:

@enumerate
@item
Install the final versions of @code{Y-axis-column},
@code{graph-body-print}, and @code{print-graph} (in addition to the
rest of the code.)

@item
Copy the following expression:

@smallexample
(print-graph '(3 2 5 6 7 5 3 4 6 4 3 2 1))
@end smallexample

@item
Switch to the @file{*scratch*} buffer and place the cursor where you
want the axis labels to start.

@item
Type @kbd{M-:} (@code{eval-expression}).

@item
Yank the test expression into the minibuffer
with @kbd{C-y} (@code{yank)}.

@item
Press @key{RET} to evaluate the expression.
@end enumerate

@need 1250
Emacs will print a graph that looks like this:

@smallexample
@group
10 -


         *
        **   *
 5 -   ****  *
       **** ***
     * *********
     ************
 1 - *************

     |   |    |    |
     1   5   10   15
@end group
@end smallexample

@need 1200
On the other hand, if you pass @code{print-graph} a
@code{vertical-step} value of 2, by evaluating this expression:

@smallexample
(print-graph '(3 2 5 6 7 5 3 4 6 4 3 2 1) 2)
@end smallexample

@need 1250
@noindent
The graph looks like this:

@smallexample
@group
20 -


         *
        **   *
10 -   ****  *
       **** ***
     * *********
     ************
 2 - *************

     |   |    |    |
     1   5   10   15
@end group
@end smallexample

@noindent
(A question: is the @samp{2} on the bottom of the vertical axis a bug or a
feature?  If you think it is a bug, and should be a @samp{1} instead, (or
even a @samp{0}), you can modify the sources.)

@node Graphing words in defuns
@appendixsubsec Graphing Numbers of Words and Symbols

Now for the graph for which all this code was written: a graph that
shows how many function definitions contain fewer than 10 words and
symbols, how many contain between 10 and 19 words and symbols, how
many contain between 20 and 29 words and symbols, and so on.

This is a multi-step process.  First make sure you have loaded all the
requisite code.

@need 1500
It is a good idea to reset the value of @code{top-of-ranges} in case
you have set it to some different value.  You can evaluate the
following:

@smallexample
@group
(setq top-of-ranges
 '(10  20  30  40  50
   60  70  80  90 100
  110 120 130 140 150
  160 170 180 190 200
  210 220 230 240 250
  260 270 280 290 300)
@end group
@end smallexample

@noindent
Next create a list of the number of words and symbols in each range.

@need 1500
@noindent
Evaluate the following:

@smallexample
@group
(setq list-for-graph
       (defuns-per-range
         (sort
          (recursive-lengths-list-many-files
           (directory-files "/usr/local/emacs/lisp"
                            t ".+el$"))
          '<)
         top-of-ranges))
@end group
@end smallexample

@noindent
On my old machine, this took about an hour.  It looked though 303 Lisp
files in my copy of Emacs version 19.23.  After all that computing,
the @code{list-for-graph} had this value:

@smallexample
@group
(537 1027 955 785 594 483 349 292 224 199 166 120 116 99
90 80 67 48 52 45 41 33 28 26 25 20 12 28 11 13 220)
@end group
@end smallexample

@noindent
This means that my copy of Emacs had 537 function definitions with
fewer than 10 words or symbols in them, 1,027 function definitions
with 10 to 19 words or symbols in them, 955 function definitions with
20 to 29 words or symbols in them, and so on.

Clearly, just by looking at this list we can see that most function
definitions contain ten to thirty words and symbols.

Now for printing.  We do @emph{not} want to print a graph that is
1,030 lines high @dots{}  Instead, we should print a graph that is
fewer than twenty-five lines high.  A graph that height can be
displayed on almost any monitor, and easily printed on a sheet of paper.

This means that each value in @code{list-for-graph} must be reduced to
one-fiftieth its present value.

Here is a short function to do just that, using two functions we have
not yet seen, @code{mapcar} and @code{lambda}.

@smallexample
@group
(defun one-fiftieth (full-range)
  "Return list, each number one-fiftieth of previous."
 (mapcar (lambda (arg) (/ arg 50)) full-range))
@end group
@end smallexample

@node lambda
@appendixsubsec A @code{lambda} Expression: Useful Anonymity
@cindex Anonymous function
@findex lambda

@code{lambda} is the symbol for an anonymous function, a function
without a name.  Every time you use an anonymous function, you need to
include its whole body.

@need 1250
@noindent
Thus,

@smallexample
(lambda (arg) (/ arg 50))
@end smallexample

@noindent
is a function that returns the value resulting from
dividing whatever is passed to it as @code{arg} by 50.

@need 1200
Earlier, for example, we had a function @code{multiply-by-seven}; it
multiplied its argument by 7.  This function is similar, except it
divides its argument by 50; and, it has no name.  The anonymous
equivalent of @code{multiply-by-seven} is:

@smallexample
(lambda (number) (* 7 number))
@end smallexample

@noindent
(@xref{defun, ,  The @code{defun} Macro}.)

@need 1250
@noindent
If we want to multiply 3 by 7, we can write:

@c clear print-postscript-figures
@c lambda example diagram #1
@ifnottex
@smallexample
@group
(multiply-by-seven 3)
 \_______________/ ^
         |         |
      function  argument
@end group
@end smallexample
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{lambda-1}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
(multiply-by-seven 3)
 \_______________/ ^
         |         |
      function  argument
@end group
@end smallexample
@end iftex
@end ifclear

@noindent
This expression returns 21.

@need 1250
@noindent
Similarly, we can write:

@c lambda example diagram #2
@ifnottex
@smallexample
@group
((lambda (number) (* 7 number)) 3)
 \____________________________/ ^
               |                |
      anonymous function     argument
@end group
@end smallexample
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{lambda-2}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
((lambda (number) (* 7 number)) 3)
 \____________________________/ ^
               |                |
      anonymous function     argument
@end group
@end smallexample
@end iftex
@end ifclear

@need 1250
@noindent
If we want to divide 100 by 50, we can write:

@c lambda example diagram #3
@ifnottex
@smallexample
@group
((lambda (arg) (/ arg 50)) 100)
 \______________________/  \_/
             |              |
    anonymous function   argument
@end group
@end smallexample
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{lambda-3}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
((lambda (arg) (/ arg 50)) 100)
 \______________________/  \_/
             |              |
    anonymous function   argument
@end group
@end smallexample
@end iftex
@end ifclear

@noindent
This expression returns 2.  The 100 is passed to the function, which
divides that number by 50.

@xref{Lambda Expressions, , Lambda Expressions, elisp, The GNU Emacs
Lisp Reference Manual}, for more about @code{lambda}.  Lisp and lambda
expressions derive from the Lambda Calculus.

@node mapcar
@appendixsubsec The @code{mapcar} Function
@findex mapcar

@code{mapcar} is a function that calls its first argument with each
element of its second argument, in turn.  The second argument must be
a sequence.

The @samp{map} part of the name comes from the mathematical phrase,
``mapping over a domain'', meaning to apply a function to each of the
elements in a domain.  The mathematical phrase is based on the
metaphor of a surveyor walking, one step at a time, over an area he is
mapping.  And @samp{car}, of course, comes from the Lisp notion of the
first of a list.

@need 1250
@noindent
For example,

@smallexample
@group
(mapcar '1+ '(2 4 6))
     @result{} (3 5 7)
@end group
@end smallexample

@noindent
The function @code{1+} which adds one to its argument, is executed on
@emph{each} element of the list, and a new list is returned.

Contrast this with @code{apply}, which applies its first argument to
all the remaining.
(@xref{Readying a Graph, , Readying a Graph}, for an explanation of
@code{apply}.)

@need 1250
In the definition of @code{one-fiftieth}, the first argument is the
anonymous function:

@smallexample
(lambda (arg) (/ arg 50))
@end smallexample

@noindent
and the second argument is @code{full-range}, which will be bound to
@code{list-for-graph}.

@need 1250
The whole expression looks like this:

@smallexample
(mapcar (lambda (arg) (/ arg 50)) full-range))
@end smallexample

@xref{Mapping Functions, , Mapping Functions, elisp, The GNU Emacs
Lisp Reference Manual}, for more about @code{mapcar}.

Using the @code{one-fiftieth} function, we can generate a list in
which each element is one-fiftieth the size of the corresponding
element in @code{list-for-graph}.

@smallexample
@group
(setq fiftieth-list-for-graph
      (one-fiftieth list-for-graph))
@end group
@end smallexample

@need 1250
The resulting list looks like this:

@smallexample
@group
(10 20 19 15 11 9 6 5 4 3 3 2 2
1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 4)
@end group
@end smallexample

@noindent
This, we are almost ready to print!  (We also notice the loss of
information: many of the higher ranges are 0, meaning that fewer than
50 defuns had that many words or symbols---but not necessarily meaning
that none had that many words or symbols.)

@node Another Bug
@appendixsubsec Another Bug @dots{} Most Insidious
@cindex Bug, most insidious type
@cindex Insidious type of bug

I said ``almost ready to print''!  Of course, there is a bug in the
@code{print-graph} function @dots{}  It has a @code{vertical-step}
option, but not a @code{horizontal-step} option.  The
@code{top-of-range} scale goes from 10 to 300 by tens.  But the
@code{print-graph} function will print only by ones.

This is a classic example of what some consider the most insidious
type of bug, the bug of omission.  This is not the kind of bug you can
find by studying the code, for it is not in the code; it is an omitted
feature.  Your best actions are to try your program early and often;
and try to arrange, as much as you can, to write code that is easy to
understand and easy to change.  Try to be aware, whenever you can,
that whatever you have written, @emph{will} be rewritten, if not soon,
eventually.  A hard maxim to follow.

It is the @code{print-X-axis-numbered-line} function that needs the
work; and then the @code{print-X-axis} and the @code{print-graph}
functions need to be adapted.  Not much needs to be done; there is one
nicety: the numbers ought to line up under the tic marks.  This takes
a little thought.

@need 1250
Here is the corrected @code{print-X-axis-numbered-line}:

@smallexample
@group
(defun print-X-axis-numbered-line
  (number-of-X-tics X-axis-leading-spaces
   &optional horizontal-step)
  "Print line of X-axis numbers"
  (let ((number X-axis-label-spacing)
        (horizontal-step (or horizontal-step 1)))
@end group
@group
    (insert X-axis-leading-spaces)
    ;; @r{Delete extra leading spaces.}
    (delete-char
     (- (1-
         (length (number-to-string horizontal-step)))))
    (insert (concat
             (make-string
@end group
@group
              ;; @r{Insert white space.}
              (-  (* symbol-width
                     X-axis-label-spacing)
                  (1-
                   (length
                    (number-to-string horizontal-step)))
                  2)
              ? )
             (number-to-string
              (* number horizontal-step))))
@end group
@group
    ;; @r{Insert remaining numbers.}
    (setq number (+ number X-axis-label-spacing))
    (while (> number-of-X-tics 1)
      (insert (X-axis-element
               (* number horizontal-step)))
      (setq number (+ number X-axis-label-spacing))
      (setq number-of-X-tics (1- number-of-X-tics)))))
@end group
@end smallexample

@need 1500
If you are reading this in Info, you can see the new versions of
@code{print-X-axis} @code{print-graph} and evaluate them.  If you are
reading this in a printed book, you can see the changed lines here
(the full text is too much to print).

@iftex
@smallexample
@group
(defun print-X-axis (numbers-list horizontal-step)
  @dots{}
    (print-X-axis-numbered-line
     tic-number leading-spaces horizontal-step))
@end group
@end smallexample

@smallexample
@group
(defun print-graph
  (numbers-list
   &optional vertical-step horizontal-step)
  @dots{}
    (print-X-axis numbers-list horizontal-step))
@end group
@end smallexample
@end iftex

@ifnottex
@smallexample
@group
(defun print-X-axis (numbers-list horizontal-step)
  "Print X axis labels to length of NUMBERS-LIST.
Optionally, HORIZONTAL-STEP, a positive integer,
specifies how much an X  axis label increments for
each column."
@end group
@group
;; Value of symbol-width and full-Y-label-width
;; are passed by print-graph.
  (let* ((leading-spaces
          (make-string full-Y-label-width ? ))
       ;; symbol-width @r{is provided by} graph-body-print
       (tic-width (* symbol-width X-axis-label-spacing))
       (X-length (length numbers-list))
@end group
@group
       (X-tic
        (concat
         (make-string
          ;; @r{Make a string of blanks.}
          (-  (* symbol-width X-axis-label-spacing)
              (length X-axis-tic-symbol))
          ? )
@end group
@group
         ;; @r{Concatenate blanks with tic symbol.}
         X-axis-tic-symbol))
       (tic-number
        (if (zerop (% X-length tic-width))
            (/ X-length tic-width)
          (1+ (/ X-length tic-width)))))
@end group

@group
    (print-X-axis-tic-line
     tic-number leading-spaces X-tic)
    (insert "\n")
    (print-X-axis-numbered-line
     tic-number leading-spaces horizontal-step)))
@end group
@end smallexample

@smallexample
@group
(defun print-graph
  (numbers-list &optional vertical-step horizontal-step)
  "Print labeled bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values.
@end group

@group
Optionally, VERTICAL-STEP, a positive integer,
specifies how much a Y axis label increments for
each line.  For example, a step of 5 means that
each row is five units.
@end group

@group
Optionally, HORIZONTAL-STEP, a positive integer,
specifies how much an X  axis label increments for
each column."
  (let* ((symbol-width (length graph-blank))
         ;; @code{height} @r{is both the largest number}
         ;; @r{and the number with the most digits.}
         (height (apply 'max numbers-list))
@end group
@group
         (height-of-top-line
          (if (zerop (% height Y-axis-label-spacing))
              height
            ;; @r{else}
            (* (1+ (/ height Y-axis-label-spacing))
               Y-axis-label-spacing)))
@end group
@group
         (vertical-step (or vertical-step 1))
         (full-Y-label-width
          (length
           (concat
            (number-to-string
             (* height-of-top-line vertical-step))
            Y-axis-tic))))
@end group
@group
    (print-Y-axis
     height-of-top-line full-Y-label-width vertical-step)
    (graph-body-print
        numbers-list height-of-top-line symbol-width)
    (print-X-axis numbers-list horizontal-step)))
@end group
@end smallexample
@end ifnottex

@c qqq
@ignore
Graphing Definitions Re-listed

@need 1250
Here are all the graphing definitions in their final form:

@smallexample
@group
(defvar top-of-ranges
 '(10  20  30  40  50
   60  70  80  90 100
  110 120 130 140 150
  160 170 180 190 200
  210 220 230 240 250)
 "List specifying ranges for `defuns-per-range'.")
@end group

@group
(defvar graph-symbol "*"
  "String used as symbol in graph, usually an asterisk.")
@end group

@group
(defvar graph-blank " "
  "String used as blank in graph, usually a blank space.
graph-blank must be the same number of columns wide
as graph-symbol.")
@end group

@group
(defvar Y-axis-tic " - "
   "String that follows number in a Y axis label.")
@end group

@group
(defvar Y-axis-label-spacing 5
  "Number of lines from one Y axis label to next.")
@end group

@group
(defvar X-axis-tic-symbol "|"
  "String to insert to point to a column in X axis.")
@end group

@group
(defvar X-axis-label-spacing
  (if (boundp 'graph-blank)
      (* 5 (length graph-blank)) 5)
  "Number of units from one X axis label to next.")
@end group
@end smallexample

@smallexample
@group
(defun count-words-in-defun ()
  "Return the number of words and symbols in a defun."
  (beginning-of-defun)
  (let ((count 0)
        (end (save-excursion (end-of-defun) (point))))
@end group

@group
    (while
        (and (< (point) end)
             (re-search-forward
              "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"
              end t))
      (setq count (1+ count)))
    count))
@end group
@end smallexample

@smallexample
@group
(defun lengths-list-file (filename)
  "Return list of definitions' lengths within FILE.
The returned list is a list of numbers.
Each number is the number of words or
symbols in one function definition."
@end group

@group
  (message "Working on `%s' ... " filename)
  (save-excursion
    (let ((buffer (find-file-noselect filename))
          (lengths-list))
      (set-buffer buffer)
      (setq buffer-read-only t)
      (widen)
      (goto-char (point-min))
@end group

@group
      (while (re-search-forward "^(defun" nil t)
        (setq lengths-list
              (cons (count-words-in-defun) lengths-list)))
      (kill-buffer buffer)
      lengths-list)))
@end group
@end smallexample

@smallexample
@group
(defun lengths-list-many-files (list-of-files)
  "Return list of lengths of defuns in LIST-OF-FILES."
  (let (lengths-list)
;;; @r{true-or-false-test}
    (while list-of-files
      (setq lengths-list
            (append
             lengths-list
@end group
@group
;;; @r{Generate a lengths' list.}
             (lengths-list-file
              (expand-file-name (car list-of-files)))))
;;; @r{Make files' list shorter.}
      (setq list-of-files (cdr list-of-files)))
;;; @r{Return final value of lengths' list.}
    lengths-list))
@end group
@end smallexample

@smallexample
@group
(defun defuns-per-range (sorted-lengths top-of-ranges)
  "SORTED-LENGTHS defuns in each TOP-OF-RANGES range."
  (let ((top-of-range (car top-of-ranges))
        (number-within-range 0)
        defuns-per-range-list)
@end group

@group
    ;; @r{Outer loop.}
    (while top-of-ranges

      ;; @r{Inner loop.}
      (while (and
              ;; @r{Need number for numeric test.}
              (car sorted-lengths)
              (< (car sorted-lengths) top-of-range))

        ;; @r{Count number of definitions within current range.}
        (setq number-within-range (1+ number-within-range))
        (setq sorted-lengths (cdr sorted-lengths)))
@end group

@group
      ;; @r{Exit inner loop but remain within outer loop.}

      (setq defuns-per-range-list
            (cons number-within-range defuns-per-range-list))
      (setq number-within-range 0)      ; @r{Reset count to zero.}

      ;; @r{Move to next range.}
      (setq top-of-ranges (cdr top-of-ranges))
      ;; @r{Specify next top of range value.}
      (setq top-of-range (car top-of-ranges)))
@end group

@group
    ;; @r{Exit outer loop and count the number of defuns larger than}
    ;; @r{  the largest top-of-range value.}
    (setq defuns-per-range-list
          (cons
           (length sorted-lengths)
           defuns-per-range-list))

    ;; @r{Return a list of the number of definitions within each range,}
    ;; @r{  smallest to largest.}
    (nreverse defuns-per-range-list)))
@end group
@end smallexample

@smallexample
@group
(defun column-of-graph (max-graph-height actual-height)
  "Return list of MAX-GRAPH-HEIGHT strings;
ACTUAL-HEIGHT are graph-symbols.
The graph-symbols are contiguous entries at the end
of the list.
The list will be inserted as one column of a graph.
The strings are either graph-blank or graph-symbol."
@end group

@group
  (let ((insert-list nil)
        (number-of-top-blanks
         (- max-graph-height actual-height)))

    ;; @r{Fill in @code{graph-symbols}.}
    (while (> actual-height 0)
      (setq insert-list (cons graph-symbol insert-list))
      (setq actual-height (1- actual-height)))
@end group

@group
    ;; @r{Fill in @code{graph-blanks}.}
    (while (> number-of-top-blanks 0)
      (setq insert-list (cons graph-blank insert-list))
      (setq number-of-top-blanks
            (1- number-of-top-blanks)))

    ;; @r{Return whole list.}
    insert-list))
@end group
@end smallexample

@smallexample
@group
(defun Y-axis-element (number full-Y-label-width)
  "Construct a NUMBERed label element.
A numbered element looks like this `  5 - ',
and is padded as needed so all line up with
the element for the largest number."
@end group
@group
  (let* ((leading-spaces
         (- full-Y-label-width
            (length
             (concat (number-to-string number)
                     Y-axis-tic)))))
@end group
@group
    (concat
     (make-string leading-spaces ? )
     (number-to-string number)
     Y-axis-tic)))
@end group
@end smallexample

@smallexample
@group
(defun print-Y-axis
  (height full-Y-label-width &optional vertical-step)
  "Insert Y axis by HEIGHT and FULL-Y-LABEL-WIDTH.
Height must be the  maximum height of the graph.
Full width is the width of the highest label element.
Optionally, print according to VERTICAL-STEP."
@end group
@group
;; Value of height and full-Y-label-width
;; are passed by 'print-graph'.
  (let ((start (point)))
    (insert-rectangle
     (Y-axis-column height full-Y-label-width vertical-step))
@end group
@group
    ;; @r{Place point ready for inserting graph.}
    (goto-char start)
    ;; @r{Move point forward by value of} full-Y-label-width
    (forward-char full-Y-label-width)))
@end group
@end smallexample

@smallexample
@group
(defun print-X-axis-tic-line
  (number-of-X-tics X-axis-leading-spaces X-axis-tic-element)
  "Print ticks for X axis."
    (insert X-axis-leading-spaces)
    (insert X-axis-tic-symbol)  ; @r{Under first column.}
@end group
@group
    ;; @r{Insert second tic in the right spot.}
    (insert (concat
             (make-string
              (-  (* symbol-width X-axis-label-spacing)
                  ;; @r{Insert white space up to second tic symbol.}
                  (* 2 (length X-axis-tic-symbol)))
              ? )
             X-axis-tic-symbol))
@end group
@group
    ;; @r{Insert remaining ticks.}
    (while (> number-of-X-tics 1)
      (insert X-axis-tic-element)
      (setq number-of-X-tics (1- number-of-X-tics))))
@end group
@end smallexample

@smallexample
@group
(defun X-axis-element (number)
  "Construct a numbered X axis element."
  (let ((leading-spaces
         (-  (* symbol-width X-axis-label-spacing)
             (length (number-to-string number)))))
    (concat (make-string leading-spaces ? )
            (number-to-string number))))
@end group
@end smallexample

@smallexample
@group
(defun graph-body-print (numbers-list height symbol-width)
  "Print a bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values.
HEIGHT is maximum height of graph.
SYMBOL-WIDTH is number of each column."
@end group
@group
  (let (from-position)
    (while numbers-list
      (setq from-position (point))
      (insert-rectangle
       (column-of-graph height (car numbers-list)))
      (goto-char from-position)
      (forward-char symbol-width)
@end group
@group
      ;; @r{Draw graph column by column.}
      (sit-for 0)
      (setq numbers-list (cdr numbers-list)))
    ;; @r{Place point for X axis labels.}
    (forward-line height)
    (insert "\n")))
@end group
@end smallexample

@smallexample
@group
(defun Y-axis-column
  (height width-of-label &optional vertical-step)
  "Construct list of labels for Y axis.
HEIGHT is maximum height of graph.
WIDTH-OF-LABEL is maximum width of label.
@end group
@group
VERTICAL-STEP, an option, is a positive integer
that specifies how much a Y axis label increments
for each line.  For example, a step of 5 means
that each line is five units of the graph."
  (let (Y-axis
        (number-per-line (or vertical-step 1)))
@end group
@group
    (while (> height 1)
      (if (zerop (% height Y-axis-label-spacing))
          ;; @r{Insert label.}
          (setq Y-axis
                (cons
                 (Y-axis-element
                  (* height number-per-line)
                  width-of-label)
                 Y-axis))
@end group
@group
        ;; @r{Else, insert blanks.}
        (setq Y-axis
              (cons
               (make-string width-of-label ? )
               Y-axis)))
      (setq height (1- height)))
@end group
@group
    ;; @r{Insert base line.}
    (setq Y-axis (cons (Y-axis-element
                        (or vertical-step 1)
                        width-of-label)
                       Y-axis))
    (nreverse Y-axis)))
@end group
@end smallexample

@smallexample
@group
(defun print-X-axis-numbered-line
  (number-of-X-tics X-axis-leading-spaces
   &optional horizontal-step)
  "Print line of X-axis numbers"
  (let ((number X-axis-label-spacing)
        (horizontal-step (or horizontal-step 1)))
@end group
@group
    (insert X-axis-leading-spaces)
    ;; line up number
    (delete-char (- (1- (length (number-to-string horizontal-step)))))
    (insert (concat
             (make-string
              ;; @r{Insert white space up to next number.}
              (-  (* symbol-width X-axis-label-spacing)
                  (1- (length (number-to-string horizontal-step)))
                  2)
              ? )
             (number-to-string (* number horizontal-step))))
@end group
@group
    ;; @r{Insert remaining numbers.}
    (setq number (+ number X-axis-label-spacing))
    (while (> number-of-X-tics 1)
      (insert (X-axis-element (* number horizontal-step)))
      (setq number (+ number X-axis-label-spacing))
      (setq number-of-X-tics (1- number-of-X-tics)))))
@end group
@end smallexample

@smallexample
@group
(defun print-X-axis (numbers-list horizontal-step)
  "Print X axis labels to length of NUMBERS-LIST.
Optionally, HORIZONTAL-STEP, a positive integer,
specifies how much an X  axis label increments for
each column."
@end group
@group
;; Value of symbol-width and full-Y-label-width
;; are passed by 'print-graph'.
  (let* ((leading-spaces
          (make-string full-Y-label-width ? ))
       ;; symbol-width @r{is provided by} graph-body-print
       (tic-width (* symbol-width X-axis-label-spacing))
       (X-length (length numbers-list))
@end group
@group
       (X-tic
        (concat
         (make-string
          ;; @r{Make a string of blanks.}
          (-  (* symbol-width X-axis-label-spacing)
              (length X-axis-tic-symbol))
          ? )
@end group
@group
         ;; @r{Concatenate blanks with tic symbol.}
         X-axis-tic-symbol))
       (tic-number
        (if (zerop (% X-length tic-width))
            (/ X-length tic-width)
          (1+ (/ X-length tic-width)))))
@end group

@group
    (print-X-axis-tic-line
     tic-number leading-spaces X-tic)
    (insert "\n")
    (print-X-axis-numbered-line
     tic-number leading-spaces horizontal-step)))
@end group
@end smallexample

@smallexample
@group
(defun one-fiftieth (full-range)
  "Return list, each number of which is 1/50th previous."
 (mapcar (lambda (arg) (/ arg 50)) full-range))
@end group
@end smallexample

@smallexample
@group
(defun print-graph
  (numbers-list &optional vertical-step horizontal-step)
  "Print labeled bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values.
@end group

@group
Optionally, VERTICAL-STEP, a positive integer,
specifies how much a Y axis label increments for
each line.  For example, a step of 5 means that
each row is five units.
@end group

@group
Optionally, HORIZONTAL-STEP, a positive integer,
specifies how much an X  axis label increments for
each column."
  (let* ((symbol-width (length graph-blank))
         ;; @code{height} @r{is both the largest number}
         ;; @r{and the number with the most digits.}
         (height (apply 'max numbers-list))
@end group
@group
         (height-of-top-line
          (if (zerop (% height Y-axis-label-spacing))
              height
            ;; @r{else}
            (* (1+ (/ height Y-axis-label-spacing))
               Y-axis-label-spacing)))
@end group
@group
         (vertical-step (or vertical-step 1))
         (full-Y-label-width
          (length
           (concat
            (number-to-string
             (* height-of-top-line vertical-step))
            Y-axis-tic))))
@end group
@group

    (print-Y-axis
     height-of-top-line full-Y-label-width vertical-step)
    (graph-body-print
        numbers-list height-of-top-line symbol-width)
    (print-X-axis numbers-list horizontal-step)))
@end group
@end smallexample
@c qqq
@end ignore

@page
@node Final printed graph
@appendixsubsec The Printed Graph

When made and installed, you can call the @code{print-graph} command
like this:
@sp 1

@smallexample
@group
(print-graph fiftieth-list-for-graph 50 10)
@end group
@end smallexample
@sp 1

@noindent
Here is the graph:
@sp 2

@smallexample
@group
1000 -  *
        **
        **
        **
        **
 750 -  ***
        ***
        ***
        ***
        ****
 500 - *****
       ******
       ******
       ******
       *******
 250 - ********
       *********                     *
       ***********                   *
       *************                 *
  50 - ***************** *           *
       |   |    |    |    |    |    |    |
      10  50  100  150  200  250  300  350
@end group
@end smallexample

@sp 2

@noindent
The largest group of functions contain 10--19 words and symbols each.

@node 自由软件和自由手册
@appendix 自由软件和自由手册

@strong{作者：理查德·斯托曼}
@sp 1

自由操作系统中最大的不足之处不在于软件本身，而在于我们无法在这些系统中包含好的自由手册。许多我们最重要的程序都没有附带完整的手册。文档是任何软件包的基本组成部分；当一个重要的自由软件包没有附带自由手册时，这是一个重大的缺陷。我们今天有许多这样的缺口。

很多年前的一天，我想学习Perl。我找到了一本免费的手册副本，但我发现它很难阅读。当我询问Perl用户是否有其他选择时，他们告诉我有更好的入门手册---但那些手册并不是免费的。

为什么会这样呢？好的手册作者为O'Reilly Associates编写了手册，该出版社以限制性条款发布它们---禁止复制、禁止修改、源文件不可用---这些条件使它们无法进入自由软件社区。

这并不是这种情况发生的第一次，而且（令我们的社区丧失很多）远非最后一次。自从那时以来，专有手册出版商引诱了许多作者限制他们的手册。许多次我听到GNU用户热切地告诉我，他正在撰写一本手册，他希望能够帮助GNU项目---然后我的希望落空，因为他继续解释说他已经签署了一份与出版商的合同，该合同将限制使用，以至于我们无法使用它。

鉴于写好英语是程序员中一种罕见的技能，我们不能承受以这种方式失去手册的代价。

自由文档，就像自由软件一样，是关乎自由而非价格的问题。这些手册的问题并不在于O'Reilly Associates对印刷品收费---这本身是可以接受的。自由软件基金会在@uref{https://shop.fsf.org, 官方商店}出售免费@uref{https://www.gnu.org/doc/doc.html, GNU手册}的印刷本。但GNU手册以源代码形式提供，而这些手册只能以纸质形式获得。GNU手册附带有复制和修改的权限；Perl手册则没有。这些限制是问题所在。

对于一个自由手册，标准几乎与自由软件相同：它涉及给予所有用户特定的自由。必须允许重新分发（包括商业重新分发），以便手册可以随程序的每个副本一起提供，无论是在线还是纸质的。修改的许可也是至关重要的。

总的来说，我不认为人们有必要获得修改各种文章和书籍的权限。对于文学作品，问题不一定与软件相同。例如，我认为你和我没有义务允许修改像这篇文章这样描述我们行动和观点的文章。

但是，为自由软件提供文档的关键原因之一是修改的自由至关重要。当人们行使他们修改软件的权利，添加或更改其功能时，如果他们是尽责的，他们将同时更改手册---以便他们可以为修改后的程序提供准确可用的文档。一份手册，禁止程序员尽责并完成工作，或者更确切地说，如果他们更改程序，则要求他们从头开始编写新手册，这将无法满足我们社区的需求。

虽然对修改的全面禁令是不可接受的，但对修改方式的某些限制并不构成问题。例如，要求保留原作者的版权声明、分发条款或作者列表是可以接受的。还要求修改版本包含修改通知，甚至包含整个部分不得删除或更改，只要这些部分涉及非技术主题，也没有问题（一些GNU手册有这些限制）。

这些种类的限制不是问题，因为从实际角度来看，它们并不阻止认真的程序员调整手册以适应修改后的程序。换句话说，它们并不阻止自由软件社区充分利用手册。

然而，必须有可能修改手册的所有技术内容，然后通过所有通常的媒体、通过所有通常的渠道分发结果；否则，这些限制将阻碍社区，手册就不是自由的，因此我们需要另一份手册。

不幸的是，当存在专有手册时，很难找到愿意写另一份手册的人。阻碍在于许多用户认为专有手册已经足够好---因此他们认为没有必要写一份自由手册。他们没有意识到自由操作系统存在需要填补的空白。

为什么用户认为专有手册已经足够好呢？有些人还没有考虑这个问题。我希望这篇文章能够改变这种看法。

其他用户认为专有手册是可以接受的，原因与许多人认为专有软件是可以接受的原因相同：他们纯粹以实际的角度进行判断，而不使用自由作为标准。这些人有权发表他们的观点，但由于这些观点源于不包括自由的价值观，对于那些重视自由的人来说，它们并不是指导。

请传播关于这个问题的信息。我们继续失去手册，因为它们受到专有出版的限制。如果我们传播这样的信息，即专有手册是不够的，也许下一个想通过撰写文档来帮助GNU的人在为时已晚之前会意识到，他首先必须使其自由。

我们还可以鼓励商业出版商销售自由的、遵循版权的手册，而不是专有的手册。你可以帮助实现这一点的一种方式是在购买手册之前检查其分发条款，并更喜欢遵循版权的手册而不是非遵循版权的手册。

@sp 2
@noindent
注：自由软件基金会在其网站上维护了一个页面，列出了其他出版商提供的免费图书：@*
@uref{https://www.gnu.org/doc/other-free-books.html}

@node GNU Free Documentation License
@appendix GNU Free Documentation License

@cindex FDL, GNU Free Documentation License
@include doclicense.texi

@node Index
@unnumbered Index

@ignore
MENU ENTRY: NODE NAME.
@end ignore

@printindex cp

@iftex
@c Place biographical information on right-hand (verso) page

@tex
\par\vfill\supereject
\ifodd\pageno
    \global\evenheadline={\hfil} \global\evenfootline={\hfil}
    \global\oddheadline={\hfil} \global\oddfootline={\hfil}
    %\page\hbox{}\page
\else
%    \par\vfill\supereject
    \global\evenheadline={\hfil} \global\evenfootline={\hfil}
    \global\oddheadline={\hfil} \global\oddfootline={\hfil}
    %\page\hbox{}%\page
    %\page\hbox{}%\page
\fi
@end tex

@c page
@w{ }

@c ================ Biographical information ================

@w{ }
@sp 8
@center About the Author
@sp 1
@end iftex

@ifnottex
@node 作者简介
@unnumbered 作者简介
@end ifnottex

@quotation
罗伯特·J·查瑟尔（1946--2017）于1985年开始使用GNU Emacs。他撰写和编辑了Emacs和Emacs Lisp的教材，并在世界各地演讲，倡导软件自由。查瑟尔是自由软件基金会（Free Software Foundation, Inc.）的创始董事兼财务主管。他是《Texinfo》手册的合著者，还编辑了十多本其他书籍。他毕业于英格兰剑桥大学，对社会和经济历史有浓厚兴趣，同时还是一名私人飞行爱好者。

@uref{https://www.fsf.org/blogs/community/goodbye-to-bob-chassell,
"向鲍勃·查瑟尔告别"}
@end quotation

@c @page
@c @w{ }
@c
@c @c Prevent page number on blank verso, so eject it first.
@c @tex
@c \par\vfill\supereject
@c @end tex

@c @iftex
@c @headings off
@c @evenheading @thispage @| @| @thistitle
@c @oddheading            @| @| @thispage
@c @end iftex

@bye
