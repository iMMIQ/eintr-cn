\input texinfo                       @c -*- mode: texinfo; coding: utf-8 -*-
@comment %**start of header
@setfilename ../../info/eintr.info
@settitle Programming in Emacs Lisp
@include docstyle.texi
@syncodeindex vr cp
@syncodeindex fn cp
@finalout

@include emacsver.texi

@c ================ How to Print a Book in Various Sizes ================

@c This book can be printed in any of three different sizes.
@c Set the following @-commands appropriately.

@c     7 by 9.25 inches:
@c              @smallbook
@c              @clear largebook

@c     8.5 by 11 inches:
@c              @c smallbook
@c              @set largebook

@c     European A4 size paper:
@c              @c smallbook
@c              @afourpaper
@c              @set largebook

@c (Note: if you edit the book so as to change the length of the
@c table of contents, you may have to change the value of 'pageno' below.)

@c <<<< For hard copy printing, this file is now
@c      set for smallbook, which works for all sizes
@c      of paper, and with PostScript figures >>>>

@set smallbook
@ifset smallbook
@smallbook
@clear  largebook
@end ifset

@c ================ Included Figures ================

@c If you clear this, the figures will be printed as ASCII diagrams
@c rather than PostScript/PDF.
@c (This is not relevant to Info, since Info only handles ASCII.)
@set print-postscript-figures
@c clear print-postscript-figures

@comment %**end of header

@c per rms and peterb, use 10pt fonts for the main text, mostly to
@c save on paper cost.
@c Do this inside @tex for now, so current makeinfo does not complain.
@tex
@ifset smallbook
@fonttextsize 10

@end ifset
\global\hbadness=6666 % don't worry about not-too-underfull boxes
@end tex

@c For next or subsequent edition:
@c   create function using with-output-to-temp-buffer
@c   create a major mode, with keymaps
@c   run an asynchronous process, like grep or diff

@c For 8.5 by 11 inch format: do not use such a small amount of
@c whitespace between paragraphs as smallbook format
@ifset largebook
@tex
\global\parskip 6pt plus 1pt
@end tex
@end ifset

@c For all sized formats:  print within-book cross
@c reference with ``...''  rather than [...]

@c This works with the texinfo.tex file, version 2003-05-04.08,
@c in the Texinfo version 4.6 of the 2003 Jun 13 distribution.

@tex
\if \xrefprintnodename
 \global\def\xrefprintnodename#1{\unskip, ``#1''}
 \else
 \global\def\xrefprintnodename#1{ ``#1''}
\fi
% \global\def\xrefprintnodename#1{, ``#1''}
@end tex

@c ----------------------------------------------------

@dircategory Emacs lisp
@direntry
* Emacs Lisp Intro: (eintr).    A simple introduction to Emacs Lisp programming.
@end direntry

@c When printing, define edition-number to be the printed edition
@c number, titlepage-edition-number to be the spelled out edition
@c number suitable for the title page, and update-date to be the date,
@c in the preferred style for these.  E.g., run the shell command:
@c   texi2any -D 'edition-number 3.11' \
@c            -D 'titlepage-edition-number Revised Third Edition' \
@c            -D 'update-date 31 March 2020'
@c This relates mainly to the published book sold by the FSF.

@copying
这是针对非程序员的 @cite{Emacs Lisp 编程简介}
@sp 1
@ifset edition-number
版本 @value{edition-number}, @value{update-date}
@end ifset
@sp 1
随 Emacs 版本 @value{EMACSVER} 发行.
@sp 1
Copyright @copyright{} 1990--1995, 1997, 2001--2023 自由软件基金会.
@sp 1

@iftex
由以下机构出版:@*

GNU Press,               @hfill @uref{https://www.fsf.org/licensing/gnu-press/}@*
自由软件基金会旗下的一个分部               @hfill email: @email{sales@@fsf.org}@*
Free Software Foundation, Inc.  @hfill 电话: +1 (617) 542-5942@*
51 Franklin Street, Fifth Floor @hfill 传真: +1 (617) 542-2652@*
美国马萨诸塞州波士顿，邮编02110-1301
@end iftex

@ifnottex
纸质版本可在 @uref{https://shop.fsf.org/} 获得。由以下机构出版：

@example
GNU Press,                        https://www.fsf.org/licensing/gnu-press/
自由软件基金会旗下的一个分部                 电子邮件：sales@@fsf.org
Free Software Foundation, Inc.    电话：+1 (617) 542-5942
51 Franklin Street, Fifth Floor   传真：+1 (617) 542-2652
美国马萨诸塞州波士顿，邮编02110-1301
@end example
@end ifnottex

@sp 1
ISBN 1-882114-43-4

@quotation
允许复制、分发和/或修改本文档，遵循 GNU 自由文档许可证 1.3 版或由自由软件基金会发布的任何以后版本的条款；本文档没有不变章节，封面文本为“GNU 手册”，反面封面文本如 (a) 所示。许可证的副本包含在名为“GNU 自由文档许可证”的章节中。

(a) FSF 的背面封面文本是：“你有自由复制和修改这份 GNU 手册。从 FSF 购买副本支持其开发 GNU 并推广软件自由。”
@end quotation
@end copying

@c half title; two lines here, so do not use 'shorttitlepage'
@tex
{\begingroup%
    \hbox{}\vskip 1.5in \chaprm \centerline{An Introduction to}%
        \endgroup}%
{\begingroup\hbox{}\vskip 0.25in \chaprm%
        \centerline{Programming in Emacs Lisp}%
        \endgroup\page\hbox{}\page}
@end tex

@titlepage
@sp 6
@center @titlefont{An Introduction to}
@sp 2
@center @titlefont{Programming in Emacs Lisp}
@sp 2
@ifset titlepage-edition-number
@center @value{titlepage-edition-number}
@end ifset
@sp 4
@center by Robert J. Chassell

@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@iftex
@headings off
@evenheading @thispage @| @| @thischapter
@oddheading @thissection @| @| @thispage
@end iftex

@ifnothtml
@c     Keep T.O.C. short by tightening up for largebook
@ifset largebook
@tex
\global\parskip 2pt plus 1pt
\global\advance\baselineskip by -1pt
@end tex
@end ifset
@end ifnothtml

@c If you think this manual is too large for an introduction, please
@c consider this email exchange:
@c
@c       >> The intro is almost 300 pages in full.  I had expected 60 pages.
@c       >
@c       > This is an important point in its own right.  Could you
@c       > write a simplified introduction that is only 50 pages or so?
@c       > That would be helpful to many potential users, I'd think.
@c
@c   > The problem with the introduction is that it was written when
@c   > programming was only starting to be a skill "normal" people could
@c   > have access to.  So the text is extremely verbose and is
@c   > sometimes hard to follow because of that.  The gist of the
@c   > document could be summarized in 50 pages.
@c
@c This book is intentionally addressed to people who don't know how to
@c program.  That is its purpose.  We recommend people start learning to
@c program using this book.
@c
@c If you DO know how to program in some other language, you can probably
@c learn Emacs Lisp starting with the Emacs Lisp Reference Manual.
@c
@c        Richard Stallman <rms@gnu.org>,
@c        https://lists.gnu.org/r/emacs-devel/2018-05/msg00374.html

@shortcontents
@contents

@ifnottex
@node Top
@top Emacs Lisp 编程简介

@ifset WWW_GNU_ORG
@html
<p>GNU Emacs的网站位于
<a href="/software/emacs/">https://www.gnu.org/software/emacs/</a>.<br>
要查看其他格式的本手册，请点击
<a href="/software/emacs/manual/eintr.html">这里</a>.
@end html
@end ifset

@insertcopying

此主菜单首先列出每个章节和索引；然后列出每个章节中的每个节点。
@end ifnottex

@c Uncomment the 3 lines below, starting with @iftex, if you want the
@c pages of Preface to be numbered in roman numerals.  Use -9 instead
@c of -11 for smallbook format.

@c >>>> Set pageno appropriately <<<<

@c The first page of the Preface is a roman numeral; it is the first
@c right handed page after the Table of Contents; hence the following
@c setting must be for an odd negative number.

@c iftex
@c global@pageno = -11
@c end iftex

@set COUNT-WORDS count-words-example
@c Length of variable name chosen so that things still line up when expanded.

@menu
* Preface::                     What to look for.
* List Processing::             What is Lisp?
* Practicing Evaluation::       Running several programs.
* Writing Defuns::              How to write function definitions.
* Buffer Walk Through::         Exploring a few buffer-related functions.
* More Complex::                A few, even more complex functions.
* Narrowing & Widening::        Restricting your and Emacs attention to
                                    a region.
* car cdr & cons::              Fundamental functions in Lisp.
* Cutting & Storing Text::      Removing text and saving it.
* List Implementation::         How lists are implemented in the computer.
* Yanking::                     Pasting stored text.
* Loops & Recursion::           How to repeat a process.
* Regexp Search::               Regular expression searches.
* Counting Words::              A review of repetition and regexps.
* Words in a defun::            Counting words in a @code{defun}.
* Readying a Graph::            A prototype graph printing function.
* Emacs Initialization::        How to write a @file{.emacs} file.
* Debugging::                   How to run the Emacs Lisp debuggers.
* Conclusion::                  Now you have the basics.
* the-the::                     An appendix: how to find reduplicated words.
* Kill Ring::                   An appendix: how the kill ring works.
* Full Graph::                  How to create a graph with labeled axes.
* Free Software and Free Manuals::
* GNU Free Documentation License::
* Index::
* About the Author::

@detailmenu
 --- The Detailed Node Listing ---

Preface

* Why::                         Why learn Emacs Lisp?
* On Reading this Text::        Read, gain familiarity, pick up habits....
* Who You Are::                 For whom this is written.
* Lisp History::
* Note for Novices::            You can read this as a novice.
* Thank You::

List Processing

* Lisp Lists::                  What are lists?
* Run a Program::               Any list in Lisp is a program ready to run.
* Making Errors::               Generating an error message.
* Names & Definitions::         Names of symbols and function definitions.
* Lisp Interpreter::            What the Lisp interpreter does.
* Evaluation::                  Running a program.
* Variables::                   Returning a value from a variable.
* Arguments::                   Passing information to a function.
* set & setq::                  Setting the value of a variable.
* Summary::                     The major points.
* Error Message Exercises::

Lisp Lists

* Numbers Lists::               List have numbers, other lists, in them.
* Lisp Atoms::                  Elemental entities.
* Whitespace in Lists::         Formatting lists to be readable.
* Typing Lists::                How GNU Emacs helps you type lists.

The Lisp Interpreter

* Complications::               Variables, Special forms, Lists within.
* Byte Compiling::              Specially processing code for speed.

Evaluation

* How the Interpreter Acts::    Returns and Side Effects...
* Evaluating Inner Lists::      Lists within lists...

Variables

* fill-column Example::
* Void Function::               The error message for a symbol
                                  without a function.
* Void Variable::               The error message for a symbol without a value.

Arguments

* Data types::                  Types of data passed to a function.
* Args as Variable or List::    An argument can be the value
                                  of a variable or list.
* Variable Number of Arguments::  Some functions may take a
                                  variable number of arguments.
* Wrong Type of Argument::      Passing an argument of the wrong type
                                  to a function.
* message::                     A useful function for sending messages.

Setting the Value of a Variable

* Using set::                  Setting values.
* Using setq::                 Setting a quoted value.
* Counting::                   Using @code{setq} to count.

Practicing Evaluation

* How to Evaluate::            Typing editing commands or @kbd{C-x C-e}
                                 causes evaluation.
* Buffer Names::               Buffers and files are different.
* Getting Buffers::            Getting a buffer itself, not merely its name.
* Switching Buffers::          How to change to another buffer.
* Buffer Size & Locations::    Where point is located and the size of
                               the buffer.
* Evaluation Exercise::

How To Write Function Definitions

* Primitive Functions::
* defun::                        The @code{defun} macro.
* Install::                      Install a function definition.
* Interactive::                  Making a function interactive.
* Interactive Options::          Different options for @code{interactive}.
* Permanent Installation::       Installing code permanently.
* let::                          Creating and initializing local variables.
* if::                           What if?
* else::                         If--then--else expressions.
* Truth & Falsehood::            What Lisp considers false and true.
* save-excursion::               Keeping track of point and buffer.
* Review::
* defun Exercises::

Install a Function Definition

* Effect of installation::
* Change a defun::              How to change a function definition.

Make a Function Interactive

* Interactive multiply-by-seven::  An overview.
* multiply-by-seven in detail::    The interactive version.

@code{let}

* Prevent confusion::
* Parts of let Expression::
* Sample let Expression::
* Uninitialized let Variables::

The @code{if} Special Form

* if in more detail::
* type-of-animal in detail::    An example of an @code{if} expression.

Truth and Falsehood in Emacs Lisp

* nil explained::               @code{nil} has two meanings.

@code{save-excursion}

* Point and mark::              A review of various locations.
* Template for save-excursion::

A Few Buffer-Related Functions

* Finding More::                How to find more information.
* simplified-beginning-of-buffer::  Shows @code{goto-char},
                                @code{point-min}, and @code{push-mark}.
* mark-whole-buffer::           Almost the same as @code{beginning-of-buffer}.
* append-to-buffer::            Uses @code{save-excursion} and
                                @code{insert-buffer-substring}.
* Buffer Related Review::       Review.
* Buffer Exercises::

The Definition of @code{mark-whole-buffer}

* mark-whole-buffer overview::
* Body of mark-whole-buffer::   Only three lines of code.

The Definition of @code{append-to-buffer}

* append-to-buffer overview::
* append interactive::          A two part interactive expression.
* append-to-buffer body::       Incorporates a @code{let} expression.
* append save-excursion::       How the @code{save-excursion} works.

A Few More Complex Functions

* copy-to-buffer::              With @code{set-buffer}, @code{get-buffer-create}.
* insert-buffer::               Read-only, and with @code{or}.
* beginning-of-buffer::         Shows @code{goto-char},
                                @code{point-min}, and @code{push-mark}.
* Second Buffer Related Review::
* optional Exercise::

The Definition of @code{insert-buffer}

* insert-buffer code::
* insert-buffer interactive::   When you can read, but not write.
* insert-buffer body::          The body has an @code{or} and a @code{let}.
* if & or::                     Using an @code{if} instead of an @code{or}.
* Insert or::                   How the @code{or} expression works.
* Insert let::                  Two @code{save-excursion} expressions.
* New insert-buffer::

The Interactive Expression in @code{insert-buffer}

* Read-only buffer::            When a buffer cannot be modified.
* b for interactive::           An existing buffer or else its name.

Complete Definition of @code{beginning-of-buffer}

* Optional Arguments::
* beginning-of-buffer opt arg::  Example with optional argument.
* beginning-of-buffer complete::

@code{beginning-of-buffer} with an Argument

* Disentangle beginning-of-buffer::
* Large buffer case::
* Small buffer case::

Narrowing and Widening

* Narrowing advantages::        The advantages of narrowing
* save-restriction::            The @code{save-restriction} special form.
* what-line::                   The number of the line that point is on.
* narrow Exercise::

@code{car}, @code{cdr}, @code{cons}: Fundamental Functions

* Strange Names::               A historical aside: why the strange names?
* car & cdr::                   Functions for extracting part of a list.
* cons::                        Constructing a list.
* nthcdr::                      Calling @code{cdr} repeatedly.
* nth::
* setcar::                      Changing the first element of a list.
* setcdr::                      Changing the rest of a list.
* cons Exercise::

@code{cons}

* Build a list::
* length::                      How to find the length of a list.

Cutting and Storing Text

* Storing Text::                Text is stored in a list.
* zap-to-char::                 Cutting out text up to a character.
* kill-region::                 Cutting text out of a region.
* copy-region-as-kill::         A definition for copying text.
* Digression into C::           Minor note on C programming language macros.
* defvar::                      How to give a variable an initial value.
* cons & search-fwd Review::
* search Exercises::

@code{zap-to-char}

* Complete zap-to-char::        The complete implementation.
* zap-to-char interactive::     A three part interactive expression.
* zap-to-char body::            A short overview.
* search-forward::              How to search for a string.
* progn::                       The @code{progn} special form.
* Summing up zap-to-char::      Using @code{point} and @code{search-forward}.

@code{kill-region}

* Complete kill-region::        The function definition.
* condition-case::              Dealing with a problem.
* Lisp macro::

@code{copy-region-as-kill}

* Complete copy-region-as-kill::  The complete function definition.
* copy-region-as-kill body::      The body of @code{copy-region-as-kill}.

The Body of @code{copy-region-as-kill}

* last-command & this-command::
* kill-append function::
* kill-new function::

Initializing a Variable with @code{defvar}

* See variable current value::
* defvar and asterisk::

How Lists are Implemented

* Lists diagrammed::
* Symbols as Chest::            Exploring a powerful metaphor.
* List Exercise::

Yanking Text Back

* Kill Ring Overview::
* kill-ring-yank-pointer::      The kill ring is a list.
* yank nthcdr Exercises::       The @code{kill-ring-yank-pointer} variable.

Loops and Recursion

* while::                       Causing a stretch of code to repeat.
* dolist dotimes::
* Recursion::                   Causing a function to call itself.
* Looping exercise::

@code{while}

* Looping with while::          Repeat so long as test returns true.
* Loop Example::                A @code{while} loop that uses a list.
* print-elements-of-list::      Uses @code{while}, @code{car}, @code{cdr}.
* Incrementing Loop::           A loop with an incrementing counter.
* Incrementing Loop Details::
* Decrementing Loop::           A loop with a decrementing counter.

Details of an Incrementing Loop

* Incrementing Example::        Counting pebbles in a triangle.
* Inc Example parts::           The parts of the function definition.
* Inc Example altogether::      Putting the function definition together.

Loop with a Decrementing Counter

* Decrementing Example::        More pebbles on the beach.
* Dec Example parts::           The parts of the function definition.
* Dec Example altogether::      Putting the function definition together.

Save your time: @code{dolist} and @code{dotimes}

* dolist::
* dotimes::

Recursion

* Building Robots::             Same model, different serial number ...
* Recursive Definition Parts::  Walk until you stop ...
* Recursion with list::         Using a list as the test whether to recurse.
* Recursive triangle function::
* Recursion with cond::
* Recursive Patterns::          Often used templates.
* No Deferment::                Don't store up work ...
* No deferment solution::

Recursion in Place of a Counter

* Recursive Example arg of 1 or 2::
* Recursive Example arg of 3 or 4::

Recursive Patterns

* Every::
* Accumulate::
* Keep::

Regular Expression Searches

* sentence-end::                The regular expression for @code{sentence-end}.
* re-search-forward::           Very similar to @code{search-forward}.
* forward-sentence::            A straightforward example of regexp search.
* forward-paragraph::           A somewhat complex example.
* Regexp Review::
* re-search Exercises::

@code{forward-sentence}

* Complete forward-sentence::
* fwd-sentence while loops::    Two @code{while} loops.
* fwd-sentence re-search::      A regular expression search.

@code{forward-paragraph}: a Goldmine of Functions

* forward-paragraph in brief::  Key parts of the function definition.
* fwd-para let::                The @code{let*} expression.
* fwd-para while::              The forward motion @code{while} loop.

Counting: Repetition and Regexps

* Why Count Words::
* @value{COUNT-WORDS}::         Use a regexp, but find a problem.
* recursive-count-words::       Start with case of no words in region.
* Counting Exercise::

The @code{@value{COUNT-WORDS}} Function

* Design @value{COUNT-WORDS}::  The definition using a @code{while} loop.
* Whitespace Bug::              The Whitespace Bug in @code{@value{COUNT-WORDS}}.

Counting Words in a @code{defun}

* Divide and Conquer::
* Words and Symbols::           What to count?
* Syntax::                      What constitutes a word or symbol?
* count-words-in-defun::        Very like @code{@value{COUNT-WORDS}}.
* Several defuns::              Counting several defuns in a file.
* Find a File::                 Do you want to look at a file?
* lengths-list-file::           A list of the lengths of many definitions.
* Several files::               Counting in definitions in different files.
* Several files recursively::   Recursively counting in different files.
* Prepare the data::            Prepare the data for display in a graph.

Count Words in @code{defuns} in Different Files

* lengths-list-many-files::     Return a list of the lengths of defuns.
* append::                      Attach one list to another.

Prepare the Data for Display in a Graph

* Data for Display in Detail::
* Sorting::                     Sorting lists.
* Files List::                  Making a list of files.
* Counting function definitions::

Readying a Graph

* Columns of a graph::
* graph-body-print::            How to print the body of a graph.
* recursive-graph-body-print::
* Printed Axes::
* Line Graph Exercise::

Your @file{.emacs} File

* Default Configuration::
* Site-wide Init::              You can write site-wide init files.
* defcustom::                   Emacs will write code for you.
* Beginning init File::         How to write a @file{.emacs} init file.
* Text and Auto-fill::          Automatically wrap lines.
* Mail Aliases::                Use abbreviations for email addresses.
* Indent Tabs Mode::            Don't use tabs with @TeX{}
* Key Bindings::                Create some personal key bindings.
* Keymaps::                     More about key binding.
* Loading Files::               Load (i.e., evaluate) files automatically.
* Autoload::                    Make functions available.
* Simple Extension::            Define a function; bind it to a key.
* X11 Colors::                  Colors in X.
* Miscellaneous::
* Mode Line::                   How to customize your mode line.

Debugging

* debug::                       How to use the built-in debugger.
* debug-on-entry::              Start debugging when you call a function.
* debug-on-quit::               Start debugging when you quit with @kbd{C-g}.
* edebug::                      How to use Edebug, a source level debugger.
* Debugging Exercises::

Handling the Kill Ring

* What the Kill Ring Does::
* current-kill::
* yank::                        Paste a copy of a clipped element.
* yank-pop::                    Insert element pointed to.
* ring file::

The @code{current-kill} Function

* Code for current-kill::
* Understanding current-kill::

@code{current-kill} in Outline

* Body of current-kill::
* Digression concerning error::  How to mislead humans, but not computers.
* Determining the Element::

A Graph with Labeled Axes

* Labeled Example::
* print-graph Varlist::         @code{let} expression in @code{print-graph}.
* print-Y-axis::                Print a label for the vertical axis.
* print-X-axis::                Print a horizontal label.
* Print Whole Graph::           The function to print a complete graph.

The @code{print-Y-axis} Function

* print-Y-axis in Detail::
* Height of label::             What height for the Y axis?
* Compute a Remainder::         How to compute the remainder of a division.
* Y Axis Element::              Construct a line for the Y axis.
* Y-axis-column::               Generate a list of Y axis labels.
* print-Y-axis Penultimate::    A not quite final version.

The @code{print-X-axis} Function

* Similarities differences::    Much like @code{print-Y-axis}, but not exactly.
* X Axis Tic Marks::            Create tic marks for the horizontal axis.

Printing the Whole Graph

* The final version::           A few changes.
* Test print-graph::            Run a short test.
* Graphing words in defuns::    Executing the final code.
* lambda::                      How to write an anonymous function.
* mapcar::                      Apply a function to elements of a list.
* Another Bug::                 Yet another bug @dots{} most insidious.
* Final printed graph::         The graph itself!

@end detailmenu
@end menu

@node Preface
@unnumbered 前言

GNU Emacs集成环境的大部分都是用一种叫做Emacs Lisp的编程语言编写的。用这种编程语言编写的代码是软件，是一组指令，告诉计算机在你给它命令时应该做什么。Emacs被设计成可以用Emacs Lisp编写新代码，并轻松地将其安装为编辑器的扩展。

(GNU Emacs有时被称为“可扩展编辑器”，但它的功能远不止提供编辑功能。更恰当的称呼是将Emacs视为“可扩展计算环境”。然而，这个短语有点拗口。简单地将Emacs称为编辑器更容易理解。此外，在Emacs中的一切活动，如查找玛雅日期和月相、简化多项式、调试代码、管理文件、阅读邮件、撰写书籍，都可以看作是一种最一般意义上的编辑。)

@menu
* Why::                         Why learn Emacs Lisp?
* On Reading this Text::        Read, gain familiarity, pick up habits....
* Who You Are::                 For whom this is written.
* Lisp History::
* Note for Novices::            You can read this as a novice.
* Thank You::
@end menu

@ifnottex
@node Why
@unnumberedsec 为什么要学习 Emacs Lisp？
@end ifnottex

尽管Emacs Lisp通常只与Emacs相关，但它是一种完整的计算机编程语言。您可以像使用其他编程语言一样使用Emacs Lisp。

也许您想了解编程；也许您想扩展Emacs；或者也许您想成为一名程序员。这个关于Emacs Lisp的介绍旨在帮助您入门：引导您学习编程的基础知识，更重要的是，向您展示如何自学以更进一步。

@node On Reading this Text
@unnumberedsec 关于阅读本文

在本文中，您将看到一些可以在Emacs中运行的小示例程序。如果您正在使用GNU Emacs的Info模式阅读本文，您可以按照示例中的说明来运行这些程序（这很容易做到，当示例程序出现时会有解释）。或者，您可以在运行Emacs的计算机旁边阅读这本介绍性的书籍。（这是我个人偏好的方式；我喜欢纸质书籍。）如果您旁边没有正在运行的Emacs，您仍然可以阅读这本书，但在这种情况下，最好将其视为一部小说或一本尚未探索过的国家的旅行指南：虽然有趣，但不同于亲自实践。

这个介绍的大部分内容都是关于GNU Emacs中的代码演练和代码导览。这些导览有两个目的：首先，使您熟悉真实的、可工作的代码（您每天使用的代码）；其次，使您熟悉Emacs的工作方式。看到一个工作环境是如何实现的是非常有趣的。此外，我希望您会养成浏览源代码的习惯。您可以从中学习并获得灵感。拥有GNU Emacs就像拥有一个充满宝藏的巨龙巢穴。

除了学习作为编辑器的Emacs和作为编程语言的Emacs Lisp，示例和导览还将让您有机会熟悉作为Lisp编程环境的Emacs。GNU Emacs支持编程，并提供了各种工具，如@kbd{M-.}（调用@code{xref-find-definitions}命令的键）。您还将学习关于缓冲区和环境中的其他对象的信息。学习这些Emacs的特性就像探索自己家乡的新路线一样。

@ignore
In addition, I have written several programs as extended examples.
Although these are examples, the programs are real.  I use them.
Other people use them.  You may use them.  Beyond the fragments of
programs used for illustrations, there is very little in here that is
just for teaching purposes; what you see is used.  This is a great
advantage of Emacs Lisp: it is easy to learn to use it for work.
@end ignore

最后，我希望传授一些使用Emacs来学习您不了解的编程方面的技能。您通常可以使用Emacs来帮助您理解困扰您的事情或做一些新的东西。这种自力更生不仅是一种乐趣，还是一种优势。

@node Who You Are
@unnumberedsec 目标读者

本文是为那些不是程序员的人写的初级介绍。如果您是一名程序员，可能对这篇入门文章感到不满意。原因是您可能已经熟练掌握了阅读参考手册的技巧，并且可能不喜欢这篇文章的组织方式。

一位经验丰富的程序员在审阅这篇文章后对我说：

@quotation
@i{我更喜欢从参考手册中学习。我在每个段落中深入阅读，然后在段落之间稍作休息。}

@i{当我阅读完一个段落时，我假设该主题已经讲解完毕，我知道我需要的一切信息（除非下一个段落开始更详细地讨论它）。我期望一个写得很好的，不会有太多冗余的参考手册，而且会有出色的指向（一个）我想要的信息的链接。}
@end quotation

这个介绍不是针对这样的人写的！

首先，我尽量将每件事情都至少重复三次：首先是介绍它；其次是在上下文中展示它；第三是在不同的上下文中展示它，或者进行复习。

其次，我通常不会把有关某个主题的所有信息都集中在一个地方，更不用说一个段落了。根据我的思维方式，这会对读者造成过多的负担。相反，我只会尝试在您需要了解时提供解释。（有时我会包含一些额外信息，以便稍后当额外信息正式介绍时，您不会觉得突然)。

当您阅读这篇文章时，您不必一次性掌握所有内容。通常，您只需要对提到的一些项目有一点了解。我希望我已经结构化了这篇文章并提供了足够的提示，以便您能够意识到什么是重要的，并专注于它。

您需要深入研究一些段落；别无他法。但我已经尽量减少这类段落的数量。这本书旨在作为一个平易近人的小山丘，而不是一个令人望而却步的高峰。

这本名为 @cite{An Introduction to Programming in Emacs Lisp} 的书有一个配套文档,
@iftex
@cite{The GNU Emacs Lisp Reference Manual}.
@end iftex
@ifnottex
@ref{Top, , The GNU Emacs Lisp Reference Manual, elisp, The GNU
Emacs Lisp Reference Manual}.
@end ifnottex
参考手册比这个入门介绍包含更多细节。在参考手册中，有关一个主题的所有信息都集中在一个地方。如果您是像上面的程序员一样，就应该参考它。当然，在阅读完这本@cite{Introduction}后, 您在编写自己的程序时会发现 @cite{Reference Manual} 很有用.

@node Lisp History
@unnumberedsec Lisp的历史
@cindex Lisp history

Lisp语言在20世纪50年代晚期由麻省理工学院为人工智能研究而开发。Lisp语言的强大之处使其在其他领域也表现出色，例如编写编辑器命令和集成环境。

@cindex Maclisp
@cindex Common Lisp
GNU Emacs Lisp在很大程度上受到Maclisp的启发，Maclisp是在20世纪60年代由麻省理工学院开发的。它也在一定程度上受到Common Lisp的启发，Common Lisp在20世纪80年代成为了一种标准。然而，Emacs Lisp比Common Lisp简单得多。（标准的Emacs发行版包含一个可选的扩展文件@file{cl-lib.el}，它为Emacs Lisp添加了许多Common Lisp功能。）

@node Note for Novices
@unnumberedsec 新手须知

即使您不了解GNU Emacs，您仍然可以从本文中有所收获。但是，我建议您学习Emacs，即使只是为了学会在计算机屏幕上移动。您可以使用内置教程来自学如何使用Emacs。要使用它，输入@kbd{C-h t}。（这意味着您同时按下和释放@key{CTRL}键和@kbd{h}键，然后按下和释放@kbd{t}键。）

此外，我经常通过列出用于调用标准Emacs命令的按键，然后在括号中给出命令的名称，来引用Emacs的标准命令之一，就像这样：@kbd{M-C-\}（@code{indent-region}）。这意味着@code{indent-region}命令通常是通过键入@kbd{M-C-\}来调用的。（如果您愿意，您可以更改用于调用命令的按键；这被称为@dfn{rebinding, 重新绑定}。@xref{Keymaps, , Keymaps}。）@kbd{M-C-\}的缩写意味着你需要同时按下@key{META}键、@key{CTRL}键和@kbd{\}键。在许多现代键盘上，@key{META}键帽上标着@key{ALT}。像这样的组合被称为组合键(keychord)。如果你的键盘没有@key{META}键，单击@key{ESC}键来代替它。在这种情况下，@kbd{M-C-\}意味着您按下并释放@key{ESC}键，然后同时按下@key{CTRL}键和@kbd{\}键。但通常@kbd{M-C-\}意味着同时按下标有@key{ALT}的键和@key{CTRL}键，同时再按@kbd{\}键。

除了长按单个组合键外，您还可以在你输入的内容前加上@kbd{C-u}，这被称为@dfn{通用参数}。@kbd{C-u}组合键会将参数传递给后续的命令。因此，要以6空格缩进一段纯文本的区域，首先标记该区域，然后输入@w{@kbd{C-u 6 M-C-\}}。（如果您不指定一个数字，Emacs将默认数字为4，或者以不同于其他情况的方式运行该命令。）@xref{Arguments, , Numeric Arguments, emacs, The GNU Emacs Manual}。

如果您是在GNU Emacs中使用Info模式阅读这篇文章，您可以通过按下空格键@key{SPC}来浏览整个文档。（要了解Info，请输入@kbd{C-h i}，然后选择Info。）

关于术语的说明：当我单独使用Lisp这个词时，我通常是在泛指各种Lisp方言，但当我谈到Emacs Lisp时，我指的是特定的GNU Emacs Lisp。

@node Thank You
@unnumberedsec 致谢

感谢所有帮助我完成这本书的人。特别感谢@r{Jim Blandy}，@r{Noah Friedman}，@w{Jim Kingdon}，@r{Roland McGrath}，@w{Frank Ritter}，@w{Randy Smith}，@w{Richard M. Stallman}和@w{Melissa Weisshaus}。我还要感谢@w{Philip Johnson}和@w{David Stampe}，他们的耐心鼓励对我非常重要。如有遗漏是我的问题。

@flushright
Robert J. Chassell
@ifnothtml
@email{bob@@gnu.org}
@end ifnothtml
@ifhtml
bob@@gnu.org
@end ifhtml
@end flushright

@c ================ Beginning of main text ================

@c Start main text on right-hand (verso) page

@tex
\par\vfill\supereject
\headings off
\ifodd\pageno
    \par\vfill\supereject
\else
    \par\vfill\supereject
    \page\hbox{}\page
    \par\vfill\supereject
\fi
@end tex

@c Note: this resetting of the page number back to 1 causes TeX to gripe
@c about already having seen page numbers 1-4 before (in the preface):
@c   pdfTeX warning (ext4): destination with the same identifier (name{1})
@c   has been already used, duplicate ignored
@c I guess that is harmless (what happens if a later part of the text
@c makes a link to something in the first 4 pages though?).
@c E.g., note that the Emacs manual has a preface, but does not bother
@c resetting the page numbers back to 1 after that.
@c Alternatively, uncomment the 3 lines above (search for ``pageno'')
@c to have the preface numbered in roman numerals.
@iftex
@headings off
@evenheading @thispage @| @| @thischapter
@oddheading @thissection @| @| @thispage
@global@pageno = 1
@end iftex

@node List Processing
@chapter 列表处理

对于未经培训的人来说，Lisp 是一种奇特的编程语言。在 Lisp 代码中，到处都是括号。甚至有人声称这个名字代表“Lots of Isolated Silly Parentheses”（很多孤立的愚蠢括号）。但这种说法是不准确的。Lisp 代表 LISt Processing，这种编程语言通过处理括号中的@emph{列表}（以及列表的列表）来工作。括号标示着列表的边界。有时候，列表前面会有一个撇号@samp{'}，称作 Lisp 中的@dfn{单引号}。
@footnote{A single-quote is an
abbreviation for the special form @code{quote}; you need not think
about special forms now.
@ifnottex
@xref{Complications}.
@end ifnottex
@iftex
@xref{Lisp Interpreter}.
@end iftex
}  列表是 Lisp 的基础。

@menu
* Lisp Lists::                  什么是列表？
* Run a Program::               Lisp中的任何列表都可以直接运行
* Making Errors::               生成错误消息
* Names & Definitions::         符号的名称和函数定义
* Lisp Interpreter::            Lisp解释器的作用
* Evaluation::                  运行程序
* Variables::                   从变量返回值
* Arguments::                   向函数传递信息
* set & setq::                  设置变量的值
* Summary::                     总结
* Error Message Exercises::
@end menu

@node Lisp Lists
@section Lisp列表
@cindex Lisp Lists

在Lisp中，一个列表看起来像这样：@code{'(rose violet daisy buttercup)}。这个列表前面有一个单引号。它也可以写成如下形式，更像你可能熟悉的列表：

@smallexample
@group
'(rose
  violet
  daisy
  buttercup)
@end group
@end smallexample

@noindent
这个列表的元素是四种不同花的名称，它们之间用空格分隔，被括号包围，就像田野中的花朵被一堵石墙围绕着。
@cindex 田野中的花朵

@menu
* Numbers Lists::               包含数字和其他列表的列表。
* Lisp Atoms::                  基本实体。
* Whitespace in Lists::         格式化使列表更易阅读。
* Typing Lists::                GNU Emacs如何帮助您输入列表。
@end menu

@ifnottex
@node Numbers Lists
@unnumberedsubsec 列表中的数字与列表
@end ifnottex

在 Lisp 中,列表也可以包含数值，就像这个列表：@code{(+ 2 2)}。
这个列表包含一个加号，@samp{+}，后面跟着两个 @samp{2}，它们之间用空格分隔。

在Lisp中，数据和程序都以相同的方式表示；也就是说，它们都是由单词、数字或其他列表组成，之间用空格分隔，括在括号中。 (由于程序看起来像数据，一个程序可以轻松地作为另一个程序的数据；这是Lisp的一个非常强大的特性。) (顺便说一下，这两个括号中的注释@emph{不是}Lisp列表，因为它们包含了分号 @samp{;} 和句点 @samp{.} 作为标点符号。)

@need 1200
这里还有一个列表，这次里面包含了一个列表：

@smallexample
'(this list has (a list inside of it))
@end smallexample

这个列表的组成部分包括单词 @samp{this}, @samp{list},
@samp{has}, 和列表 @samp{(a list inside of it)}.  内部列表由单词 @samp{a}, @samp{list}, @samp{inside},
@samp{of}, @samp{it} 组成。

@node Lisp Atoms
@subsection Lisp原子
@cindex Lisp Atoms

在Lisp中，我们一直称之为单词的东西被称为@dfn{原子}。这个术语来自于“原子”一词的历史含义，即“不可分割”。就Lisp而言，我们在列表中使用的单词不能再分割成更小的部分，仍然具有与程序的某个部分相同的含义；数字和单字符符号（如@samp{+}）也是如此。然而，与古代的原子不同，列表可以被分割成部分。 (@xref{car cdr & cons,
, @code{car} @code{cdr} & @code{cons} Fundamental Functions}.)

在列表中，原子之间由空格分隔。它们可以紧邻括号。

@cindex @samp{empty list} defined
从技术上讲，Lisp中的列表由括号括起，括号内部包含由空格分隔的原子，或者括号内部包含其他列表，或者同时包含原子和其他列表。一个列表可以只包含一个原子，也可以什么都不包含。一个什么都不包含的列表看起来像这样：@code{()}，称为@dfn{空列表}。与其他东西不同，空列表既是原子又是列表。

@cindex Symbolic expressions, introduced
@cindex @samp{表达式} defined
@cindex @samp{形式} defined
原子和列表的打印表示被称为@dfn{符号表达式}，或更简洁地称为@dfn{s-表达式}。单词@dfn{表达式}本身可以指的是打印表示，也可以指的是计算机内部保存的原子或列表。通常，人们会不加区分地使用@dfn{表达式}一词。 (此外，许多文本中，@dfn{形式}也被用作表达式的同义词。)

@c This and the next paragraph say ``kinds of atom'', but that is not
@c a typo, just slightly ``old-fashioned wording which adds a fillip
@c of interest to it'', and ``is more elegant writing'', according to
@c RMS.
顺便提一下，构成我们宇宙的原子最初被认为是不可分割的。但后来发现，原子并非不可分割。原子可以分裂成两个大致相等的部分，或者可以有部分组成从原子中分离出来。也就是说，原子在其真正性质被发现之前就被过早地命名了。在Lisp中，某些类型的原子，例如数组，也可以被分割成部分，但这种分割数组的机制与分割列表的机制不同。就列表操作而言，列表的原子是不可分割的。

与汉语词语的含义不同于单个汉字的含义一样,Lisp语言中的原子也不等同于组成它的字母。例如，熊猫，与"熊" 和 "猫"完全不同。

自然界中有许多种类的原子，而在Lisp中只有少数几种：例如，@dfn{数字}，比如37、511或1729，以及@dfn{符号}，比如@samp{+}、@samp{foo}或@samp{forward-line}。我们在上面的示例中列出的单词都是符号。在日常的Lisp对话中，“原子”这个术语很少被直接使用，因为程序员通常会尽量明确他们正在处理哪一类型的原子。Lisp编程主要涉及列表中符号的处理（有时还涉及数字）。(顺便一提，前文中的括号注释也是一个合法的Lisp列表，因为它由原子组成，这些原子是符号，被空格分隔并用括号括起，没有任何非Lisp符号。)

@need 1250
用双引号括起的文本，即使是句子或段落，也会被视为一个原子。下面是一个例子：
@cindex Text between double quotation marks

@smallexample
'(this list includes "text between quotation marks.")
@end smallexample

@cindex @samp{string} defined
@noindent
在Lisp中，所有引号括起的内容，包括标点符号和空格，都会被视为一个单独的原子。这种类型的原子被称为@dfn{字符串}(string)，通常用于让计算机打印出人类可读的消息。字符串与数字或符号不同，使用方式也有区别。

@node Whitespace in Lists
@subsection 列表中的空格
@cindex Whitespace in lists

@need 1200
在Lisp语言中，表中的空格数量并不重要。从Lisp的角度看，

@smallexample
@group
'(this list
   looks like this)
@end group
@end smallexample

@need 800
@noindent
与这个表达式完全等价：

@smallexample
'(this list looks like this)
@end smallexample

这两个例子展示了在Lisp中相同的一个列表，它由这些符号 @samp{this}、@samp{list}、@samp{looks}、@samp{like} 和 @samp{this} 按顺序组成。

额外的空格和换行只是为了让人更容易阅读列表。当Lisp读取表达式时，会忽略额外的空格（但原子之间至少需要一个空格来区分）。

尽管看起来很奇怪，但我们已经涵盖了Lisp中几乎所有列表的情况！Lisp中的其他列表都或多或少与这些例子相似，只是列表可能更长更复杂。简而言之，列表在括号内，字符串在引号内，符号看起来像单词，数字看起来像数字。（对于某些情况，可能会使用方括号、点号等一些特殊字符；但即使没有它们，我们也已经可以处理很多情况了。）

@node Typing Lists
@subsection GNU Emacs帮助您输入列表
@cindex Help typing lists
@cindex Formatting help

在GNU Emacs中，当您在Lisp交互模式或Lisp模式下输入Lisp表达式时，可以使用一些命令来格式化Lisp表达式，以提高代码的可读性。例如，按下@key{TAB}键会自动合理缩进当前行。通常，用于正确缩进区域中的代码的快捷键绑定为@kbd{M-C-\}。代码缩进可以让您清楚地看出哪些元素属于某个列表---子列表的元素缩进会比包含它的列表更深。

此外，当您键入右括号时，Emacs会短暂地将光标跳回到对应的左括号，这样您可以看到右括号与哪个左括号匹配。这非常有用，因为在Lisp中，您写的每个列表都必须有对应的右括号和左括号。（有关Emacs模式的更多信息，@xref{Major Modes, , Major Modes, emacs, The GNU Emacs Manual}）

@node Run a Program
@section 运行程序
@cindex Run a program
@cindex Program, running one

@cindex @samp{evaluate} defined
在Lisp中，任何列表本身都可以作为一个准备执行的程序。如果对列表进行求值（在Lisp术语中称为@dfn{评估}(evaluate, eval)），计算机会执行以下三种操作之一：直接返回列表本身且不做任何处理；显示错误信息；或者将列表中的第一个符号视为命令并执行相应操作。 （当然，通常您期望的是最后一种情况！）

@c 用代码表示单引号，而不是samp。
@findex quote
@cindex @code{'} for quoting
@cindex quoting using apostrophe
@cindex apostrophe for quoting
在前面章节的示例中，我在某些列表之前使用的@code{'}，称为@dfn{单引号}；它的作用是告诉Lisp直接原样输出这个列表，不做任何处理。但是，如果列表前没有单引号，那么列表中的第一个元素就具有特殊意义：它是计算机要执行的命令。 （在Lisp中，这些命令被称为@emph{函数}。）上例中的@code{(+ 2 2)}列表没有单引号，因此Lisp会将@code{+}视为指示对后面的数字进行相加运算的命令。

@need 1250
如果您在GNU Emacs中的Info模式下阅读此文档，可以通过以下步骤来执行Lisp表达式的计算：将光标置于以下列表的右括号之后，键入@kbd{C-x C-e}：

@smallexample
(+ 2 2)
@end smallexample

@c 这里使用代码格式表示数字四，而不是samp。
@noindent
您将在回显区域看到数字@code{4}@footnote{Emacs以十进制、八进制和十六进制以及字符的方式显示整数值，但现在让我们忽略这个便利功能。}。 （您刚刚对该列表进行了评估。回显区域位于屏幕底部区域，或是输出文本信息。）现在尝试对一个带引号的列表执行相同的操作：将光标放在下例列表的右括号后，键入@kbd{C-x C-e}：

@smallexample
'(this is a quoted list)
@end smallexample

@noindent
您将在回显区域看到 @code{(this is a quoted list)}。

@cindex Lisp interpreter, explained
@cindex Interpreter, Lisp, explained
在上述两种情况下，您所做的是向GNU Emacs内部的一个叫做@dfn{Lisp解释器}的程序发送一个命令，即给解释器一个要评估的表达式。Lisp解释器(interpreter)得名于它解释表达式含义的功能,就像一个人在解释一样。

您也可以评估一个不是列表的原子，即一个没有被括号包围的原子；同样，Lisp解释器会将这种人类可读的表达式翻译成计算机语言。但在讨论这个之前（@pxref{Variables}），我们先来看当出现错误时Lisp解释器会做什么。

@node Making Errors
@section 生成错误信息
@cindex Generate an error message
@cindex Error message generation

部分原因是,如果您不小心出错了,也不用担心，我们现在将向 Lisp 解释器发出一个命令，让它生成一条错误信息。 这是一项无害的尝试； 事实上，我们经常会尝试故意生成错误信息。 一旦您理解了相关术语，错误信息就可以提供丰富的信息帮助。 它们不应该被称为“错误”信息，而更应该被称为“帮助”信息。 它们就像异国游客遇到的路标； 解读这些信息可能很困难，但一旦理解其含义，它们就能指明道路。

错误信息是由GNU Emacs内置的调试器生成的。我们将进入调试器环境。您可以通过键入 @code{q} 来退出调试器。

我们要做的是对一个没有加单引号且第一个元素不是有效命令的列表进行评估。这个列表和我们之前用过的类似,只是没有加上单引号。将光标定位到该列表的后面，然后输入 @kbd{C-x C-e}：

@smallexample
(this is an unquoted list)
@end smallexample

这将打开一个 @file{*Backtrace*} 的窗口，您应该在其中看到以下内容：

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function this)
  (this is an unquoted list)
  eval((this is an unquoted list) nil)
  elisp--eval-last-sexp(nil)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@need 1200
@noindent
此时光标会定位在这个窗口中（可能需要等待几秒才显示出来）。要退出调试器并关闭调试器窗口，请输入：

@smallexample
q
@end smallexample

@noindent
请现在按下 @kbd{q}键，以确保您能退出调试器。然后再次输入 @kbd{C-x C-e} 重新进入调试器。

@cindex @samp{函数} defined
根据我们已经了解的知识，我们基本可以解析这个错误信息的含义。

从下往上查看 @file{*Backtrace*} 缓冲区的内容；它记录了Emacs执行的步骤。当您输入 @kbd{C-x C-e} 时，向命令 @code{eval-last-sexp} 发起了交互调用。@code{eval} 是“evaluate（评估）”的缩写，@code{sexp} 是“symbolic expression（符号表达式）”的缩写。该命令的含义是“评估最后一个符号表达式”，也就是光标前的那个表达式。

以上每一行都在告诉我们Lisp解释器接下来评估的内容。最新的操作在顶部。这个缓冲区被称为 @file{*Backtrace*} ，因为它允许我们回溯Emacs的执行步骤。

@need 800
在 @file{*Backtrace*} 缓冲区的顶部，您可以看到这样一行：

@smallexample
Debugger entered--Lisp error: (void-function this)
@end smallexample

@noindent
Lisp 解释器试图对列表的第一个原子 @samp{this} 进行评估。正是这个操作产生了错误信息 @samp{void-function this}。

这个信息包含了 @samp{void-function} 和 @samp{this} 两个词。

@cindex @samp{函数} defined
@samp{函数} (function)这个词之前提到过一次。这是一个非常重要的概念。对我们而言，可以定义简单理解为一组指令，用于告诉计算机要执行什么操作。

现在我们可以开始解析这个错误信息@samp{void-function this}的含义了。这个函数（也就是，@samp{this}这个词）没有关联任何一组指令来告诉计算机要执行什么操作。

这个比较奇怪的词@samp{void-function}是为了反映Emacs Lisp的实现方式，也就是说，当一个符号没有绑定函数定义时，原本要包含执行指令的位置是空的。

另一方面，由于我们可以成功对2和2进行相加（通过评估 @code{(+ 2 2)}），我们可以推断符号 @code{+} 一定有一组与之关联的指令，这些指令会指示计算机将紧随其后的数字相加。

在这种情况下，可以避免Emacs进入调试器。我们暂不解释如何实现，但会提及结果的样子，因为当您在使用某段Emacs代码遇到类似情况时，也可能看到类似的效果。在这种情况下，您只会看到一行错误信息；它会出现在回显区，看起来像这样：

@smallexample
Symbol's function definition is void:@: this
@end smallexample

@noindent
@ignore
(Also, your terminal may beep at you---some do, some don't; and others
blink.  This is just a device to get your attention.)
@end ignore
当你输入任何键，哪怕只是移动一下光标，这个消息就会消失。

我们知道@samp{Symbol}这个词的含义。它指代的是列表中的第一个原子，也就是词@samp{this}。@samp{function}一词表示用于告知计算机要执行什么操作的指令。（技术上来说，这个符号会告知计算机在何处可以找到这些指令，但这个复杂问题我们暂时可以忽略。）

所以错误信息可以这样理解：@samp{Symbol's function definition is void:@: this}。这个符号(Symbol)（也就是词@samp{this}）缺少可供计算机执行的指令。

@node Names & Definitions
@section 符号名称和函数定义
@cindex Symbol names

根据目前我们的讨论,我们可以归纳出Lisp的另一关键特性：像 @code{+} 这样的符号本身并不是计算机可执行的一组指令。相反，这些符号仅用于暂时定位相关的定义或指令集。我们看到的只是通过该符号名称才能找到实际指令的方式。人的名字也是一样的。我可以被称为 @samp{Bob}；然而，我不是字母 @samp{B}、@samp{o}、@samp{b} 的组合，而是（或者曾是）一个与特定生命形式长期关联的意识。名字并不是我，但可以用来指称我。

在 Lisp 中，一组指令可以被关联到多个名字上。例如，加法运算的计算机指令可以关联到符号 @code{plus}，也可以关联到符号 @code{+}上（在某些 Lisp 方言中是这样的）。对于人名，我可以被称为 @samp{Robert}，也可以被称为 @samp{Bob}，以及其他词汇。

但是，一个符号一次只能有一个函数定义与之关联。否则，计算机就会困惑应该使用哪个定义。如果这种情况发生在人类身上，世界上也只能有一个人被命名为 @samp{Bob}。然而，符号所代表的函数定义可以很容易地被更改。(@xref{安装, , 安装函数定义}.)

由于 Emacs Lisp 非常庞大，通常会以能够指明函数属于Emacs的哪个部分的方式来命名符号。因此，所有涉及 Texinfo 处理的函数名都以 @samp{texinfo-} 开头，而处理邮件读取的函数则以 @samp{rmail-} 开头。

@node Lisp Interpreter
@section Lisp解释器
@cindex Lisp interpreter, what it does
@cindex Interpreter, what it does

基于我们所见，现在我们可以开始弄清楚当命令Lisp解释器评估列表时它会做什么。首先，它会查看列表前是否有引号；如果有，解释器会直接返回这个列表。另一方面，如果没有引号，解释器会查看列表中的第一个元素，检查它是否有一个函数定义与之关联。如果有，解释器就会执行该函数定义中的指令。否则，解释器会打印错误信息。

这就是Lisp的工作原理。简单明了。当然，还有一些额外的复杂性，我们后面会提到，但这些是基础。想要编写Lisp程序，您还需要了解如何编写函数定义并将其关联到函数名上，以及如何在不使自己和计算机产生困惑的情况下实现这一点。

@menu
* Complications::               变量、特殊形式、内部列表。
* Byte Compiling::              为加速对代码特殊处理。
@end menu

@ifnottex
@node Complications
@unnumberedsubsec 复杂情况
@end ifnottex

现在，我们来看第一个复杂情况。除了列表，Lisp 解释器还可以对没有引号且没有被括号包围的单个符号进行评估。在这种情况下，Lisp 解释器会试图确定该符号作为@dfn{变量}的值。这种情况我们会在变量部分进行描述。(@xref{Variables}.)

@cindex Special form
第二个复杂情况是，有一些函数的工作方式与常规函数不同，那些不同寻常的函数被称为@dfn{特殊形式}。它们用于处理特定任务，比如定义函数，而且数量并不多。在后续章节中，您会了解到一些更重要的特殊形式。

除特殊形式外，还有@dfn{宏}。宏是Lisp中定义的一种构造，不同于函数的地方在于，它会将一个Lisp表达式转换成另一个要代替原始表达式进行评估的表达式。(@xref{Lisp macro}。)

就本书而言，您无需过于担心某个东西是特殊形式、宏还是普通函数。例如，@code{if} 是一个特殊形式（@pxref{if}），而@code{when} 是一个宏（@pxref{Lisp macro}）。在Emacs的早期版本中，@code{defun} 是一个特殊形式，但现在它是一个宏（@pxref{defun}），不过它的用法没有改变。

最后一个复杂情况是：如果Lisp解释器正在处理的函数不是特殊形式，并且它是列表的一部分，Lisp解释器会检查这个列表是否包含内部列表。如果存在内部列表，Lisp解释器先确定应该如何处理内部列表，然后再处理外部列表。如果内部列表中还嵌套了另一个列表，它还会先处理那个列表，以此类推。解释器总是先处理最内层的列表。它会首先对最内层列表进行评估，得到结果用于外层表达式。

否则，解释器会从左到右顺序处理表达式，每个表达式依次处理。

@node Byte Compiling
@subsection 字节编译
@cindex Byte compiling

Lisp解释器可以处理两种实体：人类可读的代码，这会是我们的重点；以及经过特殊处理的代码，称为 @dfn{字节编译}的代码，后者不是人类可读的。字节编译的代码的运行速度比人类可读的代码要快。

您可以通过运行像 @code{byte-compile-file} 这样的编译命令，将人类可读的代码转换为字节编译的代码。字节编译后的代码通常保存在以 @file{.elc} 为扩展名的文件中，而不是 @file{.el}。在 @file{emacs/lisp} 目录下您会看到这两种类型的文件；需要阅读的是那些 @file{.el} 扩展名的文件。

实际上，对于大多数自定义和扩展Emacs的需要，您不一定要进行字节编译；我在这里也不会详细讨论这个话题。要获取字节编译的完整描述，@xref{Byte Compilation, , Byte Compilation, elisp, The GNU Emacs Lisp Reference Manual}。

@node Evaluation
@section 评估
@cindex Evaluation

当Lisp解释器对表达式进行处理时，这个活动被称为 @dfn{评估}。我们说解释器 "评估表达式"。我之前已经多次使用过这个术语。这个词来源于日常语言中的 "确定价值或数量"，根据 @cite{Webster's New Collegiate Dictionary} 的定义。

@menu
* How the Interpreter Acts::    返回值和副作用...
* Evaluating Inner Lists::      列表内部的列表...
@end menu

@ifnottex
@node How the Interpreter Acts
@unnumberedsubsec Lisp 解释器的行为方式
@end ifnottex

@cindex @samp{returned value} explained
在对表达式评估后，Lisp 解释器很可能会@dfn{返回}计算机通过执行函数定义中的指令得到的值，或者它可能放弃对该函数的处理并生成错误消息。（也可能出现解释器被抛入另一个函数的执行,或者陷入无限循环的情况,但这些比较少见,我们可以忽略。）最常见的情况是，解释器返回一个值。

@cindex @samp{side effect} defined
与此同时，解释器还可能执行其他操作，如移动光标或复制文件；这类被称为@dfn{副作用}。我们人类认为重要的操作，比如打印结果，通常是 Lisp 解释器的副作用。学习使用副作用相对比较简单。

综上所述，对符号表达式评估通常会导致 Lisp 解释器返回一个值，并可能产生副作用；否则就会产生错误信息。

@node Evaluating Inner Lists
@subsection 评估内部列表
@cindex Inner list evaluation
@cindex Evaluating inner lists

如果对嵌套在另一个列表中的内部列表进行评估，外部列表在评估时可能会使用内层列表的评估结果作为信息。这解释了为什么要首先对内部表达式进行评估：它们的返回值会被外部表达式使用。

@need 1250
我们可以通过对另一个加法示例进行评估来调查这个过程。将光标置于以下表达式之后，键入@kbd{C-x C-e}：

@smallexample
(+ 2 (+ 3 3))
@end smallexample

@noindent
数字8将会出现在回显区域。

过程是这样的，Lisp解释器首先对内部表达式@code{(+ 3 3)}进行评估，返回值是6；然后它对外部表达式评估，就像表达式写成@code{(+ 2 6)}一样，返回值是8。由于没有更多外层表达式需要评估，解释器将这个值打印在回显区域。

现在很容易理解@kbd{C-x C-e}这个快捷键所调用命令的名称 @code{eval-last-sexp}。@code{sexp}是“symbolic expression”（符号表达式）的缩写，而@code{eval}是“evaluate”（评估）的缩写。该命令对最后一个符号表达式进行评估。

作为实验，您可以尝试通过将光标放在表达式后面紧跟的下一行行首，或者放在表达式内部来评估该表达式。

@need 800
下面是表达式的另一份副本：

@smallexample
(+ 2 (+ 3 3))
@end smallexample

@noindent
如果将光标放在紧随表达式后面的空白行行首，然后键入 @kbd{C-x C-e}，您仍然会在回显区域中看到打印的值8。现在试着将光标放在表达式内部。如果将光标放在倒数第二个括号后（使它看起来位于最后一个括号上方），您会在回显区域看到打印的值6！这是因为该命令评估了表达式 @code{(+ 3 3)}。

现在将光标放在一个数字后面。键入 @kbd{C-x C-e}，您会得到那个数字本身。在Lisp中，对一个数字评估会直接返回这个数字本身——这是数字与符号的区别。如果对以像 @code{+} 这样的符号开头的列表评估，您会得到一个返回值，该返回值是计算机执行附加在该符号上的函数定义中的指令所得到的结果。如果单独对一个符号评估，会发生一些不同的事情，我们将在下一节看到。

@node Variables
@section 变量
@cindex Variables

在 Emacs Lisp 中，一个符号可以附加一个值，就像它可以附加一个函数定义一样。这两者是不同的。函数定义是计算机将执行的一组指令。值，另一方面，是一些可以变化的东西，比如一个数字或一个名称（这就是为什么这样的符号被称为变量的原因）。一个符号的值可以是Lisp中的任何表达式，比如一个符号、数字、列表或字符串。一个具有值的符号通常被称为@dfn{变量}。

一个符号可以同时有一个函数定义和一个值。或者它可以只有其中之一。这两者是独立的。这与剑桥这个名称既可以指代马萨诸塞州的城市，又可以附带一些信息，比如“伟大的编程中心”，有些相似。

@ignore
（顺便说一下，在Emacs Lisp中，一个符号还可以附加两个其他东西：属性列表和文档字符串；这些稍后会讨论。）
@end ignore

另一种思考这个问题的方式是将一个符号想象成一个抽屉柜。函数定义放在一个抽屉里，值放在另一个抽屉里，依此类推。在值的抽屉里放置的东西可以更改，而不影响放置函数定义的抽屉的内容，反之亦然。

@menu
* fill-column Example::
* Void Function::               一个没有函数的符号的错误消息。
* Void Variable::               一个没有值的符号的错误消息。
@end menu

@ifnottex
@node fill-column Example
@unnumberedsubsec @code{fill-column}，一个示例变量
@end ifnottex

@findex fill-column@r{，一个示例变量}
@cindex 示例变量，@code{fill-column}
@cindex 变量，示例，@code{fill-column}
变量 @code{fill-column} 说明了一个带有值的符号：在每个 GNU Emacs 缓冲区中，该符号被设置为某个值，通常是 72 或 70，但有时也可能是其他值。要找到此符号的值，请通过单独评估它来执行。如果您在 GNU Emacs 中的 Info 中阅读此信息，可以将光标放在符号后面，然后键入 @kbd{C-x C-e} 来执行：

@smallexample
fill-column
@end smallexample

@noindent
在我键入 @kbd{C-x C-e} 后，Emacs 在我的回显区打印了数字 72。这是我在编写此内容时为 @code{fill-column} 设置的值。在您的 Info 缓冲区中，这个值可能是不同的。请注意，变量返回的值与执行其指令的函数返回的值的打印方式完全相同。从 Lisp 解释器的角度来看，返回的值就是返回的值。一旦知道值是什么，它来自哪种表达式就不再重要。

一个符号可以附有任何值，或者用行话说，我们可以将变量@dfn{绑定}到一个值上：可以是一个数字，比如 72；可以是一个字符串，比如 @code{"如此"}；可以是一个列表，比如 @code{(云杉 松树 橡树)}；我们甚至可以将变量绑定到一个函数定义上。

一个符号可以以多种方式绑定到一个值。有关如何执行此操作的信息，请参阅@xref{set & setq, , Setting the Value of a Variable}。

@node Void Function
@subsection 没有函数的符号的错误消息
@cindex 没有函数的符号错误
@cindex 没有函数的符号错误消息

当我们评估变量 @code{fill-column} 以获取其值时，我们没有在单词周围加括号。这是因为我们没有打算将其用作函数名称。

如果 @code{fill-column} 是列表的第一个或唯一元素，Lisp 解释器将尝试找到与之关联的函数定义。但是 @code{fill-column} 没有函数定义。尝试评估以下内容：

@smallexample
(fill-column)
@end smallexample

@need 1250
@noindent
将会创建一个 @file{*Backtrace*} 缓冲区，其中显示：

@smallexample
@group
---------- 缓冲区：*Backtrace* ----------
Debugger entered--Lisp error: (void-function fill-column)
  (fill-column)
  eval((fill-column) nil)
  elisp--eval-last-sexp(nil)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
---------- 缓冲区：*Backtrace* ----------
@end group
@end smallexample

@noindent
（记住，要退出调试器并关闭调试器窗口，请在 @file{*Backtrace*} 缓冲区中键入 @kbd{q}。）

@node Void Variable
@subsection 没有值的符号的错误消息
@cindex 没有值的符号错误
@cindex 没有值的符号错误消息

如果你尝试评估一个没有绑定值的符号，你将收到一个错误消息。你可以通过尝试我们的2加2的加法来看到这一点。在下面的表达式中，将光标放在第一个数字2之前的@code{+}右边，然后输入@kbd{C-x C-e}：

@smallexample
(+ 2 2)
@end smallexample

@need 1500
@noindent
在GNU Emacs 22中，你将创建一个名为@file{*Backtrace*}的缓冲区，显示如下错误消息：

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-variable +)
  eval(+)
  elisp--eval-last-sexp(nil)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@noindent
（同样，你可以在@file{*Backtrace*}缓冲区中输入@kbd{q}来退出调试器。）

这个回溯与我们最初看到的第一个错误消息不同，它说的是@samp{Debugger entered--Lisp error: (void-function this)}。在这种情况下，该函数没有作为变量的值；而在其他错误消息中，函数（单词@samp{this}）没有定义。

在这个对@code{+}的实验中，我们的做法是导致Lisp解释器评估@code{+}并寻找变量的值，而不是函数的定义。我们通过将光标放在符号右边而不是在封闭列表的括号后面，使Lisp解释器执行了前一个S表达式，这种情况下是单独的@code{+}。

由于@code{+}没有绑定到任何值，只有函数定义，错误消息报告该符号作为变量的值为空。

@node 参数
@section 参数
@cindex 参数
@cindex 将信息传递给函数

为了了解信息是如何传递给函数的，让我们再次看看我们的老朋友，@code{2 + 2}。在Lisp中，它被写成如下形式：

@smallexample
(+ 2 2)
@end smallexample

如果你评估这个表达式，数字4将出现在你的回显区。Lisp解释器所做的是将跟随@code{+}的数字相加。

@cindex @samp{argument} 的定义
由@code{+}相加的数字被称为函数@code{+}的@dfn{参数}。这些数字是传递给函数的信息。

“参数”这个词来自数学中的用法，不是指两个人之间的辩论；而是指提供给函数的信息，在这种情况下，是提供给@code{+}的信息。在Lisp中，函数的参数是跟随函数的原子或列表。通过评估这些原子或列表的结果值传递给函数。不同的函数需要不同数量的参数；有些函数根本不需要参数。@footnote{追踪“参数”这个词如何在数学中和日常英语中拥有两个不同的含义是很有趣的。根据《牛津英语词典》的说法，这个词源于拉丁语，意思是“澄清，证明”；因此，它通过一条推导线的方式，来表示“作为证据提供的信息”，也就是说，“提供的信息”，这导致了它在Lisp中的含义。但在另一条推导线上，它的意思变成了“以一种其他人可以提出反对主张的方式断言”，这解释了这个词作为争论的含义。(注意这里英语单词同时拥有两个不同的定义。相比之下，在Emacs Lisp中，一个符号在同一时间不能拥有两个不同的函数定义。)}

@menu
* 数据类型::                  传递给函数的数据类型。
* 将参数作为变量或列表::    参数可以是变量或列表的值。
* 可变数量的参数::  一些函数可能接受可变数量的参数。
* 错误类型的参数::      将错误类型的参数传递给函数。
* message::                     用于发送消息的有用函数。
@end menu

@node 数据类型
@subsection 参数的数据类型
@cindex 数据类型
@cindex 数据的类型
@cindex 参数的数据类型

应传递给函数的数据类型取决于它使用的信息的种类。例如，像@code{+}这样的函数的参数必须是数字，因为@code{+}是对数字进行加法运算的。其他函数使用不同类型的数据作为它们的参数。

@need 1250
@findex concat
例如，@code{concat}函数将两个或多个文本字符串连接或合并成一个字符串。其参数是字符串。连接两个字符字符串@code{abc}和@code{def}将产生单个字符串@code{abcdef}。通过评估以下表达式可以看到这一点：

@smallexample
(concat "abc" "def")
@end smallexample

@noindent
评估这个表达式产生的值是@code{"abcdef"}。

@cindex substring
像@code{substring}这样的函数使用字符串和数字作为参数。该函数返回字符串的一部分，即第一个参数的@dfn{子字符串}。该函数接受三个参数。其第一个参数是字符字符串，第二个和第三个参数是指示子字符串的开始（包括）和结束（不包括）的数字。这些数字表示从字符串开头开始的字符数（包括空格和标点符号）。注意字符串中的字符是从零开始编号的，而不是从一开始。

@need 800
例如，如果你评估以下表达式：

@smallexample
(substring "The quick brown fox jumped." 16 19)
@end smallexample

@noindent
你将在回显区看到@code{"fox"}。这些参数分别是字符串和两个数字。

请注意，传递给@code{substring}的字符串是一个单一的原子，即使它由多个用空格分隔的单词组成。Lisp将引号之间的所有内容都计为字符串的一部分，包括空格。你可以将@code{substring}函数看作是一种原子粒子解体器，因为它从一个否则不可分割的原子中提取了一部分。但是，@code{substring}只能从参数是字符串的原子中提取子字符串，而不能从其他类型的原子（如数字或符号）中提取。

@node 将参数作为变量或列表
@subsection 参数作为变量或列表的值

参数可以是一个符号，在评估时返回一个值。例如，当单独评估符号@code{fill-column}时，它会返回一个数字。这个数字可以在加法中使用。

@need 1250
将光标定位到以下表达式后，键入@kbd{C-x C-e}：

@smallexample
(+ 2 fill-column)
@end smallexample

@noindent
该值将是比仅评估@code{fill-column}得到的数字多两个。对我来说，这是74，因为我的@code{fill-column}值是72。

正如我们刚刚看到的，参数可以是在评估时返回值的符号。此外，参数还可以是在评估时返回值的列表。例如，在以下表达式中，函数@code{concat}的参数是字符串@w{@code{"The "}}和@w{@code{" red foxes."}}，以及列表@code{(number-to-string (+ 2 fill-column))}。

@smallexample
(concat "The " (number-to-string (+ 2 fill-column)) " red foxes.")
@end smallexample

@noindent
如果你评估这个表达式——如果像我的Emacs一样，@code{fill-column}评估为72——@code{"The 74 red foxes."}将出现在回显区。 (注意，你必须在单词@samp{The}后面和单词@samp{red}前面加上空格，这样它们才会出现在最终的字符串中。函数@code{number-to-string}将加法函数返回的整数转换为字符串。@code{number-to-string}也被称为@code{int-to-string}。)

@node 可变数量的参数
@subsection 可变数量的参数
@cindex 可变数量的参数
@cindex 参数，可变数量的

一些函数，如@code{concat}，@code{+}或@code{*}，可以接受任意数量的参数。（@code{*}是乘法的符号。）这可以通过以通常的方式评估以下每个表达式来看到。在回显区域中看到的内容在此文本中以@samp{@result{}}打印出来，你可以将其理解为“求值为”。

@need 1250
在第一组中，函数没有参数：

@smallexample
@group
(+)       @result{} 0

(*)       @result{} 1
@end group
@end smallexample

@need 1250
在这一组中，函数每个都有一个参数：

@smallexample
@group
(+ 3)     @result{} 3

(* 3)     @result{} 3
@end group
@end smallexample

@need 1250
在这一组中，函数每个都有三个参数：

@smallexample
@group
(+ 3 4 5) @result{} 12

(* 3 4 5) @result{} 60
@end group
@end smallexample

@node 错误类型的参数
@subsection 使用错误类型的对象作为参数
@cindex 错误类型的参数
@cindex 参数，错误类型的

当一个函数被传递一个错误类型的参数时，Lisp解释器会产生一个错误消息。例如，@code{+}函数期望其参数的值为数字。作为实验，我们可以传递给它带引号的符号@code{hello}，而不是一个数字。将光标放在以下表达式后，然后输入@kbd{C-x C-e}：

@smallexample
(+ 2 'hello)
@end smallexample

@noindent
当你这样做时，将生成一个错误消息。发生的情况是，@code{+}试图将2添加到@code{'hello}返回的值，但@code{'hello}返回的值是符号@code{hello}，而不是一个数字。只有数字可以相加。所以@code{+}无法执行其加法运算。

@need 1250
你将创建并进入一个@file{*Backtrace*}缓冲区，其中显示：

@noindent
@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error:
         (wrong-type-argument number-or-marker-p hello)
  +(2 hello)
  eval((+ 2 'hello) nil)
  elisp--eval-last-sexp(t)
  eval-last-sexp(nil)
  funcall-interactively(eval-print-last-sexp nil)
  call-interactively(eval-print-last-sexp nil nil)
  command-execute(eval-print-last-sexp)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@need 1250
和往常一样，错误消息试图提供帮助，并在学会如何阅读后变得有意义。@footnote{@code{(quote hello)}是@code{'hello}缩写的扩展。}

错误消息的第一部分很简单，它说@samp{wrong type argument}。接下来是神秘的行话词@samp{number-or-marker-p}。这个词试图告诉你@code{+}期望的参数类型。

符号@code{number-or-marker-p}表示Lisp解释器正在尝试确定所呈现的信息（参数的值）是一个数字还是一个标记（表示缓冲区位置的特殊对象）。它的操作是测试@code{+}是否被赋予要相加的数字。它还测试参数是否是一种称为标记的东西，这是Emacs Lisp的一个特定特性。（在Emacs中，缓冲区中的位置被记录为标记。当使用@kbd{C-@@}或@kbd{C-@key{SPC}}命令设置标记时，其位置被保留为标记。标记可以被视为一个数字---表示该位置距离缓冲区开头的字符数。在Emacs Lisp中，@code{+}可以用于将标记位置的数值作为数字相加。

@cindex @samp{predicate} 的定义
@code{number-or-marker-p}中的@samp{p}体现了Lisp编程早期实践的一种做法。@samp{p}代表@dfn{谓词}。在早期Lisp研究者使用的行话中，谓词是指一个函数，用于确定某个属性是否为真或为假。因此，@samp{p}告诉我们@code{number-or-marker-p}是一个函数的名称，该函数确定所提供的参数是否为数字或标记。其他以@samp{p}结尾的Lisp符号包括@code{zerop}，一个测试其参数是否为零值的函数，以及@code{listp}，一个测试其参数是否为列表的函数。

最后，错误消息的最后部分是符号@code{hello}。这是传递给@code{+}的参数的值。如果相加操作传递了正确类型的对象，传递的值将是一个数字，如37，而不是像@code{hello}这样的符号。但那样你就不会收到错误消息。

@node message
@subsection @code{message} 函数
@findex message

类似于@code{+}函数，@code{message}函数接受可变数量的参数。它用于向用户发送消息，非常实用，我们将在这里描述它。

@need 1250
消息将被打印在回显区。例如，通过评估以下列表，您可以在回显区中打印一条消息：

@smallexample
(message "This message appears in the echo area!")
@end smallexample

双引号之间的整个字符串是一个单一的参数，并被整体打印出来。（请注意，在这个例子中，消息本身将在回显区中用双引号括起来；这是因为您看到了@code{message}函数返回的值。在您编写的程序中，@code{message}的大多数用法将作为副作用将文本在回显区中打印出来，而不带引号。@xref{multiply-by-seven in detail, , @code{multiply-by-seven} in
detail}，了解其中的一个示例。）

然而，如果在带引号的字符字符串中有一个@samp{%s}，@code{message}函数不会像这样打印@samp{%s}，而是查看跟随字符串的参数。它评估第二个参数，并在字符串中@samp{%s}的位置打印该值。

@need 1250
您可以通过将光标定位在以下表达式之后，然后键入@kbd{C-x C-e}来查看这一点：

@smallexample
(message "The name of this buffer is: %s." (buffer-name))
@end smallexample

@noindent
在Info中，@code{"The name of this buffer is: *info*."} 将出现在回显区。函数 @code{buffer-name} 返回缓冲区的名称作为字符串，@code{message} 函数将其插入到 @code{%s} 的位置。

要将值以整数形式打印，可以使用 @samp{%d}，与 @samp{%s} 的使用方式相同。例如，要在回显区中打印一条消息，指出 @code{fill-column} 的值，请评估以下内容：

@smallexample
(message "The value of fill-column is %d." fill-column)
@end smallexample

@noindent
在我的系统上，当我评估这个列表时，@code{"The value of fill-column is 72."} 将出现在我的回显区@footnote{实际上，你可以使用 @code{%s} 打印一个数字。它是非具体的。@code{%d} 只打印小数点左边的数字部分，而不包括任何非数字内容。}。

如果在引用的字符串中有多个 @samp{%s}，则在第一个 @samp{%s} 的位置打印跟在引用字符串后的第一个参数的值，并在第二个 @samp{%s} 的位置打印第二个参数的值，依此类推。

@need 1250
例如，如果你评估以下内容，

@smallexample
@group
(message "There are %d %s in the office!"
         (- fill-column 14) "pink elephants")
@end group
@end smallexample

@noindent
你的回显区将显示一条相当奇特的消息。在我的系统上，它会显示，@code{"There are 58 pink elephants in the office!"}。

表达式@code{(- fill-column 14)}被评估，生成的数字插入到@samp{%d}的位置；双引号中的字符串@code{"pink elephants"}被视为单个参数，插入到@samp{%s}的位置。（也就是说，双引号之间的字符串评估为它本身，就像一个数字一样。）

最后，这里有一个稍微复杂的例子，不仅说明了一个数字的计算，而且还展示了如何在一个表达式中使用另一个表达式来生成替代@samp{%s}的文本：

@smallexample
@group
(message "He saw %d %s"
         (- fill-column 32)
         (concat "red "
                 (substring
                  "The quick brown foxes jumped." 16 21)
                 " leaping."))
@end group
@end smallexample

在这个例子中，@code{message}有三个参数：字符串@code{"He saw %d %s"}，表达式@code{(- fill-column 32)}，以及以@code{concat}函数开头的表达式。通过评估@code{(- fill-column 32)}生成的值插入到@samp{%d}的位置；以及通过评估以@code{concat}开头的表达式生成的值插入到@samp{%s}的位置。

当你的填充列为70时，评估这个表达式，消息@code{"He saw 38 red foxes leaping."}将出现在你的回显区。

@node set & setq
@section 设置变量的值
@cindex 变量，设置值
@cindex 设置变量的值

@cindex @samp{bind}定义
有几种方式可以给一个变量赋值。其中一种方式是使用函数@code{set}或特殊形式@code{setq}。另一种方式是使用@code{let}（@pxref{let}）。（这个过程的行话术语是将变量@dfn{bind}到一个值上。）

以下章节不仅描述了@code{set}和@code{setq}的工作方式，还说明了如何传递参数。

@menu
* 使用 set::                  设置值。
* 使用 setq::                 设置引用值。
* 计数::                      使用@code{setq}进行计数。
@end menu

@node 使用 set
@subsection 使用 @code{set}
@findex set

要将符号 @code{flowers} 的值设置为列表 @code{'(rose violet daisy buttercup)}，请通过将光标定位在表达式后并键入 @kbd{C-x C-e} 来评估以下表达式。

@smallexample
(set 'flowers '(rose violet daisy buttercup))
@end smallexample

@noindent
列表 @code{(rose violet daisy buttercup)} 将出现在回显区域。这是由 @code{set} 函数@emph{返回}的内容。作为副作用，符号 @code{flowers} 被绑定到该列表；也就是说，可以将符号 @code{flowers} 视为变量，然后将该列表赋给它作为值。（顺便说一下，这个过程说明了对于Lisp解释器来说，设置值是我们人类感兴趣的主要效果。这是因为如果Lisp函数没有出错，它必须返回一个值，但只有在设计为具有副作用时才会有副作用。）

在评估 @code{set} 表达式后，可以评估符号 @code{flowers}，它将返回刚刚设置的值。这是该符号。将光标放在其后，然后键入 @kbd{C-x C-e}。

@smallexample
flowers
@end smallexample

@noindent
当你评估 @code{flowers} 时，列表 @code{(rose violet daisy buttercup)} 将出现在回显区域。

顺便说一下，如果你评估 @code{'flowers}，在带引号的变量前面，你将在回显区域看到符号本身，即 @code{flowers}。这是带引号的符号，所以你可以试一下：

@smallexample
'flowers
@end smallexample

还要注意，当你使用 @code{set} 时，需要引用 @code{set} 的两个参数，除非你想要它们被评估。因为我们不想让任何一个参数被评估，所以变量 @code{flowers} 和列表 @code{(rose violet daisy buttercup)} 都被引用。（当你使用 @code{set} 而不引用其第一个参数时，第一个参数在执行任何其他操作之前被评估。如果你这样做而且 @code{flowers} 没有一个已经存在的值，你会得到一个错误消息，指明 @samp{Symbol's value as variable is void}；另一方面，如果在评估后 @code{flowers} 返回了一个值，@code{set} 将尝试设置返回的值。有些情况下这是函数正确的行为，但这样的情况很少见。）

@node 使用 setq
@subsection 使用 @code{setq}
@findex setq

实际上，几乎总是对@code{set}的第一个参数加引号。@code{set}和引用的第一个参数的组合是如此常见，以至于它有自己的名称：特殊形式@code{setq}。这个特殊形式与@code{set}几乎相同，只是第一个参数被@code{setq}自动引用，因此您不需要自己输入引号。此外，作为额外的便利，@code{setq}允许您在一个表达式中设置多个不同的变量为不同的值。

为了使用@code{setq}将变量@code{carnivores}的值设置为列表@code{'(lion tiger leopard)}，可以使用以下表达式：

@smallexample
(setq carnivores '(lion tiger leopard))
@end smallexample

@noindent
这与使用@code{set}完全相同，只是@code{setq}自动引用了第一个参数。（@code{setq}中的@samp{q}表示@code{quote}。）

@need 1250
使用@code{set}，表达式如下：

@smallexample
(set 'carnivores '(lion tiger leopard))
@end smallexample

此外，@code{setq}还可以用于为不同的变量分配不同的值。第一个参数绑定到第二个参数的值，第三个参数绑定到第四个参数的值，依此类推。例如，您可以使用以下表达式将树的列表分配给符号@code{trees}，将食草动物的列表分配给符号@code{herbivores}：

@smallexample
@group
(setq trees '(pine fir oak maple)
      herbivores '(gazelle antelope zebra))
@end group
@end smallexample

@noindent
（表达式同样可以在一行上，但它可能不适合一页；并且人们更容易阅读格式良好的列表。）

尽管我一直在使用术语“分配”，但还有一种理解@code{set}和@code{setq}运作方式的方式；即@code{set}和@code{setq}使符号@emph{指向}列表。这种思考方式非常常见，在接下来的章节中，我们将至少遇到一个其名称中包含“指针”的符号。之所以选择这个名称，是因为符号有一个值，具体来说是一个列表，与之相关联；或者，换句话说，该符号被设置为指向该列表。

@node 计数
@subsection 计数
@cindex 计数

以下是一个示例，展示了如何在计数器中使用@code{setq}。您可以使用这种方法来计算程序的某个部分重复的次数。首先将一个变量设置为零；然后在程序重复自身时每次将该数字加一。为此，您需要一个用作计数器的变量，以及两个表达式：一个初始的@code{setq}表达式，将计数器变量设置为零；和第二个@code{setq}表达式，在每次评估时递增计数器。

@smallexample
@group
(setq counter 0)                ; @r{我们称之为初始化器。}

(setq counter (+ counter 1))    ; @r{这是递增器。}

counter                         ; @r{这是计数器。}
@end group
@end smallexample

@noindent
（在@samp{;}之后的文本是注释。@xref{修改 defun, , 修改函数定义}。）

如果您评估这些表达式中的第一个，即初始化器@code{(setq counter 0)}，然后评估第三个表达式@code{counter}，数字@code{0}将显示在回显区域中。然后，如果您评估第二个表达式，即递增器@code{(setq counter (+ counter 1))}，计数器将获得值1。因此，如果您再次评估@code{counter}，数字@code{1}将显示在回显区域中。每次评估第二个表达式时，计数器的值将递增。

当您评估递增器@code{(setq counter (+ counter 1))}时，Lisp解释器首先评估最内层的列表；这是加法。为了评估此列表，它必须评估变量@code{counter}和数字@code{1}。当它评估变量@code{counter}时，它会得到它的当前值。它将这个值和数字@code{1}传递给@code{+}，将它们相加。然后，总和作为内部列表的值返回，并传递给@code{setq}，将变量@code{counter}设置为这个新值。因此，变量@code{counter}的值被更改。

@node 总结
@section 总结

学习 Lisp 就像攀登一座山，其中的第一部分是最陡峭的。你现在已经攀登过最困难的部分；随着你继续前进，剩下的部分会变得更容易。

@need 1000
总的来说，

@itemize @bullet

@item
Lisp 程序由表达式组成，这些表达式可以是列表或单个原子。

@item
列表由零个或多个原子或内部列表组成，它们之间由空格分隔，并用括号括起来。列表可以为空。

@item
原子可以是多字符符号，比如 @code{forward-paragraph}，也可以是单字符符号，比如 @code{+}，还可以是双引号之间的字符字符串或数字。

@item
数字在求值时等于其自身。

@item
双引号之间的字符串在求值时也等于其自身。

@item
当你对一个符号进行单独求值时，它的值会被返回。

@item
当你对一个列表进行求值时，Lisp 解释器首先查看列表中的第一个符号，然后查找与该符号绑定的函数定义。然后执行函数定义中的指令。

@item
单引号 @samp{'} 告诉 Lisp 解释器它应该按照写法返回后面的表达式，而不是像没有引号那样对其进行求值。

@item
参数是传递给函数的信息。函数的参数是通过求值列表的其余元素来计算的，其中函数是第一个元素。

@item
函数在求值时总是返回一个值（除非出现错误）；此外，它还可能执行一些是副作用的动作。在许多情况下，函数的主要目的是创建副作用。
@end itemize

@node 错误消息练习
@section 练习

一些简单的练习：

@itemize @bullet
@item
通过评估一个适当的不在括号内的符号生成一个错误消息。

@item
通过评估一个适当的在括号之间的符号生成一个错误消息。

@item
创建一个计数器，其增量为两而不是一。

@item
编写一个在评估时在回显区域打印消息的表达式。
@end itemize

@node 练习评估
@chapter 练习评估
@cindex 练习评估
@cindex 评估练习

在学习如何在Emacs Lisp中编写函数定义之前，花一点时间评估已经编写的各种表达式是很有用的。这些表达式将是具有函数作为它们的第一个（通常是唯一的）元素的列表。由于与缓冲区相关的一些函数既简单又有趣，我们将从这些函数开始。在本节中，我们将评估其中的一些。在另一节中，我们将研究其他几个与缓冲区相关的函数的代码，以了解它们是如何编写的。

@menu
* 如何进行评估::            键入编辑命令或 @kbd{C-x C-e} 会导致评估。
* 缓冲区名称::               缓冲区和文件是不同的。
* 获取缓冲区::               获取缓冲区本身，而不仅仅是它的名称。
* 切换缓冲区::               如何切换到另一个缓冲区。
* 缓冲区大小与位置::         point 的位置以及缓冲区的大小。
* 评估练习::
@end menu

@ifnottex
@node 如何进行评估
@unnumberedsec 如何进行评估
@end ifnottex

@i{每当你向Emacs Lisp发送一个编辑命令}，比如移动光标或滚动屏幕时，@i{你都在评估一个表达式，}其第一个元素是一个函数。@i{这就是Emacs的工作原理。}

@cindex @samp{交互函数}定义
@cindex @samp{命令}定义
当你键入键位时，你会导致Lisp解释器评估一个表达式，这就是你获得结果的方式。甚至键入纯文本也涉及评估一个Emacs Lisp函数，这种情况下，使用的是@code{self-insert-command}，它简单地插入你键入的字符。通过键入按键而评估的函数称为@dfn{交互}函数或@dfn{命令}；如何使函数具有交互性将在编写函数定义的章节中说明。@xref{交互操作, , 使函数具有交互性}。

除了键入键盘命令，我们已经看到第二种评估表达式的方法：将光标定位在列表后面，然后键入@kbd{C-x C-e}。这是本节其余部分将要做的事情。还有其他评估表达式的方式；当我们遇到它们时会进行描述。

除了用于练习评估之外，下面几节中显示的函数在其自身方面也是重要的。研究这些函数清晰地展示了缓冲区和文件之间的区别，如何切换到一个缓冲区以及如何确定其中的位置。

@node 缓冲区名称
@section 缓冲区名称
@findex buffer-name
@findex buffer-file-name

两个函数，@code{buffer-name} 和 @code{buffer-file-name}，展示了文件和缓冲区之间的区别。当你评估下面的表达式 @code{(buffer-name)} 时，缓冲区的名称会出现在回显区。当你评估 @code{(buffer-file-name)} 时，缓冲区所引用的文件的名称会出现在回显区。通常，由 @code{(buffer-name)} 返回的名称与它引用的文件的名称相同，而由 @code{(buffer-file-name)} 返回的名称是文件的完整路径名。

文件和缓冲区是两个不同的实体。文件是永久记录在计算机中的信息（除非你删除它）。另一方面，缓冲区是 Emacs 内部的信息，在编辑会话结束时（或者当你杀死缓冲区时）将会消失。通常，缓冲区包含你从文件中复制的信息；我们说缓冲区正在@dfn{访问}该文件。这份副本是你要操作和修改的。对缓冲区的更改不会影响文件，直到你保存缓冲区。当你保存缓冲区时，缓冲区被复制到文件中，因此被永久保存。

@need 1250
如果你正在 GNU Emacs 中的 Info 中阅读本文，你可以通过将光标定位在表达式后并键入 @kbd{C-x C-e} 来评估以下每个表达式。

@example
@group
(buffer-name)

(buffer-file-name)
@end group
@end example

@noindent
在 Info 中执行 @code{(buffer-name)} 时，返回的值是 @file{"*info*"}，而执行 @code{(buffer-file-name)} 时返回的值是 @file{nil}。

另一方面，在我编写这个文档时，执行 @code{(buffer-name)} 返回的值是 @file{"introduction.texinfo"}，而执行 @code{(buffer-file-name)} 返回的值是 @file{"/gnu/work/intro/introduction.texinfo"}。

@cindex @code{nil}，单词的历史
前者是缓冲区的名称，而后者是文件的名称。在 Info 中，缓冲区名称是 @file{"*info*"}。Info 没有指向任何文件，因此执行 @code{(buffer-file-name)} 的结果是 @file{nil}。符号 @code{nil} 源自拉丁语单词 "nothing"，在这种情况下，它表示该缓冲区未关联任何文件。（在 Lisp 中，@code{nil} 也用于表示 "false"，并且是空列表 @code{()} 的同义词。）

在编写文档时，我的缓冲区名称是 @file{"introduction.texinfo"}。它指向的文件名称是 @file{"/gnu/work/intro/introduction.texinfo"}。

（在这些表达式中，括号告诉 Lisp 解释器将 @w{@code{buffer-name}} 和 @w{@code{buffer-file-name}} 视为函数；没有括号，解释器将尝试将这些符号评估为变量。@xref{Variables}。）

尽管文件和缓冲区之间有区别，但你经常会发现人们在指代文件时实际上是指缓冲区，反之亦然。实际上，大多数人会说：“我正在编辑一个文件”，而不是说：“我正在编辑一个缓冲区，稍后将保存到文件。” 从上下文中几乎总能清楚人们的意思。然而，在处理计算机程序时，保持区别是重要的，因为计算机没有人类那么智能。

@cindex 缓冲区，单词的历史
顺便说一下，“缓冲区”这个词的意义来源于它作为减缓碰撞力的缓冲物。在早期计算机中，缓冲区起到了文件与计算机中央处理单元之间相互作用的缓冲作用。持有文件的磁鼓或磁带和中央处理单元是非常不同的设备，它们以各自的速度、断断续续地工作。缓冲区使它们能够有效地协同工作。最终，缓冲区从一个中介、一个临时存放的地方，发展成为工作完成的地方。这种转变有点像一个小港口发展成为一个大城市：曾经它只是在货物被装上船之前的临时仓库；然后它成为一个独立的商业和文化中心。

并非所有的缓冲区都与文件相关。例如，`*scratch*` 缓冲区没有访问任何文件。同样，`*Help*` 缓冲区也没有与任何文件相关。

在过去，当你没有 `~/.emacs` 文件，通过输入 `emacs` 命令启动 Emacs 会话时，不指定任何文件，Emacs 会以 `*scratch*` 缓冲区可见的状态启动。现在，你会看到一个启动画面。你可以按照启动画面上建议的命令之一，访问一个文件，或按 `q` 键退出启动画面并进入 `*scratch*` 缓冲区。

如果切换到 `*scratch*` 缓冲区，输入 `(buffer-name)`，将光标定位到其后，然后键入 `C-x C-e` 以评估表达式。将返回并显示 `*scratch*` 的名称在回显区。`*scratch*` 就是该缓冲区的名称。当你在 `*scratch*` 缓冲区中输入 `(buffer-file-name)` 并评估时，回显区将显示 `nil`，就像在 Info 中评估 `(buffer-file-name)` 时一样。

顺便提一下，如果你在 `*scratch*` 缓冲区中，想要将表达式返回的值显示在 `*scratch*` 缓冲区本身而不是在回显区，可以键入 `C-u C-x C-e` 而不是 `C-x C-e`。这将导致返回的值出现在表达式之后。缓冲区会看起来像这样：

@smallexample
(buffer-name)"*scratch*"
@end smallexample

@noindent
在 Info 中你不能这样做，因为 Info 是只读的，它不允许你更改缓冲区的内容。但是在任何你可以编辑的缓冲区中，你都可以这样做；当你编写代码或文档（比如这本书）时，这个功能非常有用。

@node 获取缓冲区
@section 获取缓冲区
@findex current-buffer
@findex other-buffer
@cindex 获取缓冲区

函数@code{buffer-name}返回缓冲区的@emph{名称}；要获取缓冲区@emph{本身}，需要使用另一个函数：@code{current-buffer}函数。如果在代码中使用这个函数，你将得到缓冲区本身。

名称和名称所指代的对象或实体是不同的。你不是你的名字。你是一个被别人用名字指称的人。如果你要求与George交谈，而有人递给你一张写有字母@samp{G}、@samp{e}、@samp{o}、@samp{r}、@samp{g}和@samp{e}的卡片，你可能会感到有趣，但你不会满意。你不想和名字交谈，而是想和名字所指代的人交谈。缓冲区类似：临时缓冲区的名称是@file{*scratch*}，但名称不是缓冲区。要获取缓冲区本身，需要使用诸如@code{current-buffer}这样的函数。

然而，有一个小复杂性：如果在一个表达式中评估@code{current-buffer}，就像我们在这里所做的那样，你所看到的是缓冲区名称的打印表示，而不是缓冲区的内容。Emacs之所以以这种方式工作有两个原因：缓冲区可能有成千上万行长---太长了无法方便地显示；另一个缓冲区可能具有相同的内容但具有不同的名称，区分它们是很重要的。

@need 800
下面是包含该函数的表达式：

@smallexample
(current-buffer)
@end smallexample

@noindent
如果你在Emacs中通常的方式下在Info中评估这个表达式，@file{#<buffer *info*>} 将会出现在回显区。这个特殊的格式表示正在返回的是缓冲区本身，而不仅仅是它的名称。

顺便提一下，虽然你可以在程序中键入数字或符号，但不能在缓冲区的打印表示中这样做：获取缓冲区本身的唯一方式是使用诸如@code{current-buffer}的函数。

一个相关的函数是@code{other-buffer}。它返回除了当前所在的缓冲区之外最近选择的缓冲区，而不是其名称的打印表示。如果你最近在@file{*scratch*}缓冲区之间切换，@code{other-buffer}将返回该缓冲区。

@need 800
你可以通过评估以下表达式来看到这一点：

@smallexample
(other-buffer)
@end smallexample

@noindent
你应该在回显区看到@file{#<buffer *scratch*>}出现，或者是你最近切换回来的任何其他缓冲区的名称@footnote{实际上，默认情况下，如果你刚刚从中切换的缓冲区在另一个窗口中可见，@code{other-buffer}将选择你无法看到的最近的缓冲区；这是我经常忘记的一个细微之处。}。

@node 切换缓冲区
@section 切换缓冲区
@findex switch-to-buffer
@findex set-buffer
@cindex 切换到缓冲区

实际上，当将@code{other-buffer}函数用作需要缓冲区参数的函数的参数时，它实际上提供了一个缓冲区。通过使用@code{other-buffer}和@code{switch-to-buffer}来切换到不同的缓冲区，我们可以看到这一点。

但首先，让我们简要介绍一下@code{switch-to-buffer}函数。当你在Info和@file{*scratch*}缓冲区之间切换以评估@code{(buffer-name)}时，你很可能会输入@kbd{C-x b}，然后在迷你缓冲区中输入@file{*scratch*}。@footnote{或者更确切地说，为了节省输入，如果默认缓冲区是@file{*scratch*}，你可能只输入@kbd{RET}，或者如果它不同，则只输入部分名称，如@code{*sc}，按下@kbd{TAB}键使其扩展为完整名称，然后输入@kbd{RET}。} 用于切换到所需缓冲区的名称。按下@kbd{C-x b}这些按键会导致Lisp解释器评估交互函数@code{switch-to-buffer}。正如我们之前所说，这就是Emacs的工作原理：不同的按键调用或运行不同的函数。例如，@kbd{C-f}调用@code{forward-char}，@kbd{M-e}调用@code{forward-sentence}等等。

通过在表达式中编写@code{switch-to-buffer}，并给它一个要切换到的缓冲区，我们可以像@kbd{C-x b}一样切换缓冲区：

@smallexample
(switch-to-buffer (other-buffer))
@end smallexample

@noindent
符号 @code{switch-to-buffer} 是列表的第一个元素，因此Lisp解释器将其视为一个函数并执行与其关联的指令。但在执行之前，解释器会注意到 @code{other-buffer} 在括号内，并首先处理该符号。@code{other-buffer} 是此列表的第一个元素（在这种情况下，也是唯一的元素），因此Lisp解释器调用或运行该函数。它返回另一个缓冲区。接下来，解释器运行 @code{switch-to-buffer}，将另一个缓冲区作为参数传递给它，这就是Emacs将要切换到的缓冲区。如果您正在Info中阅读此内容，请立即尝试。评估此表达式。（要返回，请键入 @kbd{C-x b @key{RET}}。）@footnote{请记住，此表达式将将您移动到您无法看到的最近的其他缓冲区。如果您真的想转到最近选择的缓冲区，即使您仍然可以看到它，您需要评估以下更复杂的表达式：

@smallexample
(switch-to-buffer (other-buffer (current-buffer) t))
@end smallexample

@c noindent
在这种情况下，@code{other-buffer} 的第一个参数告诉它要跳过的缓冲区（当前的缓冲区），第二个参数告诉 @code{other-buffer} 可以切换到可见的缓冲区。在常规用法中，@code{switch-to-buffer}将您带到窗口中不可见的缓冲区，因为您很可能使用 @kbd{C-x o}（@code{other-window}）转到另一个可见的缓冲区。}

在本文档后面的编程示例中，您将更频繁地看到函数 @code{set-buffer} 而不是 @code{switch-to-buffer}。这是因为计算机程序和人类之间存在一个差异：人类有眼睛，并期望在计算机终端上看到他们正在操作的缓冲区。这是如此明显，几乎不言而喻。然而，程序没有眼睛。当计算机程序在缓冲区上工作时，该缓冲区不需要在屏幕上可见。

@code{switch-to-buffer} 是为人类设计的，它执行两个不同的操作：它切换Emacs关注的缓冲区，并将窗口显示的缓冲区切换到新的缓冲区。另一方面，@code{set-buffer} 只执行一项任务：它将计算机程序的注意力切换到另一个缓冲区。屏幕上的缓冲区保持不变（当然，通常在命令运行完成之前不会发生任何变化）。

@cindex @samp{call} 定义
此外，我们刚刚介绍了另一个行话术语，即词语 @dfn{call}。当您评估一个列表，其中第一个符号是一个函数时，您正在调用该函数。该术语的使用来自于将函数视为如果您调用它可以为您做一些事情的实体的概念，就像水管工是一个实体，如果您呼叫他或她，他或她可以修理漏水一样。

@node 缓冲区大小与位置
@section 缓冲区大小和点的位置
@cindex 缓冲区大小
@cindex 缓冲区大小
@cindex 点的位置
@cindex 点的位置

最后，让我们看一些相当简单的函数，@code{buffer-size}、@code{point}、@code{point-min}和@code{point-max}。它们提供有关缓冲区大小和点在其中的位置的信息。

函数@code{buffer-size}告诉您当前缓冲区的大小；也就是说，该函数返回缓冲区中字符的数量。

@smallexample
(buffer-size)
@end smallexample

@noindent
您可以通过将光标放置在表达式后，并键入@kbd{C-x C-e}来评估它。

@cindex @samp{point}定义
在Emacs中，光标的当前位置被称为@dfn{point}。表达式@code{(point)}返回一个数字，告诉您光标的位置，以字符数表示，从缓冲区开头到point的位置。

@need 1250
您可以通过以通常的方式评估以下表达式来查看point在该缓冲区的字符计数：

@smallexample
(point)
@end smallexample

@noindent
在我写这篇文章的时候，point的值是65724。@code{point}函数在本书的一些后面的示例中经常被使用。

@need 1250
point的值当然取决于它在缓冲区内的位置。如果在这个位置评估point，数字会更大：

@smallexample
(point)
@end smallexample

@noindent
对我而言，在这个位置，point的值是66043，这意味着两个表达式之间有319个字符（包括空格）。 （毫无疑问，由于我首次评估point后进行了编辑，你可能会看到不同的数字。）

@cindex @samp{narrowing}定义
函数@code{point-min}与@code{point}有些相似，但它返回当前缓冲区中point的最小允许值。这个值是1，除非启用了@dfn{narrowing}。（Narrowing是一种机制，通过它，您可以将自己或程序限制在仅对缓冲区的一部分进行操作。@xref{缩窄与扩大, , 窄化和扩展}。）同样，函数@code{point-max}返回当前缓冲区中point的最大允许值。

@node 评估练习
@section 练习

找到您正在使用的文件，并移动到其中间。
找到其缓冲区名称、文件名称、长度以及您在文件中的位置。

@node 编写 Defuns
@chapter 如何编写函数定义
@cindex 定义编写
@cindex 函数定义编写
@cindex 编写函数定义

当Lisp解释器评估一个列表时，它会查看列表上的第一个符号是否附有一个函数定义；或者换句话说，该符号是否指向一个函数定义。如果是的话，计算机将执行定义中的指令。一个具有函数定义的符号被简单地称为函数（尽管严格来说，定义是函数，符号是它的引用）。

@menu
* 原始函数::
* defun::                        @code{defun} 宏。
* 安装::                          安装函数定义。
* 交互操作::                        使函数具有交互性。
* 交互选项::                    @code{interactive} 的不同选项。
* 永久安装::                      永久安装代码。
* let::                          创建并初始化局部变量。
* if::                           如果是这样怎么办？
* else::                         If--then--else 表达式。
* 真与假::                       Lisp认为的真和假。
* save-excursion::               跟踪点和缓冲区。
* 回顾::
* defun 练习::
@end menu

@ifnottex
@node 原始函数
@unnumberedsec 关于原始函数的一些说明
@end ifnottex
@cindex 原始函数
@cindex 函数，原始

@cindex C语言原语
@cindex 用C编写的原语
所有函数都是基于其他函数定义的，除了一些用C编写的@dfn{原始}函数。当你编写函数定义时，你将使用Emacs Lisp编写它们，并将其他函数作为构建块。你将使用的一些函数本身是用Emacs Lisp编写的（也许是由你编写的），而另一些是用C编写的原语。这些原始函数的使用方式与用Emacs Lisp编写的函数完全相同，并且其行为也相同。它们是用C编写的，以便我们可以轻松地在任何具有足够计算能力且能够运行C的计算机上运行GNU Emacs。

让我再强调一下：当你在Emacs Lisp中编写代码时，你不区分是使用用C编写的函数还是使用用Emacs Lisp编写的函数。这种区别是无关紧要的。我提到这个区别只是因为它是有趣的。实际上，除非你调查，你不会知道一个已经编写好的函数是用Emacs Lisp还是C编写的。

@node defun
@section @code{defun} 宏
@findex defun

@cindex @samp{函数定义} 已定义
在Lisp中，像 @code{mark-whole-buffer} 这样的符号附有与其关联的代码，告诉计算机在调用该函数时应该执行什么操作。这段代码称为 @dfn{函数定义}，它是通过评估以符号 @code{defun}（它是 @emph{define function} 的缩写）开头的Lisp表达式创建的。

在后续的章节中，我们将查看Emacs源代码中的函数定义，比如 @code{mark-whole-buffer}。在本节中，我们将描述一个简单的函数定义，以便您了解其外观。这个函数定义使用算术运算，因为这样做可以提供一个简单的例子。有些人不喜欢使用算术的例子；然而，如果您是这样的人，请不要绝望。在本介绍的其余部分中，我们将几乎不涉及算术或数学的代码。例子主要涉及以某种方式涉及文本的内容。

一个函数定义由跟在 @code{defun} 之后的最多五个部分组成：

@enumerate
@item
应该附加函数定义的符号的名称。

@item
将传递给函数的参数列表。如果不会传递任何参数给函数，这是一个空列表，即 @code{()}。

@item
描述函数的文档。（从技术上讲是可选的，但强烈推荐。）

@item
可选地，一个表达式，使函数具有交互性，以便您可以通过键入 @kbd{M-x}，然后输入函数的名称来使用它；或通过输入适当的键或键组。

@cindex @samp{函数体} 已定义
@item
告诉计算机要执行的代码：函数定义的 @dfn{函数体}。
@end enumerate

有助于将函数定义的五个部分视为一个模板，其中为每个部分都留有槽位：

@smallexample
@group
(defun @var{function-name} (@var{arguments}@dots{})
  "@var{optional-documentation}@dots{}"
  (interactive @var{argument-passing-info})     ; @r{可选}
  @var{body}@dots{})
@end group
@end smallexample

以一个将其参数乘以7的函数为例说明。 （此示例不是交互式的。有关此信息，请参阅@xref{交互操作,,使函数具有交互性}。）

@smallexample
@group
(defun multiply-by-seven (number)
  "将NUMBER乘以七。"
  (* 7 number))
@end group
@end smallexample

这个定义以括号和符号@code{defun}开始，后跟函数的名称。

@cindex @samp{argument list} defined
函数名称后面是一个包含将传递给函数的参数的列表。 这个列表称为@dfn{参数列表}。 在这个例子中，列表只有一个元素，即符号@code{number}。 当使用函数时，该符号将绑定到作为函数参数的值。

与选择@code{number}作为参数名称不同，我可以选择任何其他名称。 例如，我可以选择单词@code{multiplicand}。 我选择了单词“number”是因为它说明了此槽位所需的值的类型； 但是我完全可以选择单词“multiplicand”来指示在函数运作中放入此槽位的值所起的作用。 我可以称其为@code{foogle}，但那是一个不好的选择，因为它不会告诉人们它的含义。 名称的选择由程序员决定，应该选择使函数的含义清晰的名称。

确实，你可以为参数列表中的符号选择任何你喜欢的名称，甚至是在其他函数中使用的符号的名称：在参数列表中使用的名称对于该特定定义是私有的。在该定义中，该名称指的是与函数定义之外使用的同名实体不同的实体。假设在你的家庭中你有一个绰号“矮子”；当你的家庭成员提到“矮子”时，他们指的是你。但在你的家庭之外，比如在电影中，“矮子”这个名字指的是别人。因为参数列表中的名称对函数定义是私有的，你可以在函数体内改变这样一个符号的值，而不会改变它在函数外的值。这个效果类似于`let`表达式（@xref{let, , @code{let}}）。

@ignore
还要注意，我们以两种不同的方式讨论“number”这个词：一是作为代码中出现的符号，二是作为在函数评估过程中将被其他东西替换的东西的名称。在第一种情况下，@code{number}是一个符号，而不是一个数字；恰巧在函数内部，它是一个其值为相应数字的变量，但我们对它的主要关注是作为一个符号。另一方面，当我们谈论该函数时，我们关注的是我们将用一个数字替换掉@var{number}这个词。为了保持这种区别清晰，我们在这两种情况下使用不同的排版。当我们谈论这个函数，或者它的工作原理时，我们通过写@var{number}来引用这个数字。在函数本身中，我们通过写@code{number}来引用它。
@end ignore

参数列表后面是描述函数的文档字符串。这是当你键入@w{@kbd{C-h f}}和函数的名称时所看到的内容。顺便说一句，当你编写这样的文档字符串时，应该将第一行写成完整的句子，因为有些命令（比如@code{apropos}）只打印多行文档字符串的第一行。此外，如果有第二行文档字符串，不应该对其进行缩进，因为在使用@kbd{C-h f}（@code{describe-function}）时，这样看起来很奇怪。文档字符串是可选的，但它非常有用，几乎应该包含在你编写的每个函数中。

@findex * @r{(乘法)}
该示例的第三行是函数定义的主体。 （当然，大多数函数的定义要比这个长。）在这个函数中，主体是列表@code{(* 7 number)}，它表示将@var{number}的值乘以7。（在Emacs Lisp中，@code{*}是乘法的函数，就像@code{+}是加法的函数一样。）

当你使用 @code{multiply-by-seven} 函数时，参数 @code{number} 会被评估为你希望使用的实际数字。下面是展示如何使用 @code{multiply-by-seven} 的示例；但现在不要尝试评估它！

@smallexample
(multiply-by-seven 3)
@end smallexample

@noindent
在函数定义的下一部分中指定的符号 @code{number} 在实际使用函数时被绑定到值 3。请注意，尽管在函数定义中 @code{number} 处于括号中，但传递给 @code{multiply-by-seven} 函数的参数不在括号中。括号写在函数定义中，这样计算机可以确定参数列表的结束位置和函数定义的其余部分的开始位置。

如果你评估这个示例，很可能会收到错误消息。（试试看吧！）这是因为我们已经写了函数定义，但还没有告诉计算机有关定义——我们还没有在Emacs中加载函数定义。安装函数是告诉Lisp解释器函数定义的过程。安装过程在下一部分中描述。

@node 安装
@section 安装函数定义
@cindex 安装函数定义
@cindex 定义安装
@cindex 函数定义安装

如果你正在 Emacs 的 Info 中阅读本文，你可以尝试执行 @code{multiply-by-seven} 函数，首先评估函数定义，然后评估 @code{(multiply-by-seven 3)}。函数定义的副本如下。将光标放在函数定义的最后一个括号之后，然后键入 @kbd{C-x C-e}。当你这样做时，@code{multiply-by-seven} 将显示在回显区域。（这意味着当评估函数定义时，它返回的值是定义的函数的名称。）与此同时，此操作安装了函数定义。

@smallexample
@group
(defun multiply-by-seven (number)
  "将 NUMBER 乘以七。"
  (* 7 number))
@end group
@end smallexample

@noindent
通过评估这个 @code{defun}，你刚刚在 Emacs 中安装了 @code{multiply-by-seven}。该函数现在与 Emacs 中的其他编辑函数（如 @code{forward-word}）一样成为 Emacs 的一部分。（@code{multiply-by-seven} 将一直保持安装状态，直到你退出 Emacs。要在每次启动 Emacs 时自动重新加载代码，请参阅 @ref{永久安装, , 永久安装代码}。）

@menu
* 安装的效果::
* 更改 defun::              如何更改函数定义。
@end menu

@ifnottex
@node 安装效果
@unnumberedsubsec 安装的效果
@end ifnottex

通过评估以下示例，您可以看到安装 @code{multiply-by-seven} 的效果。将光标放在下面的表达式之后，然后键入 @kbd{C-x C-e}。数字 21 将出现在回显区域。

@smallexample
(multiply-by-seven 3)
@end smallexample

如果您愿意，可以通过键入 @kbd{C-h f}（@code{describe-function}）然后输入函数的名称 @code{multiply-by-seven} 来阅读该函数的文档。这样做时，您的屏幕上将出现一个 @file{*Help*} 窗口，内容如下：

@smallexample
@group
multiply-by-seven 是一个 Lisp 函数。

(multiply-by-seven NUMBER)

将 NUMBER 乘以七。
@end group
@end smallexample

@noindent
（要返回到屏幕上的单个窗口，请键入 @kbd{C-x 1}。）
@menu
* 安装效果::
* 更改 defun::              如何更改函数定义。
@end menu

@node 修改 defun
@subsection 修改函数定义
@cindex 修改函数定义
@cindex 函数定义，如何修改
@cindex 定义，如何修改

如果你想修改 @code{multiply-by-seven} 中的代码，只需重新编写它。要将新版本安装到旧版本的位置，重新评估函数定义即可。这就是在Emacs中修改代码的方式，非常简单。

举个例子，你可以将 @code{multiply-by-seven} 函数更改为将数字加到自身七次，而不是将数字乘以七。它产生相同的答案，但是通过不同的路径。同时，我们将在代码中添加一条注释；注释是Lisp解释器忽略的文本，但对人类读者可能很有用或启发。注释是这是第二个版本。

@smallexample
@group
(defun multiply-by-seven (number)       ; @r{第二个版本。}
  "将 NUMBER 乘以七。"
  (+ number number number number number number number))
@end group
@end smallexample

@cindex Lisp 代码中的注释
注释以分号 @samp{;} 开头。在Lisp中，分号后面的一行上的所有内容都是注释。行的结尾是注释的结尾。要将注释延伸到两行或更多行，请在每一行开头加上分号。

@xref{Beginning init File, , 开始一个 @file{.emacs}
文件}，和 @ref{Comments, , 注释, elisp, GNU Emacs Lisp
参考手册}，了解更多关于注释的信息。

你可以通过以与第一个函数相同的方式评估它来安装 @code{multiply-by-seven} 函数的这个版本：将光标放在最后一个括号后，然后输入 @kbd{C-x C-e}。

总之，这就是在Emacs Lisp中编写代码的方式：编写函数；安装它；测试它；然后进行修复或增强，并再次安装它。

@node 交互操作
@section 使函数具有交互性
@cindex 交互式函数
@findex interactive

通过在文档后面紧跟以特殊形式 @code{interactive} 开头的列表，可以使函数具有交互性。用户可以通过键入 @kbd{M-x}，然后键入函数名，或者通过键入其绑定的键来调用交互式函数，例如通过键入 @kbd{C-n} 调用 @code{next-line}，或者通过键入 @kbd{C-x h} 调用 @code{mark-whole-buffer}。

有趣的是，当你以交互方式调用交互式函数时，返回的值不会自动显示在回显区。这是因为通常你调用交互式函数是为了其副作用，比如按单词或行前进，而不是为了返回的值。如果每次键入一个键时都在回显区显示返回的值，会非常分散注意力。

@menu
* 交互式multiply-by-seven::  概述。
* multiply-by-seven in detail::  交互式版本。
@end menu

@ifnottex
@node 交互式multiply-by-seven
@unnumberedsubsec 交互式 @code{multiply-by-seven}，概述
@end ifnottex

通过创建 @code{multiply-by-seven} 的交互式版本，可以演示特殊形式 @code{interactive} 的使用以及在回显区域显示值的一种方式。

@need 1250
以下是代码：

@smallexample
@group
(defun multiply-by-seven (number)       ; @r{交互式版本.}
  "将 NUMBER 乘以七。"
  (interactive "p")
  (message "结果是 %d" (* 7 number)))
@end group
@end smallexample

@noindent
您可以通过将光标放置在代码后并键入 @kbd{C-x C-e} 来安装此代码。函数的名称将出现在回显区域中。然后，您可以通过键入 @kbd{C-u} 和一个数字，然后键入 @kbd{M-x multiply-by-seven} 并按 @key{RET} 使用此代码。回显区域中将出现短语 @samp{结果是 @dots{}}，后面跟着乘积。

更一般地说，可以通过以下两种方式调用这样的函数：

@enumerate
@item
通过键入包含要传递的数字的前缀参数，然后键入 @kbd{M-x} 和函数的名称，如 @kbd{C-u 3 M-x forward-sentence}；或者，

@item
通过键入函数绑定的键或键序列，如 @kbd{C-u 3 M-e}。
@end enumerate

@noindent
刚才提到的两个示例均以相同的方式工作，将光标向前移动三个句子。 (由于 @code{multiply-by-seven} 未绑定到键，它无法用作绑定键的示例。)

(@xref{Key Bindings, , 一些按键绑定}, 了解如何将命令绑定到键。)

通过键入数字键后跟一个数字，例如 @kbd{M-3 M-e}，或者通过键入 @kbd{C-u} 然后是一个数字，例如 @kbd{C-u 3 M-e}，将一个 @dfn{前缀参数} 传递给交互式函数（如果键入 @kbd{C-u} 而没有数字，则默认为 4）。

@node multiply-by-seven in detail
@subsection 交互式 @code{multiply-by-seven} 详解

让我们看一下特殊形式 @code{interactive} 的使用，然后再看一下@code{multiply-by-seven} 的交互版本中的函数 @code{message}。你会记得该函数定义如下：

@smallexample
@group
(defun multiply-by-seven (number)       ; @r{交互版本。}
  "将 NUMBER 乘以七。"
  (interactive "p")
  (message "结果是 %d" (* 7 number)))
@end group
@end smallexample

在这个函数中，表达式 @code{(interactive "p")} 是一个包含两个元素的列表。@code{"p"} 告诉 Emacs 将前缀参数传递给函数，并将其值用作函数的参数。

@need 1000
参数将是一个数字。这意味着在以下行中，符号@code{number} 将绑定到一个数字：

@smallexample
(message "结果是 %d" (* 7 number))
@end smallexample

@need 1250
@noindent
例如，如果你的前缀参数是 5，Lisp 解释器将将该行解释为：

@smallexample
(message "结果是 %d" (* 7 5))
@end smallexample

@noindent
(如果你在 GNU Emacs 中阅读此文，你可以自行评估这个表达式。)首先，解释器将评估内部列表，即 @code{(* 7 5)}。这将返回一个值为 35。接下来，它将评估外部列表，将列表的第二个和随后的元素的值传递给函数 @code{message}。

正如我们所见，@code{message} 是一个专为向用户发送单行消息而设计的 Emacs Lisp 函数。（@xref{message, , The @code{message} function}。）总体而言，@code{message} 函数会将其第一个参数原样打印在回显区域，但会替换@samp{%d} 或 @samp{%s}（以及我们未提及的其他各种 %-sequences）的出现。当它看到控制序列时，该函数会查找第二个或随后的参数，并在字符串中的控制序列位置打印参数的值。

在交互式 @code{multiply-by-seven} 函数中，控制字符串是 @samp{%d}，需要一个数字，而通过评估 @code{(* 7 5)} 返回的值是数字 35。因此，数字 35 将在 @samp{%d} 的位置打印，消息为 @samp{结果是 35}。

（请注意，当调用函数 @code{multiply-by-seven} 时，消息会以无引号形式打印，但调用 @code{message} 时，文本将以双引号形式打印。这是因为 @code{message} 返回的值是在评估其第一个元素为 @code{message} 的表达式时出现在回显区域中的内容；但在嵌入函数中时，@code{message} 以副作用的方式打印文本，没有引号。）

@node 交互选项
@section @code{interactive} 的不同选项
@cindex @code{interactive} 的选项
@cindex 交互选项

在例子中，@code{multiply-by-seven} 使用 @code{"p"} 作为@code{interactive} 的参数。这个参数告诉 Emacs 解释你的输入，无论是 @kbd{C-u} 后跟一个数字还是 @key{META} 后跟一个数字，都是将该数字作为参数传递给函数。Emacs 预定义了超过二十个字符，可以用于 @code{interactive}。在几乎所有情况下，这些选项之一将使你能够以交互方式向函数传递正确的信息。(@xref{Interactive Codes, , @code{interactive} 代码章节, elisp, GNU Emacs Lisp 参考手册}.)

@need 1250
考虑函数 @code{zap-to-char}。它的交互表达式为

@c FIXME: zap-to-char 的交互表达式已更改
@c (在2012-04-10)。

@smallexample
(interactive "p\ncZap to char: ")
@end smallexample

@code{interactive} 的参数的第一部分是 @samp{p}，这是你已经熟悉的。这个参数告诉 Emacs 解释一个前缀，作为传递给函数的数字。你可以通过键入 @kbd{C-u} 后跟一个数字或者键入 @key{META} 后跟一个数字来指定前缀。前缀是指定的字符数。因此，如果你的前缀是三，指定的字符是@samp{x}，那么你将删除所有文本，包括第三个 @samp{x}。如果你没有设置前缀，那么你将删除所有文本，包括指定的字符，但不包括之后的文本。

@samp{c} 告诉函数要删除的字符的名称。

更正式地说，具有两个或更多参数的函数可以通过向跟随 @code{interactive} 的字符串添加部分来将信息传递给每个参数。当你这样做时，信息将按照它在@code{interactive} 列表中指定的顺序传递给每个参数。在字符串中，每个部分都由一个 @samp{\n}（换行符）与下一个部分分隔开。例如，你可以在 @samp{p} 后面加上一个 @samp{\n} 和一个 @samp{cZap to char:}。这将导致 Emacs 传递前缀参数的值（如果有的话）和字符。

在这种情况下，函数定义如下，其中 @code{arg} 和 @code{char} 是由 @code{interactive} 绑定的前缀参数和指定字符：

@smallexample
@group
(defun @var{name-of-function} (arg char)
  "@var{documentation}@dots{}"
  (interactive "p\ncZap to char: ")
  @var{body-of-function}@dots{})
@end group
@end smallexample

@noindent
（在提示符的冒号后加一个空格使其看起来更好。@xref{copy-to-buffer, , 函数 @code{copy-to-buffer} 的定义}，提供一个例子。）

当函数不接受参数时，@code{interactive} 不需要任何参数。这样的函数包含简单的表达式 @code{(interactive)}。@code{mark-whole-buffer} 函数就是这样的一个例子。

或者，如果特殊的字母代码不适合你的应用程序，你可以将自己的参数作为列表传递给 @code{interactive}。

@xref{append-to-buffer, , 函数 @code{append-to-buffer} 的定义}，提供一个例子。@xref{Using Interactive, , 使用 @code{Interactive}, elisp, GNU Emacs Lisp 参考手册}，提供有关这一技术的更完整解释。

@node 永久安装
@section 永久安装代码
@cindex 永久安装代码
@cindex 永久性代码安装
@cindex 代码安装

当通过评估来安装函数定义时，它将一直保持安装状态，直到退出 Emacs。下次启动 Emacs 时，除非重新评估函数定义，否则该函数将不会安装。

在某个时刻，您可能希望在每次启动新的 Emacs 会话时自动安装代码。有几种方法可以实现这一点：

@itemize @bullet
@item
如果您的代码只是针对您个人的，您可以将函数定义的代码放入您的 @file{.emacs} 初始化文件中。当您启动 Emacs 时，您的 @file{.emacs} 文件会自动评估，并安装其中的所有函数定义。
@xref{Emacs Initialization, , 您的 @file{.emacs} 文件}。

@item
或者，您可以将要安装的函数定义放入一个或多个单独的文件中，并使用 @code{load} 函数使 Emacs 评估并安装这些文件中的每个函数。
@xref{Loading Files, , 加载文件}。

@item
第三，如果您有整个站点都会使用的代码，通常将其放入一个名为 @file{site-init.el} 的文件中，在构建 Emacs 时加载该文件。这使得代码对使用您的计算机的每个人都可用。（请参阅 Emacs 发行版的 @file{INSTALL} 文件。）
@end itemize

最后，如果您的代码是每个使用 Emacs 的人都可能需要的，您可以将其发布到计算机网络上，或将副本发送给自由软件基金会。（在执行此操作时，请使用许可证许可代码及其文档，允许其他人运行、复制、研究、修改和重新分发代码，并保护您免受他人夺走您的工作的风险。）如果您向自由软件基金会发送代码的副本，并正确保护自己和其他人，它可能会包含在下一个 Emacs 发布版中。在很大程度上，这就是 Emacs 在过去几年中发展的方式，通过捐赠。

@node let
@section @code{let}
@findex let

@code{let}表达式是Lisp中的一种特殊形式，你在大多数函数定义中都需要使用它。

@code{let}用于以一种方式将符号绑定到值，使得Lisp解释器不会将该变量与不属于函数的同名变量混淆。

为了理解为什么需要@code{let}特殊形式，考虑以下情况：假设你拥有一所房子，通常将其称为“房子”，就像在句子中说：“房子需要粉刷。” 如果你正在访问朋友，而你的主人提到“房子”，他可能是在指的是@emph{他}的房子，而不是你的，也就是说，是另一座房子。

如果你的朋友正在指他的房子，而你认为他正在指你的房子，那么可能会产生一些混乱。在Lisp中，如果在一个函数内部使用的变量与另一个函数内部使用的同名变量相同，并且两者意图不是引用相同的值，则可能发生类似的情况。@code{let}特殊形式防止了这种混淆。

@menu
* 避免混淆::
* let 表达式的组成部分::
* 示例 let 表达式::
* 未初始化的let语句变量::
@end menu

@ifnottex
@node 避免混淆
@unnumberedsubsec @code{let} 避免混淆
@end ifnottex

@cindex @samp{局部变量} 定义
@cindex @samp{变量, 局部}, 定义
特殊形式 @code{let} 可以避免混淆。@code{let} 创建一个@dfn{局部变量}的名称，它会遮蔽任何在 @code{let} 表达式之外使用相同名称的情况。这就像理解当你的主机提到“房子”时，他指的是他的房子，而不是你的房子一样。（在参数列表中使用的符号也是同样的道理。@xref{defun, , @code{defun} 宏}。）

由 @code{let} 表达式创建的局部变量只在 @code{let} 表达式本身（以及在 @code{let} 表达式内调用的表达式中）中保持其值；这些局部变量在 @code{let} 表达式之外没有影响。

另一种理解 @code{let} 的方式是，它就像一个临时和局部的 @code{setq}。由 @code{let} 设置的值在 @code{let} 结束时会自动撤销。这个设置只影响在 @code{let} 表达式边界内的表达式。在计算机科学的术语中，我们会说符号的绑定仅在 @code{let} 表单中调用的函数中可见；在 Emacs Lisp 中，默认的作用域是动态的，而不是词法的。 （非默认的词法绑定在本手册中未讨论。）

@code{let} 可以一次创建多个变量。此外，@code{let} 为它创建的每个变量都提供一个初始值，可以是你指定的值，也可以是 @code{nil}。（在术语中，这是将变量绑定到值。）在 @code{let} 创建并绑定了变量之后，它会执行 @code{let} 主体中的代码，并返回主体中最后一个表达式的值，作为整个 @code{let} 表达式的值。（“执行”是一个术语，指的是评估列表；它源自“实施”一词的使用，意味着“实际生效”（@cite{Oxford English Dictionary}）。由于你评估一个表达式来执行一个动作，“执行”已经演变为“评估”的同义词。）

@node let 表达式的组成部分
@subsection @code{let} 表达式的组成部分
@cindex @code{let} 表达式，组成部分
@cindex @code{let} 表达式的组成

@cindex @samp{varlist} 的定义
一个 @code{let} 表达式包含三个部分。第一部分是符号 @code{let}。第二部分是一个列表，称为@dfn{varlist}，其中每个元素要么是一个单独的符号，要么是一个两元素列表，其中第一个元素是一个符号。@code{let} 表达式的第三部分是 @code{let} 的主体。主体通常包含一个或多个列表。

@need 800
@code{let} 表达式的模板如下：

@smallexample
(let @var{varlist} @var{body}@dots{})
@end smallexample

@noindent
varlist 中的符号是由 @code{let} 特殊形式给予初始值的变量。单独的符号被赋予 @code{nil} 的初始值；而每个作为两元素列表的第一个元素的符号则被绑定到 Lisp 解释器评估第二个元素时返回的值。

因此，varlist 可以看起来像这样：@code{(thread (needles 3))}。在这种情况下，在 @code{let} 表达式中，Emacs 将符号 @code{thread} 绑定到初始值 @code{nil}，并将符号 @code{needles} 绑定到初始值 3。

当编写 @code{let} 表达式时，你要做的是将适当的表达式放入 @code{let} 表达式模板的各个部分。

如果 varlist 由两元素列表组成，这在许多情况下是常见的，那么 @code{let} 表达式的模板如下：

@smallexample
@group
(let ((@var{variable} @var{value})
      (@var{variable} @var{value})
      @dots{})
  @var{body}@dots{})
@end group
@end smallexample

@node 示例 let 表达式
@subsection 示例 @code{let} 表达式
@cindex 示例 @code{let} 表达式
@cindex @code{let} 表达式示例

以下表达式创建并为两个变量 @code{zebra} 和 @code{tiger} 赋予初始值。@code{let} 表达式的主体是一个调用 @code{message} 函数的列表。

@smallexample
@group
(let ((zebra "条纹")
      (tiger "凶猛"))
  (message "一种动物有 %s，另一种是 %s。"
           zebra tiger))
@end group
@end smallexample

在这里，varlist 是 @code{((zebra "条纹") (tiger "凶猛"))}。

这两个变量是 @code{zebra} 和 @code{tiger}。每个变量都是两元素列表的第一个元素，每个值都是其两元素列表的第二个元素。在 varlist 中，Emacs 将变量 @code{zebra} 绑定到值 @code{"条纹"}@footnote{根据Jared Diamond在 @cite{枪炮、病菌与钢铁} 中的说法，“@dots{} 斑马在变老时变得异常危险”，但这里的说法是它们不会像老虎一样变得凶猛。(1997, W. W. Norton 和 Co., ISBN 0-393-03894-2, 第171页)}，并将变量 @code{tiger} 绑定到值 @code{"凶猛"}。在这个例子中，两个值都是字符串。这些值同样可以是另一个列表或符号。@code{let} 的主体紧随包含变量的列表之后。在这个例子中，主体是一个列表，使用 @code{message} 函数在回显区域打印一个字符串。

@need 1500
您可以按照通常的方式评估这个示例，将光标放在最后一个括号后，然后键入 @kbd{C-x C-e}。这样做时，回显区域将显示以下内容：

@smallexample
"一种动物有条纹，另一种是凶猛。"
@end smallexample

正如我们之前看到的，@code{message} 函数打印其第一个参数，除了 @samp{%s}。在这个例子中，变量 @code{zebra} 的值将打印在第一个 @samp{%s} 的位置，而变量 @code{tiger} 的值将打印在第二个 @samp{%s} 的位置。

@node 未初始化的let语句变量
@subsection @code{let} 语句中的未初始化变量
@cindex 未初始化的 @code{let} 变量
@cindex @code{let} 变量未初始化

如果在 @code{let} 语句中不将变量绑定到特定的初始值，它们将自动绑定到初始值为 @code{nil}，如下面的表达式所示：

@smallexample
@group
(let ((birch 3)
      pine
      fir
      (oak 'some))
  (message
   "这里有 %d 个变量，分别具有 %s、%s 和 %s 的值。"
   birch pine fir oak))
@end group
@end smallexample

@noindent
这里，变量列表是 @code{((birch 3) pine fir (oak 'some))}。

@need 1250
如果以通常的方式评估此表达式，将在你的回显区域中看到以下内容：

@smallexample
"这里有 3 个变量，分别具有 nil、nil 和 some 的值。"
@end smallexample

@noindent
在这个例子中，Emacs将符号 @code{birch} 绑定到数字3，将符号 @code{pine} 和 @code{fir} 绑定到 @code{nil}，并将符号 @code{oak} 绑定到值 @code{some}。

注意，在 @code{let} 的第一部分中，变量 @code{pine} 和 @code{fir} 作为不带括号的原子独立存在；这是因为它们被绑定到 @code{nil}，即空列表。但是，@code{oak} 被绑定到 @code{some}，因此是列表 @code{(oak 'some)} 的一部分。类似地，@code{birch} 被绑定到数字3，因此在具有该数字的列表中。 (由于数字在评估时为自身，因此数字不需要引用。此外，消息中使用 @samp{%d} 而不是 @samp{%s} 打印数字。) 这四个变量作为一个组被放入列表中，以将它们与 @code{let} 的主体分开。

@node if
@section 特殊形式 @code{if}
@findex if
@cindex 使用 @code{if} 的条件语句

另一种特殊形式是条件语句 @code{if}。该形式用于指导计算机进行决策。您可以编写不使用 @code{if} 的函数定义，但它被经常使用且足够重要，因此在这里进行介绍。例如，在函数 @code{beginning-of-buffer} 的代码中就使用了它。

@code{if} 的基本思想是，@emph{如果}测试为真，@emph{那么}就会评估一个表达式。如果测试不为真，则不会评估该表达式。例如，您可能会做出这样的决定：“如果天气暖和而且阳光明媚，那么就去海滩！”

@menu
* if 详细说明::
* type-of-animal 详细说明::    一个 @code{if} 表达式的示例。
@end menu

@ifnottex
@node if 详细说明
@unnumberedsubsec @code{if}详细说明
@end ifnottex

@cindex @samp{if-part}定义
@cindex @samp{then-part}定义
在Lisp中，@code{if}表达式不使用单词“then”；测试和动作是列表的第二个和第三个元素，其第一个元素是@code{if}。尽管如此，@code{if}表达式的测试部分通常称为@dfn{if-part}，第二个参数通常称为@dfn{then-part}。

此外，当编写@code{if}表达式时，通常将真假测试写在与符号@code{if}相同的行上，但如果测试为真，则执行的操作，即then-part，会写在第二行及后续行。这样可以使@code{if}表达式更易读。

@smallexample
@group
(if @var{true-or-false-test}
    @var{action-to-carry-out-if-test-is-true})
@end group
@end smallexample

@noindent
真假测试将是由Lisp解释器评估的表达式。

以下是一个您可以按照通常方式评估的示例。测试是数字5是否大于数字4。由于是，将打印消息@samp{5 is greater than 4!}。

@smallexample
@group
(if (> 5 4)                             ; @r{if-part}
    (message "5 is greater than 4!"))   ; @r{then-part}
@end group
@end smallexample

@noindent
（函数@code{>}测试其第一个参数是否大于其第二个参数，并在其为真时返回true。）
@findex > @r{(greater than)}

当然，在实际使用中，@code{if} 表达式中的测试将不会像表达式 @code{(> 5 4)} 中那样永远固定。相反，测试中至少一个变量将被绑定到一个预先未知的值。
（如果值在预先知道，我们就不需要运行测试了！）

例如，该值可以绑定到函数定义的参数上。在以下函数定义中，动物的特性是传递给函数的值。如果绑定到 @code{characteristic} 的值是 @code{"fierce"}，则将打印消息 @samp{It is a tiger!}；否则，将返回 @code{nil}。

@smallexample
@group
(defun type-of-animal (characteristic)
  "根据 CHARACTERISTIC 在回显区打印消息。
如果 CHARACTERISTIC 是字符串 \"fierce\"，
则警告是一只老虎。"
  (if (equal characteristic "fierce")
      (message "It is a tiger!")))
@end group
@end smallexample

@need 1500
@noindent
如果您正在 GNU Emacs 中阅读此文档，您可以按照通常的方式评估函数定义以在 Emacs 中安装它，然后可以评估以下两个表达式以查看结果：

@smallexample
@group
(type-of-animal "fierce")

(type-of-animal "striped")
@end group
@end smallexample

@c 以下句子已重新编写以防止 hbox 溢出。
@noindent
当您评估 @code{(type-of-animal "fierce")} 时，您将在回显区看到打印的以下消息：@code{"It is a tiger!"}；当您评估 @code{(type-of-animal "striped")} 时，您将在回显区看到打印的 @code{nil}。

@node type-of-animal 详细说明
@subsection 详细介绍 @code{type-of-animal} 函数

让我们详细看一下 @code{type-of-animal} 函数。

@code{type-of-animal} 函数的定义是通过填充两个模板而完成的，一个用于整个函数定义，另一个用于 @code{if} 表达式。

@need 1250
每个非交互式函数的模板如下：

@smallexample
@group
(defun @var{name-of-function} (@var{argument-list})
  "@var{documentation}@dots{}"
  @var{body}@dots{})
@end group
@end smallexample

@need 800
符合此模板的函数部分如下：

@smallexample
@group
(defun type-of-animal (characteristic)
  "根据 CHARACTERISTIC 在回显区域打印消息。
如果 CHARACTERISTIC 是字符串 \"fierce\"，则警告可能是老虎。"
  @var{body: the} @code{if} @var{expression})
@end group
@end smallexample

函数的名称是 @code{type-of-animal}；它接受一个参数的值。参数列表后面是多行文档字符串。在示例中包含文档字符串是一个良好的习惯，建议为每个函数定义都编写文档字符串。函数定义的主体由 @code{if} 表达式组成。

@need 800
@code{if} 表达式的模板如下：

@smallexample
@group
(if @var{true-or-false-test}
    @var{action-to-carry-out-if-the-test-returns-true})
@end group
@end smallexample

@need 1250
在 @code{type-of-animal} 函数中，@code{if} 的代码如下：

@smallexample
@group
(if (equal characteristic "fierce")
    (message "它是一只老虎！"))
@end group
@end smallexample

@need 800
在这里，true-or-false-test 是表达式：

@smallexample
(equal characteristic "fierce")
@end smallexample

在 Lisp 中，@code{equal} 是一个函数，它确定其第一个参数是否等于第二个参数。第二个参数是字符串 @code{"fierce"}，第一个参数是符号 @code{characteristic} 的值，换句话说，就是传递给该函数的参数。

在 @code{type-of-animal} 的第一个示例中，传递了参数 @code{"fierce"}。由于 @code{"fierce"} 等于 @code{"fierce"}，表达式 @code{(equal characteristic "fierce")} 返回 true。当发生这种情况时，@code{if} 会评估 @code{if} 的第二个参数或 true 部分：@code{(message "它是一只老虎！")}。

另一方面，在 @code{type-of-animal} 的第二个示例中，传递了参数 @code{"striped"}。@code{"striped"} 不等于 @code{"fierce"}，因此 true 部分不会被评估，@code{if} 表达式返回 @code{nil}。

@node else
@section If--then--else 表达式
@cindex Else

一个 @code{if} 表达式可能有一个可选的第三个参数，称为 @dfn{else-部分}，用于当真假测试返回 false 时的情况。当这种情况发生时，整个 @code{if} 表达式的第二个参数或者 then-部分 @emph{不会} 被评估，而第三个参数或 else-部分 @emph{会} 被评估。你可以将其看作是决策的“如果天气温暖且晴朗，则去海滩，否则读一本书”的多云日备选方案。

在Lisp代码中并没有写下单词 "else"；@code{if} 表达式的 else-部分在 then-部分之后。在书写的Lisp中，else-部分通常写在自己的一行上，并且比 then-部分的缩进少：

@smallexample
@group
(if @var{真假测试}
    @var{真时执行的动作}
  @var{假时执行的动作})
@end group
@end smallexample

例如，下面的 @code{if} 表达式在通常的情况下，当你对其进行求值时，会打印消息 @samp{4不大于5！}：

@smallexample
@group
(if (> 4 5)                               ; @r{if-部分}
    (message "4 falsely greater than 5!") ; @r{then-部分}
  (message "4 is not greater than 5!"))   ; @r{else-部分}
@end group
@end smallexample

@noindent
请注意，不同缩进级别使得很容易区分 then-部分 和 else-部分。（GNU Emacs 有几个命令可以自动正确缩进 @code{if} 表达式。@xref{Typing Lists, , GNU Emacs Helps You Type Lists}.）

我们可以通过在 @code{type-of-animal} 函数中加入一个 else 部分来扩展它，只需在 @code{if} 表达式中加入一个额外的部分即可。

@need 1500
如果你评估以下版本的 @code{type-of-animal} 函数定义以安装它，然后评估两个后续表达式，将不同的参数传递给函数，你就能看到这样做的后果。

@smallexample
@group
(defun type-of-animal (characteristic)  ; @r{第二个版本。}
  "根据 CHARACTERISTIC 在回显区域打印消息。
如果 CHARACTERISTIC 是字符串 \"fierce\"，
则警告是一只老虎；否则说它不凶猛。"
  (if (equal characteristic "fierce")
      (message "这是一只老虎！")
    (message "它不凶猛！")))
@end group
@end smallexample
@sp 1

@smallexample
@group
(type-of-animal "fierce")

(type-of-animal "striped")

@end group
@end smallexample

@c 为了防止 hbox 过满，以下句子已重新编写。
@noindent
当你评估 @code{(type-of-animal "fierce")} 时，你将在回显区域看到以下消息打印出来：@code{"这是一只老虎！"}；但是当你评估 @code{(type-of-animal "striped")} 时，你将看到 @code{"它不凶猛！"}。

（当然，如果 @var{characteristic} 是 @code{"ferocious"}，则将打印消息 @code{"它不凶猛！"}；这可能会产生误导！在编写代码时，你需要考虑到 @code{if} 可能会测试到这样的参数，并相应地编写你的程序。）

@node 真值与假值
@section Emacs Lisp 中的真值和假值
@cindex Emacs Lisp 中的真值和假值
@cindex Emacs Lisp 中的假值和真值
@findex nil

在 @code{if} 表达式中，有一个重要的关于真值测试的方面。到目前为止，我们已经谈到“true”和“false”作为谓词的值，好像它们是新种类的 Emacs Lisp 对象一样。实际上，“false”只是我们的老朋友 @code{nil}。任何其他东西——无论什么——都是“true”。

对真值进行测试的表达式在解释时会被视为 @dfn{真}，如果它的求值结果不是 @code{nil}。换句话说，如果返回的值是一个数字，比如 47，一个字符串，比如 @code{"hello"}，或者一个符号（除了 @code{nil} 之外的任何符号），或者一个列表（只要它不是空的），甚至是一个缓冲区，测试的结果就被认为是真的！

@menu
* nil explained::               @code{nil} 有两个含义。
@end menu

@ifnottex
@node nil解释
@unnumberedsubsec @code{nil}的解释
@end ifnottex

在说明真值测试之前，我们需要解释一下 @code{nil}。

在Emacs Lisp中，符号 @code{nil} 有两个含义。首先，它表示空列表。其次，它表示假，是在真假测试返回假时返回的值。@code{nil}可以被写成空列表，@code{()}，或者写作 @code{nil}。就Lisp解释器而言，@code{()} 和 @code{nil} 是一样的。然而，人们倾向于将 @code{nil} 用于表示假，而将 @code{()} 用于表示空列表。

在Emacs Lisp中，任何不是 @code{nil}，即非空列表的值，被认为是真。这意味着如果一个求值返回了不是空列表的值，一个 @code{if} 表达式将测试为真。例如，如果一个数字被放在测试的槽位，它将被求值并返回它自己，因为这是数字在被求值时所做的。在这个条件语句中，@code{if} 表达式将测试为真。该表达式仅在通过求值表达式返回 @code{nil}，即空列表时测试为假。

通过对以下示例中的两个表达式进行求值，您可以看到这一点。

在第一个示例中，数字4作为 @code{if} 表达式中的测试被求值并返回自己；因此，表达式的then部分被求值并返回：在回显区域中显示 @samp{true}。在第二个示例中，@code{nil} 表示假；因此，表达式的else部分被求值并返回：在回显区域中显示 @samp{false}。

@smallexample
@group
(if 4
    'true
  'false)
@end group

@group
(if nil
    'true
  'false)
@end group
@end smallexample

@need 1250
顺便说一句，如果某个有用的值在返回真的测试时不可用，那么Lisp解释器将返回符号 @code{t} 代表真。例如，表达式 @code{(> 5 4)} 在被求值时返回 @code{t}，您可以通过通常的方式进行求值查看：

@smallexample
(> 5 4)
@end smallexample

@need 1250
@noindent
另一方面，如果测试为假，则该函数返回 @code{nil}。

@smallexample
(> 4 5)
@end smallexample

@node save-excursion
@section @code{save-excursion}
@findex save-excursion
@cindex Region, what it is
@cindex Preserving point and buffer
@cindex Point and buffer preservation
@findex point
@findex mark

@code{save-excursion}函数是我们将在本章中讨论的最后一个特殊形式。

在用于编辑的Emacs Lisp程序中，@code{save-excursion}函数非常常见。它保存点（point）的位置，执行函数体，然后如果点的位置发生了变化，则将点还原到其先前的位置。其主要目的是防止用户因点的意外移动而感到惊讶和困扰。

@menu
* Point and mark::              各种位置的回顾。
* Template for save-excursion::
@end menu

@ifnottex
@node 光标位置和标记
@unnumberedsubsec 光标位置和标记
@end ifnottex

然而，在讨论 @code{save-excursion} 之前，首先回顾一下在 GNU Emacs 中点（Point）和标记（Mark）的概念可能会很有用。@dfn{点} 是光标的当前位置。光标所在的位置就是点。更准确地说，在光标位于字符之上的终端上，点位于紧接在字符之前。在 Emacs Lisp 中，点是一个整数。缓冲区中的第一个字符是编号为一，第二个是编号为二，依此类推。函数 @code{point} 返回光标的当前位置作为一个数字。每个缓冲区都有其自己的点值。

@dfn{标记} 是缓冲区中的另一个位置；它的值可以通过诸如 @kbd{C-@key{SPC}}（@code{set-mark-command}）的命令设置。如果已经设置了标记，可以使用命令 @kbd{C-x C-x}（@code{exchange-point-and-mark}）使光标跳到标记位置，并将标记设置为点的先前位置。此外，如果设置了另一个标记，前一个标记的位置将保存在标记环中。可以通过键入 @kbd{C-u C-@key{SPC}} 一次或多次将光标跳到保存的标记位置。

点和标记之间的缓冲区部分称为@dfn{区域}。许多命令在区域上起作用，包括 @code{center-region}、@code{count-words-region}、@code{kill-region} 和 @code{print-region}。

@code{save-excursion} 特殊形式保存点的位置，并在该特殊形式的主体内的代码被 Lisp 解释器评估后恢复这个位置。因此，如果点在文本的开头，某些代码将点移到缓冲区的末尾，@code{save-excursion} 将在函数主体中的表达式被评估后将点放回到它之前的位置。

在 Emacs 中，一个函数通常会在其内部工作的过程中移动点，尽管用户不希望这样。例如，@code{count-words-region} 会移动点。为了防止用户受到既意外又（从用户的角度）不必要的跳跃的困扰，通常使用 @code{save-excursion} 来保持点在用户预期的位置上。使用 @code{save-excursion} 是良好的编码风格。

为了确保代码书写规范，@code{save-excursion} 即使在其内部代码发生错误时也会恢复点的值（或者更准确地说，``在异常退出的情况下''）。这个特性非常有帮助。

除了记录点的值，@code{save-excursion} 还跟踪当前缓冲区，并在需要时进行恢复。这意味着你可以编写改变缓冲区的代码，并通过 @code{save-excursion} 切换回原始缓冲区。这就是 @code{save-excursion} 在 @code{append-to-buffer} 中的使用方式。(@xref{append-to-buffer, , @code{append-to-buffer} 的定义}.) 

@node save-excursion 表达式模板
@subsection @code{save-excursion} 表达式的模板

@need 800
使用 @code{save-excursion} 的代码模板很简单：

@smallexample
@group
(save-excursion
  @var{body}@dots{})
@end group
@end smallexample

@noindent
函数体是一个或多个表达式，它们将按顺序由Lisp解释器求值。如果在函数体中有多个表达式，则最后一个表达式的值将作为 @code{save-excursion} 函数的返回值。函数体中的其他表达式仅用于它们的副作用；而 @code{save-excursion} 本身仅用于其副作用（即还原point的位置）。

@need 1250
更详细地说，@code{save-excursion} 表达式的模板如下：

@smallexample
@group
(save-excursion
  @var{函数体中的第一个表达式}
  @var{函数体中的第二个表达式}
  @var{函数体中的第三个表达式}
   @dots{}
  @var{函数体中的最后一个表达式})
@end group
@end smallexample

@noindent
一个表达式当然可以是一个独立的符号或一个列表。

在Emacs Lisp代码中，@code{save-excursion} 表达式经常出现在 @code{let} 表达式的体内。它的形式如下：

@smallexample
@group
(let @var{变量列表}
  (save-excursion
    @var{函数体}@dots{}))
@end group
@end smallexample

@node Review
@section 复习

在过去的几章中，我们介绍了一个宏和相当多的函数和特殊形式。这里对它们进行简要描述，以及一些尚未提到的类似函数。

@table @code
@item eval-last-sexp
评估光标前的最后一个符号表达式。除非在调用该函数时使用参数，否则该值将打印在回显区域；在这种情况下，输出将打印在当前缓冲区中。通常，此命令绑定到 @kbd{C-x C-e}。

@item defun
定义函数。此宏最多有五个部分：名称、传递给函数的参数的模板、文档、可选的交互声明和定义的主体。

@need 1250
例如，在Emacs中，@code{dired-unmark-all-marks} 的函数定义如下。

@smallexample
@group
(defun dired-unmark-all-marks ()
  "从Dired缓冲区中的所有文件中删除所有标记。"
  (interactive)
  (dired-unmark-all-files ?\r))
@end group
@end smallexample

@item interactive
声明函数可交互使用。此特殊形式后面可能跟着一个包含一个或多个部分的字符串，将信息传递给函数的参数，按顺序。这些部分还可以告诉解释器提示信息。字符串的各部分由新行，即 @samp{\n} 分隔。

@need 1000
常见的代码字符包括：

@table @code
@item b
现有缓冲区的名称。

@item f
现有文件的名称。

@item p
数值前缀参数。（注意，此处的 @code{p} 是小写。）

@item r
光标和标记，作为两个数值参数，从最小到最大。这是唯一指定两个连续参数而不是一个参数的代码字母。
@end table

@xref{Interactive Codes, , 用于 @samp{interactive} 的代码字符, elisp, GNU Emacs Lisp参考手册}，以获取完整的代码字符列表。

@item let
声明一个变量列表，用于在@code{let}体内使用，并给它们一个初始值，可以是@code{nil}或指定的值；然后评估@code{let}体内的其余表达式，并返回最后一个表达式的值。在@code{let}体内，Lisp解释器看不到与外部绑定的同名变量的值。

@need 1250
例如，

@smallexample
@group
(let ((foo (buffer-name))
      (bar (buffer-size)))
  (message
   "当前缓冲区是 %s，包含 %d 个字符。"
   foo bar))
@end group
@end smallexample

@item save-excursion
在评估此特殊形式的体之前，记录point和当前缓冲区的值。在评估完体后，恢复point和缓冲区的值。

@need 1250
例如，

@smallexample
@group
(message "我们已经在这个缓冲区中 %d 个字符。"
         (- (point)
            (save-excursion
              (goto-char (point-min)) (point))))
@end group
@end smallexample

@item if
评估函数的第一个参数；如果为真，则评估第二个参数；否则，如果存在第三个参数，则评估第三个参数。

@code{if}特殊形式被称为@dfn{条件语句}。Emacs Lisp中还有其他条件语句，但@code{if}可能是最常用的。

@need 1250
例如，

@smallexample
@group
(if (= 22 emacs-major-version)
    (message "这是22版的Emacs")
  (message "这不是22版的Emacs"))
@end group
@end smallexample

@need 1250
@item <
@itemx >
@itemx <=
@itemx >=
@code{<}函数测试其第一个参数是否小于第二个参数。相应的函数@code{>}测试第一个参数是否大于第二个参数。类似地，@code{<=}测试第一个参数是否小于或等于第二个参数，而@code{>=}测试第一个参数是否大于或等于第二个参数。在所有情况下，两个参数必须是数字或标记（标记表示缓冲区中的位置）。

@need 800
@item =
@code{=}函数测试两个参数是否相等，这两个参数都必须是数字或标记。

@need 1250
@item equal
@itemx eq
测试两个对象是否相同。@code{equal}使用“相同”一词的一种含义，而@code{eq}使用另一种含义：如果两个对象具有相似的结构和内容，例如同一本书的两个副本，则@code{equal}返回真。另一方面，@code{eq}返回真，如果两个参数实际上是同一个对象。

@findex equal
@findex eq

@need 1250
@item string<
@itemx string-lessp
@itemx string=
@itemx string-equal
@code{string-lessp}函数测试其第一个参数是否小于第二个参数。同样功能的较短名称（@code{defalias}）是@code{string<}。

@code{string-lessp}的参数必须是字符串或符号；排序是词法的，因此大小写是敏感的。使用符号的打印名称而不是符号本身。

@cindex @samp{empty string}定义
空字符串，即@samp{""}，即不包含字符的字符串，小于任何包含字符的字符串。

@code{string-equal}提供相应的相等测试。它的较短名称是@code{string=}。没有与@var{>}，@code{>=}或@code{<=}相对应的字符串测试函数。

@item message
在回显区域打印消息。第一个参数是一个字符串，可以包含@samp{%s}，@samp{%d}或@samp{%c}，用于打印紧随其后的参数的值。由@samp{%s}使用的参数必须是字符串或符号；由@samp{%d}使用的参数必须是数字。由@samp{%c}使用的参数必须是@sc{ascii}代码数字；它将被打印为具有该@sc{ascii}代码的字符。 （其他各种未提到的%-序列未在此提及。）

@item setq
@itemx set
@code{setq}特殊形式将其第一个参数的值设置为第二个参数的值。第一个参数由@code{setq}自动引用。它对后续的参数对执行相同的操作。另一个函数@code{set}只接受两个参数，并在设置其第一个参数返回的值之前评估两个参数。

@item buffer-name
没有参数时，返回缓冲区的名称，作为字符串。

@item buffer-file-name
没有参数时，返回缓冲区正在访问的文件的名称。

@item current-buffer
返回Emacs处于活动状态的缓冲区；它可能不是屏幕上可见的缓冲区。

@item other-buffer
返回最近选择的缓冲区（不包括作为参数传递给@code{other-buffer}的缓冲区和当前缓冲区）。

@item switch-to-buffer
选择Emacs处于活动状态并在当前窗口中显示的缓冲区，以便用户可以查看它。通常绑定到@kbd{C-x b}。

@item set-buffer
切换Emacs的注意力到将运行程序的缓冲区。不更改窗口显示的内容。

@item buffer-size
返回当前缓冲区中字符的数量。

@item point
返回光标当前位置的值，作为从缓冲区开头计算的整数字符数。

@item point-min
返回当前缓冲区中point的最小允许值。除非限制了缩小，否则为1。

@item point-max
返回当前缓冲区中point的最大允许值。除非限制了缩小，否则为缓冲区的末尾。
@end table

@need 1500
@node defun 练习
@section 练习

@itemize @bullet
@item
编写一个非交互式函数，它将其参数（一个数字）的值加倍。将该函数设为交互式。

@item
编写一个函数，检查当前的@code{fill-column}值是否大于传递给函数的参数，如果是，则打印相应的消息。
@end itemize

@node Buffer Walk Through
@chapter 几个与缓冲区相关的函数

在这一章中，我们详细研究了GNU Emacs中使用的几个函数。这被称为“步进演示”。这些函数被用作Lisp代码的示例，但它们并不是虚构的例子；除了第一个简化的函数定义之外，这些函数展示了GNU Emacs中实际使用的代码。你可以从这些定义中学到很多东西。这里描述的函数都与缓冲区有关。稍后，我们将研究其他函数。

@menu
* 查找更多信息::                  如何查找更多信息。
* simplified-beginning-of-buffer::  展示了 @code{goto-char}、
                                  @code{point-min} 和 @code{push-mark}。
* mark-whole-buffer::             几乎与 @code{beginning-of-buffer} 相同。
* append-to-buffer::              使用 @code{save-excursion} 和
                                  @code{insert-buffer-substring}。
* 缓冲区相关回顾::                  回顾。
* 缓冲区练习::
@end menu

@node 查找更多
@section 查找更多信息

@findex describe-function@r{, introduced}
@cindex 查找函数文档
在这个步骤中，我将在遇到新函数时逐一描述它，有时详细介绍，有时简要说明。如果你感兴趣，你可以随时通过输入@kbd{C-h f}，然后输入函数的名称（然后按@key{RET}）获取任何Emacs Lisp函数的完整文档。类似地，你可以通过输入@kbd{C-h v}，然后输入变量的名称（然后按@key{RET}）获取变量的完整文档。

@cindex 查找函数源码
@c 在版本22中，告诉C和Emacs Lisp的函数定义位置
此外，@code{describe-function}还会告诉你函数定义的位置。

将光标放在包含函数的文件名上，然后按@key{RET}键。在这种情况下，@key{RET}意味着@code{push-button}，而不是“return”或“enter”。Emacs将直接跳转到函数定义处。

@ignore
在版本22中不存在

如果将光标移到文件名上并按@key{RET}键，这种情况下@key{RET}意味着@code{help-follow}而不是“return”或“enter”，Emacs将直接跳转到函数定义处。
@end ignore

更一般地说，如果你想在原始源文件中查看函数，你可以使用@code{xref-find-definitions}函数跳转到它。@code{xref-find-definitions}适用于各种语言，不仅限于Lisp和C，它还适用于非编程文本。例如，@code{xref-find-definitions}将跳转到本文档的Texinfo源文件的各个节点（前提是你已经运行@command{etags}实用程序记录了Emacs附带手册中的所有节点；@pxref{Create Tags Table,,, emacs, The GNU Emacs Manual}）。

要使用@code{xref-find-definitions}命令，输入@kbd{M-.}（即，按住@key{META}键的同时按下句点键，或者按@key{ESC}键，然后输入句点键），然后在提示符处输入你想要查看源代码的函数的名称，比如@code{mark-whole-buffer}，然后输入@key{RET}。 （如果命令没有提示，带一个参数调用它：@kbd{C-u M-.}；@pxref{交互选项}。）Emacs将切换缓冲区并在屏幕上显示函数的源代码@footnote{
如果Emacs不是显示Lisp函数的源代码，而是询问你要访问哪个标签表，请在其主要模式为Emacs Lisp或Lisp Interaction的缓冲区中调用@kbd{M-.}。
}。要切换回当前缓冲区，输入@kbd{M-,}或@kbd{C-x b @key{RET}}。（在某些键盘上，@key{META}键标记为@key{ALT}。）

@cindex Library, 作为“文件”一词的用法
顺便说一下，包含Lisp代码的文件通常被称为@dfn{库}。这个比喻来源于专业图书馆的概念，比如法律图书馆或工程图书馆，而不是普通图书馆。每个库或文件都包含与特定主题或活动相关的函数，比如处理缩写和其他输入快捷方式的@file{abbrev.el}，以及用于帮助的@file{help.el}。（有时，多个库提供单个活动的代码，就像各种@file{rmail@dots{}}文件提供阅读电子邮件的代码一样。）在@cite{The GNU Emacs Manual}中，你会看到类似“@kbd{C-h p}命令允许你按主题关键字搜索标准的Emacs Lisp库。”的句子。

@node simplified-beginning-of-buffer
@section 一个简化的 @code{beginning-of-buffer} 定义
@findex simplified-beginning-of-buffer

@code{beginning-of-buffer} 命令是一个很好的起点函数，因为你可能熟悉它，并且它易于理解。作为交互式命令使用时，@code{beginning-of-buffer} 将光标移动到缓冲区的开头，同时在先前的位置留下标记。通常绑定到 @kbd{M-<}。

在这一节中，我们将讨论该函数的一个简化版本，展示它最常用的形式。这个简化的函数按原样工作，但不包含复杂选项的代码。在另一节中，我们将描述整个函数。(@xref{beginning-of-buffer, , @code{beginning-of-buffer} 的完整定义}。)

在查看代码之前，让我们考虑函数定义必须包含的内容：必须包括一个使函数可交互的表达式，以便通过键入 @kbd{M-x beginning-of-buffer} 或键入键序（如 @kbd{M-<}）来调用它；必须包括代码以在缓冲区中原始位置留下一个标记；必须包括将光标移动到缓冲区开头的代码。

@need 1250
以下是该函数简化版本的完整文本：

@smallexample
@group
(defun simplified-beginning-of-buffer ()
  "将光标移动到缓冲区开头；在先前位置留下标记。"
  (interactive)
  (push-mark)
  (goto-char (point-min)))
@end group
@end smallexample

与所有函数定义一样，此定义在宏 @code{defun} 之后有五个部分：

@enumerate
@item
名称：在这个例子中是 @code{simplified-beginning-of-buffer}。

@item
参数列表：在这个例子中是一个空列表，@code{()}。

@item
文档字符串。

@item
交互表达式。

@item
主体。
@end enumerate

@noindent
在此函数定义中，参数列表为空，这意味着此函数不需要任何参数。 （当我们查看完整函数定义时，我们将看到它可以传递一个可选参数。）

交互式表达式告诉Emacs该函数旨在以交互方式使用。在这个例子中，@code{interactive} 没有参数，因为 @code{simplified-beginning-of-buffer} 不需要参数。

@need 800
函数的主体包括两行：

@smallexample
@group
(push-mark)
(goto-char (point-min))
@end group
@end smallexample

这些行中的第一行是表达式 @code{(push-mark)}。当Lisp解释器评估此表达式时，它在光标当前位置设置一个标记，无论光标在哪里。该标记的位置保存在标记环中。

接下来的一行是 @code{(goto-char (point-min))}。此表达式将光标跳到缓冲区的最小点，即缓冲区的开头（如果缩小了，则是缓冲区的可访问部分的开头。@xref{缩窄与扩大, , 缩小和扩大}.)

@code{push-mark} 命令在光标被 @code{(goto-char (point-min))} 表达式移动到缓冲区开头之前的位置设置一个标记。因此，如果愿意，可以通过键入 @kbd{C-x C-x} 返回到最初的位置。

这就是整个函数定义的全部内容！

@findex describe-function
当阅读这样的代码并遇到不熟悉的函数时，比如 @code{goto-char}，可以使用 @code{describe-function} 命令了解它的作用。要使用此命令，输入 @kbd{C-h f}，然后输入函数的名称并按 @key{RET}。@code{describe-function} 命令将在 @file{*Help*} 窗口中打印函数的文档字符串。例如，@code{goto-char} 的文档如下：

@smallexample
@group
将点设置为 POSITION，一个数字或标记。
缓冲区的开头是位置 (point-min)，结束是 (point-max)。
@end group
@end smallexample

@noindent
函数的一个参数是所需的位置。

@noindent
（对于 @code{describe-function} 的提示将提供光标下或之前的符号，因此您可以通过将光标直接定位到函数上方或之后，然后键入 @kbd{C-h f @key{RET}} 以节省输入。）

@code{end-of-buffer} 函数定义与 @code{beginning-of-buffer} 定义的方式相同，只是函数的主体包含 @code{(goto-char (point-max))} 表达式，而不是 @code{(goto-char (point-min))}。

@node mark-whole-buffer
@section 定义 @code{mark-whole-buffer}
@findex mark-whole-buffer

@code{mark-whole-buffer} 函数的理解并不比 @code{simplified-beginning-of-buffer} 函数更难。然而，在这种情况下，我们将看一下完整的函数，而不是缩短版本。

@code{mark-whole-buffer} 函数并不像 @code{beginning-of-buffer} 函数那样常用，但仍然很有用：它通过将点放在开头并在缓冲区末尾放置标记来标记整个缓冲区作为一个区域。通常绑定到 @kbd{C-x h}。

@menu
* mark-whole-buffer 概述::
* mark-whole-buffer 函数体::   只有三行代码。
@end menu

@ifnottex
@node mark-whole-buffer 概述
@unnumberedsubsec @code{mark-whole-buffer} 概述
@end ifnottex

@need 1250
在GNU Emacs 22中，完整函数的代码如下：

@smallexample
@group
(defun mark-whole-buffer ()
  "将点放在缓冲区的开头，将标记放在缓冲区的末尾。
在Lisp程序中，您可能不应该使用此函数；
让Lisp函数使用使用或设置标记的任何子例程通常是一个错误。"
  (interactive)
  (push-mark (point))
  (push-mark (point-max) nil t)
  (goto-char (point-min)))
@end group
@end smallexample

@need 1250
与所有其他函数一样，@code{mark-whole-buffer} 函数符合函数定义的模板。模板如下：

@smallexample
@group
(defun @var{name-of-function} (@var{argument-list})
  "@var{documentation}@dots{}"
  (@var{interactive-expression}@dots{})
  @var{body}@dots{})
@end group
@end smallexample

函数的名称是 @code{mark-whole-buffer}；后面是一个空的参数列表，@samp{()} 表示函数不需要参数。接下来是文档。

下一行是一个 @code{(interactive)} 表达式，告诉Emacs该函数将以交互方式使用。这些细节类似于前一节中描述的 @code{simplified-beginning-of-buffer} 函数。

@need 1250
@node mark-whole-buffer 函数体
@subsection @code{mark-whole-buffer} 函数体

@code{mark-whole-buffer} 函数的主体由三行代码组成：

@c GNU Emacs 22
@smallexample
@group
(push-mark (point))
(push-mark (point-max) nil t)
(goto-char (point-min))
@end group
@end smallexample

这些行中的第一行是表达式 @code{(push-mark (point))}。

这行与 @code{simplified-beginning-of-buffer} 函数体的第一行 @code{(push-mark)} 完全相同。在这两种情况下，Lisp解释器在光标的当前位置设置一个标记。

我不知道为什么 @code{mark-whole-buffer} 中的表达式写为 @code{(push-mark (point))}，而在 @code{beginning-of-buffer} 中的表达式写为 @code{(push-mark)}。也许编写代码的人不知道 @code{push-mark} 的参数是可选的，如果 @code{push-mark} 没有传递参数，该函数默认会在点的位置自动设置标记。或者也许该表达式是为了与下一行的结构相呼应而写的。无论如何，这行使Emacs确定点的位置并在那里设置一个标记。

在GNU Emacs的早期版本中，@code{mark-whole-buffer} 的下一行是 @code{(push-mark (point-max))}。此表达式在缓冲区中具有最大编号的地方设置一个标记。这将是缓冲区的末尾（或者，如果缓冲区被缩小，缓冲区的可访问部分的末尾。有关缩小的更多信息，请参见 @xref{缩窄与扩大, , Narrowing and Widening}）。设置了此标记后，前一个标记（在点处设置的标记）不再设置，但Emacs记住了其位置，就像始终记住所有其他最近的标记一样。这意味着您可以通过键入 @kbd{C-u C-@key{SPC}} 两次返回到该位置，如果您愿意的话。

@need 1250
在GNU Emacs 22中，@code{(point-max)} 稍微复杂一些。该行读取

@smallexample
(push-mark (point-max) nil t)
@end smallexample

@noindent
该表达式几乎与之前相同。它在缓冲区中具有最大编号的位置设置一个标记。然而，在此版本中，@code{push-mark} 有两个额外的参数。@code{push-mark} 的第二个参数是 @code{nil}。这告诉函数在推送标记时应显示一个消息，该消息说“标记已设置”。第三个参数是 @code{t}。这告诉 @code{push-mark} 在启用瞬时标记模式时激活标记。瞬时标记模式突出显示当前活动的区域。通常情况下会关闭它。

最后，函数的最后一行是 @code{(goto-char (point-min)))}。这与 @code{beginning-of-buffer} 中写得一样。该表达式将光标移动到缓冲区的最小点，即缓冲区的开头（或者可访问部分的开头）。因此，点被放置在缓冲区的开头，标记被设置在缓冲区的末尾。整个缓冲区因此成为了一个区域。

@node append-to-buffer
@section @code{append-to-buffer}的定义
@findex append-to-buffer

@code{append-to-buffer}命令比@code{mark-whole-buffer}命令更复杂。其功能是将当前缓冲区中点和标记之间的区域复制到指定的缓冲区。

@menu
* append-to-buffer概述::
* append交互::          由两部分交互式表达式组成。
* append-to-buffer主体::       包含@code{let}表达式。
* append保存位置::       @code{save-excursion}的工作原理。
@end menu

@ifnottex
@node append-to-buffer概述
@unnumberedsubsec @code{append-to-buffer}的概述
@end ifnottex

@findex insert-buffer-substring
@code{append-to-buffer}命令使用@code{insert-buffer-substring}函数来复制区域。@code{insert-buffer-substring}的名称已经解释了它的功能：它从一个缓冲区中取出子字符串，然后插入到另一个缓冲区中。

大部分@code{append-to-buffer}涉及设置@code{insert-buffer-substring}工作条件：代码必须指定文本将进入的缓冲区，它来自的窗口以及它要去的窗口，以及将被复制的区域。

@need 1250
下面是该函数的可能实现：

@c GNU Emacs 22
@smallexample
@group
(defun append-to-buffer (buffer start end)
  "将区域的文本附加到指定缓冲区。
它插入到该缓冲区的点之前。
@end group

@group
在从程序调用时，提供三个参数：
BUFFER（或缓冲区名称），START和END。
START和END指定要复制的当前缓冲区的部分。"
  (interactive
   (list (read-buffer "追加到缓冲区：" (other-buffer
                                            (current-buffer) t))
         (region-beginning) (region-end)))
@end group
@group
  (let ((oldbuf (current-buffer)))
    (save-excursion
      (let* ((append-to (get-buffer-create buffer))
             (windows (get-buffer-window-list append-to t t))
             point)
        (set-buffer append-to)
        (setq point (point))
        (barf-if-buffer-read-only)
        (insert-buffer-substring oldbuf start end)
        (dolist (window windows)
          (when (= (window-point window) point)
            (set-window-point window (point))))))))
@end group
@end smallexample

通过查看该函数，可以理解它是一系列填充模板。

最外层模板是函数定义。在这个函数中，它看起来像这样（填充了几个槽）：

@smallexample
@group
(defun append-to-buffer (buffer start end)
  "@var{文档}@dots{}"
  (interactive @dots{})
  @var{主体}@dots{})
@end group
@end smallexample

函数的第一行包括其名称和三个参数。这些参数是文本将要复制到的@code{buffer}，以及将要复制的当前缓冲区的@code{start}和@code{end}。

函数的下一部分是文档，非常清晰而完整。按照惯例，这三个参数以大写字母写入，以便您轻松注意到它们。更好的是，它们按照参数列表中的顺序进行描述。

请注意文档区分了缓冲区和其名称。（该函数可以处理任何一种。）

@node append interactive
@subsection @code{append-to-buffer} 交互式表达式

由于 @code{append-to-buffer} 函数将被交互使用，该函数必须具有一个 @code{interactive} 表达式。 (有关 @code{interactive} 的详细信息，请参阅 @ref{交互操作, , 使函数具有交互性}。)

表达式如下：

@smallexample
@group
(interactive
 (list (read-buffer
        "追加到缓冲区: "
        (other-buffer (current-buffer) t))
       (region-beginning)
       (region-end)))
@end group
@end smallexample

@noindent
该表达式不是一个字母代表部分的表达式，如前所述。相反，它以这些部分开始一个列表：

列表的第一部分是一个表达式，用于读取缓冲区的名称并将其作为字符串返回。那就是 @code{read-buffer}。该函数需要一个提示作为其第一个参数，即 @samp{"追加到缓冲区: "}。其第二个参数告诉命令如果不指定任何值，应提供什么值。

在这种情况下，第二个参数是一个包含函数 @code{other-buffer}、一个异常和 @samp{t} 的表达式，表示为真。

@code{other-buffer} 的第一个参数是异常，是另一个函数 @code{current-buffer}。这不会被返回。第二个参数是真的符号，即 @code{t}。这告诉 @code{other-buffer} 它可以显示可见缓冲区（在这种情况下，它将不显示当前缓冲区，这是有道理的）。

@need 1250
表达式如下：

@smallexample
(other-buffer (current-buffer) t)
@end smallexample

@code{list} 表达式的第二个和第三个参数是 @code{(region-beginning)} 和 @code{(region-end)}。这两个函数指定要追加的文本的开头和结尾。

@need 1250
最初，该命令使用字母 @samp{B} 和 @samp{r}。整个 @code{interactive} 表达式如下：

@smallexample
(interactive "B追加到缓冲区:@: \nr")
@end smallexample

@noindent
但是当这样做时，切换到的缓冲区的默认值变为不可见。这是不想要的。

（提示与第二个参数之间用换行符 @samp{\n} 分隔。它后面跟着一个 @samp{r}，告诉 Emacs 将跟随函数参数列表中 @code{buffer} 符号后面的两个参数（即 @code{start} 和 @code{end}）绑定到点和标记的值。这个参数运行良好。）

@node append-to-buffer body
@subsection @code{append-to-buffer} 函数体

@code{append-to-buffer} 函数的体部分以 @code{let} 开始。

正如我们之前所见 (@pxref{let, , @code{let}})，@code{let} 表达式的目的是在 @code{let} 的体内创建并给予一个或多个变量初始值。这意味着这样的变量不会与 @code{let} 表达式外部同名的任何变量混淆。

通过以下提纲展示了 @code{append-to-buffer} 函数的模板，其中包含 @code{let} 表达式：

@smallexample
@group
(defun append-to-buffer (buffer start end)
  "@var{documentation}@dots{}"
  (interactive @dots{})
  (let ((@var{variable} @var{value}))
        @var{body}@dots{}))
@end group
@end smallexample

@code{let} 表达式包含三个元素：

@enumerate
@item
符号 @code{let}；

@item
一个 varlist，包含一个两元素列表，即 @code{(@var{variable} @var{value})}；

@item
@code{let} 表达式的体部分。
@end enumerate

@need 800
在 @code{append-to-buffer} 函数中，varlist 的样式如下：

@smallexample
(oldbuf (current-buffer))
@end smallexample

@noindent
在 @code{let} 表达式的这部分中，唯一的变量 @code{oldbuf} 被绑定到 @code{(current-buffer)} 表达式返回的值。这个变量 @code{oldbuf} 用于跟踪你正在操作的缓冲区，并从中复制。

varlist 的元素或元素组被一对括号括起，以便 Lisp 解释器能够区分 varlist 和 @code{let} 的体部分。因此，varlist 中的两元素列表被一对括号包围。这一行看起来像这样：

@smallexample
@group
(let ((oldbuf (current-buffer)))
  @dots{} )
@end group
@end smallexample

@noindent
在 @code{oldbuf} 之前的两个括号可能会让你感到惊讶，如果你没有意识到 @code{oldbuf} 之前的第一个括号标记了 varlist 的边界，而第二个括号标记了两元素列表 @code{(oldbuf (current-buffer))} 的开始。

@node append save-excursion
@subsection @code{save-excursion} 在 @code{append-to-buffer} 中的应用

在 @code{append-to-buffer} 中的 @code{let} 表达式的主体由一个 @code{save-excursion} 表达式组成。

@code{save-excursion} 函数保存 point 的位置，并在 @code{save-excursion} 主体表达式执行完成后将其恢复到该位置。此外，@code{save-excursion} 还跟踪原始缓冲区并将其恢复，这就是在 @code{append-to-buffer} 中使用 @code{save-excursion} 的方式。

@need 1500
@cindex 缩进用于格式化
@cindex 格式化约定
顺便提一下，值得注意的是，Lisp 函数通常格式化为多行展开的形式，其中所有被包裹在多行展开的内容都比第一个符号缩进得更多。在这个函数定义中，@code{let} 的缩进比 @code{defun} 大，而 @code{save-excursion} 的缩进比 @code{let} 大，就像这样：

@smallexample
@group
(defun @dots{}
  @dots{}
  @dots{}
  (let@dots{}
    (save-excursion
      @dots{}
@end group
@end smallexample

@need 1500
@noindent
这种格式约定使得很容易看到 @code{save-excursion} 主体中的行是由与 @code{save-excursion} 相关的括号括起来的，就像 @code{save-excursion} 本身由与 @code{let} 相关的括号括起来一样：

@smallexample
@group
(let ((oldbuf (current-buffer)))
  (save-excursion
    @dots{}
    (set-buffer @dots{})
    (insert-buffer-substring oldbuf start end)
    @dots{}))
@end group
@end smallexample

@need 1200
使用 @code{save-excursion} 函数的方式可以看作是填充模板的过程：

@smallexample
@group
(save-excursion
  @var{主体中的第一个表达式}
  @var{主体中的第二个表达式}
   @dots{}
  @var{主体中的最后一个表达式})
@end group
@end smallexample

@need 1200
@noindent
@anchor{let* introduced}
@findex let*
在这个函数中，@code{save-excursion} 的主体只包含一个表达式，即 @code{let*} 表达式。你已经了解了 @code{let} 函数，而 @code{let*} 函数则不同。它允许 Emacs 按顺序设置 varlist 中的每个变量，依次设置在 varlist 较早部分设置的变量的值，以便 varlist 较后部分的变量可以使用 varlist 较早部分设置的值。

观察 @code{append-to-buffer} 中的 @code{let*} 表达式：

@smallexample
@group
(let* ((append-to (get-buffer-create buffer))
       (windows (get-buffer-window-list append-to t t))
       point)
  BODY...)
@end group
@end smallexample

@noindent
我们可以看到，@code{append-to} 被绑定到由 @w{@code{(get-buffer-create buffer)}} 返回的值上。在下一行，@code{append-to} 作为参数传递给了 @code{get-buffer-window-list}；这在 @code{let} 表达式中是不可能的。注意，@code{point} 被自动绑定为 @code{nil}，就像在 @code{let} 语句中一样。

现在让我们专注于 @code{let*} 表达式的主体中的 @code{set-buffer} 和 @code{insert-buffer-substring} 函数。

@need 1250
在旧版本中，@code{set-buffer} 表达式是简单的

@smallexample
(set-buffer (get-buffer-create buffer))
@end smallexample

@need 1250
@noindent
但现在它是

@smallexample
(set-buffer append-to)
@end smallexample

@noindent
这是因为 @code{append-to} 在 @code{let*} 表达式中先绑定到了 @code{(get-buffer-create buffer)} 的值上。

@code{append-to-buffer} 函数定义将文本从当前缓冲区插入到一个命名的缓冲区中。巧合的是，@code{insert-buffer-substring} 恰好相反——它从另一个缓冲区复制文本到当前缓冲区——这就是为什么 @code{append-to-buffer} 定义以一个 @code{let} 开始的原因，该 @code{let} 将本地符号 @code{oldbuf} 绑定到在执行 @code{append-to-buffer} 命令时的 @code{current-buffer} 的值上。

@need 1250
@code{insert-buffer-substring} 表达式看起来像这样：

@smallexample
(insert-buffer-substring oldbuf start end)
@end smallexample

@noindent
@code{insert-buffer-substring} 函数将一个字符串从其第一个参数指定的缓冲区中复制并插入到当前缓冲区。在这种情况下，@code{insert-buffer-substring} 的参数是由 @code{let} 创建并绑定的变量的值，即 @code{oldbuf} 的值，这是在给出 @code{append-to-buffer} 命令时的当前缓冲区。

在 @code{insert-buffer-substring} 完成其工作后，@code{save-excursion} 将恢复操作到原始缓冲区，而 @code{append-to-buffer} 将完成其工作。

@need 800
以骨架形式编写，主体的工作看起来像这样：

@smallexample
@group
(let (@var{将-}@code{current-buffer}@var{的值绑定到-}@code{oldbuf})
  (save-excursion                       ; @r{跟踪缓冲区。}
    @var{更改缓冲区}
    @var{从-}@code{oldbuf}@var{中插入子串到缓冲区})

  @var{完成时切换回原始缓冲区}
  @var{完成时使-}@code{oldbuf}@var{的局部含义消失}
@end group
@end smallexample

总之，@code{append-to-buffer} 的工作方式如下：它保存了当前缓冲区的值在名为 @code{oldbuf} 的变量中。它获取新的缓冲区（如果需要，创建一个），并将 Emacs 的注意力切换到它。使用 @code{oldbuf} 的值，它将来自旧缓冲区的文本区域插入新缓冲区；然后使用 @code{save-excursion}，它将你带回原始缓冲区。

通过查看 @code{append-to-buffer}，你已经探索了一个相当复杂的函数。它展示了如何使用 @code{let}、@code{save-excursion} 以及如何在不同缓冲区之间切换和返回的方法。许多函数定义都以这种方式使用 @code{let}、@code{save-excursion} 和 @code{set-buffer}。

@node 缓冲区相关复习
@section 复习

这里是本章讨论的各种函数的简要总结。

@table @code
@item describe-function
@itemx describe-variable
打印函数或变量的文档。通常绑定到 @kbd{C-h f} 和 @kbd{C-h v}。

@item xref-find-definitions
查找包含函数或变量源代码的文件，并切换到该文件，将光标定位在该项的开头。通常绑定到 @kbd{M-.}（这是在 @key{META} 键后面加上句点）。

@item save-excursion
保存光标位置，并在评估 @code{save-excursion} 参数后还原其值。还记住当前缓冲区并返回到它。

@item push-mark
在某个位置设置标记，并记录标记环上前一个标记的值。标记是缓冲区中的一个位置，即使在缓冲区中添加或删除文本，它也会保持相对位置。

@item goto-char
将光标设置为由参数的值指定的位置，该参数可以是数字、标记或返回位置数字的表达式，例如 @code{(point-min)}。

@item insert-buffer-substring
从作为参数传递给函数的缓冲区中复制文本区域，并将该区域插入到当前缓冲区中。

@item mark-whole-buffer
将整个缓冲区标记为一个区域。通常绑定到 @kbd{C-x h}。

@item let*
声明一个变量列表并为它们赋初始值；然后评估 @code{let*} 体中的其余表达式。变量的值可以用来绑定列表中随后的变量。

@item set-buffer
将Emacs的注意力切换到另一个缓冲区，但不更改显示的窗口。在程序而不是人类要在不同的缓冲区上工作时使用。

@item get-buffer-create
@itemx get-buffer
查找命名的缓冲区，如果不存在该名称的缓冲区，则创建一个。如果命名的缓冲区不存在，@code{get-buffer} 函数返回 @code{nil}。
@end table

@need 1500
@node 缓冲区练习
@section 练习

@itemize @bullet
@item
编写自己的 @code{simplified-end-of-buffer} 函数定义；然后测试它是否有效。

@item
使用 @code{if} 和 @code{get-buffer} 编写一个函数，该函数打印一条消息，告诉您缓冲区是否存在。

@item
使用 @code{xref-find-definitions} 查找 @code{copy-to-buffer} 函数的源代码。
@end itemize

@node 复杂一些
@chapter 几个更复杂的函数

在这一章中，我们在前几章学到的基础上，深入研究更复杂的函数。@code{copy-to-buffer} 函数演示了在一个定义中使用两个 @code{save-excursion} 表达式，而 @code{insert-buffer} 函数则演示了在 @code{interactive} 表达式中使用星号、使用 @code{or}，以及名称和名称引用的对象之间的重要区别。

@menu
* copy-to-buffer::              使用 @code{set-buffer}、@code{get-buffer-create}。
* insert-buffer::               只读，并带有 @code{or}。
* beginning-of-buffer::         展示了 @code{goto-char}、@code{point-min} 和 @code{push-mark}。
* 第二缓冲区相关回顾::
* 可选练习::
@end menu

@node copy-to-buffer
@section 函数 @code{copy-to-buffer} 的定义
@findex copy-to-buffer

在理解了 @code{append-to-buffer} 的工作原理后，很容易理解 @code{copy-to-buffer}。这个函数将文本复制到一个缓冲区，但与其向第二个缓冲区添加文本不同，它替换了第二个缓冲区中的所有先前文本。

@need 800
@code{copy-to-buffer} 的主体如下，

@smallexample
@group
@dots{}
(interactive "BCopy to buffer: \nr")
(let ((oldbuf (current-buffer)))
  (with-current-buffer (get-buffer-create buffer)
    (barf-if-buffer-read-only)
    (erase-buffer)
    (save-excursion
      (insert-buffer-substring oldbuf start end)))))
@end group
@end smallexample

与 @code{append-to-buffer} 不同，@code{copy-to-buffer} 函数的交互表达式更简单。

@need 800
接下来的定义如下

@smallexample
(with-current-buffer (get-buffer-create buffer) @dots{}
@end smallexample

首先，看最内部的表达式；它首先被评估。该表达式以 @code{get-buffer-create buffer} 开头。该函数告诉计算机使用指定为要复制到的缓冲区的名称，或者如果不存在这样的缓冲区，则创建它。然后，@code{with-current-buffer} 函数使用该缓冲区临时作为当前缓冲区来评估其主体。

（这展示了另一种改变计算机注意力但不改变用户注意力的方法。@code{append-to-buffer} 函数展示了如何使用 @code{save-excursion} 和 @code{set-buffer} 来实现相同的效果。@code{with-current-buffer} 是一种较新、可能更简单的机制。）

@code{barf-if-buffer-read-only} 函数在您无法修改缓冲区时发送错误消息，指示该缓冲区为只读。

接下来的一行只包含 @code{erase-buffer} 函数。该函数擦除缓冲区。

最后，最后两行包含 @code{save-excursion} 表达式，其主体是 @code{insert-buffer-substring}。@code{insert-buffer-substring} 表达式将文本从当前缓冲区复制到另一个缓冲区（您并没有看到计算机改变其注意力，因此您不知道该缓冲区现在被称为 @code{oldbuf}）。

顺便说一下，这就是“替换”的含义。为了替换文本，Emacs 先擦除先前的文本，然后插入新文本。

@need 1250
大致上，@code{copy-to-buffer} 的主体如下：

@smallexample
@group
(let (@var{bind-}@code{oldbuf}@var{-to-value-of-}@code{current-buffer})
    (@var{with-the-buffer-you-are-copying-to}
      (@var{but-do-not-erase-or-copy-to-a-read-only-buffer})
      (erase-buffer)
      (save-excursion
        @var{insert-substring-from-}@code{oldbuf}@var{-into-buffer})))
@end group
@end smallexample

@node insert-buffer
@section 函数 @code{insert-buffer} 的定义
@findex insert-buffer

@code{insert-buffer} 是另一个与缓冲区相关的函数。该命令将另一个缓冲区的内容@emph{插入}到当前缓冲区中。它是 @code{append-to-buffer} 或 @code{copy-to-buffer} 的反向操作，因为它们将文本区域从当前缓冲区@emph{复制到}另一个缓冲区。

以下讨论基于原始代码。该代码在2003年进行了简化，变得更难理解。

(@xref{New insert-buffer, , @code{insert-buffer} 的新主体}, 以查看新主体的讨论。)

此外，这段代码说明了与可能是@dfn{只读}的缓冲区一起使用@code{interactive}的用法，以及对象名称与实际引用的对象之间的重要区别。

@menu
* insert-buffer code::
* insert-buffer interactive::   当您能读取但无法写入时。
* insert-buffer body::          主体包含一个 @code{or} 和一个 @code{let}。
* if & or::                     使用 @code{if} 而不是 @code{or}。
* Insert or::                   @code{or} 表达式的工作原理。
* Insert let::                  两个 @code{save-excursion} 表达式。
* New insert-buffer::
@end menu

@ifnottex
@node insert-buffer code
@unnumberedsubsec @code{insert-buffer} 的代码
@end ifnottex

@need 800
以下是早期的代码：

@smallexample
@group
(defun insert-buffer (buffer)
  "在点之后插入缓冲区的内容。
在插入的文本之后设置标记。
BUFFER 可以是缓冲区或缓冲区名称。"
  (interactive "*bInsert buffer:@: ")
@end group
@group
  (or (bufferp buffer)
      (setq buffer (get-buffer buffer)))
  (let (start end newmark)
    (save-excursion
      (save-excursion
        (set-buffer buffer)
        (setq start (point-min) end (point-max)))
@end group
@group
      (insert-buffer-substring buffer start end)
      (setq newmark (point)))
    (push-mark newmark)))
@end group
@end smallexample

@need 1200
与其他函数定义一样，您可以使用模板查看函数的轮廓：

@smallexample
@group
(defun insert-buffer (buffer)
  "@var{documentation}@dots{}"
  (interactive "*bInsert buffer:@: ")
  @var{body}@dots{})
@end group
@end smallexample

@node insert-buffer interactive
@subsection @code{insert-buffer} 函数中的交互表达式
@findex interactive@r{, 用法示例}

在 @code{insert-buffer} 中，@code{interactive} 声明的参数有两部分，一个星号 @samp{*} 和 @samp{bInsert buffer:@: }。

@menu
* 只读缓冲区::            当缓冲区无法修改时。
* b 用于交互::             存在的缓冲区或其名称。
@end menu

@node 只读缓冲区
@unnumberedsubsubsec 只读缓冲区
@cindex 只读缓冲区
@cindex 用于只读缓冲区的星号
@findex * @r{用于只读缓冲区}

星号用于当前缓冲区为只读缓冲区的情况---无法修改的缓冲区。如果在当前缓冲区为只读时调用 @code{insert-buffer}，将在回显区打印相应的消息，并且终端可能会发出哔声或闪烁；您将无法将任何内容插入当前缓冲区。星号后无需加换行符以将其与下一个参数分隔开。

@node b 用于交互
@unnumberedsubsubsec 交互表达式中的 @samp{b}

交互表达式中的下一个参数以小写 @samp{b} 开头。 （这与 @code{append-to-buffer} 的代码不同，后者使用大写 @samp{B}。@xref{append-to-buffer, , @code{append-to-buffer} 的定义}。）小写 @samp{b} 表示 Lisp 解释器应该将 @code{insert-buffer} 的参数绑定到一个现有缓冲区，否则应该绑定到其名称。Emacs 将提示您输入缓冲区的名称，并提供默认缓冲区，并启用名称补全。如果缓冲区不存在，您将收到消息“没有匹配”；终端也可能会哔哔作响。

新的简化代码生成了 @code{interactive} 的列表。它使用我们已经熟悉的 @code{barf-if-buffer-read-only} 和 @code{read-buffer} 函数以及我们尚不熟悉的 @code{progn} 特殊形式（稍后将进行描述）。

@node insert-buffer body
@subsection @code{insert-buffer} 函数的主体

@code{insert-buffer} 函数的主体有两个主要部分：一个 @code{or} 表达式和一个 @code{let} 表达式。 @code{or} 表达式的目的是确保参数 @code{buffer} 绑定到一个缓冲区，而不仅仅是缓冲区的名称。 @code{let} 表达式的主体包含将另一个缓冲区复制到当前缓冲区的代码。

@need 1250
简而言之，这两个表达式适合于 @code{insert-buffer} 函数，如下所示：

@smallexample
@group
(defun insert-buffer (buffer)
  "@var{documentation}@dots{}"
  (interactive "*bInsert buffer:@: ")
  (or @dots{}
      @dots{}
@end group
@group
  (let (@var{varlist})
      @var{body-of-}@code{let}@dots{} )
@end group
@end smallexample

要理解 @code{or} 表达式如何确保参数 @code{buffer} 绑定到一个缓冲区而不是缓冲区的名称，首先需要了解 @code{or} 函数。

在这之前，让我使用 @code{if} 重新编写此函数的一部分，以便您可以以熟悉的方式看到所做的事情。

@node if & or
@subsection 使用 @code{if} 替代 @code{or} 的 @code{insert-buffer}

要完成的任务是确保 @code{buffer} 的值是一个缓冲区本身，而不是缓冲区的名称。如果值是名称，则必须获取缓冲区本身。

你可以想象自己在一个会议上，一个引座员正拿着一张带有你的名字的名单四处寻找你：引座员与你的名字绑定，而不是与你绑定；但当引座员找到你并搀扶你的手臂时，引座员就与你绑定了。

@need 800
在 Lisp 中，你可以这样描述这种情况：

@smallexample
@group
(if (not (holding-on-to-guest))
    (find-and-take-arm-of-guest))
@end group
@end smallexample

我们想要使用缓冲区做同样的事情——如果我们没有缓冲区本身，我们就希望获取它。

@need 1200
使用一个叫做 @code{bufferp} 的谓词，它告诉我们是否有一个缓冲区（而不是它的名称），我们可以这样编写代码：

@smallexample
@group
(if (not (bufferp buffer))              ; @r{if-部分}
    (setq buffer (get-buffer buffer)))  ; @r{then-部分}
@end group
@end smallexample

@noindent
这里，@code{if} 表达式的真假测试是 @w{@code{(not (bufferp buffer))}}；然后部分是表达式 @w{@code{(setq buffer (get-buffer buffer))}}。

在测试中，函数 @code{bufferp} 如果其参数是一个缓冲区，则返回 true——但如果其参数是缓冲区的名称，则返回 false。 （函数名 @code{bufferp} 的最后一个字符是字符 @samp{p}；正如我们前面看到的，@samp{p} 的这种用法是一个约定，表示该函数是一个谓词，这是一个术语，表示该函数将确定某个属性是真还是假。@xref{错误类型的参数, , 使用错误类型的对象作为参数}.)

@need 1200
函数 @code{not} 位于表达式 @code{(bufferp buffer)} 之前，因此真假测试看起来像这样：

@smallexample
(not (bufferp buffer))
@end smallexample

@noindent
@code{not} 是一个函数，如果其参数为 false，则返回 true；如果其参数为 true，则返回 false。因此，如果 @code{(bufferp buffer)} 返回 true，则 @code{not} 表达式返回 false，反之亦然。

使用这个测试，@code{if} 表达式的工作方式如下：当变量 @code{buffer} 的值实际上是一个缓冲区而不是其名称时，真假测试返回 false，@code{if} 表达式不会评估 then-部分。这是可以的，因为如果它确实是一个缓冲区，我们就不需要对变量 @code{buffer} 做任何操作。

另一方面，当 @code{buffer} 的值不是一个缓冲区本身，而是缓冲区的名称时，真假测试返回 true，并且评估表达式的 then-部分。在这种情况下，then-部分是 @code{(setq buffer (get-buffer buffer))}。该表达式使用 @code{get-buffer} 函数通过名称返回实际的缓冲区本身。然后，@code{setq} 将变量 @code{buffer} 设置为缓冲区本身的值，替换其先前的值（该值是缓冲区的名称）。

@node Insert or
@subsection @code{insert-buffer} 中的 @code{or} 表达式

@code{insert-buffer} 函数中 @code{or} 表达式的目的是确保参数 @code{buffer} 绑定到一个缓冲区，而不仅仅是缓冲区的名称。前一节展示了如何使用 @code{if} 表达式完成此任务。然而，@code{insert-buffer} 函数实际上使用了 @code{or}。要理解这一点，有必要了解 @code{or} 的工作原理。

@findex or
一个 @code{or} 函数可以有任意数量的参数。它依次评估每个参数，并返回其参数中第一个不是 @code{nil} 的值。此外，这是 @code{or} 的一个关键特性，即在返回第一个非 @code{nil} 值后，它不再评估任何后续参数。

@need 800
@code{or} 表达式如下：

@smallexample
@group
(or (bufferp buffer)
    (setq buffer (get-buffer buffer)))
@end group
@end smallexample

@noindent
@code{or} 的第一个参数是表达式 @code{(bufferp buffer)}。如果缓冲区实际上是一个缓冲区而不仅仅是缓冲区的名称，则此表达式返回 true（一个非 @code{nil} 值）。在 @code{or} 表达式中，如果是这种情况，@code{or} 表达式返回这个 true 值，并且不评估下一个表达式——这对我们来说是可以的，因为如果它确实是一个缓冲区，我们就不希望对 @code{buffer} 的值做任何操作。

另一方面，如果 @code{(bufferp buffer)} 的值是 @code{nil}，那么如果 @code{buffer} 的值是缓冲区的名称，Lisp 解释器将评估 @code{or} 表达式的下一个元素。这是表达式 @code{(setq buffer (get-buffer buffer))}。此表达式返回一个非 @code{nil} 值，这是它设置变量 @code{buffer} 的值——并且这个值是缓冲区本身，而不是缓冲区的名称。

所有这些的结果是，符号 @code{buffer} 总是绑定到缓冲区本身而不是缓冲区的名称。所有这些是必要的，因为后面的一行中的 @code{set-buffer} 函数只能与缓冲区本身一起使用，而不能与缓冲区的名称一起使用。

@need 1250
顺便说一下，使用 @code{or}，引座员的情况可以写成这样：

@smallexample
(or (holding-on-to-guest) (find-and-take-arm-of-guest))
@end smallexample

@node Insert let
@subsection @code{insert-buffer} 中的 @code{let} 表达式

在确保变量 @code{buffer} 引用的是缓冲区本身而不仅仅是缓冲区的名称后，@code{insert-buffer} 函数继续使用 @code{let} 表达式。这个表达式指定了三个局部变量 @code{start}、@code{end} 和 @code{newmark}，并将它们绑定到初始值 @code{nil}。这些变量在 @code{let} 的其余部分中被使用，并在 @code{let} 结束之前暂时隐藏了任何同名变量的其他出现。

@need 1200
@code{let} 的主体包含两个 @code{save-excursion} 表达式。首先，我们将详细查看内部 @code{save-excursion} 表达式。表达式如下：

@smallexample
@group
(save-excursion
  (set-buffer buffer)
  (setq start (point-min) end (point-max)))
@end group
@end smallexample

@noindent
表达式 @code{(set-buffer buffer)} 将 Emacs 的注意力从当前缓冲区切换到将要复制文本的缓冲区。在该缓冲区中，使用命令 @code{point-min} 和 @code{point-max} 将变量 @code{start} 和 @code{end} 设置为缓冲区的开始和结束。请注意，这里演示了 @code{setq} 如何能够在同一个表达式中设置两个变量。@code{setq} 的第一个参数设置为其第二个参数的值，其第三个参数设置为其第四个参数的值。

在内部 @code{save-excursion} 的主体被评估之后，@code{save-excursion} 会恢复原始缓冲区，但是 @code{start} 和 @code{end} 仍然设置为将要复制文本的缓冲区的开始和结束的值。

@need 1250
外部 @code{save-excursion} 表达式如下：

@smallexample
@group
(save-excursion
  (@var{inner-}@code{save-excursion}@var{-expression}
     (@var{go-to-new-buffer-and-set-}@code{start}@var{-and-}@code{end})
  (insert-buffer-substring buffer start end)
  (setq newmark (point)))
@end group
@end smallexample

@noindent
@code{insert-buffer-substring} 函数将文本从 @code{buffer} 中的 @code{start} 和 @code{end} 位置插入到当前缓冲区中。由于第二个缓冲区的整体位于 @code{start} 和 @code{end} 之间，第二个缓冲区的整体被复制到你正在编辑的缓冲区中。接下来，点的值，它将位于插入文本的末尾，被记录在变量 @code{newmark} 中。

在外部 @code{save-excursion} 的主体被评估之后，点被重新定位到其原始位置。

然而，方便的是在新插入的文本的末尾放置一个标记，并将点定位在其开头。@code{newmark} 变量记录了插入文本的末尾。在 @code{let} 表达式的最后一行中，@code{(push-mark newmark)} 表达式函数将标记设置为此位置。（标记的先前位置仍然可访问；它记录在标记环上，你可以使用 @kbd{C-u C-@key{SPC}} 返回到它。）与此同时，点位于插入文本的开头，这是你调用插入函数之前的位置，该位置由第一个 @code{save-excursion} 保存。

@need 1250
整个 @code{let} 表达式如下：

@smallexample
@group
(let (start end newmark)
  (save-excursion
    (save-excursion
      (set-buffer buffer)
      (setq start (point-min) end (point-max)))
    (insert-buffer-substring buffer start end)
    (setq newmark (point)))
  (push-mark newmark))
@end group
@end smallexample

与 @code{append-to-buffer} 函数一样，@code{insert-buffer} 函数使用了 @code{let}、@code{save-excursion} 和 @code{set-buffer}。此外，该函数演示了使用 @code{or} 的一种方式。所有这些函数都是我们将一遍又一遍找到并使用的构建块。

@node New insert-buffer
@subsection @code{insert-buffer} 的新主体
@findex insert-buffer@r{, 新版本主体}
@cindex @code{insert-buffer} 的新版本主体

GNU Emacs 22 版本中的主体比原始版本更令人困惑。

@need 1250
它包含两个表达式，

@smallexample
@group
  (push-mark
   (save-excursion
     (insert-buffer-substring (get-buffer buffer))
     (point)))

   nil
@end group
@end smallexample

@noindent
除外，这是使初学者困惑的地方，@code{push-mark} 表达式内部执行了非常重要的工作。

@code{get-buffer} 函数返回一个以提供的名称命名的缓冲区。请注意，该函数并@emph{不}被称为 @code{get-buffer-create}；如果不存在缓冲区，则不会创建一个。由 @code{get-buffer} 返回的缓冲区（已存在的缓冲区）被传递给 @code{insert-buffer-substring}，该函数插入整个缓冲区（因为您没有指定其他内容）。

@code{push-mark} 记录插入缓冲区的位置。然后，该函数返回 @code{nil}，即其最后一条命令的值。换句话说，@code{insert-buffer} 函数仅用于产生副作用，即插入另一个缓冲区，而不是返回任何值。

@node beginning-of-buffer
@section @code{beginning-of-buffer} 函数的完整定义
@findex beginning-of-buffer

@code{beginning-of-buffer} 函数的基本结构已经讨论过了。(@xref{simplified-beginning-of-buffer, , 一个简化的 @code{beginning-of-buffer} 定义}.) 本节描述了定义的复杂部分。

如前所述，当没有参数调用时，@code{beginning-of-buffer} 将光标移动到缓冲区的开头（实际上是可访问部分的开头），并将标记留在先前的位置。然而，当以介于一到十之间的数字调用该命令时，该函数将该数字视为缓冲区长度的十分之一，Emacs 将光标移动到缓冲区的该部分。因此，您可以使用键命令 @kbd{M-<} 调用该函数，将光标移动到缓冲区的开头，或者使用键命令，例如 @kbd{C-u 7 M-<}，将光标移动到缓冲区的70％处。如果使用大于十的数字作为参数，则光标将移动到缓冲区的末尾。

@code{beginning-of-buffer} 函数可以带有或不带有参数调用。使用参数是可选的。

@menu
* Optional Arguments::
* beginning-of-buffer opt arg::  带有可选参数的示例。
* beginning-of-buffer complete::
@end menu

@node Optional Arguments
@subsection 可选参数

除非另有说明，Lisp 期望具有函数定义中参数的函数在调用时将为该参数传递一个值。如果没有这样做，将出现错误并显示消息 @samp{Wrong number of arguments}。

@cindex 可选参数
@cindex 关键字
@findex optional
然而，可选参数是Lisp的一个特性：使用特定的@dfn{关键字}告诉Lisp解释器该参数是可选的。关键字是 @code{&optional}。 （@samp{&} 在 @samp{optional} 前面是关键字的一部分。）在函数定义中，如果一个参数跟在关键字 @code{&optional} 后面，那么在调用函数时无需传递值给该参数。

@need 1200
因此，@code{beginning-of-buffer} 函数的函数定义的第一行看起来像这样：

@smallexample
(defun beginning-of-buffer (&optional arg)
@end smallexample

@need 1250
概括而言，整个函数看起来像这样：

@smallexample
@group
(defun beginning-of-buffer (&optional arg)
  "@var{documentation}@dots{}"
  (interactive "P")
  (or (@var{is-the-argument-a-cons-cell} arg)
      (and @var{are-both-transient-mark-mode-and-mark-active-true})
      (push-mark))
  (let (@var{determine-size-and-set-it})
  (goto-char
    (@var{if-there-is-an-argument}
        @var{figure-out-where-to-go}
      @var{else-go-to}
      (point-min))))
   @var{do-nicety}
@end group
@end smallexample

该函数类似于 @code{simplified-beginning-of-buffer} 函数，只是 @code{interactive} 表达式的参数是 @code{"P"}，并且 @code{goto-char} 函数后面跟着一个 if-then-else 表达式，用于确定如果有一个不是 cons cell 的参数，光标应该放在哪里。

（由于我在很多章节里都没有解释 cons cell，请考虑忽略函数 @code{consp}。@xref{列表实现, , 如何实现列表}，以及 @ref{Cons Cell Type, , Cons Cell and List Types, elisp, The GNU Emacs Lisp Reference Manual}。）

@code{interactive} 表达式中的 @code{"P"} 告诉 Emacs 将前缀参数（如果有的话）以原始形式传递给函数。前缀参数是通过按 @key{META} 键后面跟一个数字，或者按 @kbd{C-u} 然后是一个数字来生成的。（如果不输入数字，@kbd{C-u} 默认为带有 4 的 cons cell。在 @code{interactive} 表达式中的小写 @code{"p"} 会导致函数将前缀参数转换为数字。）

@code{if} 表达式的真值测试看起来复杂，但实际上并不复杂：它检查 @code{arg} 是否具有非 @code{nil} 的值，以及它是否是 cons cell。 （这就是 @code{consp} 做的事情；它检查其参数是否为 cons cell。）如果 @code{arg} 具有非 @code{nil} 的值（并且不是 cons cell），这个真值测试将返回 true，并且 @code{if} 表达式的 then-部分将被评估。另一方面，如果 @code{beginning-of-buffer} 没有带参数调用，@code{arg} 的值将为 @code{nil}，并且 @code{if} 表达式的 else-部分将被评估。else-部分就是 @code{point-min}，当这是结果时，整个 @code{goto-char} 表达式是 @code{(goto-char (point-min))}，这就是我们在简化形式中看到的 @code{beginning-of-buffer} 函数。

@node beginning-of-buffer opt arg
@subsection @code{beginning-of-buffer} with an Argument

当使用参数调用@code{beginning-of-buffer}时，将计算一个表达式来确定传递给@code{goto-char}的值。这个表达式乍一看相当复杂。它包括一个内部的@code{if}表达式和许多算术运算。具体如下：

@smallexample
@group
(if (> (buffer-size) 10000)
    ;; @r{避免大缓冲区大小溢出！}
                          (* (prefix-numeric-value arg)
                             (/ size 10))
  (/
   (+ 10
      (*
       size (prefix-numeric-value arg))) 10)))
@end group
@end smallexample

@menu
* Disentangle beginning-of-buffer::
* Large buffer case::
* Small buffer case::
@end menu

@ifnottex
@node Disentangle beginning-of-buffer
@unnumberedsubsubsec Disentangle @code{beginning-of-buffer}
@end ifnottex

与其他复杂的表达式一样，@code{beginning-of-buffer}中的条件表达式可以通过将其视为模板的一部分（在这种情况下，是if-then-else表达式的模板）来解开。在骨架形式中，该表达式如下：

@smallexample
@group
(if (@var{buffer-is-large}
    @var{divide-buffer-size-by-10-and-multiply-by-arg}
  @var{else-use-alternate-calculation}
@end group
@end smallexample

这个内部的@code{if}表达式的真值或假值测试检查缓冲区的大小。这样做的原因是，旧版本的Emacs使用的数字不超过八百万左右，在随后的计算中，程序员担心如果缓冲区很大，Emacs可能会尝试使用过大的数字。注释中提到的术语“溢出”意味着数字过大。更近期的Emacs版本使用更大的数字，但由于人们现在查看的缓冲区远远大于以往，这段代码没有被更改。

有两种情况：如果缓冲区很大，如果不大。

@node Large buffer case
@unnumberedsubsubsec 在大缓冲区中发生了什么

在@code{beginning-of-buffer}中，内部的@code{if}表达式测试缓冲区的大小是否大于10,000个字符。为了做到这一点，它使用了@code{>}函数和来自let表达式的@code{size}计算。

在旧版本中，使用了@code{buffer-size}函数。不仅调用了该函数多次，而且它给出的是整个缓冲区的大小，而不是可访问部分的大小。当只处理可访问部分时，计算会更有意义。关于将注意力集中到可访问部分的更多信息，请参阅《缩小和扩大》。

@need 800
这一行看起来像这样：

@smallexample
(if (> size 10000)
@end smallexample

@need 1200
@noindent
当缓冲区很大时，@code{if}表达式的then部分将被评估。它读起来像这样（格式化以便阅读）：

@smallexample
@group
(*
  (prefix-numeric-value arg)
  (/ size 10))
@end group
@end smallexample

@noindent
这个表达式是一个乘法，具有@code{*}函数的两个参数。

第一个参数是@code{(prefix-numeric-value arg)}。当@code{interactive}的参数为@code{"P"}时，传递给函数的参数是一个@dfn{原始前缀参数}，而不是一个数字（它是一个列表中的数字）。为了进行算术运算，需要进行转换，@code{prefix-numeric-value}完成了这个任务。

@findex / @r{(division)}
@cindex Division
第二个参数是@code{(/ size 10)}。这个表达式将数值除以十---可访问部分缓冲区大小的数值。这产生一个数字，告诉我们十分之一缓冲区大小由多少字符组成。在Lisp中，@code{/}用于除法，就像@code{*}用于乘法一样。

@need 1200
在整个乘法表达式中，这个数量被乘以前缀参数的值---乘法看起来像这样：

@smallexample
@group
(* @var{numeric-value-of-prefix-arg}
   @var{number-of-characters-in-one-tenth-of-the-accessible-buffer})
@end group
@end smallexample

@noindent
例如，如果前缀参数是@samp{7}，那么十分之一的值将乘以7，以给出在缓冲区大小的70%的位置。

@need 1200
所有这些的结果是，如果可访问部分的缓冲区很大，那么@code{goto-char}表达式将如下：

@smallexample
@group
(goto-char (* (prefix-numeric-value arg)
              (/ size 10)))
@end group
@end smallexample

这把光标放在我们想要的位置。

@node 小缓冲区情况
@unnumberedsubsubsec 小缓冲区中的情况

如果缓冲区包含的字符少于10,000个，将执行略有不同的计算。你可能认为这是不必要的，因为第一种计算方法可以完成工作。然而，在小缓冲区中，第一种方法可能无法将光标精确放置在所需的行上；而第二种方法效果更好。

@need 800
以下是代码：

@c 请将此内容放在一行上。
@smallexample
(/ (+ 10 (* size (prefix-numeric-value arg))) 10))
@end smallexample

@need 1200
@noindent
这是一段代码，你可以通过发现函数嵌套在括号中的方式来理解它的运行。如果每个表达式都比其封闭表达式缩进得更深，那么代码会更容易阅读：

@smallexample
@group
  (/
   (+ 10
      (*
       size
       (prefix-numeric-value arg)))
   10))
@end group
@end smallexample

@need 1200
@noindent
通过查看括号，我们可以看到最内层的操作是@code{(prefix-numeric-value arg)}，它将原始参数转换为数字。在下面的表达式中，这个数字被乘以缓冲区的可访问部分的大小：

@smallexample
(* size (prefix-numeric-value arg))
@end smallexample

@noindent
这个乘法会产生一个可能比缓冲区的大小更大的数字——例如，如果参数是7，那么这个数字会大七倍。然后，这个数字加上10，最终将这个大数字除以10，得到的值比缓冲区中的百分比位置多一个字符。

所有这些计算得到的数字被传递给@code{goto-char}，并将光标移动到该位置。

@need 1500
@node beginning-of-buffer complete
@subsection 完整的@code{beginning-of-buffer}

@need 1000
下面是@code{beginning-of-buffer}函数的完整文本：
@sp 1

@c 在GNU Emacs 22中
@smallexample
@group
(defun beginning-of-buffer (&optional arg)
  "将点移到缓冲区的开头；在先前位置留下标记。
使用 \\[universal-argument] 前缀时，不在先前位置设置标记。
使用数值参数 N 时，将点设置为从开头开始的 N/10 处。

如果缩小了缓冲区，
此命令使用缓冲区的可访问部分的开头和大小。
@end group

@group
不要在Lisp程序中使用这个命令！
\(goto-char (point-min))更快
且不会破坏标记。"
  (interactive "P")
  (or (consp arg)
      (and transient-mark-mode mark-active)
      (push-mark))
@end group
@group
  (let ((size (- (point-max) (point-min))))
    (goto-char (if (and arg (not (consp arg)))
                   (+ (point-min)
                      (if (> size 10000)
                          ;; 避免大缓冲区大小的溢出！
                          (* (prefix-numeric-value arg)
                             (/ size 10))
                        (/ (+ 10 (* size (prefix-numeric-value arg)))
                           10)))
                 (point-min))))
  (if (and arg (not (consp arg))) (forward-line 1)))
@end group
@end smallexample

@ignore
从GNU Emacs 22之前
@smallexample
@group
(defun beginning-of-buffer (&optional arg)
  "将点移到缓冲区的开头；在先前位置留下标记。
如果有参数 N，则将点设置为从真正开头开始的 N/10 处。
@end group
@group
不要在Lisp程序中使用这个！
\(goto-char (point-min))更快
且不会设置标记。"
  (interactive "P")
  (push-mark)
@end group
@group
  (goto-char
   (if arg
       (if (> (buffer-size) 10000)
           ;; @r{避免大缓冲区大小的溢出！}
           (* (prefix-numeric-value arg)
              (/ (buffer-size) 10))
@end group
@group
         (/ (+ 10 (* (buffer-size)
                     (prefix-numeric-value arg)))
            10))
     (point-min)))
  (if arg (forward-line 1)))
@end group
@end smallexample
@end ignore

@noindent
除了文档字符串中的一个细节和函数的最后一行之外，前面的讨论展示了这个函数的工作原理。

@need 800
在文档字符串中，有一个表达式的引用：

@smallexample
\\[universal-argument]
@end smallexample

@noindent
在这个表达式的第一个方括号之前使用了@samp{\\}。这个@samp{\\}告诉Lisp解释器替换当前绑定到@samp{[@dots{}]}的键。在@code{universal-argument}的情况下，通常是@kbd{C-u}，但也可能不同。有关更多信息，@xref{Documentation Tips, ,文档字符串提示, GNU Emacs Lisp参考手册}。

@need 1200
最后，@code{beginning-of-buffer}命令的最后一行指示，如果带有参数调用命令：

@smallexample
(if (and arg (not (consp arg))) (forward-line 1))
@end smallexample

@noindent
如果使用@kbd{C-u}指定命令，但没有数字，也就是说，原始前缀参数只是一个cons单元，该命令将光标放在第二行的开头。

@node 第二缓冲区相关复习
@section 复习

这里是对本章涵盖的一些主题的简要总结。

@table @code
@item or
依次评估每个参数，并返回第一个不是 @code{nil} 的参数的值；如果没有返回一个不是 @code{nil} 的值，则返回 @code{nil}。简言之，返回参数中的第一个真值；如果其中任何一个是真值，则返回真值。

@item and
依次评估每个参数，并且如果任何一个是 @code{nil}，则返回 @code{nil}；如果没有一个是 @code{nil}，则返回最后一个参数的值。简言之，只有当所有参数都为真时才返回真值；如果其中任何一个为真，则返回真值。

@item &optional
用于指示函数定义中的参数是可选的关键字；这意味着如果需要，可以在不提供参数的情况下评估函数。

@item prefix-numeric-value
将由 @code{(interactive "P")} 生成的原始前缀参数转换为数值。

@item forward-line
将点移动到下一行的开头，或者如果参数大于一，则向前移动那么多行。如果无法移动到应该移动到的位置，@code{forward-line} 将尽量向前移动，并返回无法移动的额外行数的计数。

@item erase-buffer
删除当前缓冲区的所有内容。

@item bufferp
如果其参数是缓冲区，则返回 @code{t}；否则返回 @code{nil}。
@end table

@node optional Exercise
@section @code{optional} 参数练习

编写一个交互式函数，该函数带有一个可选参数，用于测试其参数（一个数字）是否大于或等于 @code{fill-column} 的值，否则，小于该值，并通过消息告诉您结果。然而，如果您没有向函数传递参数，则使用默认值56。

@node 缩窄与扩大
@chapter 缩窄与扩大
@cindex 焦点集中（缩窄）
@cindex 缩窄
@cindex 扩大

缩窄是Emacs的一个功能，使您能够专注于缓冲区的特定部分，并且在不小心更改其他部分的情况下工作。通常情况下，缩窄是禁用的，因为它可能使初学者感到困惑。

@menu
* 缩窄的优势::              缩窄的优势
* save-restriction::        @code{save-restriction} 特殊形式。
* what-line::               光标所在行的行号。
* 缩窄练习::
@end menu

@ifnottex
@node 缩小的优势
@unnumberedsec 缩小的优势
@end ifnottex

通过缩小，缓冲区的其余部分被隐藏起来，就好像它们不存在一样。这是一个优势，例如，如果你想替换缓冲区的某个部分中的一个单词，而不影响其他部分，你可以缩小到你想要的部分，替换只在该部分进行，而不影响缓冲区的其余部分。搜索也仅在缩小的区域内工作，而不在外部，因此如果你正在修复文档的一部分，你可以通过缩小到你想要的区域来防止意外地找到不需要修复的部分。
（@code{narrow-to-region}的键绑定是@kbd{C-x n n}。）

然而，缩小会使缓冲区的其余部分变得不可见，这可能会吓到那些不小心调用缩小并认为已删除文件的一部分的人。此外，@code{undo}命令（通常绑定到@kbd{C-x u}）不会取消缩小（也不应该取消），所以如果人们不知道可以使用@code{widen}命令将缓冲区的其余部分恢复为可见状态，他们可能会变得相当绝望。
（@code{widen}的键绑定是@kbd{C-x n w}。）

缩小对Lisp解释器和人类一样有用。通常，Emacs Lisp函数被设计为仅在缓冲区的一部分上工作；或者相反，Emacs Lisp函数需要在已经缩小的整个缓冲区上工作。例如，@code{what-line}函数会在缓冲区存在缩小的情况下移除缩小，并在完成工作后将缩小恢复到原来的状态。另一方面，@code{count-lines}函数使用缩小来限制自己只在其感兴趣的缓冲区部分中运行，然后恢复到先前的情况。

@node save-restriction
@section 特殊形式 @code{save-restriction}
@findex save-restriction

在Emacs Lisp中，你可以使用特殊形式 @code{save-restriction} 来追踪当前是否存在缩小范围的情况。当Lisp解释器遇到 @code{save-restriction} 时，它会执行 @code{save-restriction} 表达式体中的代码，然后撤销代码引起的任何缩小范围的更改。例如，如果缓冲区被缩小，而跟在 @code{save-restriction} 后面的代码消除了缩小，则 @code{save-restriction} 将在之后将缓冲区恢复到缩小的区域。在 @code{what-line} 命令中，由 @code{save-restriction} 命令后立即执行的 @code{widen} 命令会撤销缓冲区可能存在的任何缩小。任何原始的缩小在函数完成之前都会被恢复。

@need 1250
@code{save-restriction} 表达式的模板很简单：

@smallexample
@group
(save-restriction
  @var{body}@dots{} )
@end group
@end smallexample

@noindent
@code{save-restriction} 的体是一个或多个将由Lisp解释器按顺序评估的表达式。

最后，需要注意的一点是：当你同时使用 @code{save-excursion} 和 @code{save-restriction}，并且它们紧跟在彼此之后时，应该将 @code{save-excursion} 放在最外层。如果你以相反的顺序编写它们，可能无法记录Emacs在调用 @code{save-excursion} 后切换到的缓冲区的缩小。因此，在一起编写时，@code{save-excursion} 和 @code{save-restriction} 应该像这样编写：

@smallexample
@group
(save-excursion
  (save-restriction
    @var{body}@dots{}))
@end group
@end smallexample

在其他情况下，当它们没有一起编写时，@code{save-excursion} 和 @code{save-restriction} 特殊形式必须按照适合函数的顺序编写。

@need 1250
例如，

@smallexample
@group
  (save-restriction
    (widen)
    (save-excursion
    @var{body}@dots{}))
@end group
@end smallexample

@ignore
Emacs 22
/usr/local/src/emacs/lisp/simple.el

(defun what-line ()
  "Print the current buffer line number and narrowed line number of point."
  (interactive)
  (let ((start (point-min))
        (n (line-number-at-pos)))
    (if (= start 1)
        (message "Line %d" n)
      (save-excursion
        (save-restriction
          (widen)
          (message "line %d (narrowed line %d)"
                   (+ n (line-number-at-pos start) -1) n))))))

(defun line-number-at-pos (&optional pos)
  "Return (narrowed) buffer line number at position POS.
If POS is nil, use current buffer location.
Counting starts at (point-min), so the value refers
to the contents of the accessible portion of the buffer."
  (let ((opoint (or pos (point))) start)
    (save-excursion
      (goto-char (point-min))
      (setq start (point))
      (goto-char opoint)
      (forward-line 0)
      (1+ (count-lines start (point))))))

(defun count-lines (start end)
  "Return number of lines between START and END.
This is usually the number of newlines between them,
but can be one more if START is not equal to END
and the greater of them is not at the start of a line."
  (save-excursion
    (save-restriction
      (narrow-to-region start end)
      (goto-char (point-min))
      (if (eq selective-display t)
          (save-match-data
            (let ((done 0))
              (while (re-search-forward "[\n\C-m]" nil t 40)
                (setq done (+ 40 done)))
              (while (re-search-forward "[\n\C-m]" nil t 1)
                (setq done (+ 1 done)))
              (goto-char (point-max))
              (if (and (/= start end)
                       (not (bolp)))
                  (1+ done)
                done)))
        (- (buffer-size) (forward-line (buffer-size)))))))
@end ignore

@node 行号
@section @code{what-line}
@findex what-line
@cindex 扩展，示例

@code{what-line}命令告诉您光标所在位置的行号。该函数演示了@code{save-restriction}和@code{save-excursion}命令的用法。以下是该函数的原始文本：

@smallexample
@group
(defun what-line ()
  "打印光标所在位置（在缓冲区中）的当前行号。"
  (interactive)
  (save-restriction
    (widen)
    (save-excursion
      (beginning-of-line)
      (message "第%d行"
               (1+ (count-lines 1 (point)))))))
@end group
@end smallexample

（在GNU Emacs的现代版本中，@code{what-line}函数已经扩展，不仅告诉您在扩展缓冲区中的行号，还告诉您在狭窄缓冲区中的行号。现代版本比这里展示的版本更复杂。如果您感到有冒险精神，可以在弄清楚此版本的工作原理后查看它。您可能需要使用@kbd{C-h f}（@code{describe-function}）。新版本使用条件判断确定缓冲区是否已经被狭窄。

此外，@code{what-line}的现代版本使用@code{line-number-at-pos}，它除了简单的表达式（例如@code{(goto-char (point-min))}）外，还使用@code{(forward-line 0)}将光标移动到当前行的开头，而不是@code{beginning-of-line}。）

这里展示的@code{what-line}函数具有文档行并且是交互式的，正如您所期望的那样。接下来的两行使用了@code{save-restriction}和@code{widen}函数。

@code{save-restriction}特殊形式记录当前缓冲区中任何有效的缩小范围（如果有的话），并在@code{save-restriction}的主体代码被评估后恢复该缩小范围。

@code{save-restriction}特殊形式后跟@code{widen}。此函数撤消了在调用@code{what-line}时当前缓冲区可能存在的任何缩小。 （@code{save-restriction}记住的是存在的缩小。）这种扩展使得行计数命令能够从缓冲区的开头计数。否则，它们将受限于在可访问区域内计数。任何原始缩小都在@code{save-restriction}特殊形式完成函数后立即恢复。

对@code{widen}的调用后跟@code{save-excursion}，该函数保存光标（即点）的位置，并在@code{save-excursion}的主体代码使用@code{beginning-of-line}函数移动点后恢复它。

（请注意，@code{(widen)}表达式位于@code{save-restriction}和@code{save-excursion}特殊形式之间。当您按顺序编写两个@code{save- @dots{}}表达式时，将@code{save-excursion}写在最外层。）

@need 1200
@code{what-line}函数的最后两行是用于计算缓冲区中行数然后在回显区打印该数字的函数。

@smallexample
@group
(message "第%d行"
         (1+ (count-lines 1 (point)))))))
@end group
@end smallexample

@code{message}函数在Emacs屏幕底部打印一行消息。第一个参数位于引号中，被打印为一个字符串。但是，它可能包含@samp{%d}表达式，以打印后续参数。@samp{%d}将参数打印为十进制数，因此消息将显示类似于@samp{第243行}的内容。

@need 1200
替换@samp{%d}的位置打印的数字由函数的最后一行计算：

@smallexample
(1+ (count-lines 1 (point)))
@end smallexample

@ignore
GNU Emacs 22

(defun count-lines (start end)
  "返回START和END之间的行数。
通常这是它们之间的换行符数，
但是如果START不等于END并且它们中的较大者不在行的开头，则可能多一行。"
  (save-excursion
    (save-restriction
      (narrow-to-region start end)
      (goto-char (point-min))
      (if (eq selective-display t)
          (save-match-data
            (let ((done 0))
              (while (re-search-forward "[\n\C-m]" nil t 40)
                (setq done (+ 40 done)))
              (while (re-search-forward "[\n\C-m]" nil t 1)
                (setq done (+ 1 done)))
              (goto-char (point-max))
              (if (and (/= start end)
                       (not (bolp)))
                  (1+ done)
                done)))
        (- (buffer-size) (forward-line (buffer-size)))))))
@end ignore

@noindent
这是从缓冲区的第一个位置（由@code{1}指示）到@code{(point)}的行数，然后将其加一。 （@code{1+}函数将其参数加一。）我们加一是因为第2行之前只有一行，而@code{count-lines}只计算当前行之前的行。

在@code{count-lines}完成其工作并且消息已经在回显区打印后，@code{save-excursion}将点还原到其原始位置；@code{save-restriction}恢复原始的缩小（如果有的话）。

@node narrow Exercise
@section 使用 Narrowing 进行练习

编写一个函数，即使将缓冲区缩小到其后半部分以至于第一行不可访问，也能显示当前缓冲区的前60个字符。需要使用一系列函数，包括 @code{save-restriction}、@code{widen}、@code{goto-char}、@code{point-min}、@code{message} 和 @code{buffer-substring}。

@cindex 属性提及 @code{buffer-substring-no-properties}
（@code{buffer-substring} 是一个先前未提及的函数，您需要自行查阅；或者您可能需要使用 @code{buffer-substring-no-properties} 或 @code{filter-buffer-substring} @dots{}，还有其他函数。文本属性是本文未讨论的另一个功能。@xref{文本属性, , 文本属性, elisp, The GNU Emacs Lisp Reference Manual}。）

另外，是否真的需要 @code{goto-char} 或 @code{point-min}？或者您能否在不使用它们的情况下编写该函数？

@node car cdr & cons
@chapter @code{car}、@code{cdr} 和 @code{cons}：基本函数
@findex car@r{, introduced}
@findex cdr@r{, introduced}

在 Lisp 中，@code{car}、@code{cdr} 和 @code{cons} 是基本函数。@code{cons} 函数用于构建列表，而 @code{car} 和 @code{cdr} 函数用于分解列表。

在 @code{copy-region-as-kill} 函数的演练中，我们将看到 @code{cons} 以及两个变体的 @code{cdr}，即 @code{setcdr} 和 @code{nthcdr}。(@xref{copy-region-as-kill}.)

@menu
* Strange Names::               一个历史插曲：为什么是这些奇怪的名字？
* car & cdr::                   用于提取列表的部分的函数。
* cons::                        构建列表。
* nthcdr::                      反复调用 @code{cdr}。
* nth::
* setcar::                      更改列表的第一个元素。
* setcdr::                      更改列表的其余部分。
* cons Exercise::
@end menu

@ifnottex
@node Strange Names
@unnumberedsec Strange Names
@end ifnottex

@code{cons} 函数的名称并不无道理：它是“construct”一词的缩写。另一方面，@code{car} 和 @code{cdr} 的命名起源有些深奥：@code{car} 是短语“Contents of the Address part of the Register”的首字母缩写；而 @code{cdr}（发音为“could-er”）是短语“Contents of the Decrement part of the Register”的首字母缩写。这些短语指的是原始 Lisp 开发时使用的 IBM 704 计算机。

IBM 704 在历史上留下了痕迹，但这些名字现在已经成为 Lisp 珍爱的传统。

@node car & cdr
@section @code{car} 和 @code{cdr}

列表的 @sc{car}（首元素）简单地就是列表中的第一个项。因此，列表 @code{(rose violet daisy buttercup)} 的 @sc{car} 就是 @code{rose}。

@need 1200
如果你在 GNU Emacs 的 Info 中阅读此文档，你可以通过执行以下命令来验证：

@smallexample
(car '(rose violet daisy buttercup))
@end smallexample

@noindent
在执行此表达式之后，@code{rose} 将会出现在回显区域。

@code{car} 不会从列表中删除第一个项；它只是报告这个项是什么。在术语中，@code{car} 是“非破坏性”的。这一特性事实上变得很重要。

列表的 @sc{cdr}（剩余元素）是列表中剩下的部分，即 @code{cdr} 函数返回紧随第一个项之后的列表部分。因此，虽然列表 @code{'(rose violet daisy buttercup)} 的 @sc{car} 是 @code{rose}，但列表的其余部分，即 @code{cdr} 函数返回的值，是 @code{(violet daisy buttercup)}。

@need 800
你可以通过以通常的方式执行以下命令来验证这一点：

@smallexample
(cdr '(rose violet daisy buttercup))
@end smallexample

@noindent
当你执行此命令时，@code{(violet daisy buttercup)} 将会出现在回显区域。

与 @code{car} 一样，@code{cdr} 也不会从列表中移除任何元素，它只是返回第二个及后续元素的报告。

顺便说一下，在例子中，花卉列表是被引用的。如果没有引用，Lisp 解释器会尝试通过调用 @code{rose} 作为函数来评估列表。在这个例子中，我们不想这样做。

在处理列表时，使用 @code{first} 和 @code{rest} 这样的名称可能比 @code{car} 和 @code{cdr} 更有意义。事实上，一些程序员会将 @code{first} 和 @code{rest} 定义为 @code{car} 和 @code{cdr} 的别名，然后在代码中使用 @code{first} 和 @code{rest}。

然而，在Lisp中，列表是使用称为“cons单元”（@pxref{列表实现}）的较低级结构构建的，在其中“第一个”或“剩余”这样的概念是不存在的，而 @sc{car} 和 @sc{cdr} 是对称的。Lisp 不会隐藏 cons 单元的存在，程序也会将它们用于除列表之外的其他事物。因此，这些名称有助于提醒程序员，尽管在列表中它们是不对称使用的，但 @code{car} 和 @code{cdr} 实际上是对称的。

@ignore
很显然，对于 @code{cdr} 来说，一个更合理的名字应该是 @code{rest}。

（这里有一个教训：当给新函数命名时，要非常谨慎，因为你可能会一直使用这些名称的时间比你预期的长。这份文档之所以延续使用这些名称，是因为 Emacs Lisp 源代码使用了它们，如果我不使用它们，你将很难阅读代码；但请尽量避免在自己的代码中使用这些术语。以后的人会感激你的。）
@end ignore

当 @code{car} 和 @code{cdr} 应用于由符号组成的列表时（例如，列表 @code{(pine fir oak maple)}），函数 @code{car} 返回的列表元素是符号 @code{pine} 而没有括号。@code{pine} 是列表中的第一个元素。然而，列表的 @sc{cdr} 本身是一个列表，即 @code{(fir oak maple)}，你可以通过以通常的方式执行以下表达式来验证：

@smallexample
@group
(car '(pine fir oak maple))

(cdr '(pine fir oak maple))
@end group
@end smallexample

另一方面，在列表的列表中，第一个元素本身是一个列表。例如，以下列表包含三个子列表，一个肉食动物列表，一个食草动物列表和一个海洋哺乳动物列表：

@smallexample
@group
(car '((lion tiger cheetah)
       (gazelle antelope zebra)
       (whale dolphin seal)))
@end group
@end smallexample

@noindent
在这个例子中，列表的第一个元素或 @sc{car} 是肉食动物列表 @code{(lion tiger cheetah)}，而列表的其余部分是 @code{((gazelle antelope zebra) (whale dolphin seal))}。

@smallexample
@group
(cdr '((lion tiger cheetah)
       (gazelle antelope zebra)
       (whale dolphin seal)))
@end group
@end smallexample

值得再次强调的是，@code{car} 和 @code{cdr} 是非破坏性的——也就是说，它们不会修改或改变应用到它们的列表。这对它们的使用非常重要。

另外，在第一章中，关于原子的讨论中，我提到在Lisp中，某些类型的原子，例如数组，可以被分解成部分；但这个机制与拆分列表的机制不同。就Lisp而言，列表的原子是不可分割的。(@xref{Lisp Atoms}.) @code{car} 和 @code{cdr} 函数用于拆分列表，被认为是Lisp的基本功能。由于它们不能拆分或访问数组的部分，数组被认为是原子。相反，另一个基本函数 @code{cons} 可以组合或构造列表，但不能构造数组。 （数组由数组特定的函数处理。@xref{Arrays, , Arrays, elisp, The GNU Emacs Lisp Reference Manual}。）

@node cons
@section @code{cons}
@findex cons@r{, introduced}

@code{cons}函数用于构建列表；它是@code{car}和@code{cdr}的反函数。例如，@code{cons}可以用来从三元素列表@code{(fir oak maple)}中创建一个四元素列表：

@smallexample
(cons 'pine '(fir oak maple))
@end smallexample

@need 800
@noindent
在评估了这个列表之后，你将会看到：

@smallexample
(pine fir oak maple)
@end smallexample

@noindent
出现在回显区。@code{cons}导致创建一个新的列表，其中元素后面是原始列表的元素。

我们经常说@code{cons}将一个新元素放在列表的开头，或者附加或推送元素到列表中，但这种表达可能会误导，因为@code{cons}不会改变现有的列表，而是创建一个新列表。

与@code{car}和@code{cdr}一样，@code{cons}是非破坏性的。

@menu
* 构建列表::
* 长度::                      如何找到列表的长度。
@end menu

@ifnottex
@node 构建列表
@unnumberedsubsec 构建列表
@end ifnottex

@code{cons}必须有一个要附加的列表。@footnote{实际上，你可以将元素@code{cons}到原子上以生成一个点对。这里不讨论点对；参见@ref{Dotted Pair Notation, , Dotted Pair Notation, elisp, The GNU Emacs Lisp Reference Manual}。} 你不能从绝对的空白开始。如果你正在构建一个列表，你需要至少在开头提供一个空列表。以下是一系列的@code{cons}表达式，用于构建一系列花的列表。如果你在GNU Emacs中的Info中阅读这个，你可以按照通常的方式评估每个表达式；值将在这个文本中以@samp{@result{}}打印出来，你可以将其解读为“评估为”。

@smallexample
@group
(cons 'buttercup ())
     @result{} (buttercup)
@end group

@group
(cons 'daisy '(buttercup))
     @result{} (daisy buttercup)
@end group

@group
(cons 'violet '(daisy buttercup))
     @result{} (violet daisy buttercup)
@end group

@group
(cons 'rose '(violet daisy buttercup))
     @result{} (rose violet daisy buttercup)
@end group
@end smallexample

@noindent
在第一个例子中，空列表显示为@code{()}，并构建了一个由@code{buttercup}后面跟着空列表的列表。正如你所见，空列表在构建的列表中没有显示。因为空列表中没有任何内容，通常来说，空列表是不可见的。

在第二个例子中，@code{(cons 'daisy '(buttercup))}通过将@code{daisy}放在@code{buttercup}前面构建了一个新的两元素列表；第三个例子通过将@code{violet}放在@code{daisy}和@code{buttercup}前面构建了一个三元素列表。

@node 长度
@subsection 查找列表的长度：@code{length}
@findex length

你可以使用Lisp函数@code{length}来查找列表中有多少元素，例如以下示例：

@smallexample
@group
(length '(buttercup))
     @result{} 1
@end group

@group
(length '(daisy buttercup))
     @result{} 2
@end group

@group
(length (cons 'violet '(daisy buttercup)))
     @result{} 3
@end group
@end smallexample

@noindent
在第三个例子中，@code{cons}函数用于构建一个包含三个元素的列表，然后将其作为参数传递给@code{length}函数。

@need 1200
我们还可以使用@code{length}来计算空列表中的元素个数：

@smallexample
@group
(length ())
     @result{} 0
@end group
@end smallexample

@noindent
正如你所期望的那样，空列表中的元素个数为零。

一个有趣的实验是找出当你尝试找到根本没有列表的长度时会发生什么；也就是说，如果你尝试调用@code{length}而没有给它提供参数，甚至没有空列表：

@smallexample
(length )
@end smallexample

@need 800
@noindent
如果你评估这个表达式，你将看到错误消息：

@smallexample
Lisp error: (wrong-number-of-arguments length 0)
@end smallexample

@noindent
这意味着函数在期望某个其他数量的参数时（在本例中是一个参数），收到了错误数量的参数，即零。在这种情况下，期望一个参数，而参数是要测量其长度的列表。（注意，@emph{一个}列表是@emph{一个}参数，即使列表内有多个元素。）

错误消息中的@samp{length}是函数的名称。

@ignore
@code{length}仍然是一个子例程，但你需要使用C-h f来发现这一点。

在早期版本中：
这是用一种特殊的符号@samp{#<subr}写的，表示函数@code{length}是用C编写而不是用Emacs Lisp编写的原始函数之一。(@samp{subr}是“子例程”的缩写。) 更多关于子例程的信息，请参阅@ref{What Is a Function, , What Is a Function?, elisp, The GNU Emacs Lisp Reference Manual}。
@end ignore

@node nthcdr
@section @code{nthcdr}
@findex nthcdr

函数 @code{nthcdr} 与函数 @code{cdr} 相关联。它的作用是重复地取一个列表的 @sc{cdr}。

如果对列表 @code{(pine fir oak maple)} 进行 @sc{cdr} 操作，将得到列表 @code{(fir oak maple)}。如果在这个结果上再进行一次 @sc{cdr}，将得到列表 @code{(oak maple)}。当然，对原始列表反复 @sc{cdr} 只会得到原始的 @sc{cdr}，因为该函数不会改变列表。需要对 @sc{cdr} 进行评估，然后继续操作。最终，你将得到一个空列表，在这个例子中，它显示为 @code{nil} 而非 @code{()}。

@need 1200
为了复习，以下是一系列重复的 @sc{cdr} 操作，@samp{@result{}} 后的文本显示了返回的结果。

@smallexample
@group
(cdr '(pine fir oak maple))
     @result{} (fir oak maple)
@end group

@group
(cdr '(fir oak maple))
     @result{} (oak maple)
@end group

@group
(cdr '(oak maple))
     @result{} (maple)
@end group

@group
(cdr '(maple))
     @result{} nil
@end group

@group
(cdr 'nil)
     @result{} nil
@end group

@group
(cdr ())
     @result{} nil
@end group
@end smallexample

@need 1200
你也可以进行多次 @sc{cdr} 操作而不打印中间值，像这样：

@smallexample
@group
(cdr (cdr '(pine fir oak maple)))
     @result{} (oak maple)
@end group
@end smallexample

@noindent
在这个例子中，Lisp 解释器首先评估最内层的列表。最内层的列表被引用，因此它只是将列表传递给最内层的 @code{cdr}。这个 @code{cdr} 将由列表的第二个及之后的元素组成的列表传递给最外层的 @code{cdr}，产生一个由原始列表的第三个及之后的元素组成的列表。在这个例子中，重复调用 @code{cdr} 函数并返回一个由原始列表的前两个元素之外的元素组成的列表。

函数 @code{nthcdr} 的作用与重复调用 @code{cdr} 相同。在下面的例子中，参数 2 被传递给函数 @code{nthcdr}，连同列表一起传递，返回的值是没有前两个项的列表，这与在列表上连续调用两次 @code{cdr} 是一样的：

@smallexample
@group
(nthcdr 2 '(pine fir oak maple))
     @result{} (oak maple)
@end group
@end smallexample

@need 1200
使用原始的四个元素列表，我们可以看到当传递不同的数值参数给 @code{nthcdr} 时会发生什么，包括 0、1 和 5：

@smallexample
@group
;; @r{保留列表不变。}
(nthcdr 0 '(pine fir oak maple))
     @result{} (pine fir oak maple)
@end group

@group
;; @r{返回去掉第一个元素的列表副本。}
(nthcdr 1 '(pine fir oak maple))
     @result{} (fir oak maple)
@end group

@group
;; @r{返回去掉三个元素的列表副本。}
(nthcdr 3 '(pine fir oak maple))
     @result{} (maple)
@end group

@group
;; @r{返回去掉所有四个元素的列表副本。}
(nthcdr 4 '(pine fir oak maple))
     @result{} nil
@end group

@group
;; @r{返回去掉所有元素的列表副本。}
(nthcdr 5 '(pine fir oak maple))
     @result{} nil
@end group
@end smallexample

@node nth
@section @code{nth}
@findex nth

函数 @code{nthcdr} 重复获取列表的 @sc{cdr}。函数 @code{nth} 获取由 @code{nthcdr} 返回的结果的 @sc{car}。它返回列表的第 N 个元素。

@need 1500
因此，如果不是为了速度而在C中定义，@code{nth} 的定义将是：

@smallexample
@group
(defun nth (n list)
  "返回列表 LIST 的第 N 个元素。
N 从零开始计数。如果列表没有那么长，则返回 nil。"
  (car (nthcdr n list)))
@end group
@end smallexample

@noindent
(最初，@code{nth} 是在Emacs Lisp中在@file{subr.el}中定义的，但它的定义在1980年代被重写为C语言。)

@code{nth} 函数返回列表的单个元素。这可能非常方便。

请注意，元素从零开始编号，而不是从一开始。也就是说，列表的第一个元素，它的 @sc{car} 是零号元素。这种从零开始计数通常会让习惯于列表中第一个元素为编号一的人感到困扰。

@need 1250
例如：

@smallexample
@group
(nth 0 '("one" "two" "three"))
    @result{} "one"

(nth 1 '("one" "two" "three"))
    @result{} "two"
@end group
@end smallexample

值得一提的是，@code{nth}、@code{nthcdr} 和 @code{cdr} 都不会改变原始列表---这些函数是非破坏性的。这与 @code{setcar} 和 @code{setcdr} 函数形成鲜明对比。

@node setcar
@section @code{setcar}
@findex setcar

从它们的名字中，你可能已经猜到了，@code{setcar} 和 @code{setcdr} 函数用于将列表的 @sc{car} 或 @sc{cdr} 设置为新值。它们实际上会改变原始列表，与 @code{car} 和 @code{cdr} 不同，它们保持原始列表不变。了解这是如何工作的一种方法是进行实验。我们首先来看一下 @code{setcar} 函数。

@need 1200
首先，我们可以创建一个列表，然后使用 @code{setq} 特殊形式将变量的值设置为该列表。因为我们打算使用 @code{setcar} 来更改列表，所以这个 @code{setq} 不应该使用引用形式 @code{'(antelope giraffe lion tiger)}，因为那将产生一个程序的一部分的列表，如果我们尝试在运行时更改程序的一部分，可能会导致问题。通常来说，Emacs Lisp 程序的组件在程序运行时应该是常量（或不变的）。因此，我们使用 @code{list} 函数构造一个动物列表，如下所示：

@smallexample
(setq animals (list 'antelope 'giraffe 'lion 'tiger))
@end smallexample

@noindent
如果你在 GNU Emacs 中的 Info 中阅读这篇文章，你可以通过按 @kbd{C-x C-e} 将光标定位在表达式之后，以通常的方式评估这个表达式。（我在写这篇文章的时候就是这样做的。这是将解释器内置到计算环境中的优势之一。顺便说一句，当最终括号之后的行上没有任何内容，比如注释时，光标可以在下一行。因此，如果你的光标在下一行的第一列，你不需要移动它。事实上，Emacs 允许在最终括号之后有任意量的空白。）

@need 1200
当我们评估变量 @code{animals} 时，我们看到它绑定到列表 @code{(antelope giraffe lion tiger)}：

@smallexample
@group
animals
     @result{} (antelope giraffe lion tiger)
@end group
@end smallexample

@noindent
换句话说，变量 @code{animals} 指向列表 @code{(antelope giraffe lion tiger)}。

接下来，评估函数 @code{setcar}，同时传递给它两个参数，变量 @code{animals} 和引用的符号 @code{hippopotamus}；这是通过编写三个元素的列表 @code{(setcar animals 'hippopotamus)}，然后以通常的方式评估它来完成的：

@smallexample
(setcar animals 'hippopotamus)
@end smallexample

@need 1200
@noindent
评估完这个表达式后，再次评估变量 @code{animals}。你会看到动物列表已经改变了：

@smallexample
@group
animals
     @result{} (hippopotamus giraffe lion tiger)
@end group
@end smallexample

@noindent
列表的第一个元素 @code{antelope} 被 @code{hippopotamus} 替换。

所以我们可以看到，@code{setcar} 并没有像 @code{cons} 那样向列表中添加新元素；它替换了 @code{antelope} 为 @code{hippopotamus}；它@emph{改变了}列表。

@node setcdr
@section @code{setcdr}
@findex setcdr

@code{setcdr}函数类似于@code{setcar}函数，不同之处在于该函数替换列表的第二个及其后的元素，而不是第一个元素。

(要了解如何更改列表的最后一个元素，请查看@ref{kill-new 函数, , @code{kill-new} 函数}，该函数使用@code{nthcdr}和@code{setcdr}函数。)

@need 1200
为了了解它是如何工作的，请通过评估以下表达式将变量的值设置为一组驯养的动物：

@smallexample
(setq domesticated-animals (list 'horse 'cow 'sheep 'goat))
@end smallexample

@need 1200
@noindent
如果现在评估该列表，将返回列表@code{(horse cow sheep goat)}：

@smallexample
@group
domesticated-animals
     @result{} (horse cow sheep goat)
@end group
@end smallexample

@need 1200
接下来，通过使用两个参数评估@code{setcdr}，第一个参数是具有列表值的变量的名称，第二个参数是将设置为第一个列表的@sc{cdr}的列表；

@smallexample
(setcdr domesticated-animals '(cat dog))
@end smallexample

@noindent
如果评估此表达式，将在回显区域看到列表@code{(cat dog)}。这是该函数返回的值。我们感兴趣的结果是副作用，可以通过评估变量@code{domesticated-animals}来查看：

@smallexample
@group
domesticated-animals
     @result{} (horse cat dog)
@end group
@end smallexample

@noindent
确实，列表从@code{(horse cow sheep goat)}更改为@code{(horse cat dog)}。列表的@sc{cdr}从@code{(cow sheep goat)}更改为@code{(cat dog)}。

@node cons 练习
@section 练习

通过评估多个表达式使用@code{cons}构建一个包含四只鸟的列表。了解当你使用@code{cons}将一个列表连接到自身时会发生什么。将四只鸟的列表的第一个元素替换为一条鱼。用其他鱼的列表替换该列表的其余部分。

@node 剪切与存储文本
@chapter 剪切与存储文本
@cindex 剪切与存储文本
@cindex 存储与剪切文本
@cindex 删除文本
@cindex 剪切文本
@cindex 擦除文本
@cindex 删除文本

无论何时在GNU Emacs中使用@dfn{kill}命令剪切或剪贴文本，它都会被存储在一个列表中，您可以使用@dfn{yank}命令将其恢复。

（在Emacs中使用“kill”一词来表示那些特别@emph{不}破坏实体值的过程是一个不幸的历史偶然。一个更合适的词语应该是“剪切”，因为kill命令的作用是剪切文本并将其放入存储中，从中可以重新调用。我经常被诱惑着全局替换Emacs源代码中所有“kill”出现的地方为“clip”，并将所有“killed”的出现地方替换为“clipped”）。

@menu
* 存储文本::                   文本被存储在一个列表中。
* zap-to-char::               剪切文本直到某个字符。
* kill-region::               从区域中剪切文本。
* copy-region-as-kill::       复制文本的定义。
* 进入C的插曲::               C编程语言宏的小注记。
* defvar::                    如何给变量一个初始值。
* cons & search-fwd 回顾::
* 搜索练习::
@end menu

@ifnottex
@node 存储文本
@unnumberedsec 将文本存储在列表中
@end ifnottex

当文本从缓冲区中剪切出来时，它被存储在一个列表中。连续的文本片段被依次存储在列表中，因此列表可能看起来像这样：

@smallexample
("一段文本" "之前的片段")
@end smallexample

@need 1200
@noindent
函数@code{cons}可用于从文本片段（称为“原子”）和现有列表创建一个新列表，如下所示：

@smallexample
@group
(cons "另一段"
      '("一段文本" "之前的片段"))
@end group
@end smallexample

@need 1200
@noindent
如果您评估此表达式，一个包含三个元素的列表将显示在回显区：

@smallexample
("另一段" "一段文本" "之前的片段")
@end smallexample

使用@code{car}和@code{nthcdr}函数，您可以检索您想要的任何文本片段。例如，在以下代码中，@code{nthcdr 1 @dots{}}返回删除第一个项目的列表；而@code{car}返回该剩余部分的第一个元素---原始列表的第二个元素：

@smallexample
@group
(car (nthcdr 1 '("另一段"
                 "一段文本"
                 "之前的片段")))
     @result{} "一段文本"
@end group
@end smallexample

实际的Emacs函数当然比这更复杂。剪切和检索文本的代码必须被编写，以便Emacs可以弄清楚您想要列表中的哪个元素---第一个、第二个、第三个等。此外，当到达列表的末尾时，Emacs应该给您列表的第一个元素，而不是什么都不给您。

保存文本片段的列表称为@dfn{kill环}。本章首先描述了kill环，以及首先追踪@code{zap-to-char}函数的工作方式。此函数调用一个调用函数，该函数操纵kill环。因此，在到达山脚之前，我们要先爬过丘陵。

后续章节描述了从缓冲区剪切的文本如何被检索。@xref{插入文本, , 检索文本}。

@node zap-to-char
@section @code{zap-to-char}
@findex zap-to-char

让我们看一下交互式函数 @code{zap-to-char}。

@menu
* Complete zap-to-char::        完整的实现。
* zap-to-char interactive::     一个三部分的交互式表达式。
* zap-to-char body::            简要概述。
* search-forward::              如何搜索字符串。
* progn::                       特殊形式 @code{progn}。
* Summing up zap-to-char::      使用 @code{point} 和 @code{search-forward}。
@end menu

@ifnottex
@node Complete zap-to-char
@unnumberedsubsec 完整的 @code{zap-to-char} 实现
@end ifnottex

@code{zap-to-char} 函数删除光标位置（即 point）到下一个指定字符（包括该字符）之间的文本。@code{zap-to-char} 删除的文本被放入 kill ring，可以通过键入 @kbd{C-y}（@code{yank}）从 kill ring 中检索。如果给命令传递了一个参数，它将通过指定数量的出现次数删除文本。因此，如果光标位于本句的开头，字符为 @samp{s}，则将删除 @samp{Thus}。如果参数为二，则将删除 @samp{Thus, if the curs}，直到 @samp{cursor} 中的 @samp{s}。

如果未找到指定的字符，@code{zap-to-char} 将显示“Search failed”，告诉您输入的字符，并且不会删除任何文本。

为了确定要删除多少文本，@code{zap-to-char} 使用搜索函数。搜索在处理文本的代码中广泛使用，我们将重点关注搜索以及删除命令。

@ignore
@c GNU Emacs version 19
(defun zap-to-char (arg char)  ; version 19 implementation
  "Kill up to and including ARG'th occurrence of CHAR.
Goes backward if ARG is negative; error if CHAR not found."
  (interactive "*p\ncZap to char: ")
  (kill-region (point)
               (progn
                 (search-forward
                  (char-to-string char) nil nil arg)
                 (point))))
@end ignore

@need 1250
下面是版本 22 的函数实现的完整文本：

@c GNU Emacs 22
@smallexample
@group
(defun zap-to-char (arg char)
  "Kill up to and including ARG'th occurrence of CHAR.
Case is ignored if `case-fold-search' is non-nil in the current buffer.
Goes backward if ARG is negative; error if CHAR not found."
  (interactive "p\ncZap to char: ")
  (if (char-table-p translation-table-for-input)
      (setq char (or (aref translation-table-for-input char) char)))
  (kill-region (point) (progn
                         (search-forward (char-to-string char)
                                         nil nil arg)
                         (point))))
@end group
@end smallexample

文档非常详细。您需要了解“kill”这个术语的含义。

@cindex curved quotes
@cindex curly quotes
@code{zap-to-char} 版本 22 的文档字符串使用 ASCII grave accent 和撇号引用一个符号，因此它显示为 @t{`case-fold-search'}。这种引用风格受到上世纪 70 年代显示器的启发，在那里 grave accent 和撇号经常是镜像图像，适合用作引号。在大多数现代显示器上，这不再成立，当这两个 ASCII 字符出现在文档字符串或诊断消息格式中时，Emacs 通常将它们转换为 @dfn{弯引号}（左右单引号），因此上面引用的符号显示为 @t{‘case-fold-search’}。源代码字符串也可以直接使用弯引号。

@node zap-to-char interactive
@subsection @code{interactive} 表达式

@need 800
@code{zap-to-char} 命令中的交互式表达式如下：

@smallexample
(interactive "p\ncZap to char: ")
@end smallexample

引号内的部分，@code{"p\ncZap to char: "}，指定了两个不同的信息。首先，最简单的是 @samp{p}。这一部分与下一部分由换行符 @samp{\n} 分隔。@samp{p} 表示函数的第一个参数将传递一个 @dfn{processed prefix} 的值。前缀参数通过键入 @kbd{C-u} 和一个数字，或者 @kbd{M-} 和一个数字传递。如果在不带前缀的情况下交互调用该函数，则将 1 传递给此参数。

@code{"p\ncZap to char: "} 的第二部分是 @samp{cZap to char:@:  }。在这一部分中，小写的 @samp{c} 表示 @code{interactive} 期望一个提示，并且参数将是一个字符。提示跟在 @samp{c} 后面，是字符串 @samp{Zap to char:@: }（冒号后面有一个空格，使其看起来更好）。

所有这些都是为了准备 @code{zap-to-char} 的参数，以使它们具有正确的类型，并为用户提供提示。

在只读缓冲区中，@code{zap-to-char} 函数将文本复制到 kill ring，但不删除它。回显区显示一条消息，指示缓冲区是只读的。此外，终端可能会发出哔声或闪烁提醒。

@node zap-to-char body
@subsection @code{zap-to-char}函数的主体

@code{zap-to-char}函数的主体包含了用于删除（即移除）文本的代码，该文本位于光标当前位置到指定字符（包括该字符）的区域。

代码的第一部分如下：

@smallexample
(if (char-table-p translation-table-for-input)
    (setq char (or (aref translation-table-for-input char) char)))
(kill-region (point) (progn
                       (search-forward (char-to-string char) nil nil arg)
                       (point)))
@end smallexample

@noindent
@code{char-table-p}是一个前文未见的函数。它用于确定其参数是否为字符表。当是字符表时，它将传递给@code{zap-to-char}的字符设置为其中之一（如果该字符存在），否则设置为字符本身。（这对于非欧洲语言中的某些字符很重要。@code{aref}函数从数组中提取元素。它是一个特定于数组的函数，本文档不详细描述。@xref{Arrays, , Arrays, elisp, The GNU Emacs Lisp Reference Manual}。）

@noindent
@code{(point)}是光标的当前位置。

代码的下一部分是一个使用@code{progn}的表达式。@code{progn}的主体由对@code{search-forward}和@code{point}的调用组成。

在学习@code{progn}之前，了解一下@code{search-forward}会更容易理解，因此我们将先看看@code{search-forward}，然后再看@code{progn}。

@node search-forward
@subsection @code{search-forward}函数
@findex search-forward

@code{search-forward}函数用于在@code{zap-to-char}中定位要删除的字符。如果搜索成功，@code{search-forward}将光标立即置于目标字符串的最后一个字符之后。（在@code{zap-to-char}中，目标字符串只有一个字符长。@code{zap-to-char}使用@code{char-to-string}函数确保计算机将该字符视为字符串。）如果搜索是向后的，@code{search-forward}将光标放在目标的第一个字符之前。此外，@code{search-forward}返回@code{t}表示真（移动光标因此是一个副作用）。

@need 1250
在@code{zap-to-char}中，@code{search-forward}函数如下：

@smallexample
(search-forward (char-to-string char) nil nil arg)
@end smallexample

@code{search-forward}函数接受四个参数：

@enumerate
@item
第一个参数是目标，即要搜索的内容。这必须是一个字符串，例如@samp{"z"}。

正好传递给@code{zap-to-char}的参数是一个单个字符。由于计算机的构造方式，Lisp解释器可能会将单个字符视为与字符串不同。在计算机内部，单个字符具有与一个字符的字符串不同的电子格式。（计算机中通常可以用一个字节精确地记录一个单个字符；但字符串可能更长，计算机需要为此做好准备。）因此，@code{zap-to-char}函数接收的字符必须在计算机内部从一种格式转换为另一种格式；否则，@code{search-forward}函数将失败。使用@code{char-to-string}函数进行此转换。

@item
第二个参数限制了搜索的范围；它指定为缓冲区中的位置。在这种情况下，搜索可以到达缓冲区的末尾，因此未设置边界，第二个参数为@code{nil}。

@item
第三个参数告诉函数如果搜索失败应该做什么——它可以发出错误（并打印一条消息），或者返回@code{nil}。将@code{nil}作为第三个参数会导致函数在搜索失败时发出错误。

@item
@code{search-forward}的第四个参数是重复计数——要查找字符串的出现次数。此参数是可选的，如果函数在没有重复计数的情况下调用，则此参数将传递值1。如果此参数为负数，则搜索将向后进行。
@end enumerate

@need 800
在模板形式中，@code{search-forward}表达式如下：

@smallexample
@group
(search-forward "@var{target-string}"
                @var{limit-of-search}
                @var{what-to-do-if-search-fails}
                @var{repeat-count})
@end group
@end smallexample

接下来我们将看一下@code{progn}。

@node progn
@subsection @code{progn}特殊形式
@findex progn

@code{progn}是一种特殊形式，它导致按顺序评估其每个参数，然后返回最后一个参数的值。前面的表达式仅为它们执行的副作用而进行评估。它们产生的值被丢弃。

@need 800
@code{progn}表达式的模板非常简单：

@smallexample
@group
(progn
  @var{body}@dots{})
@end group
@end smallexample

在`zap-to-char`中，@code{progn}表达式必须执行两个操作：将点放置在准确的位置，并返回点的位置，以便@code{kill-region}知道要删除多远。

@code{progn}的第一个参数是@code{search-forward}。当@code{search-forward}找到字符串时，该函数将点立即置于目标字符串的最后一个字符之后。（在本例中，目标字符串只有一个字符长。）如果搜索是向后的，则@code{search-forward}将点置于目标的第一个字符之前。点的移动是一个副作用。

@code{progn}的第二个也是最后一个参数是表达式@code{(point)}。此表达式返回点的值，而在这种情况下，它将是由@code{search-forward}移动到的位置。（在源代码中，一行指示函数转到前一个字符（如果它是向前的）的代码在1999年被注释掉了；我不记得这个功能或错误是否曾经是分布源代码的一部分。）@code{point}的值由@code{progn}表达式返回，并作为@code{kill-region}的第二个参数传递。

@node Summing up zap-to-char
@subsection 总结@code{zap-to-char}

现在我们已经看到了@code{search-forward}和@code{progn}的工作原理，我们可以看到@code{zap-to-char}函数是如何整体工作的。

@code{kill-region}的第一个参数是在给定@code{zap-to-char}命令时光标的位置——即那个时刻的点的值。在@code{progn}内，搜索函数然后将点移动到刚刚删除的字符之后，并且@code{point}返回此位置的值。@code{kill-region}函数将这两个点的值组合在一起，第一个作为区域的起始，第二个作为区域的结束，然后删除该区域。

@code{progn}特殊形式是必需的，因为@code{kill-region}命令接受两个参数；如果@code{search-forward}和@code{point}表达式被顺序写为两个额外的参数，它将失败。@code{progn}表达式是@code{kill-region}的单个参数，并返回@code{kill-region}所需的唯一值作为其第二个参数。

@node kill-region
@section @code{kill-region}
@findex kill-region

@code{zap-to-char} 函数使用 @code{kill-region} 函数。这个函数从一个区域裁剪文本并将其复制到 kill ring 中，然后可以从中检索该文本。

@ignore
GNU Emacs 22:

(defun kill-region (beg end &optional yank-handler)
  "杀死（\"cut\"）点和标记之间的文本。
这会从缓冲区中删除文本并将其保存在 kill ring 中。
命令 \\[yank] 可以从中检索它。
\(如果你想要立即杀死然后粘贴，使用 \\[kill-ring-save]。)

如果你想将被杀死的区域追加到上次被杀死的文本中，
在 \\[kill-region] 之前使用 \\[append-next-kill]。

如果缓冲区是只读的，Emacs 会响铃并且不会删除文本，但仍会将文本放入 kill ring 中。
这意味着你可以使用删除命令从只读缓冲区复制文本。

这是程序用于杀死文本的原语（与删除不同）。
提供两个参数，指示要杀死的文本范围的字符位置。
调用此函数的任何命令都是“杀死命令”。
如果上一个命令也是杀死命令，
这次被杀死的文本将追加到上次被杀死的文本中，
形成 kill ring 中的一个条目。

在 Lisp 代码中，可选的第三个参数 YANK-HANDLER，如果非空，指定要设置在被杀死文本上的 yank-handler 文本属性。参见 `insert-for-yank'。"
  ;; 传递 point 先，然后是 mark，因为在调用 kill-append 时顺序很重要。
  (interactive (list (point) (mark)))
  (unless (and beg end)
    (error "当前未设置标记，因此没有区域"))
  (condition-case nil
      (let ((string (filter-buffer-substring beg end t)))
        (when string                        ;如果 BEG = END，则 STRING 为 nil
          ;; 以某种方式将该字符串添加到 kill ring 中。
          (if (eq last-command 'kill-region)
              (kill-append string (< end beg) yank-handler)
            (kill-new string nil yank-handler)))
        (when (or string (eq last-command 'kill-region))
          (setq this-command 'kill-region))
        nil)
    ((buffer-read-only text-read-only)
     ;; 上面的代码失败，因为缓冲区或区域中的某些字符是只读的。
     ;; 我们应该响铃，以防用户不知道这一点。
     ;; 但是无论如何，将区域的文本放入 kill ring 中都没有害处。
     (copy-region-as-kill beg end)
     ;; 现在设置 this-command，以便即使出现错误也会设置它。
     (setq this-command 'kill-region)
     ;; 如果 kill-read-only-ok 为真，则不会发生错误，而是发出消息。
     (if kill-read-only-ok
         (progn (message "只读文本已复制到 kill ring") nil)
       ;; 如果缓冲区是只读的，则发出错误。
       (barf-if-buffer-read-only)
       ;; 如果缓冲区不是只读的，那么文本是只读的。
       (signal 'text-read-only (list (current-buffer)))))))
@end ignore

该函数的 Emacs 22 版本使用了 @code{condition-case} 和 @code{copy-region-as-kill}，我们将对两者进行解释。@code{condition-case} 是一个重要的特殊形式。

实质上，@code{kill-region} 函数调用 @code{condition-case}，它接受三个参数。在这个函数中，第一个参数什么也不做。第二个参数包含当一切顺利时执行的代码。第三个参数包含在出现错误时调用的代码。

@menu
* Complete kill-region::        函数定义。
* condition-case::              处理问题。
* Lisp macro::
@end menu

@ifnottex
@node 完整的 kill-region
@unnumberedsubsec 完整的 @code{kill-region} 定义
@end ifnottex

@need 1200
我们将逐步讲解 @code{condition-case} 代码。首先，让我们看一下 @code{kill-region} 的定义，附带注释：

@c GNU Emacs 22:
@smallexample
@group
(defun kill-region (beg end)
  "Kill (\"cut\") text between point and mark.
This deletes the text from the buffer and saves it in the kill ring.
The command \\[yank] can retrieve it from there. @dots{} "
@end group

@group
  ;; @bullet{} 由于顺序很重要，首先传递 point。
  (interactive (list (point) (mark)))
  ;; @bullet{} 并告诉我们如果无法剪切文本要怎么办。
  ;; 'unless' 是没有 then 部分的 'if'。
  (unless (and beg end)
    (error "The mark is not set now, so there is no region"))
@end group

@group
  ;; @bullet{} 'condition-case' 接受三个参数。
  ;;    如果第一个参数是 nil，就像这里一样，
  ;;    错误信号的信息就不会被存储以供其他函数使用。
  (condition-case nil
@end group

@group
      ;; @bullet{} 'condition-case' 的第二个参数告诉 Lisp 解释器
      ;;    一切正常时要做什么。
@end group

@group
      ;;    它以一个 'let' 函数开始，提取字符串并测试它是否存在。
      ;;    如果存在（这是 'when' 检查的内容），它调用一个 'if' 函数，
      ;;    用于确定前一个命令是否是对 'kill-region' 的另一个调用；
      ;;    如果是，则新文本附加到先前的文本；如果不是，则调用
      ;;    另一个函数 'kill-new'。
@end group

@group
      ;;    'kill-append' 函数连接新字符串和旧字符串。
      ;;    'kill-new' 函数将文本插入到 kill 环中的新项目中。
@end group

@group
      ;;    'when' 是没有 else 部分的 'if'。
      ;;    第二个 'when' 再次检查当前字符串是否存在；
      ;;    此外，它还检查前一个命令是否是对 'kill-region' 的另一个调用。
      ;;    如果其中一个条件为真，则将当前命令设置为 'kill-region'。
@end group
@group
      (let ((string (filter-buffer-substring beg end t)))
        (when string                    ; 如果 BEG = END，则 STRING 为 nil
          ;; 将该字符串添加到 kill ring 中，以某种方式。
          (if (eq last-command 'kill-region)
@end group
@group
              ;;    @minus{} 'yank-handler' 是传递给 'kill-region' 的可选参数，
              ;;    告诉 'kill-append' 和 'kill-new' 函数如何处理添加到文本中的属性，
              ;;    例如 'bold' 或 'italics'。
              (kill-append string (< end beg) yank-handler)
            (kill-new string nil yank-handler)))
        (when (or string (eq last-command 'kill-region))
          (setq this-command 'kill-region))
        nil)
@end group

@group
    ;;  @bullet{} 'condition-case' 的第三个参数告诉解释器
    ;;    发生错误时要做什么。
@end group
@group
    ;;    第三个参数有一个条件部分和一个体部分。
    ;;    如果满足条件（在这种情况下，如果文本或缓冲区是只读的）
    ;;    那么就执行体部分。
@end group
@group
    ((buffer-read-only text-read-only) ;; 条件部分
     ;; @dots{} 体部分
     (copy-region-as-kill beg end)
@end group
@group
     ;;    接下来，同样作为体部分的一部分，设置 this-command，
     ;;    这样它将在错误中被设置。
     (setq this-command 'kill-region)
     ;;    最后，在体部分，如果可以在不发出错误的情况下将文本复制到 kill ring 中，则发送消息，否则不发送。
@end group
@group
     (if kill-read-only-ok
         (progn (message "Read only text copied to kill ring") nil)
       (barf-if-buffer-read-only)
       ;; 如果缓冲区不是只读的，则文本是只读的。
       (signal 'text-read-only (list (current-buffer)))))))
@end group
@end smallexample

@ignore
@c v 21
@smallexample
@group
(defun kill-region (beg end)
  "Kill between point and mark.
The text is deleted but saved in the kill ring."
  (interactive "r")
@end group

@group
  ;; 1. 'condition-case' 接受三个参数。
  ;;    如果第一个参数是 nil，就像这里一样，
  ;;    错误信号的信息就不会被存储以供其他函数使用。
  (condition-case nil
@end group

@group
      ;; 2. 'condition-case' 的第二个参数告诉 Lisp 解释器
      ;;    一切正常时要做什么。
@end group

@group
      ;;    'delete-and-extract-region' 函数通常执行工作。
      ;;    如果区域的开头和结尾都相同，则变量 'string' 将为空，或 nil。
      (let ((string (delete-and-extract-region beg end)))
@end group

@group
        ;; 'when' 是一个不能有 'else-part' 的 'if' 子句。
        ;; Emacs 通常将 'last-command' 的值设置为前一个命令。
@end group
@group
        ;; 'kill-append' 连接新字符串和旧字符串。
        ;; 'kill-new' 在 kill 环中的新项目中插入文本。
        (when string
          (if (eq last-command 'kill-region)
              ;; 如果为真，则在字符串之前添加字符串
              (kill-append string (< end beg))
            (kill-new string)))
        (setq this-command 'kill-region))
@end group

@group
    ;; 3. 'condition-case' 的第三个参数告诉解释器
    ;;    发生错误时要做什么。
@end group
@group
    ;;    第三个参数有一个条件部分和一个体部分。
    ;;    如果满足条件（在这种情况下，
    ;;             如果文本或缓冲区是只读的）
    ;;    那么就执行体部分。
@end group
@group
    ((buffer-read-only text-read-only) ;; 这是条件部分
     ;; 然后...
     (copy-region-as-kill beg end)
@end group
@group
     (if kill-read-only-ok            ;; 通常这个变量是 nil
         (message "Read only text copied to kill ring")
       ;; 否则，如果缓冲区是只读的，发出错误信号；
       (barf-if-buffer-read-only)
       ;; 并且，在任何情况下，都发出文本是只读的信号。
       (signal 'text-read-only (list (current-buffer)))))))
@end group
@end smallexample
@end ignore

@node condition-case
@subsection @code{condition-case}
@findex condition-case

正如我们之前所看到的（@pxref{Making Errors, , Generate an Error
Message}），当Emacs Lisp解释器在评估表达式时遇到问题时，它会为您提供帮助；在行话中，这被称为“发出错误信号”。通常，计算机会停止程序并显示一条消息。

然而，一些程序执行复杂的操作。它们在发生错误时不应该简单地停止。在@code{kill-region}函数中，最可能的错误是您尝试删除只读且无法删除的文本。因此，@code{kill-region}函数包含处理此情况的代码。这段代码构成了@code{kill-region}函数的主体，位于@code{condition-case}特殊形式中。

@need 800
@code{condition-case}的模板如下：

@smallexample
@group
(condition-case
  @var{var}
  @var{bodyform}
  @var{error-handler}@dots{})
@end group
@end smallexample

第二个参数，@var{bodyform}，很直观。@code{condition-case}特殊形式导致Lisp解释器评估@var{bodyform}中的代码。如果没有错误发生，特殊形式将返回代码的值并产生副作用（如果有的话）。

简而言之，@code{condition-case}表达式的@var{bodyform}部分决定一切正常时应该发生什么。

然而，如果发生错误，除了其他动作，生成错误信号的函数还将定义一个或多个错误条件名。

错误处理程序是@code{condition-case}的第三个参数。错误处理程序有两个部分，一个是@var{condition-name}，另一个是@var{body}。如果错误处理程序的@var{condition-name}部分与错误生成的条件名匹配，那么将运行错误处理程序的@var{body}部分。

正如您所期望的那样，错误处理程序的@var{condition-name}部分可以是单个条件名或条件名列表。

此外，完整的@code{condition-case}表达式可能包含多个错误处理程序。当发生错误时，将运行第一个适用的处理程序。

最后，@code{condition-case}表达式的第一个参数，@var{var}参数，有时绑定到包含有关错误的信息的变量。但是，如果该参数为@code{nil}，如在@code{kill-region}中的情况，该信息将被丢弃。

@need 1200
简而言之，在@code{kill-region}函数中，@code{condition-case}的代码如下：

@smallexample
@group
@var{如果没有错误，运行仅此代码}
    @var{但是，如果发生错误，运行另一段代码}。
@end group
@end smallexample

@ignore
2006年10月24日
在Emacs 22中，
copy-region-as-kill很短，12行，并使用
filter-buffer-substring，它更长，39行
其中包含delete-and-extract-region。
delete-and-extract-region是用C编写的。

见使用@code{defvar}初始化变量
这是第8054行
使用@code{defvar}初始化变量包括第8350行
@end ignore

@node Lisp macro
@subsection Lisp macro
@cindex Macro, lisp
@cindex Lisp macro

在期望一切顺利的情况下评估的@code{condition-case}表达式的一部分具有@code{when}。该代码使用@code{when}来确定@code{string}变量是否指向存在的文本。

@code{when}表达式只是程序员的便利。它是一个没有else子句可能性的@code{if}。在你的脑海中，你可以用@code{if}替换@code{when}并理解发生了什么。这就是Lisp解释器所做的。

从技术上讲，@code{when}是一个Lisp宏。Lisp宏使您能够定义新的控制结构和其他语言功能。它告诉解释器如何计算另一个Lisp表达式，该表达式将进而计算值。在这种情况下，另一个表达式是一个@code{if}表达式。

@code{kill-region}函数定义还有一个@code{unless}宏；它是@code{when}的反义词。@code{unless}宏是一个没有then子句的@code{if}。

有关Lisp宏的更多信息，请参阅@ref{Macros, , Macros, elisp, The GNU
Emacs Lisp Reference Manual}。C编程语言也提供宏。它们是不同的，但同样有用。

@ignore
我们将简要查看C中的宏
请参阅@ref{Digression into C}。
@end ignore

@need 1200
关于@code{when}宏，在@code{condition-case}表达式中，当字符串具有内容时，然后执行另一个条件表达式。这是一个带有then-part和else-part的@code{if}。

@smallexample
@group
(if (eq last-command 'kill-region)
    (kill-append string (< end beg) yank-handler)
  (kill-new string nil yank-handler))
@end group
@end smallexample

如果前一个命令是另一个对@code{kill-region}的调用，则评估then-part；否则，评估else-part。

@code{yank-handler}是传递给@code{kill-region}的可选参数，告诉@code{kill-append}和@code{kill-new}函数如何处理添加到文本中的属性，例如粗体或斜体。

@code{last-command}是Emacs附带的一个我们之前没有见过的变量。通常，每当执行函数时，Emacs都会将@code{last-command}的值设置为前一个命令。

@need 1200
在这个定义片段中，@code{if}表达式检查前一个命令是否为@code{kill-region}。如果是，

@smallexample
(kill-append string (< end beg) yank-handler)
@end smallexample

@noindent
将新剪贴文本的副本连接到刚刚剪贴的文本在kill ring中。

@node copy-region-as-kill
@section @code{copy-region-as-kill}
@findex copy-region-as-kill
@findex nthcdr

@code{copy-region-as-kill}函数将文本缓冲区中的一段文本复制并（通过@code{kill-append}或@code{kill-new}）保存在@code{kill-ring}中。

如果在执行@code{kill-region}命令之后立即调用@code{copy-region-as-kill}，Emacs将新复制的文本附加到先前复制的文本上。这意味着如果您粘贴文本，则会得到来自此次和上一次操作的所有文本。另一方面，如果在@code{copy-region-as-kill}之前执行了其他命令，则该函数将文本复制到kill环中的一个单独条目中。

@menu
* Complete copy-region-as-kill::  @code{copy-region-as-kill}函数的完整定义。
* copy-region-as-kill body::      @code{copy-region-as-kill}的主体部分。
@end menu

@ifnottex
@node Complete copy-region-as-kill
@unnumberedsubsec @code{copy-region-as-kill}函数的完整定义
@end ifnottex

@need 1200
以下是版本22的@code{copy-region-as-kill}函数的完整文本：

@smallexample
@group
(defun copy-region-as-kill (beg end)
  "将区域保存为已杀死，但不要杀死它。
在瞬时标记模式下，取消激活标记。
如果`interprogram-cut-function'非空，还为窗口系统剪切和粘贴保存文本。"
  (interactive "r")
@end group
@group
  (if (eq last-command 'kill-region)
      (kill-append (filter-buffer-substring beg end) (< end beg))
    (kill-new (filter-buffer-substring beg end)))
@end group
@group
  (if transient-mark-mode
      (setq deactivate-mark t))
  nil)
@end group
@end smallexample

@need 800
像往常一样，此函数可以分为其组成部分：

@smallexample
@group
(defun copy-region-as-kill (@var{argument-list})
  "@var{documentation}@dots{}"
  (interactive "r")
  @var{body}@dots{})
@end group
@end smallexample

参数是@code{beg}和@code{end}，函数以@code{"r"}交互，因此两个参数必须引用区域的起始和结束。如果您从文档开头阅读到这里，理解函数的这些部分几乎变得很常规。

文档有点令人困惑，除非您记得“kill”一词的意义与通常不同。瞬时标记和@code{interprogram-cut-function}的注释解释了某些副作用。

一旦设置了标记，缓冲区始终包含一个区域。如果愿意，可以使用瞬时标记模式临时突出显示区域。 （没有人希望一直突出显示区域，因此瞬时标记模式仅在适当的时候突出显示。许多人关闭瞬时标记模式，因此区域永远不会被突出显示。）

此外，窗口系统允许在不同程序之间复制、剪切和粘贴。例如，在X窗口系统中，@code{interprogram-cut-function}函数是@code{x-select-text}，它与窗口系统的Emacs kill环的等价物一起工作。

@code{copy-region-as-kill}函数的主体以一个@code{if}子句开始。该子句的作用是区分两种不同的情况：是否立即在先前的@code{kill-region}命令之后执行此命令。在第一种情况下，新区域将附加到先前复制的文本。否则，它将作为一个独立的文本片段插入到kill环的开头。

函数的最后两行阻止区域在瞬时标记模式打开时突出显示。

@node copy-region-as-kill body
@subsection @code{copy-region-as-kill}的主体

@code{copy-region-as-kill}函数的工作方式与@code{kill-region}函数类似。两者都被编写为使连续两次或更多次的杀死将它们的文本组合成单个条目。如果从kill环粘贴文本，则会得到一个整体。此外，从当前光标位置向前杀死的杀死将添加到先前复制的文本的末尾，而将文本向后复制的命令将其添加到先前复制的文本的开头。这样，文本中的单词保持正确的顺序。

与@code{kill-region}一样，@code{copy-region-as-kill}函数利用了@code{last-command}变量，该变量跟踪先前的Emacs命令。

@menu
* last-command & this-command::
* kill-append函数::
* kill-new函数::
@end menu

@ifnottex
@node last-command & this-command
@unnumberedsubsubsec @code{last-command}和@code{this-command}
@end ifnottex

通常情况下，每当执行函数时，Emacs将@code{this-command}的值设置为正在执行的函数（在本例中将是@code{copy-region-as-kill}）。同时，Emacs将@code{last-command}的值设置为@code{this-command}的先前值。

在@code{copy-region-as-kill}函数的主体的第一部分中，一个@code{if}表达式确定@code{last-command}的值是否为@code{kill-region}。如果是，@code{if}表达式的then-part将被评估；它使用@code{kill-append}函数将此次调用函数时复制的文本与kill环的第一个元素（@sc{car}）中已有的文本连接起来。另一方面，如果@code{last-command}的值不是@code{kill-region}，那么@code{copy-region-as-kill}函数将使用@code{kill-new}函数将一个新元素附加到kill环中。

@need 1250
@code{if}表达式如下所示；它使用@code{eq}：

@smallexample
@group
  (if (eq last-command 'kill-region)
      ;; @r{then-part}
      (kill-append  (filter-buffer-substring beg end) (< end beg))
    ;; @r{else-part}
    (kill-new  (filter-buffer-substring beg end)))
@end group
@end smallexample

@findex filter-buffer-substring
（@code{filter-buffer-substring}函数返回缓冲区的过滤子字符串，如果有的话。可选地——这里没有参数，因此也没有做任何事——该函数可以删除初始文本或返回不带其属性的文本；此函数是较早的@code{buffer-substring}函数的替代，该函数在实现文本属性之前出现。）

@findex eq @r{（用法示例）}
@noindent
@code{eq}函数测试其第一个参数是否与其第二个参数相同的Lisp对象。@code{eq}函数类似于@code{equal}函数，因为它用于测试相等性，但不同之处在于它确定两个表示实际上是计算机内部相同对象，只是具有不同的名称。@code{equal}确定两个表达式的结构和内容是否相同。

如果先前的命令是@code{kill-region}，则Emacs Lisp解释器调用@code{kill-append}函数。

@node kill-append 函数
@unnumberedsubsubsec @code{kill-append} 函数
@findex kill-append

@need 800
@code{kill-append} 函数的定义如下：

@c 在GNU Emacs 22中
@smallexample
@group
(defun kill-append (string before-p &optional yank-handler)
  "将STRING追加到kill环中最新的kill的末尾。
如果BEFORE-P非空，则将STRING插入到kill的开头。
@dots{} "
  (let* ((cur (car kill-ring)))
    (kill-new (if before-p (concat string cur) (concat cur string))
              (or (= (length cur) 0)
                  (equal yank-handler
                         (get-text-property 0 'yank-handler cur)))
              yank-handler)))
@end group
@end smallexample

@ignore
曾经的定义:
(defun kill-append (string before-p)
  "将STRING追加到kill环中最新的kill的末尾。
如果BEFORE-P非空，则将STRING插入到kill的开头。
如果`interprogram-cut-function'已设置，则将生成的kill传递给它。"
  (kill-new (if before-p
                (concat string (car kill-ring))
              (concat (car kill-ring) string))
            t))
@end ignore

@noindent
@code{kill-append} 函数非常直观。它使用了稍后我们将详细讨论的 @code{kill-new} 函数。

（此外，该函数提供了一个可选的参数叫做 @code{yank-handler}；当调用时，此参数告诉函数如何处理添加到文本的属性，比如粗体或斜体。）

@c !!! GNU Emacs 22版本中 kill-append 函数的bug？
它使用 @code{let*} 函数将kill环的第一个元素的值设置为 @code{cur}。（我不知道为什么函数不使用 @code{let} 替代；表达式中只设置了一个值。也许这是一个不会产生问题的bug？）

考虑到条件语句是 @code{kill-new} 的两个参数之一。它使用 @code{concat} 将新文本连接到kill环的 @sc{car}（第一个元素）。无论是插入还是追加文本，都取决于 @code{if} 表达式的结果：

@smallexample
@group
(if before-p                            ; @r{if-part}
    (concat string cur)                 ; @r{then-part}
  (concat cur string))                  ; @r{else-part}
@end group
@end smallexample

@noindent
如果要删除的区域位于上一次命令中删除的区域之前，那么它应该插入到之前保存的文本之前；反之，如果删除的文本跟随刚刚删除的文本，它应该追加到先前的文本之后。 @code{if} 表达式依赖于谓词 @code{before-p} 来决定新保存的文本是应该放在先前保存的文本之前还是之后。

符号 @code{before-p} 是 @code{kill-append} 函数的参数之一的名称。当评估 @code{kill-append} 函数时，它被绑定到通过评估实际参数返回的值。在这种情况下，这是表达式 @code{(< end beg)}。此表达式不直接确定此命令中删除的文本是在上次命令中删除的文本之前还是之后；它的作用是确定变量 @code{end} 的值是否小于变量 @code{beg} 的值。如果是，这意味着用户很可能朝着缓冲区的开头前进。此外，谓词表达式 @code{(< end beg)} 的评估结果将为真，文本将在先前文本之前插入。另一方面，如果变量 @code{end} 的值大于变量 @code{beg} 的值，则文本将在先前文本之后追加。

@need 800
当新保存的文本将被插入时，字符串与新文本将被连接到旧文本之前：

@smallexample
(concat string cur)
@end smallexample

@need 1200
@noindent
但如果文本将被追加，它将在旧文本之后连接：

@smallexample
(concat cur string))
@end smallexample

为了理解这是如何工作的，我们首先需要复习一下 @code{concat} 函数。@code{concat} 函数将两个文本字符串链接或合并在一起。结果是一个字符串。例如：

@smallexample
@group
(concat "abc" "def")
     @result{} "abcdef"
@end group

@group
(concat "new "
        (car '("first element" "second element")))
     @result{} "new first element"

(concat (car
        '("first element" "second element")) " modified")
     @result{} "first element modified"
@end group
@end smallexample

现在我们可以理解 @code{kill-append}：它修改了kill环的内容。kill环是一个列表，其中每个元素都是保存的文本。@code{kill-append} 函数使用 @code{kill-new} 函数，后者又使用 @code{setcar} 函数。

@node kill-new 函数
@unnumberedsubsubsec @code{kill-new} 函数
@findex kill-new

@need 1200
在版本22中，@code{kill-new} 函数的定义如下：

@smallexample
@group
(defun kill-new (string &optional replace yank-handler)
  "将STRING设为kill环中的最新kill。
将`kill-ring-yank-pointer'设为指向它。

如果`interprogram-cut-function'非nil，则将其应用于STRING。
可选的第二个参数REPLACE非nil表示STRING将替换
kill环的最前面，而不是被添加到列表中。
@dots{}"
@end group
@group
  (if (> (length string) 0)
      (if yank-handler
          (put-text-property 0 (length string)
                             'yank-handler yank-handler string))
    (if yank-handler
        (signal 'args-out-of-range
                (list string "yank-handler specified for empty string"))))
@end group
@group
  (if (fboundp 'menu-bar-update-yank-menu)
      (menu-bar-update-yank-menu string (and replace (car kill-ring))))
@end group
@group
  (if (and replace kill-ring)
      (setcar kill-ring string)
    (push string kill-ring)
    (if (> (length kill-ring) kill-ring-max)
        (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
@end group
@group
  (setq kill-ring-yank-pointer kill-ring)
  (if interprogram-cut-function
      (funcall interprogram-cut-function string (not replace))))
@end group
@end smallexample
@ignore
原先的定义：
(defun kill-new (string &optional replace)
  "将STRING设为kill环中的最新kill。
将kill-ring-yank指针设为指向它。
如果`interprogram-cut-function'非nil，则将其应用于STRING。
可选的第二个参数REPLACE非nil表示STRING将替换
kill环的最前面，而不是被添加到列表中。"
  (and (fboundp 'menu-bar-update-yank-menu)
       (menu-bar-update-yank-menu string (and replace (car kill-ring))))
  (if (and replace kill-ring)
      (setcar kill-ring string)
    (setq kill-ring (cons string kill-ring))
    (if (> (length kill-ring) kill-ring-max)
        (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
  (setq kill-ring-yank-pointer kill-ring)
  (if interprogram-cut-function
      (funcall interprogram-cut-function string (not replace))))
@end ignore

（注意，此函数不是交互式的。）

和往常一样，我们可以将这个函数分为几个部分来看。

函数定义有一个可选的@code{yank-handler}参数，
当调用时告诉函数如何处理添加到文本中的属性，比如粗体或斜体。我们将跳过这一点。

@need 1200
文档的第一行有意义：

@smallexample
将STRING设为kill环中的最新kill。
@end smallexample

@noindent
让我们暂时跳过文档的其余部分。

@noindent
同样，让我们跳过初始的@code{if}表达式以及涉及@code{menu-bar-update-yank-menu}的那些行代码。我们将在下面解释它们。

@need 1200
关键的代码在这里：

@smallexample
@group
  (if (and replace kill-ring)
      ;; @r{然后}
      (setcar kill-ring string)
@end group
@group
    ;; @r{否则}
    (push string kill-ring)
@end group
@group
    (if (> (length kill-ring) kill-ring-max)
        ;; @r{避免kill环过长}
        (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
@end group
@group
  (setq kill-ring-yank-pointer kill-ring)
  (if interprogram-cut-function
      (funcall interprogram-cut-function string (not replace))))
@end group
@end smallexample

条件测试是 @w{@code{(and replace kill-ring)}}。
当满足两个条件时，这将为真：kill环中有内容，并且@code{replace}变量为真。

@need 1250
当@code{kill-append}函数将@code{replace}设置为真时，且kill环中至少有一项时，将执行@code{setcar}表达式：

@smallexample
(setcar kill-ring string)
@end smallexample

@code{setcar}函数实际上将@code{kill-ring}列表的第一个元素更改为@code{string}的值。它替换第一个元素。

@need 1250
另一方面，如果kill环为空，或者replace为假，则执行条件的else部分：

@smallexample
(push string kill-ring)
@end smallexample

@noindent
@need 1250
@code{push}将其第一个参数推入第二个参数。它类似于较旧的

@smallexample
(setq kill-ring (cons string kill-ring))
@end smallexample

@noindent
@need 1250
或者较新的

@smallexample
(add-to-list kill-ring string)
@end smallexample

@noindent
当为假时，表达式首先通过将要被杀死的字符串作为新元素添加到旧kill环中构造了新版本的kill环（这就是@code{push}的作用）。然后它执行第二个@code{if}子句。这第二个@code{if}子句防止kill环变得过长。

让我们按顺序查看这两个表达式。

@code{push} else-part的行将新的kill环的值设置为将要被杀死的字符串添加到旧kill环中得到的值。

通过以下示例，我们可以看到它是如何工作的。

@need 800
首先，

@smallexample
(setq example-list '("here is a clause" "another clause"))
@end smallexample

@need 1200
@noindent
通过使用@kbd{C-x C-e}评估此表达式后，您可以评估@code{example-list}并查看其返回值：

@smallexample
@group
example-list
     @result{} ("here is a clause" "another clause")
@end group
@end smallexample

@need 1200
@noindent
现在，我们可以通过评估以下表达式将一个新元素添加到此列表中：
@findex push@r{, example}

@smallexample
(push "a third clause" example-list)
@end smallexample

@need 800
@noindent
当我们评估@code{example-list}时，我们发现其值为：

@smallexample
@group
example-list
     @result{} ("a third clause" "here is a clause" "another clause")
@end group
@end smallexample

@noindent
因此，通过@code{push}添加了第三个子句。

@need 1200
现在是@code{if}子句的第二部分。此表达式防止kill环变得过长。它看起来是这样的：

@smallexample
@group
(if (> (length kill-ring) kill-ring-max)
    (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil))
@end group
@end smallexample

代码检查kill环的长度是否大于允许的最大长度。这是@code{kill-ring-max}（默认为120）的值。如果kill环的长度太长，则此代码将最后一个元素设置为@code{nil}。它通过使用两个函数@code{nthcdr}和@code{setcdr}来实现。

我们之前看过@code{setcdr}（@pxref{setcdr, , @code{setcdr}}）。它设置列表的@sc{cdr}，就像@code{setcar}设置列表的@sc{car}一样。但是，在这种情况下，@code{setcdr}不会设置整个kill环的@sc{cdr}；@code{nthcdr}函数用于使其设置kill环的倒数第二个元素的@sc{cdr}——这意味着由于倒数第二个元素的@sc{cdr}是kill环的最后一个元素，它将设置kill环的最后一个元素。

@findex nthcdr@r{, example}
@code{nthcdr}函数通过重复获取列表的@sc{cdr}来工作——它获取@sc{cdr}的@sc{cdr}的@sc{cdr}等等。它这样做@var{N}次并返回结果。(@xref{nthcdr, , @code{nthcdr}}.)

@findex setcdr@r{, example}
因此，如果我们有一个应该是三个元素长的四个元素列表，我们可以将倒数第二个元素的@sc{cdr}设置为@code{nil}，从而缩短列表。（如果将最后一个元素设置为除@code{nil}之外的其他值，您可以这样做，那么您将不会缩短列表。@xref{setcdr, , @code{setcdr}}.）

通过依次评估以下三个表达式，您可以看到缩短的效果。首先将@code{trees}的值设置为@code{(maple oak pine birch)}，然后将其第二个@sc{cdr}的@sc{cdr}设置为@code{nil}，然后找到@code{trees}的值：

@smallexample
@group
(setq trees (list 'maple 'oak 'pine 'birch))
     @result{} (maple oak pine birch)
@end group

@group
(setcdr (nthcdr 2 trees) nil)
     @result{} nil

trees
     @result{} (maple oak pine)
@end group
@end smallexample

@noindent
(@code{setcdr}表达式返回的值为@code{nil}，因为它将@sc{cdr}设置为@code{nil}。)

重申一下，在@code{kill-new}中，@code{nthcdr}函数取kill环的最大允许大小减一的次数，@code{setcdr}函数将其@sc{cdr}设置为那个元素（这意味着由于倒数第二个元素的@sc{cdr}是kill环的最后一个元素，它将设置kill环的最后一个元素）。这样可以防止kill环变得过长。

@need 800
@code{kill-new}函数中倒数第二个表达式是

@smallexample
(setq kill-ring-yank-pointer kill-ring)
@end smallexample

@code{kill-ring-yank-pointer}是一个全局变量，被设置为@code{kill-ring}。

尽管@code{kill-ring-yank-pointer}被称为@samp{指针}，但它和kill环一样是一个变量。但是，为了帮助人们理解该变量的用法，选择了这个名称。

@need 1200
现在，回到函数体中的早期表达式：

@smallexample
@group
  (if (fboundp 'menu-bar-update-yank-menu)
       (menu-bar-update-yank-menu string (and replace (car kill-ring))))
@end group
@end smallexample

@noindent
它以一个@code{if}表达式开始

在这种情况下，该表达式首先测试@code{menu-bar-update-yank-menu}是否存在作为函数，并且如果存在，则调用它。@code{fboundp}函数返回true，如果它测试的符号具有非空的函数定义。如果符号的函数定义为空，我们将收到错误消息，就像我们故意创建错误一样（@pxref{Making Errors, , 生成错误消息}）。

@noindent
然后部分包含一个表达式，其第一个元素是@code{and}函数。

@findex and
特殊形式 @code{and} 对其每个参数进行求值，直到其中一个参数返回值为 @code{nil} 为止，此时 @code{and} 表达式返回 @code{nil}；然而，如果没有任何参数返回 @code{nil}，则返回最后一个参数的求值结果。 （由于这样的值不是 @code{nil}，在Emacs Lisp中被视为真值。）换句话说，只有当所有参数都为真时，@code{and} 表达式才返回真值。(@xref{第二缓冲区相关复习}.)

该表达式确定了 @code{menu-bar-update-yank-menu} 的第二个参数是否为真。
@ignore
    ;; 如果我们应该扩展现有字符串，并且该字符串确实位于菜单的前面，则原地更新它。
@end ignore

@code{menu-bar-update-yank-menu} 是使得可以在菜单条的编辑项目的“选择和粘贴”菜单中使用的函数之一；使用鼠标，您可以查看已保存的各种文本片段，并选择一个片段进行粘贴。

@code{kill-new} 函数中的最后一个表达式将新复制的字符串添加到用于在窗口系统中运行的不同程序之间复制和粘贴的任何设施中。例如，在X Windowing系统中，@code{x-select-text} 函数将字符串存储在由X操作的内存中。您可以在另一个程序中粘贴该字符串，例如Xterm。

@need 1200
该表达式如下：

@smallexample
@group
  (if interprogram-cut-function
      (funcall interprogram-cut-function string (not replace))))
@end group
@end smallexample

如果存在 @code{interprogram-cut-function}，则Emacs执行 @code{funcall}，它又调用其第一个参数作为函数，并将其余参数传递给它。 （顺便说一下，就我所看到的，此 @code{if} 表达式可以被类似于函数第一部分的 @code{and} 表达式替代。）

我们不打算进一步讨论窗口系统和其他程序，只是注意到这是一种使GNU Emacs能够轻松而有效地与其他程序协同工作的机制。

这段代码用于将文本放入kill环中，可以是与现有元素连接，也可以是作为新元素。这引导我们进入了从缓冲区中删除文本的代码——yank命令。但在讨论yank命令之前，最好先了解计算机中列表是如何实现的。这将解释“指针”一词的使用。但在此之前，我们将离题讨论C。

@ignore
@c 这在Emacs 22中是真的吗？似乎不是

  （如果表达式 @w{@code{(< end beg))}} 为真，则 @code{kill-append} 将字符串前置到刚刚剪切的文本之前。有关详细讨论，请参阅 @ref{kill-append function, , The @code{kill-append} function}.）

如果然后将文本还原，即粘贴它，则可以同时获得两个文本片段。这样，如果您连续删除两个单词，然后将它们还原，您将以正确的顺序获得两个单词，一次性粘贴。（表达式 @w{@code{(< end beg))}} 确保顺序正确。）

另一方面，如果前一个命令不是 @code{kill-region}，那么将调用 @code{kill-new} 函数，该函数将文本添加到kill环中作为最新的项，并将 @code{kill-ring-yank-pointer} 变量设置为指向它。
@end ignore
@ignore

@c 显然，Emacs 22有所更改。zap-to-char命令不使用delete-and-extract-region函数

2006年10月26日，C离题现在可以了，但应该在copy-region-as-kill和filter-buffer-substring之后

2006年10月24日
在Emacs 22中，
copy-region-as-kill很短，12行，使用
filter-buffer-substring，它更长，有39行
并包含其中的delete-and-extract-region。
delete-and-extract-region是用C编写的。

参见使用 @code{defvar} 初始化变量
@end ignore

@node 进入C的插曲
@section 进入C的插曲
@findex delete-and-extract-region
@cindex C，进入C的插曲
@cindex 进入C的插曲

@code{copy-region-as-kill} 函数（参见@pxref{copy-region-as-kill, , @code{copy-region-as-kill}}）使用了 @code{filter-buffer-substring} 函数，而该函数又使用了 @code{delete-and-extract-region} 函数。它会删除区域的内容，而且一旦删除就无法还原。

与这里讨论的其他代码不同，@code{delete-and-extract-region} 函数不是用Emacs Lisp编写的；它是用C编写的，是GNU Emacs系统的原语之一。由于它非常简单，我将简要离开Lisp并在这里描述它。

@need 1500
与许多其他Emacs原语一样，@code{delete-and-extract-region} 作为C宏的实例编写，宏是代码的模板。完整的宏如下：

@c 这是editfns.c中用于delete-and-extract-region的DEFUN的副本。
@smallexample
@group
DEFUN ("delete-and-extract-region", Fdelete_and_extract_region,
       Sdelete_and_extract_region, 2, 2, 0,
       doc: /* 删除START和END之间的文本并返回它。 */)
  (Lisp_Object start, Lisp_Object end)
@{
  validate_region (&start, &end);
  if (XFIXNUM (start) == XFIXNUM (end))
    return empty_unibyte_string;
  return del_range_1 (XFIXNUM (start), XFIXNUM (end), 1, 1);
@}
@end group
@end smallexample

在不深入宏编写过程的细节的情况下，让我指出该宏以单词 @code{DEFUN} 开头。选择单词 @code{DEFUN} 是因为该代码与Lisp中的 @code{defun} 具有相同的目的。（@code{DEFUN} C宏在@file{emacs/src/lisp.h}中定义。）

单词 @code{DEFUN} 后面跟着括号内的七个部分：

@itemize @bullet
@item
第一个部分是Lisp中给定的函数名称，@code{delete-and-extract-region}。

@item
第二部分是C中的函数名称，@code{Fdelete_and_extract_region}。按照惯例，它以 @samp{F} 开头。由于C中不使用连字符，而是使用下划线。

@item
第三部分是记录此函数信息以供内部使用的C常量结构的名称。它是C中函数的名称，但以 @samp{S} 开头而不是 @samp{F}。

@item
第四和第五部分指定函数可以有的参数的最小和最大数量。此函数要求精确地有2个参数。

@item
第六部分几乎与在Lisp中编写的函数中的 @code{interactive} 声明后面的参数相似：一个字母，然后是一个提示，也许还有一个数字。与Lisp不同的是，当使用零参数调用宏时。然后你写一个 @code{0}（它是一个空字符串），就像这个宏一样。

如果要指定参数，你会将它们放在引号之间。用于 @code{goto-char} 的C宏包括在此位置添加 @code{"NGoto char: "} 以指示该函数期望一个原始前缀，这种情况下是缓冲区中的数值位置，并提供提示。

@item
第七部分是文档字符串，就像Emacs Lisp中的函数的文档字符串一样。这是以C注释的形式编写的。（构建Emacs时，程序@command{lib-src/make-docfile}提取这些注释并用它们制作文档。）
@end itemize

@need 1200
在C宏中，接下来是形式参数，包括对象类型的说明，然后是宏的主体。对于 @code{delete-and-extract-region}，主体包括以下四行：

@smallexample
@group
validate_region (&start, &end);
if (XFIXNUM (start) == XFIXNUM (end))
  return empty_unibyte_string;
return del_range_1 (XFIXNUM (start), XFIXNUM (end), 1, 1);
@end group
@end smallexample

@code{validate_region} 函数检查作为区域开始和结束传递的值是否是正确的类型并且是否在范围内。如果开始和结束位置相同，则返回一个空字符串。

@code{del_range_1} 函数实际上删除文本。这是一个复杂的函数，我们不会深入研究。它更新缓冲区并执行其他操作。但是，值得注意的是传递给 @code{del_range_1} 的两个参数。这些是 @w{@code{XFIXNUM (start)}} 和 @w{@code{XFIXNUM (end)}}。

就C语言而言，@code{start} 和 @code{end} 是标记要删除的区域的开始和结束的两个不透明的值。更准确地说，需要更多专业知识才能理解，这两个值的类型是 @code{Lisp_Object}，它可能是C指针、C整数或C结构；C代码通常不应关心 @code{Lisp_Object} 的实现方式。

@samp{XFIXNUM} 是一个C宏，从较长的比特集中提取相关整数；类型比特被丢弃。

@need 800
@code{delete-and-extract-region} 中的命令如下：

@smallexample
del_range_1 (XFIXNUM (start), XFIXNUM (end), 1, 1);
@end smallexample

@noindent
它删除开始位置 @code{start} 和结束位置 @code{end} 之间的区域。

从编写Lisp的人的角度来看，Emacs非常简单；但是在底层隐藏着大量的复杂性，以使一切正常工作。

@node defvar
@section 使用 @code{defvar} 初始化变量
@findex defvar
@cindex 初始化变量
@cindex 变量初始化

@ignore
2006年10月24日
在Emacs 22中，
copy-region-as-kill 很短，有12行，使用了
filter-buffer-substring，它更长，有39行
并且其中包含了delete-and-extract-region。
delete-and-extract-region是用C语言编写的。

见 使用 @code{defvar} 初始化变量

@end ignore

@code{copy-region-as-kill} 函数是用Emacs Lisp编写的。其中的两个函数，@code{kill-append} 和 @code{kill-new}，复制缓冲区中的一段区域并将其保存在一个名为 @code{kill-ring} 的变量中。本节描述了如何使用 @code{defvar} 特殊形式创建和初始化 @code{kill-ring} 变量。

（再次注意，术语 @code{kill-ring} 是不准确的。从缓冲区中剪切出来的文本可以被还原；它不是一个尸体环，而是一个可以复活的文本环。）

在Emacs Lisp中，诸如 @code{kill-ring} 这样的变量是通过使用 @code{defvar} 特殊形式创建并赋予初始值的。其名称来自于“定义变量”。

@code{defvar} 特殊形式类似于 @code{setq}，因为它设置变量的值。但与 @code{setq} 不同的有两点：首先，它仅在变量尚未具有值时设置变量的值。如果变量已经有值，@code{defvar} 就不会覆盖现有值。其次，@code{defvar} 具有文档字符串。

（有一个相关的宏，@code{defcustom}，用于用户自定义的变量。它比 @code{defvar} 更强大。
（@xref{defcustom, , 使用 @code{defcustom} 设置变量}。）

@menu
* 查看变量当前值::
* defvar 和星号::
@end menu

@ifnottex
@node 查看变量当前值
@unnumberedsubsec 查看变量的当前值
@end ifnottex

您可以使用 @code{describe-variable} 函数查看任何变量的当前值，通常通过键入 @kbd{C-h v} 调用。如果在提示时键入 @kbd{C-h v} 然后键入 @code{kill-ring}（然后按 @key{RET}），您将看到当前剪切环中的内容，这可能很多！相反，如果在本次Emacs会话中除了阅读本文档之外什么都没有做，那么可能什么都没有。此外，您将看到 @code{kill-ring} 的文档：

@smallexample
@group
文档：
已删除文本序列的列表。
由于剪切环应该与窗口系统提供的剪切和粘贴功能良好地交互，因此应使用此变量
@end group
@group
与`interprogram-cut-function'和
`interprogram-paste-function'良好交互。 函数`kill-new'，
`kill-append'和`current-kill'应实现此交互；
您可能希望使用它们而不是直接操作剪切环。
@end group
@end smallexample

@need 800
剪切环的定义如下：

@smallexample
@group
(defvar kill-ring nil
  "已删除文本序列的列表。
@dots{}")
@end group
@end smallexample

@noindent
在此变量定义中，变量被赋予初始值 @code{nil}，这是有道理的，因为如果您没有保存任何内容，那么在执行 @code{yank} 命令时您希望得到空白。文档字符串的写法与 @code{defun} 的文档字符串相同。与 @code{defun} 的文档字符串一样，文档的第一行应该是一个完整的句子，因为一些命令（如 @code{apropos}）仅打印文档的第一行。后续行不应缩进，否则在使用 @kbd{C-h v}（@code{describe-variable}）时会显得奇怪。

@node defvar 和星号
@subsection @code{defvar} 和星号
@findex defvar @r{用于用户可定制的变量}
@findex defvar @r{带有星号}

过去，Emacs 在内部变量和用户可能更改的变量上都使用了 @code{defvar} 特殊形式。尽管您仍然可以使用 @code{defvar} 来定义用户可定制的变量，请改用 @code{defcustom}，因为它提供了进入定制命令的路径。
（@xref{defcustom, , 使用 @code{defcustom} 指定变量}。）

当使用 @code{defvar} 特殊形式指定变量时，您可以通过在其文档字符串的第一列键入星号（@samp{*}）来区分用户可能想更改的变量和其他变量。例如：

@smallexample
@group
(defvar shell-command-default-error-buffer nil
  "*'shell-command' @dots{}错误输出的缓冲区名称。
@dots{} ")
@end group
@end smallexample

@findex set-variable
@noindent
您可以（仍然可以）使用 @code{set-variable} 命令临时更改 @code{shell-command-default-error-buffer} 的值。但是，使用 @code{set-variable} 设置的选项仅在编辑会话期间设置。新值在会话之间不会保存。每次Emacs启动时，它都会读取原始值，除非您在 @file{.emacs} 文件中更改了该值，要么手动设置它，要么使用 @code{customize}。
@xref{Emacs Initialization, , 您的 @file{.emacs} 文件}。

对我来说，@code{set-variable} 命令的主要用途是建议我可能希望在 @file{.emacs} 文件中设置的变量。现在有700多个这样的变量，太多了，记不住。幸运的是，在调用 @code{M-x set-variable} 命令后，您可以按 @key{TAB} 键查看变量的列表。
（@xref{Examining, , 检查和设置变量, emacs, GNU Emacs手册}。）

@need 1250
@node cons & search-fwd Review
@section Review

这里是一些最近引入的函数的简要概述。

@table @code
@item car
@itemx cdr
@code{car} 返回列表的第一个元素；@code{cdr} 返回列表的第二个及后续元素。

@need 1250
例如：

@smallexample
@group
(car '(1 2 3 4 5 6 7))
     @result{} 1
(cdr '(1 2 3 4 5 6 7))
     @result{} (2 3 4 5 6 7)
@end group
@end smallexample

@item cons
@code{cons}通过将其第一个参数添加到其第二个参数前构造一个列表。

@need 1250
例如：

@smallexample
@group
(cons 1 '(2 3 4))
     @result{} (1 2 3 4)
@end group
@end smallexample

@item funcall
@code{funcall} 将其第一个参数作为函数求值，并将其余参数传递给其第一个参数。

@item nthcdr
返回在列表上对 @sc{cdr} 进行 @var{n} 次操作的结果。
@iftex
这是
@tex
$n^{th}$
@end tex
@code{cdr}。
@end iftex
可以看作是“剩下的剩下”。

@need 1250
例如：

@smallexample
@group
(nthcdr 3 '(1 2 3 4 5 6 7))
     @result{} (4 5 6 7)
@end group
@end smallexample

@item setcar
@itemx setcdr
@code{setcar} 改变列表的第一个元素；@code{setcdr} 改变列表的第二个及后续元素。

@need 1250
例如：

@smallexample
@group
(setq triple (list 1 2 3))

(setcar triple '37)

triple
     @result{} (37 2 3)

(setcdr triple '("foo" "bar"))

triple
     @result{} (37 "foo" "bar")
@end group
@end smallexample

@item progn
按顺序评估每个参数，然后返回最后一个的值。

@need 1250
例如：

@smallexample
@group
(progn 1 2 3 4)
     @result{} 4
@end group
@end smallexample

@item save-restriction
记录当前缓冲区中生效的任何缩小范围，并在评估参数后恢复该缩小。

@item search-forward
搜索字符串，如果找到，移动点。使用正则表达式时，请使用类似的 @code{re-search-forward}。
(@xref{Regexp Search, , 正则表达式搜索}，了解正则表达式模式和搜索的解释。)

@need 1250
@noindent
@code{search-forward} 和 @code{re-search-forward} 需要四个参数：

@enumerate
@item
要搜索的字符串或正则表达式。

@item
可选地，搜索的限制。

@item
可选地，如果搜索失败，返回 @code{nil} 或错误消息。

@item
可选地，重复搜索的次数；如果为负数，则向后搜索。
@end enumerate

@item kill-region
@itemx delete-and-extract-region
@itemx copy-region-as-kill

@code{kill-region} 剪切点和标记之间的文本，并将该文本存储在kill ring中，因此您可以通过粘贴将其取回。

@code{copy-region-as-kill} 将点和标记之间的文本复制到kill ring中，可以通过粘贴获取。该函数不会从缓冲区中删除文本。

@end table

@code{delete-and-extract-region} 从缓冲区中移除点和标记之间的文本并将其丢弃。您无法再获取它。 (这不是一个交互式命令。)

@need 1500
@node search Exercises
@section 搜索练习

@itemize @bullet
@item
编写一个交互式函数，用于搜索字符串。如果搜索找到字符串，将光标放在字符串后面并显示消息：“找到了！”（请勿使用@code{search-forward}作为此函数的名称；如果这样做，将覆盖Emacs自带的@code{search-forward}版本。请使用诸如@code{test-search}的名称。）

@item
编写一个函数，在回显区域打印剪切环的第三个元素（如果存在）；如果剪切环不包含第三个元素，则打印相应的消息。
@end itemize

@node 列表实现
@chapter 如何实现列表
@cindex 计算机中的列表

在Lisp中，原子以一种直截了当的方式记录；如果在实践中实现不够直截了当，理论上仍然是直截了当的。例如，原子 @samp{rose} 被记录为四个连续的字母 @samp{r}、@samp{o}、@samp{s}、@samp{e}。然而，列表的存储方式不同。机制同样简单，但需要一些时间来适应这个概念。列表使用一系列指针对来维护。在这个系列中，每对中的第一个指针指向一个原子或另一个列表，而每对中的第二个指针指向下一对，或者指向表示列表结束的符号 @code{nil}。

指针本身就是指向所指对象的电子地址。因此，列表被保存为一系列电子地址。

@menu
* 列表示意图::
* 符号作为箱子::       探索一个强有力的隐喻。
* 列表练习::
@end menu

@ifnottex
@node 列表示意图
@unnumberedsec 列表示意图
@end ifnottex

例如，列表 @code{(rose violet buttercup)} 有三个元素，@samp{rose}、@samp{violet} 和 @samp{buttercup}。在计算机中，@samp{rose} 的电子地址记录在称为 @dfn{cons cell}（因为它实际上是函数 @code{cons} 创建的东西）的计算机内存段中。该 cons cell 还保存了指向第二个 cons cell 的地址，其 @sc{car} 是原子 @samp{violet}；而该地址（指示如何找到 @samp{violet} 的地址）与保存原子 @samp{buttercup} 的地址一起保存在第三个 cons cell 的地址中。

@need 1200
这听起来比实际上更复杂，但在图表中更容易理解：

@c 清除打印后期图形
@c !!! cons-cell-diagram #1
@ifnottex
@smallexample
@group
    ___ ___      ___ ___      ___ ___
   |___|___|--> |___|___|--> |___|___|--> nil
     |            |            |
     |            |            |
      --> rose     --> violet   --> buttercup
@end group
@end smallexample
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-1}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
    ___ ___      ___ ___      ___ ___
   |___|___|--> |___|___|--> |___|___|--> nil
     |            |            |
     |            |            |
      --> rose     --> violet   --> buttercup
@end group
@end smallexample
@end iftex
@end ifclear

@noindent
在图表中，每个框表示计算机内存中的一个字，通常以内存地址的形式保存一个Lisp对象。框，即地址，是成对出现的。每个箭头指向地址所指的内容，要么是一个原子，要么是另一对地址。第一个框是 @samp{rose} 的电子地址，箭头指向 @samp{rose}；第二个框是下一对框的地址，其第一部分是 @samp{violet} 的地址，第二部分是下一对的地址。最后一个框指向符号 @code{nil}，表示列表的结束。

@need 1200
当变量使用诸如 @code{setq} 这样的操作设置为列表时，它将存储在变量中的第一个框的地址。因此，表达式的求值

@smallexample
(setq bouquet '(rose violet buttercup))
@end smallexample

@need 1250
@noindent
会创建这样的情况：

@c cons-cell-diagram #2
@ifnottex
@smallexample
@group
bouquet
     |
     |     ___ ___      ___ ___      ___ ___
      --> |___|___|--> |___|___|--> |___|___|--> nil
            |            |            |
            |            |            |
             --> rose     --> violet   --> buttercup
@end group
@end smallexample
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-2}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
bouquet
     |
     |     ___ ___      ___ ___      ___ ___
      --> |___|___|--> |___|___|--> |___|___|--> nil
            |            |            |
            |            |            |
             --> rose     --> violet   --> buttercup
@end group
@end smallexample
@end iftex
@end ifclear

@noindent
在此示例中，符号 @code{bouquet} 持有第一对框的地址。

@need 1200
相同的列表可以用不同类型的框符号表示，如下所示：

@c cons-cell-diagram #2a
@ifnottex
@smallexample
@group
bouquet
 |
 |    --------------       ---------------       ----------------
 |   | car   | cdr  |     | car    | cdr  |     | car     | cdr  |
  -->| rose  |   o------->| violet |   o------->| butter- |  nil |
     |       |      |     |        |      |     | cup     |      |
      --------------       ---------------       ----------------
@end group
@end smallexample
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-2a}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
bouquet
 |
 |    --------------       ---------------       ----------------
 |   | car   | cdr  |     | car    | cdr  |     | car     | cdr  |
  -->| rose  |   o------->| violet |   o------->| butter- |  nil |
     |       |      |     |        |      |     | cup     |      |
      --------------       ---------------       ----------------
@end group
@end smallexample
@end iftex
@end ifclear

（符号由不仅仅是地址对组成，但符号的结构由地址组成。实际上，符号 @code{bouquet} 由一组地址框组成，其中一个是打印字 @samp{bouquet} 的地址，第二个是附加到符号的函数定义的地址（如果有的话），第三个是列表 @code{(rose violet buttercup)} 的地址的第一对地址框，依此类推。这里我们显示符号的第三个地址框指向列表的第一对地址框。）

如果将符号设置为列表的 @sc{cdr}，列表本身不会改变；符号只是具有列表中更远地址的地址。 （在行话中，@sc{car} 和 @sc{cdr} 是“非破坏性的”）因此，对以下表达式的求值

@smallexample
(setq flowers (cdr bouquet))
@end smallexample

@need 800
@noindent
会产生：

@c cons-cell-diagram #3
@ifnottex
@sp 1
@smallexample
@group
bouquet        flowers
  |              |
  |     ___ ___  |     ___ ___      ___ ___
   --> |   |   |  --> |   |   |    |   |   |
       |___|___|----> |___|___|--> |___|___|--> nil
         |              |            |
         |              |            |
          --> rose       --> violet   --> buttercup
@end group
@end smallexample
@sp 1
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-3}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@sp 1
@smallexample
@group
bouquet        flowers
  |              |
  |     ___ ___  |     ___ ___      ___ ___
   --> |   |   |  --> |   |   |    |   |   |
       |___|___|----> |___|___|--> |___|___|--> nil
         |              |            |
         |              |            |
          --> rose       --> violet   --> buttercup
@end group
@end smallexample
@sp 1
@end iftex
@end ifclear

@need 1200
@noindent
变量 @code{flowers} 的值是 @code{(violet buttercup)}，也就是说，符号 @code{flowers} 持有地址的对应的框，其中第一个框持有 @code{violet} 的地址，第二个框持有 @code{buttercup} 的地址。

@cindex 点对
@cindex cons cell
一对地址框称为 @dfn{cons cell} 或 @dfn{点对}。有关 cons cell 和点对的更多信息，请参见 @xref{Cons Cell Type, , Cons Cell and List Types, elisp, The GNU Emacs Lisp Reference Manual}，以及 @ref{Dotted Pair Notation, , Dotted Pair Notation, elisp, The GNU Emacs Lisp Reference Manual}。

@need 1200
函数 @code{cons} 将一个新的地址对添加到上面所示的地址系列的前面。例如，对以下表达式的求值

@smallexample
(setq bouquet (cons 'lily bouquet))
@end smallexample

@need 1500
@noindent
产生：

@c cons-cell-diagram #4
@ifnottex
@sp 1
@smallexample
@group
bouquet                       flowers
  |                             |
  |     ___ ___        ___ ___  |     ___ ___       ___ ___
   --> |   |   |      |   |   |  --> |   |   |     |   |   |
       |___|___|----> |___|___|----> |___|___|---->|___|___|--> nil
         |              |              |             |
         |              |              |             |
          --> lily      --> rose       --> violet    --> buttercup
@end group
@end smallexample
@sp 1
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-4}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@sp 1
@smallexample
@group
bouquet                       flowers
  |                             |
  |     ___ ___        ___ ___  |     ___ ___       ___ ___
   --> |   |   |      |   |   |  --> |   |   |     |   |   |
       |___|___|----> |___|___|----> |___|___|---->|___|___|--> nil
         |              |              |             |
         |              |              |             |
          --> lily      --> rose       --> violet    --> buttercup
@end group
@end smallexample
@sp 1
@end iftex
@end ifclear

@need 1200
@noindent
然而，这并不会改变符号 @code{flowers} 的值，可以通过求值以下表达式来查看：

@smallexample
(eq (cdr (cdr bouquet)) flowers)
@end smallexample

@noindent
这会返回 @code{t}，表示为真。

在被重新设置之前，@code{flowers} 仍然具有值 @code{(violet buttercup)}；也就是说，它持有第一个框的地址，该框的第一个地址是 @code{violet}。

总而言之，在Lisp中，要获得列表的 @sc{cdr}，只需获取系列中下一个 cons cell 的地址；要获取列表的 @sc{car}，只需获取列表的第一个元素的地址；要在列表前面添加新元素，只需在列表的前面添加一个新的 cons cell。就是这样！Lisp的底层结构非常简单！

而在一系列 cons 单元中，最后一个地址指向什么呢？它指向空列表，即 @code{nil} 的地址。

总之，当一个 Lisp 变量被设置为某个值时，它会被赋予指向该变量所引用的列表的地址。

@node 符号作为抽屉
@section 符号作为抽屉式储物柜
@cindex 符号作为抽屉式储物柜
@cindex 抽屉式储物柜，作为符号的隐喻
@cindex 抽屉，抽屉式储物柜，作为符号的隐喻

在早期的一节中，我建议你将符号想象成一个抽屉式储物柜。一个抽屉放置函数定义，另一个抽屉放置值，依此类推。放在存放值的抽屉中的内容可以更改，而不影响放置函数定义的抽屉中的内容，反之亦然。

实际上，放在每个抽屉中的是值或函数定义的地址。就好像你在阁楼上发现了一只旧箱子，在其中一个抽屉里找到了一张地图，指引你找到埋藏的宝藏的地方。

（除了名称、符号定义和变量值之外，符号还有一个用于记录其他信息的@dfn{属性列表}抽屉。这里不讨论属性列表；请参阅@ref{Property Lists, , Property Lists, elisp，GNU Emacs Lisp参考手册}。）

@need 1500
这里是一个幻想的表示：

@c 抽屉式储物柜图表
@ifnottex
@sp 1
@smallexample
@group
            抽屉式储物柜            抽屉的内容

            __   o0O0o   __
          /                 \
         ---------------------
        |    符号名称的方向    |            [指向地图]
        |                     |             花束
        +---------------------+
        |    符号定义的方向    |
        |                     |             [无]
        +---------------------+
        |    变量值的方向      |            [指向地图]
        |                     |             (玫瑰 紫罗兰 毛茛)
        +---------------------+
        |    属性列表的方向    |             [这里不描述]
        |                     |
        +---------------------+
        |/                   \|
@end group
@end smallexample
@sp 1
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{drawers}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@sp 1
@smallexample
@group
            抽屉式储物柜            抽屉的内容

            __   o0O0o   __
          /                 \
         ---------------------
        |    符号名称的方向    |            [指向地图]
        |                     |             花束
        +---------------------+
        |    符号定义的方向    |
        |                     |             [无]
        +---------------------+
        |    变量值的方向      |            [指向地图]
        |                     |             (玫瑰 紫罗兰 毛茛)
        +---------------------+
        |    属性列表的方向    |             [这里不描述]
        |                     |
        +---------------------+
        |/                   \|
@end group
@end smallexample
@sp 1
@end iftex
@end ifclear

@node 列表练习
@section 练习

将@code{flowers}设置为@code{violet}和@code{buttercup}。在这个列表上再连接两朵花，并将这个新列表设置为@code{more-flowers}。将@code{flowers}的@sc{car}设置为一条鱼。现在，@code{more-flowers}列表包含什么？

@node 插入文本
@chapter 插入文本
@findex 插入
@cindex 文本检索
@cindex 检索文本
@cindex 粘贴文本

在GNU Emacs中，每当你使用一个kill命令从缓冲区中剪切文本，你都可以使用yank命令将其还原。从缓冲区中剪切出的文本被放入kill环中，而yank命令则将kill环的相应内容插入到缓冲区中（不一定是原始缓冲区）。

一个简单的@kbd{C-y}（@code{yank}）命令将kill环中的第一个条目插入到当前缓冲区中。如果@kbd{C-y}命令后面紧跟着@kbd{M-y}，那么第一个元素将被第二个元素替换。随后的@kbd{M-y}命令将第二个元素替换为第三个、第四个或第五个元素，依此类推。当达到kill环中的最后一个元素时，它将被第一个元素替换，然后循环重复。（因此，kill环被称为“环”而不仅仅是一个“列表”。然而，实际保存文本的数据结构是一个列表。@xref{Kill Ring, , 处理Kill环}，了解如何将列表作为环处理的详细信息。）

@menu
* Kill环概述::
* kill-ring-yank-pointer::      Kill环是一个列表。
* yank nthcdr 练习::           @code{kill-ring-yank-pointer}变量。
@end menu

@node Kill Ring Overview
@section Kill Ring Overview
@cindex Kill ring overview

The kill ring is a list of textual strings.  This is what it looks like:

@smallexample
("some text" "a different piece of text" "yet more text")
@end smallexample

If this were the contents of my kill ring and I pressed @kbd{C-y}, the
string of characters saying @samp{some text} would be inserted in this
buffer where my cursor is located.

The @code{yank} command is also used for duplicating text by copying it.
The copied text is not cut from the buffer, but a copy of it is put on the
kill ring and is inserted by yanking it back.

Three functions are used for bringing text back from the kill ring:
@code{yank}, which is usually bound to @kbd{C-y}; @code{yank-pop},
which is usually bound to @kbd{M-y}; and @code{rotate-yank-pointer},
which is used by the two other functions.

These functions refer to the kill ring through a variable called the
@code{kill-ring-yank-pointer}.  Indeed, the insertion code for both the
@code{yank} and @code{yank-pop} functions is:

@smallexample
(insert (car kill-ring-yank-pointer))
@end smallexample

@noindent
(Well, no more.  In GNU Emacs 22, the function has been replaced by
@code{insert-for-yank} which calls @code{insert-for-yank-1}
repetitively for each @code{yank-handler} segment.  In turn,
@code{insert-for-yank-1} strips text properties from the inserted text
according to @code{yank-excluded-properties}.  Otherwise, it is just
like @code{insert}.  We will stick with plain @code{insert} since it
is easier to understand.)

To begin to understand how @code{yank} and @code{yank-pop} work, it is
first necessary to look at the @code{kill-ring-yank-pointer} variable.

@node kill-ring-yank-pointer
@section The @code{kill-ring-yank-pointer} Variable

@code{kill-ring-yank-pointer} is a variable, just as @code{kill-ring} is
a variable.  It points to something by being bound to the value of what
it points to, like any other Lisp variable.

@need 1000
Thus, if the value of the kill ring is:

@smallexample
("some text" "a different piece of text" "yet more text")
@end smallexample

@need 1250
@noindent
and the @code{kill-ring-yank-pointer} points to the second clause, the
value of @code{kill-ring-yank-pointer} is:

@smallexample
("a different piece of text" "yet more text")
@end smallexample

As explained in the previous chapter (@pxref{列表实现}), the
computer does not keep two different copies of the text being pointed to
by both the @code{kill-ring} and the @code{kill-ring-yank-pointer}.  The
words ``a different piece of text'' and ``yet more text'' are not
duplicated.  Instead, the two Lisp variables point to the same pieces of
text.  Here is a diagram:

@c cons-cell-diagram #5
@ifnottex
@smallexample
@group
kill-ring     kill-ring-yank-pointer
    |               |
    |      ___ ___  |     ___ ___      ___ ___
     ---> |   |   |  --> |   |   |    |   |   |
          |___|___|----> |___|___|--> |___|___|--> nil
            |              |            |
            |              |            |
            |              |             --> "yet more text"
            |              |
            |               --> "a different piece of text"
            |
             --> "some text"
@end group
@end smallexample
@sp 1
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-5}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
kill-ring     kill-ring-yank-pointer
    |               |
    |      ___ ___  |     ___ ___      ___ ___
     ---> |   |   |  --> |   |   |    |   |   |
          |___|___|----> |___|___|--> |___|___|--> nil
            |              |            |
            |              |            |
            |              |             --> "yet more text"
            |              |
            |               --> "a different piece of text"
            |
             --> "some text"
@end group
@end smallexample
@sp 1
@end iftex
@end ifclear

Both the variable @code{kill-ring} and the variable
@code{kill-ring-yank-pointer} are pointers.  But the kill ring itself is
usually described as if it were actually what it is composed of.  The
@code{kill-ring} is spoken of as if it were the list rather than that it
points to the list.  Conversely, the @code{kill-ring-yank-pointer} is
spoken of as pointing to a list.

These two ways of talking about the same thing sound confusing at first but
make sense on reflection.  The kill ring is generally thought of as the
complete structure of data that holds the information of what has recently
been cut out of the Emacs buffers.  The @code{kill-ring-yank-pointer}
on the other hand, serves to indicate---that is, to point to---that part
of the kill ring of which the first element (the @sc{car}) will be
inserted.

@ignore
In GNU Emacs 22, the @code{kill-new} function calls

@code{(setq kill-ring-yank-pointer kill-ring)}

(defun rotate-yank-pointer (arg)
  "Rotate the yanking point in the kill ring.
With argument, rotate that many kills forward (or backward, if negative)."
  (interactive "p")
  (current-kill arg))

(defun current-kill (n &optional do-not-move)
  "Rotate the yanking point by N places, and then return that kill.
If N is zero, `interprogram-paste-function' is set, and calling it
returns a string, then that string is added to the front of the
kill ring and returned as the latest kill.
If optional arg DO-NOT-MOVE is non-nil, then don't actually move the
yanking point; just return the Nth kill forward."
  (let ((interprogram-paste (and (= n 0)
                                 interprogram-paste-function
                                 (funcall interprogram-paste-function))))
    (if interprogram-paste
        (progn
          ;; Disable the interprogram cut function when we add the new
          ;; text to the kill ring, so Emacs doesn't try to own the
          ;; selection, with identical text.
          (let ((interprogram-cut-function nil))
            (kill-new interprogram-paste))
          interprogram-paste)
      (or kill-ring (error "Kill ring is empty"))
      (let ((ARGth-kill-element
             (nthcdr (mod (- n (length kill-ring-yank-pointer))
                          (length kill-ring))
                     kill-ring)))
        (or do-not-move
            (setq kill-ring-yank-pointer ARGth-kill-element))
        (car ARGth-kill-element)))))

@end ignore

@need 1500
@node yank nthcdr Exercises
@section Exercises with @code{yank} and @code{nthcdr}

@itemize @bullet
@item
Using @kbd{C-h v} (@code{describe-variable}), look at the value of
your kill ring.  Add several items to your kill ring; look at its
value again.  Using @kbd{M-y} (@code{yank-pop)}, move all the way
around the kill ring.  How many items were in your kill ring?  Find
the value of @code{kill-ring-max}.  Was your kill ring full, or could
you have kept more blocks of text within it?

@item
Using @code{nthcdr} and @code{car}, construct a series of expressions
to return the first, second, third, and fourth elements of a list.
@end itemize

@node Loops & Recursion
@chapter Loops and Recursion
@cindex Loops and recursion
@cindex Recursion and loops
@cindex Repetition (loops)

Emacs Lisp has two primary ways to cause an expression, or a series of
expressions, to be evaluated repeatedly: one uses a @code{while}
loop, and the other uses @dfn{recursion}.

Repetition can be very valuable.  For example, to move forward four
sentences, you need only write a program that will move forward one
sentence and then repeat the process four times.  Since a computer does
not get bored or tired, such repetitive action does not have the
deleterious effects that excessive or the wrong kinds of repetition can
have on humans.

People mostly write Emacs Lisp functions using @code{while} loops and
their kin; but you can use recursion, which provides a very powerful
way to think about and then to solve problems@footnote{You can write
recursive functions to be frugal or wasteful of mental or computer
resources; as it happens, methods that people find easy---that are
frugal of mental resources---sometimes use considerable computer
resources.  Emacs was designed to run on machines that we now consider
limited and its default settings are conservative.  You may want to
increase the value of @code{max-lisp-eval-depth}.  In my @file{.emacs}
file, I set it to 30 times its default value.}.

@menu
* while::                       Causing a stretch of code to repeat.
* dolist dotimes::
* Recursion::                   Causing a function to call itself.
* Looping exercise::
@end menu

@node while
@section @code{while}
@cindex Loops
@findex while

The @code{while} special form tests whether the value returned by
evaluating its first argument is true or false.  This is similar to what
the Lisp interpreter does with an @code{if}; what the interpreter does
next, however, is different.

In a @code{while} expression, if the value returned by evaluating the
first argument is false, the Lisp interpreter skips the rest of the
expression (the @dfn{body} of the expression) and does not evaluate it.
However, if the value is true, the Lisp interpreter evaluates the body
of the expression and then again tests whether the first argument to
@code{while} is true or false.  If the value returned by evaluating the
first argument is again true, the Lisp interpreter again evaluates the
body of the expression.

@need 1200
The template for a @code{while} expression looks like this:

@smallexample
@group
(while @var{true-or-false-test}
  @var{body}@dots{})
@end group
@end smallexample

@menu
* Looping with while::          Repeat so long as test returns true.
* Loop Example::                A @code{while} loop that uses a list.
* print-elements-of-list::      Uses @code{while}, @code{car}, @code{cdr}.
* Incrementing Loop::           A loop with an incrementing counter.
* Incrementing Loop Details::
* Decrementing Loop::           A loop with a decrementing counter.
@end menu

@ifnottex
@node Looping with while
@unnumberedsubsec Looping with @code{while}
@end ifnottex

So long as the true-or-false-test of the @code{while} expression
returns a true value when it is evaluated, the body is repeatedly
evaluated.  This process is called a loop since the Lisp interpreter
repeats the same thing again and again, like an airplane doing a loop.
When the result of evaluating the true-or-false-test is false, the
Lisp interpreter does not evaluate the rest of the @code{while}
expression and exits the loop.

Clearly, if the value returned by evaluating the first argument to
@code{while} is always true, the body following will be evaluated
again and again @dots{} and again @dots{} forever.  Conversely, if the
value returned is never true, the expressions in the body will never
be evaluated.  The craft of writing a @code{while} loop consists of
choosing a mechanism such that the true-or-false-test returns true
just the number of times that you want the subsequent expressions to
be evaluated, and then have the test return false.

The value returned by evaluating a @code{while} is the value of the
true-or-false-test.  An interesting consequence of this is that a
@code{while} loop that evaluates without error will return @code{nil}
or false regardless of whether it has looped 1 or 100 times or none at
all.  A @code{while} expression that evaluates successfully never
returns a true value!  What this means is that @code{while} is always
evaluated for its side effects, which is to say, the consequences of
evaluating the expressions within the body of the @code{while} loop.
This makes sense.  It is not the mere act of looping that is desired,
but the consequences of what happens when the expressions in the loop
are repeatedly evaluated.

@node Loop Example
@subsection A @code{while} Loop and a List

A common way to control a @code{while} loop is to test whether a list
has any elements.  If it does, the loop is repeated; but if it does not,
the repetition is ended.  Since this is an important technique, we will
create a short example to illustrate it.

A simple way to test whether a list has elements is to evaluate the
list: if it has no elements, it is an empty list and will return the
empty list, @code{()}, which is a synonym for @code{nil} or false.  On
the other hand, a list with elements will return those elements when it
is evaluated.  Since Emacs Lisp considers as true any value that is not
@code{nil}, a list that returns elements will test true in a
@code{while} loop.

@need 1200
For example, you can set the variable @code{empty-list} to @code{nil} by
evaluating the following @code{setq} expression:

@smallexample
(setq empty-list ())
@end smallexample

@noindent
After evaluating the @code{setq} expression, you can evaluate the
variable @code{empty-list} in the usual way, by placing the cursor after
the symbol and typing @kbd{C-x C-e}; @code{nil} will appear in your
echo area:

@smallexample
empty-list
@end smallexample

On the other hand, if you set a variable to be a list with elements, the
list will appear when you evaluate the variable, as you can see by
evaluating the following two expressions:

@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))

animals
@end group
@end smallexample

Thus, to create a @code{while} loop that tests whether there are any
items in the list @code{animals}, the first part of the loop will be
written like this:

@smallexample
@group
(while animals
       @dots{}
@end group
@end smallexample

@noindent
When the @code{while} tests its first argument, the variable
@code{animals} is evaluated.  It returns a list.  So long as the list
has elements, the @code{while} considers the results of the test to be
true; but when the list is empty, it considers the results of the test
to be false.

To prevent the @code{while} loop from running forever, some mechanism
needs to be provided to empty the list eventually.  An oft-used
technique is to have one of the subsequent forms in the @code{while}
expression set the value of the list to be the @sc{cdr} of the list.
Each time the @code{cdr} function is evaluated, the list will be made
shorter, until eventually only the empty list will be left.  At this
point, the test of the @code{while} loop will return false, and the
arguments to the @code{while} will no longer be evaluated.

For example, the list of animals bound to the variable @code{animals}
can be set to be the @sc{cdr} of the original list with the
following expression:

@smallexample
(setq animals (cdr animals))
@end smallexample

@noindent
If you have evaluated the previous expressions and then evaluate this
expression, you will see @code{(giraffe lion tiger)} appear in the echo
area.  If you evaluate the expression again, @code{(lion tiger)} will
appear in the echo area.  If you evaluate it again and yet again,
@code{(tiger)} appears and then the empty list, shown by @code{nil}.

A template for a @code{while} loop that uses the @code{cdr} function
repeatedly to cause the true-or-false-test eventually to test false
looks like this:

@smallexample
@group
(while @var{test-whether-list-is-empty}
  @var{body}@dots{}
  @var{set-list-to-cdr-of-list})
@end group
@end smallexample

This test and use of @code{cdr} can be put together in a function that
goes through a list and prints each element of the list on a line of its
own.

@node print-elements-of-list
@subsection An Example: @code{print-elements-of-list}
@findex print-elements-of-list

The @code{print-elements-of-list} function illustrates a @code{while}
loop with a list.

@cindex @file{*scratch*} buffer
The function requires several lines for its output.  If you are
reading this in a recent instance of GNU Emacs, you can evaluate the
following expression inside of Info, as usual.

If you are using an earlier version of Emacs, you need to copy the
necessary expressions to your @file{*scratch*} buffer and evaluate
them there.  This is because the echo area had only one line in the
earlier versions.

You can copy the expressions by marking the beginning of the region
with @kbd{C-@key{SPC}} (@code{set-mark-command}), moving the cursor to
the end of the region and then copying the region using @kbd{M-w}
(@code{kill-ring-save}, which calls @code{copy-region-as-kill} and
then provides visual feedback).  In the @file{*scratch*}
buffer, you can yank the expressions back by typing @kbd{C-y}
(@code{yank}).

After you have copied the expressions to the @file{*scratch*} buffer,
evaluate each expression in turn.  Be sure to evaluate the last
expression, @code{(print-elements-of-list animals)}, by typing
@kbd{C-u C-x C-e}, that is, by giving an argument to
@code{eval-last-sexp}.  This will cause the result of the evaluation
to be printed in the @file{*scratch*} buffer instead of being printed
in the echo area.  (Otherwise you will see something like this in your
echo area: @code{^Jgazelle^J^Jgiraffe^J^Jlion^J^Jtiger^Jnil}, in which
each @samp{^J} stands for a newline.)

@need 1500
You can evaluate these expressions directly in the Info buffer, and
the echo area will grow to show the results.

@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))

(defun print-elements-of-list (list)
  "Print each element of LIST on a line of its own."
  (while list
    (print (car list))
    (setq list (cdr list))))

(print-elements-of-list animals)
@end group
@end smallexample

@need 1200
@noindent
When you evaluate the three expressions in sequence, you will see
this:

@smallexample
@group
gazelle

giraffe

lion

tiger
nil
@end group
@end smallexample

Each element of the list is printed on a line of its own (that is what
the function @code{print} does) and then the value returned by the
function is printed.  Since the last expression in the function is the
@code{while} loop, and since @code{while} loops always return
@code{nil}, a @code{nil} is printed after the last element of the list.

@node Incrementing Loop
@subsection A Loop with an Incrementing Counter

A loop is not useful unless it stops when it ought.  Besides
controlling a loop with a list, a common way of stopping a loop is to
write the first argument as a test that returns false when the correct
number of repetitions are complete.  This means that the loop must
have a counter---an expression that counts how many times the loop
repeats itself.

@ifnottex
@node Incrementing Loop Details
@unnumberedsubsec Details of an Incrementing Loop
@end ifnottex

The test for a loop with an incrementing counter can be an expression
such as @code{(< count desired-number)} which returns @code{t} for
true if the value of @code{count} is less than the
@code{desired-number} of repetitions and @code{nil} for false if the
value of @code{count} is equal to or is greater than the
@code{desired-number}.  The expression that increments the count can
be a simple @code{setq} such as @code{(setq count (1+ count))}, where
@code{1+} is a built-in function in Emacs Lisp that adds 1 to its
argument.  (The expression @w{@code{(1+ count)}} has the same result
as @w{@code{(+ count 1)}}, but is easier for a human to read.)

@need 1250
The template for a @code{while} loop controlled by an incrementing
counter looks like this:

@smallexample
@group
@var{set-count-to-initial-value}
(while (< count desired-number)         ; @r{true-or-false-test}
  @var{body}@dots{}
  (setq count (1+ count)))              ; @r{incrementer}
@end group
@end smallexample

@noindent
Note that you need to set the initial value of @code{count}; usually it
is set to 1.

@menu
* Incrementing Example::        Counting pebbles in a triangle.
* Inc Example parts::           The parts of the function definition.
* Inc Example altogether::      Putting the function definition together.
@end menu

@node Incrementing Example
@unnumberedsubsubsec  Example with incrementing counter

Suppose you are playing on the beach and decide to make a triangle of
pebbles, putting one pebble in the first row, two in the second row,
three in the third row and so on, like this:

@sp 1
@c pebble diagram
@ifnottex
@smallexample
@group
               *
              * *
             * * *
            * * * *
@end group
@end smallexample
@end ifnottex
@iftex
@smallexample
@group
               @bullet{}
              @bullet{} @bullet{}
             @bullet{} @bullet{} @bullet{}
            @bullet{} @bullet{} @bullet{} @bullet{}
@end group
@end smallexample
@end iftex
@sp 1

@noindent
(About 2500 years ago, Pythagoras and others developed the beginnings of
number theory by considering questions such as this.)

Suppose you want to know how many pebbles you will need to make a
triangle with 7 rows?

Clearly, what you need to do is add up the numbers from 1 to 7.  There
are two ways to do this; start with the smallest number, one, and add up
the list in sequence, 1, 2, 3, 4 and so on; or start with the largest
number and add the list going down: 7, 6, 5, 4 and so on.  Because both
mechanisms illustrate common ways of writing @code{while} loops, we will
create two examples, one counting up and the other counting down.  In
this first example, we will start with 1 and add 2, 3, 4 and so on.

If you are just adding up a short list of numbers, the easiest way to do
it is to add up all the numbers at once.  However, if you do not know
ahead of time how many numbers your list will have, or if you want to be
prepared for a very long list, then you need to design your addition so
that what you do is repeat a simple process many times instead of doing
a more complex process once.

For example, instead of adding up all the pebbles all at once, what you
can do is add the number of pebbles in the first row, 1, to the number
in the second row, 2, and then add the total of those two rows to the
third row, 3.  Then you can add the number in the fourth row, 4, to the
total of the first three rows; and so on.

The critical characteristic of the process is that each repetitive
action is simple.  In this case, at each step we add only two numbers,
the number of pebbles in the row and the total already found.  This
process of adding two numbers is repeated again and again until the last
row has been added to the total of all the preceding rows.  In a more
complex loop the repetitive action might not be so simple, but it will
be simpler than doing everything all at once.

@node Inc Example parts
@unnumberedsubsubsec The parts of the function definition

The preceding analysis gives us the bones of our function definition:
first, we will need a variable that we can call @code{total} that will
be the total number of pebbles.  This will be the value returned by
the function.

Second, we know that the function will require an argument: this
argument will be the total number of rows in the triangle.  It can be
called @code{number-of-rows}.

Finally, we need a variable to use as a counter.  We could call this
variable @code{counter}, but a better name is @code{row-number}.  That
is because what the counter does in this function is count rows, and a
program should be written to be as understandable as possible.

When the Lisp interpreter first starts evaluating the expressions in the
function, the value of @code{total} should be set to zero, since we have
not added anything to it.  Then the function should add the number of
pebbles in the first row to the total, and then add the number of
pebbles in the second to the total, and then add the number of
pebbles in the third row to the total, and so on, until there are no
more rows left to add.

Both @code{total} and @code{row-number} are used only inside the
function, so they can be declared as local variables with @code{let}
and given initial values.  Clearly, the initial value for @code{total}
should be 0.  The initial value of @code{row-number} should be 1,
since we start with the first row.  This means that the @code{let}
statement will look like this:

@smallexample
@group
  (let ((total 0)
        (row-number 1))
    @var{body}@dots{})
@end group
@end smallexample

After the internal variables are declared and bound to their initial
values, we can begin the @code{while} loop.  The expression that serves
as the test should return a value of @code{t} for true so long as the
@code{row-number} is less than or equal to the @code{number-of-rows}.
(If the expression tests true only so long as the row number is less
than the number of rows in the triangle, the last row will never be
added to the total; hence the row number has to be either less than or
equal to the number of rows.)

@need 1500
@findex <= @r{(less than or equal)}
Lisp provides the @code{<=} function that returns true if the value of
its first argument is less than or equal to the value of its second
argument and false otherwise.  So the expression that the @code{while}
will evaluate as its test should look like this:

@smallexample
(<= row-number number-of-rows)
@end smallexample

The total number of pebbles can be found by repeatedly adding the number
of pebbles in a row to the total already found.  Since the number of
pebbles in the row is equal to the row number, the total can be found by
adding the row number to the total.  (Clearly, in a more complex
situation, the number of pebbles in the row might be related to the row
number in a more complicated way; if this were the case, the row number
would be replaced by the appropriate expression.)

@smallexample
(setq total (+ total row-number))
@end smallexample

@noindent
What this does is set the new value of @code{total} to be equal to the
sum of adding the number of pebbles in the row to the previous total.

After setting the value of @code{total}, the conditions need to be
established for the next repetition of the loop, if there is one.  This
is done by incrementing the value of the @code{row-number} variable,
which serves as a counter.  After the @code{row-number} variable has
been incremented, the true-or-false-test at the beginning of the
@code{while} loop tests whether its value is still less than or equal to
the value of the @code{number-of-rows} and if it is, adds the new value
of the @code{row-number} variable to the @code{total} of the previous
repetition of the loop.

@need 1200
The built-in Emacs Lisp function @code{1+} adds 1 to a number, so the
@code{row-number} variable can be incremented with this expression:

@smallexample
(setq row-number (1+ row-number))
@end smallexample

@node Inc Example altogether
@unnumberedsubsubsec Putting the function definition together

We have created the parts for the function definition; now we need to
put them together.

@need 800
First, the contents of the @code{while} expression:

@smallexample
@group
(while (<= row-number number-of-rows)   ; @r{true-or-false-test}
  (setq total (+ total row-number))
  (setq row-number (1+ row-number)))    ; @r{incrementer}
@end group
@end smallexample

Along with the @code{let} expression varlist, this very nearly
completes the body of the function definition.  However, it requires
one final element, the need for which is somewhat subtle.

The final touch is to place the variable @code{total} on a line by
itself after the @code{while} expression.  Otherwise, the value returned
by the whole function is the value of the last expression that is
evaluated in the body of the @code{let}, and this is the value
returned by the @code{while}, which is always @code{nil}.

This may not be evident at first sight.  It almost looks as if the
incrementing expression is the last expression of the whole function.
But that expression is part of the body of the @code{while}; it is the
last element of the list that starts with the symbol @code{while}.
Moreover, the whole of the @code{while} loop is a list within the body
of the @code{let}.

@need 1250
In outline, the function will look like this:

@smallexample
@group
(defun @var{name-of-function} (@var{argument-list})
  "@var{documentation}@dots{}"
  (let (@var{varlist})
    (while (@var{true-or-false-test})
      @var{body-of-while}@dots{} )
    @dots{} ))                    ; @r{Need final expression here.}
@end group
@end smallexample

The result of evaluating the @code{let} is what is going to be returned
by the @code{defun} since the @code{let} is not embedded within any
containing list, except for the @code{defun} as a whole.  However, if
the @code{while} is the last element of the @code{let} expression, the
function will always return @code{nil}.  This is not what we want!
Instead, what we want is the value of the variable @code{total}.  This
is returned by simply placing the symbol as the last element of the list
starting with @code{let}.  It gets evaluated after the preceding
elements of the list are evaluated, which means it gets evaluated after
it has been assigned the correct value for the total.

It may be easier to see this by printing the list starting with
@code{let} all on one line.  This format makes it evident that the
@var{varlist} and @code{while} expressions are the second and third
elements of the list starting with @code{let}, and the @code{total} is
the last element:

@smallexample
@group
(let (@var{varlist}) (while (@var{true-or-false-test}) @var{body-of-while}@dots{} ) total)
@end group
@end smallexample

@need 1200
Putting everything together, the @code{triangle} function definition
looks like this:

@smallexample
@group
(defun triangle (number-of-rows)    ; @r{Version with}
                                    ; @r{  incrementing counter.}
  "Add up the number of pebbles in a triangle.
The first row has one pebble, the second row two pebbles,
the third row three pebbles, and so on.
The argument is NUMBER-OF-ROWS."
@end group
@group
  (let ((total 0)
        (row-number 1))
    (while (<= row-number number-of-rows)
      (setq total (+ total row-number))
      (setq row-number (1+ row-number)))
    total))
@end group
@end smallexample

@need 1200
After you have installed @code{triangle} by evaluating the function, you
can try it out.  Here are two examples:

@smallexample
@group
(triangle 4)

(triangle 7)
@end group
@end smallexample

@noindent
The sum of the first four numbers is 10 and the sum of the first seven
numbers is 28.

@node Decrementing Loop
@subsection Loop with a Decrementing Counter

Another common way to write a @code{while} loop is to write the test
so that it determines whether a counter is greater than zero.  So long
as the counter is greater than zero, the loop is repeated.  But when
the counter is equal to or less than zero, the loop is stopped.  For
this to work, the counter has to start out greater than zero and then
be made smaller and smaller by a form that is evaluated
repeatedly.

The test will be an expression such as @code{(> counter 0)} which
returns @code{t} for true if the value of @code{counter} is greater
than zero, and @code{nil} for false if the value of @code{counter} is
equal to or less than zero.  The expression that makes the number
smaller and smaller can be a simple @code{setq} such as @code{(setq
counter (1- counter))}, where @code{1-} is a built-in function in
Emacs Lisp that subtracts 1 from its argument.

@need 1250
The template for a decrementing @code{while} loop looks like this:

@smallexample
@group
(while (> counter 0)                    ; @r{true-or-false-test}
  @var{body}@dots{}
  (setq counter (1- counter)))          ; @r{decrementer}
@end group
@end smallexample

@menu
* Decrementing Example::        More pebbles on the beach.
* Dec Example parts::           The parts of the function definition.
* Dec Example altogether::      Putting the function definition together.
@end menu

@node Decrementing Example
@unnumberedsubsubsec Example with decrementing counter

To illustrate a loop with a decrementing counter, we will rewrite the
@code{triangle} function so the counter decreases to zero.

This is the reverse of the earlier version of the function.  In this
case, to find out how many pebbles are needed to make a triangle with
3 rows, add the number of pebbles in the third row, 3, to the number
in the preceding row, 2, and then add the total of those two rows to
the row that precedes them, which is 1.

Likewise, to find the number of pebbles in a triangle with 7 rows, add
the number of pebbles in the seventh row, 7, to the number in the
preceding row, which is 6, and then add the total of those two rows to
the row that precedes them, which is 5, and so on.  As in the previous
example, each addition only involves adding two numbers, the total of
the rows already added up and the number of pebbles in the row that is
being added to the total.  This process of adding two numbers is
repeated again and again until there are no more pebbles to add.

We know how many pebbles to start with: the number of pebbles in the
last row is equal to the number of rows.  If the triangle has seven
rows, the number of pebbles in the last row is 7.  Likewise, we know how
many pebbles are in the preceding row: it is one less than the number in
the row.

@node Dec Example parts
@unnumberedsubsubsec The parts of the function definition

We start with three variables: the total number of rows in the
triangle; the number of pebbles in a row; and the total number of
pebbles, which is what we want to calculate.  These variables can be
named @code{number-of-rows}, @code{number-of-pebbles-in-row}, and
@code{total}, respectively.

Both @code{total} and @code{number-of-pebbles-in-row} are used only
inside the function and are declared with @code{let}.  The initial
value of @code{total} should, of course, be zero.  However, the
initial value of @code{number-of-pebbles-in-row} should be equal to
the number of rows in the triangle, since the addition will start with
the longest row.

@need 1250
This means that the beginning of the @code{let} expression will look
like this:

@smallexample
@group
(let ((total 0)
      (number-of-pebbles-in-row number-of-rows))
  @var{body}@dots{})
@end group
@end smallexample

The total number of pebbles can be found by repeatedly adding the number
of pebbles in a row to the total already found, that is, by repeatedly
evaluating the following expression:

@smallexample
(setq total (+ total number-of-pebbles-in-row))
@end smallexample

@noindent
After the @code{number-of-pebbles-in-row} is added to the @code{total},
the @code{number-of-pebbles-in-row} should be decremented by one, since
the next time the loop repeats, the preceding row will be
added to the total.

The number of pebbles in a preceding row is one less than the number of
pebbles in a row, so the built-in Emacs Lisp function @code{1-} can be
used to compute the number of pebbles in the preceding row.  This can be
done with the following expression:

@smallexample
@group
(setq number-of-pebbles-in-row
      (1- number-of-pebbles-in-row))
@end group
@end smallexample

Finally, we know that the @code{while} loop should stop making repeated
additions when there are no pebbles in a row.  So the test for
the @code{while} loop is simply:

@smallexample
(while (> number-of-pebbles-in-row 0)
@end smallexample

@node Dec Example altogether
@unnumberedsubsubsec Putting the function definition together

We can put these expressions together to create a function definition
that works.  However, on examination, we find that one of the local
variables is unneeded!

@need 1250
The function definition looks like this:

@smallexample
@group
;;; @r{First subtractive version.}
(defun triangle (number-of-rows)
  "Add up the number of pebbles in a triangle."
  (let ((total 0)
        (number-of-pebbles-in-row number-of-rows))
    (while (> number-of-pebbles-in-row 0)
      (setq total (+ total number-of-pebbles-in-row))
      (setq number-of-pebbles-in-row
            (1- number-of-pebbles-in-row)))
    total))
@end group
@end smallexample

As written, this function works.

However, we do not need @code{number-of-pebbles-in-row}.

@cindex Argument as local variable
When the @code{triangle} function is evaluated, the symbol
@code{number-of-rows} will be bound to a number, giving it an initial
value.  That number can be changed in the body of the function as if
it were a local variable, without any fear that such a change will
effect the value of the variable outside of the function.  This is a
very useful characteristic of Lisp; it means that the variable
@code{number-of-rows} can be used anywhere in the function where
@code{number-of-pebbles-in-row} is used.

@need 800
Here is a second version of the function written a bit more cleanly:

@smallexample
@group
(defun triangle (number)                ; @r{Second version.}
  "Return sum of numbers 1 through NUMBER inclusive."
  (let ((total 0))
    (while (> number 0)
      (setq total (+ total number))
      (setq number (1- number)))
    total))
@end group
@end smallexample

In brief, a properly written @code{while} loop will consist of three parts:

@enumerate
@item
A test that will return false after the loop has repeated itself the
correct number of times.

@item
An expression the evaluation of which will return the value desired
after being repeatedly evaluated.

@item
An expression to change the value passed to the true-or-false-test so
that the test returns false after the loop has repeated itself the right
number of times.
@end enumerate

@node dolist dotimes
@section Save your time: @code{dolist} and @code{dotimes}

In addition to @code{while}, both @code{dolist} and @code{dotimes}
provide for looping.  Sometimes these are quicker to write than the
equivalent @code{while} loop.  Both are Lisp macros.  (@xref{Macros, ,
Macros, elisp, The GNU Emacs Lisp Reference Manual}. )

@code{dolist} works like a @code{while} loop that @sc{cdr}s down a
list:  @code{dolist} automatically shortens the list each time it
loops---takes the @sc{cdr} of the list---and binds the @sc{car} of
each shorter version of the list to the first of its arguments.

@code{dotimes} loops a specific number of times: you specify the number.

@menu
* dolist::
* dotimes::
@end menu

@node dolist
@unnumberedsubsec The @code{dolist} Macro
@findex dolist

Suppose, for example, you want to reverse a list, so that
``first'' ``second'' ``third'' becomes ``third'' ``second'' ``first''.

@need 1250
In practice, you would use the @code{reverse} function, like this:

@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))

(reverse animals)
@end group
@end smallexample

@need 800
@noindent
Here is how you could reverse the list using a @code{while} loop:

@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))

(defun reverse-list-with-while (list)
  "Using while, reverse the order of LIST."
  (let (value)  ; make sure list starts empty
    (while list
      (setq value (cons (car list) value))
      (setq list (cdr list)))
    value))

(reverse-list-with-while animals)
@end group
@end smallexample

@need 800
@noindent
And here is how you could use the @code{dolist} macro:

@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))

(defun reverse-list-with-dolist (list)
  "Using dolist, reverse the order of LIST."
  (let (value)  ; make sure list starts empty
    (dolist (element list value)
      (setq value (cons element value)))))

(reverse-list-with-dolist animals)
@end group
@end smallexample

@need 1250
@noindent
In Info, you can place your cursor after the closing parenthesis of
each expression and type @kbd{C-x C-e}; in each case, you should see

@smallexample
(tiger lion giraffe gazelle)
@end smallexample

@noindent
in the echo area.

For this example, the existing @code{reverse} function is obviously best.
The @code{while} loop is just like our first example (@pxref{Loop
Example, , A @code{while} Loop and a List}).  The @code{while} first
checks whether the list has elements; if so, it constructs a new list
by adding the first element of the list to the existing list (which in
the first iteration of the loop is @code{nil}).  Since the second
element is prepended in front of the first element, and the third
element is prepended in front of the second element, the list is reversed.

In the expression using a @code{while} loop,
the @w{@code{(setq list (cdr list))}}
expression shortens the list, so the @code{while} loop eventually
stops.  In addition, it provides the @code{cons} expression with a new
first element by creating a new and shorter list at each repetition of
the loop.

The @code{dolist} expression does very much the same as the
@code{while} expression, except that the @code{dolist} macro does some
of the work you have to do when writing a @code{while} expression.

Like a @code{while} loop, a @code{dolist} loops.  What is different is
that it automatically shortens the list each time it loops---it
@sc{cdr}s down the list on its own---and it automatically binds
the @sc{car} of each shorter version of the list to the first of its
arguments.

In the example, the @sc{car} of each shorter version of the list is
referred to using the symbol @samp{element}, the list itself is called
@samp{list}, and the value returned is called @samp{value}.  The
remainder of the @code{dolist} expression is the body.

The @code{dolist} expression binds the @sc{car} of each shorter
version of the list to @code{element} and then evaluates the body of
the expression; and repeats the loop.  The result is returned in
@code{value}.

@node dotimes
@unnumberedsubsec The @code{dotimes} Macro
@findex dotimes

The @code{dotimes} macro is similar to @code{dolist}, except that it
loops a specific number of times.

The first argument to @code{dotimes} is assigned the numbers 0, 1, 2
and so forth each time around the loop.  You need to provide the value
of the second argument, which is how many times the macro loops.

@need 1250
For example, the following binds the numbers from 0 up to, but not
including, the number 3 to the first argument, @var{number}, and then
constructs a list of the three numbers.  (The first number is 0, the
second number is 1, and the third number is 2; this makes a total of
three numbers in all, starting with zero as the first number.)

@smallexample
@group
(let (value)      ; otherwise a value is a void variable
  (dotimes (number 3)
    (setq value (cons number value)))
  value)

@result{} (2 1 0)
@end group
@end smallexample

@noindent
The way to use @code{dotimes} is to operate on some expression
@var{number} number of times and then return the result, either as
a list or an atom.

@need 1250
Here is an example of a @code{defun} that uses @code{dotimes} to add
up the number of pebbles in a triangle.

@smallexample
@group
(defun triangle-using-dotimes (number-of-rows)
  "Using `dotimes', add up the number of pebbles in a triangle."
(let ((total 0))  ; otherwise a total is a void variable
  (dotimes (number number-of-rows)
    (setq total (+ total (1+ number))))
  total))

(triangle-using-dotimes 4)
@end group
@end smallexample

@node Recursion
@section Recursion
@cindex Recursion

A recursive function contains code that tells the Lisp interpreter to
call a program that runs exactly like itself, but with slightly
different arguments.  The code runs exactly the same because it has
the same name.  However, even though the program has the same name, it
is not the same entity.  It is different.  In the jargon, it is a
different ``instance''.

Eventually, if the program is written correctly, the slightly
different arguments will become sufficiently different from the first
arguments that the final instance will stop.

@menu
* Building Robots::             Same model, different serial number ...
* Recursive Definition Parts::  Walk until you stop ...
* Recursion with list::         Using a list as the test whether to recurse.
* Recursive triangle function::
* Recursion with cond::
* Recursive Patterns::          Often used templates.
* No Deferment::                Don't store up work ...
* No deferment solution::
@end menu

@node Building Robots
@subsection Building Robots: Extending the Metaphor
@cindex Building robots
@cindex Robots, building

It is sometimes helpful to think of a running program as a robot that
does a job.  In doing its job, a recursive function calls on a second
robot to help it.  The second robot is identical to the first in every
way, except that the second robot helps the first and has been
passed different arguments than the first.

In a recursive function, the second robot may call a third; and the
third may call a fourth, and so on.  Each of these is a different
entity; but all are clones.

Since each robot has slightly different instructions---the arguments
will differ from one robot to the next---the last robot should know
when to stop.

Let's expand on the metaphor in which a computer program is a robot.

A function definition provides the blueprints for a robot.  When you
install a function definition, that is, when you evaluate a
@code{defun} macro, you install the necessary equipment to build
robots.  It is as if you were in a factory, setting up an assembly
line.  Robots with the same name are built according to the same
blueprints.  So they have the same model number, but a
different serial number.

We often say that a recursive function ``calls itself''.  What we mean
is that the instructions in a recursive function cause the Lisp
interpreter to run a different function that has the same name and
does the same job as the first, but with different arguments.

It is important that the arguments differ from one instance to the
next; otherwise, the process will never stop.

@node Recursive Definition Parts
@subsection The Parts of a Recursive Definition
@cindex Parts of a Recursive Definition
@cindex Recursive Definition Parts

A recursive function typically contains a conditional expression which
has three parts:

@enumerate
@item
A true-or-false-test that determines whether the function is called
again, here called the @dfn{do-again-test}.

@item
The name of the function.  When this name is called, a new instance of
the function---a new robot, as it were---is created and told what to do.

@item
An expression that returns a different value each time the function is
called, here called the @dfn{next-step-expression}.  Consequently, the
argument (or arguments) passed to the new instance of the function
will be different from that passed to the previous instance.  This
causes the conditional expression, the @dfn{do-again-test}, to test
false after the correct number of repetitions.
@end enumerate

Recursive functions can be much simpler than any other kind of
function.  Indeed, when people first start to use them, they often look
so mysteriously simple as to be incomprehensible.  Like riding a
bicycle, reading a recursive function definition takes a certain knack
which is hard at first but then seems simple.

@need 1200
There are several different common recursive patterns.  A very simple
pattern looks like this:

@smallexample
@group
(defun @var{name-of-recursive-function} (@var{argument-list})
  "@var{documentation}@dots{}"
  (if @var{do-again-test}
    @var{body}@dots{}
    (@var{name-of-recursive-function}
         @var{next-step-expression})))
@end group
@end smallexample

Each time a recursive function is evaluated, a new instance of it is
created and told what to do.  The arguments tell the instance what to do.

An argument is bound to the value of the next-step-expression.  Each
instance runs with a different value of the next-step-expression.

The value in the next-step-expression is used in the do-again-test.

The value returned by the next-step-expression is passed to the new
instance of the function, which evaluates it (or some
transmogrification of it) to determine whether to continue or stop.
The next-step-expression is designed so that the do-again-test returns
false when the function should no longer be repeated.

The do-again-test is sometimes called the @dfn{stop condition},
since it stops the repetitions when it tests false.

@node Recursion with list
@subsection Recursion with a List

The example of a @code{while} loop that printed the elements of a list
of numbers can be written recursively.  Here is the code, including
an expression to set the value of the variable @code{animals} to a list.

If you are reading this in Info in Emacs, you can evaluate this
expression directly in Info.  Otherwise, you must copy the example
to the @file{*scratch*} buffer and evaluate each expression there.
Use @kbd{C-u C-x C-e} to evaluate the
@code{(print-elements-recursively animals)} expression so that the
results are printed in the buffer; otherwise the Lisp interpreter will
try to squeeze the results into the one line of the echo area.

Also, place your cursor immediately after the last closing parenthesis
of the @code{print-elements-recursively} function, before the comment.
Otherwise, the Lisp interpreter will try to evaluate the comment.

@findex print-elements-recursively
@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))

(defun print-elements-recursively (list)
  "Print each element of LIST on a line of its own.
Uses recursion."
  (when list                            ; @r{do-again-test}
        (print (car list))              ; @r{body}
        (print-elements-recursively     ; @r{recursive call}
         (cdr list))))                  ; @r{next-step-expression}

(print-elements-recursively animals)
@end group
@end smallexample

The @code{print-elements-recursively} function first tests whether
there is any content in the list; if there is, the function prints the
first element of the list, the @sc{car} of the list.  Then the
function invokes itself, but gives itself as its argument, not the
whole list, but the second and subsequent elements of the list, the
@sc{cdr} of the list.

Put another way, if the list is not empty, the function invokes
another instance of code that is similar to the initial code, but is a
different thread of execution, with different arguments than the first
instance.

Put in yet another way, if the list is not empty, the first robot
assembles a second robot and tells it what to do; the second robot is
a different individual from the first, but is the same model.

When the second evaluation occurs, the @code{when} expression is
evaluated and if true, prints the first element of the list it
receives as its argument (which is the second element of the original
list).  Then the function calls itself with the @sc{cdr} of the list
it is invoked with, which (the second time around) is the @sc{cdr} of
the @sc{cdr} of the original list.

Note that although we say that the function ``calls itself'', what we
mean is that the Lisp interpreter assembles and instructs a new
instance of the program.  The new instance is a clone of the first,
but is a separate individual.

Each time the function invokes itself, it does so on a
shorter version of the original list.  It creates a new instance that
works on a shorter list.

Eventually, the function invokes itself on an empty list.  It creates
a new instance whose argument is @code{nil}.  The conditional expression
tests the value of @code{list}.  Since the value of @code{list} is
@code{nil}, the @code{when} expression tests false so the then-part is
not evaluated.  The function as a whole then returns @code{nil}.

@need 1200
When you evaluate the expression @code{(print-elements-recursively
animals)} in the @file{*scratch*} buffer, you see this result:

@smallexample
@group
gazelle

giraffe

lion

tiger
nil
@end group
@end smallexample

@need 2000
@node Recursive triangle function
@subsection Recursion in Place of a Counter
@findex triangle-recursively

@need 1200
The @code{triangle} function described in a previous section can also
be written recursively.  It looks like this:

@smallexample
@group
(defun triangle-recursively (number)
  "Return the sum of the numbers 1 through NUMBER inclusive.
Uses recursion."
  (if (= number 1)                    ; @r{do-again-test}
      1                               ; @r{then-part}
    (+ number                         ; @r{else-part}
       (triangle-recursively          ; @r{recursive call}
        (1- number)))))               ; @r{next-step-expression}

(triangle-recursively 7)
@end group
@end smallexample

@noindent
You can install this function by evaluating it and then try it by
evaluating @code{(triangle-recursively 7)}.  (Remember to put your
cursor immediately after the last parenthesis of the function
definition, before the comment.)  The function evaluates to 28.

To understand how this function works, let's consider what happens in the
various cases when the function is passed 1, 2, 3, or 4 as the value of
its argument.

@menu
* Recursive Example arg of 1 or 2::
* Recursive Example arg of 3 or 4::
@end menu

@ifnottex
@node Recursive Example arg of 1 or 2
@unnumberedsubsubsec An argument of 1 or 2
@end ifnottex

First, what happens if the value of the argument is 1?

The function has an @code{if} expression after the documentation
string.  It tests whether the value of @code{number} is equal to 1; if
so, Emacs evaluates the then-part of the @code{if} expression, which
returns the number 1 as the value of the function.  (A triangle with
one row has one pebble in it.)

Suppose, however, that the value of the argument is 2.  In this case,
Emacs evaluates the else-part of the @code{if} expression.

@need 1200
The else-part consists of an addition, the recursive call to
@code{triangle-recursively} and a decrementing action; and it looks like
this:

@smallexample
(+ number (triangle-recursively (1- number)))
@end smallexample

When Emacs evaluates this expression, the innermost expression is
evaluated first; then the other parts in sequence.  Here are the steps
in detail:

@table @i
@item Step 1 @w{  } Evaluate the innermost expression.

The innermost expression is @code{(1- number)} so Emacs decrements the
value of @code{number} from 2 to 1.

@item Step 2 @w{  } Evaluate the @code{triangle-recursively} function.

The Lisp interpreter creates an individual instance of
@code{triangle-recursively}.  It does not matter that this function is
contained within itself.  Emacs passes the result Step 1 as the
argument used by this instance of the @code{triangle-recursively}
function

In this case, Emacs evaluates @code{triangle-recursively} with an
argument of 1.  This means that this evaluation of
@code{triangle-recursively} returns 1.

@item Step 3 @w{  } Evaluate the value of @code{number}.

The variable @code{number} is the second element of the list that
starts with @code{+}; its value is 2.

@item Step 4 @w{  } Evaluate the @code{+} expression.

The @code{+} expression receives two arguments, the first
from the evaluation of @code{number} (Step 3) and the second from the
evaluation of @code{triangle-recursively} (Step 2).

The result of the addition is the sum of 2 plus 1, and the number 3 is
returned, which is correct.  A triangle with two rows has three
pebbles in it.
@end table

@node Recursive Example arg of 3 or 4
@unnumberedsubsubsec An argument of 3 or 4

Suppose that @code{triangle-recursively} is called with an argument of
3.

@table @i
@item Step 1 @w{  } Evaluate the do-again-test.

The @code{if} expression is evaluated first.  This is the do-again
test and returns false, so the else-part of the @code{if} expression
is evaluated.  (Note that in this example, the do-again-test causes
the function to call itself when it tests false, not when it tests
true.)

@item Step 2 @w{  } Evaluate the innermost expression of the else-part.

The innermost expression of the else-part is evaluated, which decrements
3 to 2.  This is the next-step-expression.

@item Step 3 @w{  } Evaluate the @code{triangle-recursively} function.

The number 2 is passed to the @code{triangle-recursively} function.

We already know what happens when Emacs evaluates @code{triangle-recursively} with
an argument of 2.  After going through the sequence of actions described
earlier, it returns a value of 3.  So that is what will happen here.

@item Step 4 @w{  } Evaluate the addition.

3 will be passed as an argument to the addition and will be added to the
number with which the function was called, which is 3.
@end table

@noindent
The value returned by the function as a whole will be 6.

Now that we know what will happen when @code{triangle-recursively} is
called with an argument of 3, it is evident what will happen if it is
called with an argument of 4:

@quotation
@need 800
In the recursive call, the evaluation of

@smallexample
(triangle-recursively (1- 4))
@end smallexample

@need 800
@noindent
will return the value of evaluating

@smallexample
(triangle-recursively 3)
@end smallexample

@noindent
which is 6 and this value will be added to 4 by the addition in the
third line.
@end quotation

@noindent
The value returned by the function as a whole will be 10.

Each time @code{triangle-recursively} is evaluated, it evaluates a
version of itself---a different instance of itself---with a smaller
argument, until the argument is small enough so that it does not
evaluate itself.

Note that this particular design for a recursive function
requires that operations be deferred.

Before @code{(triangle-recursively 7)} can calculate its answer, it
must call @code{(triangle-recursively 6)}; and before
@code{(triangle-recursively 6)} can calculate its answer, it must call
@code{(triangle-recursively 5)}; and so on.  That is to say, the
calculation that @code{(triangle-recursively 7)} makes must be
deferred until @code{(triangle-recursively 6)} makes its calculation;
and @code{(triangle-recursively 6)} must defer until
@code{(triangle-recursively 5)} completes; and so on.

If each of these instances of @code{triangle-recursively} are thought
of as different robots, the first robot must wait for the second to
complete its job, which must wait until the third completes, and so
on.

There is a way around this kind of waiting, which we will discuss in
@ref{No Deferment, , Recursion without Deferments}.

@node Recursion with cond
@subsection Recursion Example Using @code{cond}
@findex cond

The version of @code{triangle-recursively} described earlier is written
with the @code{if} special form.  It can also be written using another
special form called @code{cond}.  The name of the special form
@code{cond} is an abbreviation of the word @samp{conditional}.

Although the @code{cond} special form is not used as often in the
Emacs Lisp sources as @code{if}, it is used often enough to justify
explaining it.

@need 800
The template for a @code{cond} expression looks like this:

@smallexample
@group
(cond
 @var{body}@dots{})
@end group
@end smallexample

@noindent
where the @var{body} is a series of lists.

@need 800
Written out more fully, the template looks like this:

@smallexample
@group
(cond
 (@var{first-true-or-false-test} @var{first-consequent})
 (@var{second-true-or-false-test} @var{second-consequent})
 (@var{third-true-or-false-test} @var{third-consequent})
  @dots{})
@end group
@end smallexample

When the Lisp interpreter evaluates the @code{cond} expression, it
evaluates the first element (the @sc{car} or true-or-false-test) of
the first expression in a series of expressions within the body of the
@code{cond}.

If the true-or-false-test returns @code{nil} the rest of that
expression, the consequent, is skipped and  the true-or-false-test of the
next expression is evaluated.  When an expression is found whose
true-or-false-test returns a value that is not @code{nil}, the
consequent of that expression is evaluated.  The consequent can be one
or more expressions.  If the consequent consists of more than one
expression, the expressions are evaluated in sequence and the value of
the last one is returned.  If the expression does not have a consequent,
the value of the true-or-false-test is returned.

If none of the true-or-false-tests test true, the @code{cond} expression
returns @code{nil}.

@need 1250
Written using @code{cond}, the @code{triangle} function looks like this:

@smallexample
@group
(defun triangle-using-cond (number)
  (cond ((<= number 0) 0)
        ((= number 1) 1)
        ((> number 1)
         (+ number (triangle-using-cond (1- number))))))
@end group
@end smallexample

@noindent
In this example, the @code{cond} returns 0 if the number is less than or
equal to 0, it returns 1 if the number is 1 and it evaluates @code{(+
number (triangle-using-cond (1- number)))} if the number is greater than
1.

@node Recursive Patterns
@subsection Recursive Patterns
@cindex Recursive Patterns

Here are three common recursive patterns.  Each involves a list.
Recursion does not need to involve lists, but Lisp is designed for lists
and this provides a sense of its primal capabilities.

@menu
* Every::
* Accumulate::
* Keep::
@end menu

@node Every
@unnumberedsubsubsec Recursive Pattern: @emph{every}
@cindex Every, type of recursive pattern
@cindex Recursive pattern - every

In the @code{every} recursive pattern, an action is performed on every
element of a list.

@need 1500
The basic pattern is:

@itemize @bullet
@item
If a list be empty, return @code{nil}.
@item
Else, act on the beginning of the list (the @sc{car} of the list)
    @itemize @minus
    @item
    through a recursive call by the function on the rest (the
    @sc{cdr}) of the list,
    @item
    and, optionally, combine the acted-on element, using @code{cons},
    with the results of acting on the rest.
    @end itemize
@end itemize

@need 1500
Here is an example:

@smallexample
@group
(defun square-each (numbers-list)
  "Square each of a NUMBERS LIST, recursively."
  (if (not numbers-list)                ; do-again-test
      nil
    (cons
     (* (car numbers-list) (car numbers-list))
     (square-each (cdr numbers-list))))) ; next-step-expression
@end group

@group
(square-each '(1 2 3))
    @result{} (1 4 9)
@end group
@end smallexample

@need 1200
@noindent
If @code{numbers-list} is empty, do nothing.  But if it has content,
construct a list combining the square of the first number in the list
with the result of the recursive call.

(The example follows the pattern exactly: @code{nil} is returned if
the numbers' list is empty.  In practice, you would write the
conditional so it carries out the action when the numbers' list is not
empty.)

The @code{print-elements-recursively} function (@pxref{Recursion with
list, , Recursion with a List}) is another example of an @code{every}
pattern, except in this case, rather than bring the results together
using @code{cons}, we print each element of output.

@need 1250
The @code{print-elements-recursively} function looks like this:

@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))
@end group

@group
(defun print-elements-recursively (list)
  "Print each element of LIST on a line of its own.
Uses recursion."
  (when list                            ; @r{do-again-test}
        (print (car list))              ; @r{body}
        (print-elements-recursively     ; @r{recursive call}
         (cdr list))))                  ; @r{next-step-expression}

(print-elements-recursively animals)
@end group
@end smallexample

@need 1500
The pattern for @code{print-elements-recursively} is:

@itemize @bullet
@item
When the list is empty, do nothing.
@item
But when the list has at least one element,
    @itemize @minus
    @item
    act on the beginning of the list (the @sc{car} of the list),
    @item
    and make a recursive call on the rest (the @sc{cdr}) of the list.
    @end itemize
@end itemize

@node Accumulate
@unnumberedsubsubsec Recursive Pattern: @emph{accumulate}
@cindex Accumulate, type of recursive pattern
@cindex Recursive pattern - accumulate

Another recursive pattern is called the @code{accumulate} pattern.  In
the @code{accumulate} recursive pattern, an action is performed on
every element of a list and the result of that action is accumulated
with the results of performing the action on the other elements.

This is very like the @code{every} pattern using @code{cons}, except that
@code{cons} is not used, but some other combiner.

@need 1500
The pattern is:

@itemize @bullet
@item
If a list be empty, return zero or some other constant.
@item
Else, act on the beginning of the list (the @sc{car} of the list),
    @itemize @minus
    @item
    and combine that acted-on element, using @code{+} or
    some other combining function, with
    @item
    a recursive call by the function on the rest (the @sc{cdr}) of the list.
    @end itemize
@end itemize

@need 1500
Here is an example:

@smallexample
@group
(defun add-elements (numbers-list)
  "Add the elements of NUMBERS-LIST together."
  (if (not numbers-list)
      0
    (+ (car numbers-list) (add-elements (cdr numbers-list)))))
@end group

@group
(add-elements '(1 2 3 4))
    @result{} 10
@end group
@end smallexample

@xref{Files List, , Making a List of Files}, for an example of the
accumulate pattern.

@node Keep
@unnumberedsubsubsec Recursive Pattern: @emph{keep}
@cindex Keep, type of recursive pattern
@cindex Recursive pattern - keep

A third recursive pattern is called the @code{keep} pattern.
In the @code{keep} recursive pattern, each element of a list is tested;
the element is acted on and the results are kept only if the element
meets a criterion.

Again, this is very like the @code{every} pattern, except the element is
skipped unless it meets a criterion.

@need 1500
The pattern has three parts:

@itemize @bullet
@item
If a list be empty, return @code{nil}.
@item
Else, if the beginning of the list (the @sc{car} of the list) passes
        a test
    @itemize @minus
    @item
    act on that element and combine it, using @code{cons} with
    @item
    a recursive call by the function on the rest (the @sc{cdr}) of the list.
    @end itemize
@item
Otherwise, if the beginning of the list (the @sc{car} of the list) fails
the test
    @itemize @minus
    @item
    skip on that element,
    @item
    and, recursively call the function on the rest (the @sc{cdr}) of the list.
    @end itemize
@end itemize

@need 1500
Here is an example that uses @code{cond}:

@smallexample
@group
(defun keep-three-letter-words (word-list)
  "Keep three letter words in WORD-LIST."
  (cond
   ;; First do-again-test: stop-condition
   ((not word-list) nil)

   ;; Second do-again-test: when to act
   ((eq 3 (length (symbol-name (car word-list))))
    ;; combine acted-on element with recursive call on shorter list
    (cons (car word-list) (keep-three-letter-words (cdr word-list))))

   ;; Third do-again-test: when to skip element;
   ;;   recursively call shorter list with next-step expression
   (t (keep-three-letter-words (cdr word-list)))))
@end group

@group
(keep-three-letter-words '(one two three four five six))
    @result{} (one two six)
@end group
@end smallexample

It goes without saying that you need not use @code{nil} as the test for
when to stop; and you can, of course, combine these patterns.

@node No Deferment
@subsection Recursion without Deferments
@cindex Deferment in recursion
@cindex Recursion without Deferments

Let's consider again what happens with the @code{triangle-recursively}
function.  We will find that the intermediate calculations are
deferred until all can be done.

@need 800
Here is the function definition:

@smallexample
@group
(defun triangle-recursively (number)
  "Return the sum of the numbers 1 through NUMBER inclusive.
Uses recursion."
  (if (= number 1)                    ; @r{do-again-test}
      1                               ; @r{then-part}
    (+ number                         ; @r{else-part}
       (triangle-recursively          ; @r{recursive call}
        (1- number)))))               ; @r{next-step-expression}
@end group
@end smallexample

What happens when we call this function with an argument of 7?

The first instance of the @code{triangle-recursively} function adds
the number 7 to the value returned by a second instance of
@code{triangle-recursively}, an instance that has been passed an
argument of 6.  That is to say, the first calculation is:

@smallexample
(+ 7 (triangle-recursively 6))
@end smallexample

@noindent
The first instance of @code{triangle-recursively}---you may want to
think of it as a little robot---cannot complete its job.  It must hand
off the calculation for @code{(triangle-recursively 6)} to a second
instance of the program, to a second robot.  This second individual is
completely different from the first one; it is, in the jargon, a
``different instantiation''.  Or, put another way, it is a different
robot.  It is the same model as the first; it calculates triangle
numbers recursively; but it has a different serial number.

And what does @code{(triangle-recursively 6)} return?  It returns the
number 6 added to the value returned by evaluating
@code{triangle-recursively} with an argument of 5.  Using the robot
metaphor, it asks yet another robot to help it.

@need 800
Now the total is:

@smallexample
(+ 7 6 (triangle-recursively 5))
@end smallexample

@need 800
And what happens next?

@smallexample
(+ 7 6 5 (triangle-recursively 4))
@end smallexample

Each time @code{triangle-recursively} is called, except for the last
time, it creates another instance of the program---another robot---and
asks it to make a calculation.

@need 800
Eventually, the full addition is set up and performed:

@smallexample
(+ 7 6 5 4 3 2 1)
@end smallexample

This design for the function defers the calculation of the first step
until the second can be done, and defers that until the third can be
done, and so on.  Each deferment means the computer must remember what
is being waited on.  This is not a problem when there are only a few
steps, as in this example.  But it can be a problem when there are
more steps.

@node No deferment solution
@subsection No Deferment Solution
@cindex No deferment solution
@cindex Solution without deferment

The solution to the problem of deferred operations is to write in a
manner that does not defer operations@footnote{The phrase @dfn{tail
recursive} is used to describe such a process, one that uses
constant space.}.  This requires
writing to a different pattern, often one that involves writing two
function definitions, an initialization function and a helper
function.

The initialization function sets up the job; the helper function
does the work.

@need 1200
Here are the two function definitions for adding up numbers.  They are
so simple, I find them hard to understand.

@smallexample
@group
(defun triangle-initialization (number)
  "Return the sum of the numbers 1 through NUMBER inclusive.
This is the initialization component of a two function
duo that uses recursion."
  (triangle-recursive-helper 0 0 number))
@end group
@end smallexample

@smallexample
@group
(defun triangle-recursive-helper (sum counter number)
  "Return SUM, using COUNTER, through NUMBER inclusive.
This is the helper component of a two function duo
that uses recursion."
  (if (> counter number)
      sum
    (triangle-recursive-helper (+ sum counter)  ; @r{sum}
                               (1+ counter)     ; @r{counter}
                               number)))        ; @r{number}
@end group
@end smallexample

@need 1250
Install both function definitions by evaluating them, then call
@code{triangle-initialization} with 2 rows:

@smallexample
@group
(triangle-initialization 2)
    @result{} 3
@end group
@end smallexample

The initialization function calls the first instance of the helper
function with three arguments: zero, zero, and a number which is the
number of rows in the triangle.

The first two arguments passed to the helper function are
initialization values.  These values are changed when
@code{triangle-recursive-helper} invokes new instances.@footnote{The
jargon is mildly confusing:  @code{triangle-recursive-helper} uses a
process that is iterative in a procedure that is recursive.  The
process is called iterative because the computer need only record the
three values, @code{sum}, @code{counter}, and @code{number}; the
procedure is recursive because the function calls itself.  On the
other hand, both the process and the procedure used by
@code{triangle-recursively} are called recursive.  The word
``recursive'' has different meanings in the two contexts.}

Let's see what happens when we have a triangle that has one row.  (This
triangle will have one pebble in it!)

@need 1200
@code{triangle-initialization} will call its helper with
the arguments @w{@code{0 0 1}}.  That function will run the conditional
test whether @code{(> counter number)}:

@smallexample
(> 0 1)
@end smallexample

@need 1200
@noindent
and find that the result is false, so it will invoke
the else-part of the @code{if} clause:

@smallexample
@group
    (triangle-recursive-helper
     (+ sum counter)  ; @r{sum plus counter} @result{} @r{sum}
     (1+ counter)     ; @r{increment counter} @result{} @r{counter}
     number)          ; @r{number stays the same}
@end group
@end smallexample

@need 800
@noindent
which will first compute:

@smallexample
@group
(triangle-recursive-helper (+ 0 0)  ; @r{sum}
                           (1+ 0)   ; @r{counter}
                           1)       ; @r{number}
@exdent which is:

(triangle-recursive-helper 0 1 1)
@end group
@end smallexample

Again, @code{(> counter number)} will be false, so again, the Lisp
interpreter will evaluate @code{triangle-recursive-helper}, creating a
new instance with new arguments.

@need 800
This new instance will be;

@smallexample
@group
    (triangle-recursive-helper
     (+ sum counter)  ; @r{sum plus counter} @result{} @r{sum}
     (1+ counter)     ; @r{increment counter} @result{} @r{counter}
     number)          ; @r{number stays the same}

@exdent which is:

(triangle-recursive-helper 1 2 1)
@end group
@end smallexample

In this case, the @code{(> counter number)} test will be true!  So the
instance will return the value of the sum, which will be 1, as
expected.

Now, let's pass @code{triangle-initialization} an argument
of 2, to find out how many pebbles there are in a triangle with two rows.

That function calls @code{(triangle-recursive-helper 0 0 2)}.

@need 800
In stages, the instances called will be:

@smallexample
@group
                          @r{sum counter number}
(triangle-recursive-helper 0    1       2)

(triangle-recursive-helper 1    2       2)

(triangle-recursive-helper 3    3       2)
@end group
@end smallexample

When the last instance is called, the @code{(> counter number)} test
will be true, so the instance will return the value of @code{sum},
which will be 3.

This kind of pattern helps when you are writing functions that can use
many resources in a computer.

@need 1500
@node Looping exercise
@section Looping Exercise

@itemize @bullet
@item
Write a function similar to @code{triangle} in which each row has a
value which is the square of the row number.  Use a @code{while} loop.

@item
Write a function similar to @code{triangle} that multiplies instead of
adds the values.

@item
Rewrite these two functions recursively.  Rewrite these functions
using @code{cond}.

@c comma in printed title causes problem in Info cross reference
@item
Write a function for Texinfo mode that creates an index entry at the
beginning of a paragraph for every @samp{@@dfn} within the paragraph.
(In a Texinfo file, @samp{@@dfn} marks a definition.  This book is
written in Texinfo.)

Many of the functions you will need are described in two of the
previous chapters, @ref{剪切与存储文本, , 剪切与存储文本}, and @ref{插入文本, , Yanking Text Back}.  If you use
@code{forward-paragraph} to put the index entry at the beginning of
the paragraph, you will have to use @w{@kbd{C-h f}}
(@code{describe-function}) to find out how to make the command go
backwards.

For more information, see
@ifinfo
@ref{Indicating, , Indicating Definitions, texinfo}.
@end ifinfo
@ifhtml
@ref{Indicating, , Indicating, texinfo, Texinfo Manual}, which goes to
a Texinfo manual in the current directory.  Or, if you are on the
Internet, see
@uref{https://www.gnu.org/software/texinfo/manual/texinfo/}
@end ifhtml
@iftex
``Indicating Definitions, Commands, etc.''@: in @cite{Texinfo, The GNU
Documentation Format}.
@end iftex
@end itemize

@node Regexp Search
@chapter Regular Expression Searches
@cindex Searches, illustrating
@cindex Regular expression searches
@cindex Patterns, searching for
@cindex Motion by sentence and paragraph
@cindex Sentences, movement by
@cindex Paragraphs, movement by

Regular expression searches are used extensively in GNU Emacs.  The
two functions, @code{forward-sentence} and @code{forward-paragraph},
illustrate these searches well.  They use regular expressions to find
where to move point.  The phrase ``regular expression'' is often written
as ``regexp''.

Regular expression searches are described in @ref{Regexp Search, ,
Regular Expression Search, emacs, The GNU Emacs Manual}, as well as in
@ref{Regular Expressions, , , elisp, The GNU Emacs Lisp Reference
Manual}.  In writing this chapter, I am presuming that you have at
least a mild acquaintance with them.  The major point to remember is
that regular expressions permit you to search for patterns as well as
for literal strings of characters.  For example, the code in
@code{forward-sentence} searches for the pattern of possible
characters that could mark the end of a sentence, and moves point to
that spot.

Before looking at the code for the @code{forward-sentence} function, it
is worth considering what the pattern that marks the end of a sentence
must be.  The pattern is discussed in the next section; following that
is a description of the regular expression search function,
@code{re-search-forward}.  The @code{forward-sentence} function
is described in the section following.  Finally, the
@code{forward-paragraph} function is described in the last section of
this chapter.  @code{forward-paragraph} is a complex function that
introduces several new features.

@menu
* sentence-end::                The regular expression for @code{sentence-end}.
* re-search-forward::           Very similar to @code{search-forward}.
* forward-sentence::            A straightforward example of regexp search.
* forward-paragraph::           A somewhat complex example.
* Regexp Review::
* re-search Exercises::
@end menu

@node sentence-end
@section The Regular Expression for @code{sentence-end}
@findex sentence-end

The symbol @code{sentence-end} is bound to the pattern that marks the
end of a sentence.  What should this regular expression be?

Clearly, a sentence may be ended by a period, a question mark, or an
exclamation mark.  Indeed, in English, only clauses that end with one
of those three characters should be considered the end of a sentence.
This means that the pattern should include the character set:

@smallexample
[.?!]
@end smallexample

However, we do not want @code{forward-sentence} merely to jump to a
period, a question mark, or an exclamation mark, because such a character
might be used in the middle of a sentence.  A period, for example, is
used after abbreviations.  So other information is needed.

According to convention, you type two spaces after every sentence, but
only one space after a period, a question mark, or an exclamation mark in
the body of a sentence.  So a period, a question mark, or an exclamation
mark followed by two spaces is a good indicator of an end of sentence.
However, in a file, the two spaces may instead be a tab or the end of a
line.  This means that the regular expression should include these three
items as alternatives.

@need 800
This group of alternatives will look like this:

@smallexample
@group
\\($\\| \\|  \\)
       ^   ^^
      TAB  SPC
@end group
@end smallexample

@noindent
Here, @samp{$} indicates the end of the line, and I have pointed out
where the tab and two spaces are inserted in the expression.  Both are
inserted by putting the actual characters into the expression.

Two backslashes, @samp{\\}, are required before the parentheses and
vertical bars: the first backslash quotes the following backslash in
Emacs; and the second indicates that the following character, the
parenthesis or the vertical bar, is special.

@need 1000
Also, a sentence may be followed by one or more carriage returns, like
this:

@smallexample
@group
[
]*
@end group
@end smallexample

@noindent
Like tabs and spaces, a carriage return is inserted into a regular
expression by inserting it literally.  The asterisk indicates that the
@key{RET} is repeated zero or more times.

But a sentence end does not consist only of a period, a question mark or
an exclamation mark followed by appropriate space: a closing quotation
mark or a closing brace of some kind may precede the space.  Indeed more
than one such mark or brace may precede the space.  These require a
expression that looks like this:

@smallexample
[]\"')@}]*
@end smallexample

In this expression, the first @samp{]} is the first character in the
expression; the second character is @samp{"}, which is preceded by a
@samp{\} to tell Emacs the @samp{"} is @emph{not} special.  The last
three characters are @samp{'}, @samp{)}, and @samp{@}}.

All this suggests what the regular expression pattern for matching the
end of a sentence should be; and, indeed, if we evaluate
@code{sentence-end} we find that it returns the following value:

@smallexample
@group
sentence-end
     @result{} "[.?!][]\"')@}]*\\($\\|     \\|  \\)[
]*"
@end group
@end smallexample

@noindent
(Well, not in GNU Emacs 22; that is because of an effort to make the
process simpler and to handle more glyphs and languages.  When the
value of @code{sentence-end} is @code{nil}, then use the value defined
by the function @code{sentence-end}.  (Here is a use of the difference
between a value and a function in Emacs Lisp.)  The function returns a
value constructed from the variables @code{sentence-end-base},
@code{sentence-end-double-space}, @code{sentence-end-without-period},
and @code{sentence-end-without-space}.  The critical variable is
@code{sentence-end-base}; its global value is similar to the one
described above but it also contains two additional quotation marks.
These have differing degrees of curliness.  The
@code{sentence-end-without-period} variable, when true, tells Emacs
that a sentence may end without a period, such as text in Thai.)

@ignore
@noindent
(Note that here the @key{TAB}, two spaces, and  @key{RET} are shown
literally in the pattern.)

This regular expression can be deciphered as follows:

@table @code
@item [.?!]
The first part of the pattern is the three characters, a period, a question
mark and an exclamation mark, within square brackets.  The pattern must
begin with one or other of these characters.

@item []\"')@}]*
The second part of the pattern is the group of closing braces and
quotation marks, which can appear zero or more times.  These may follow
the period, question mark or exclamation mark.  In a regular expression,
the backslash, @samp{\}, followed by the double quotation mark,
@samp{"}, indicates the class of string-quote characters.  Usually, the
double quotation mark is the only character in this class.  The
asterisk, @samp{*}, indicates that the items in the previous group (the
group surrounded by square brackets, @samp{[]}) may be repeated zero or
more times.

@item \\($\\|   \\|  \\)
The third part of the pattern is one or other of: either the end of a
line, or two blank spaces, or a tab.  The double back-slashes are used
to prevent Emacs from reading the parentheses and vertical bars as part
of the search pattern; the parentheses are used to mark the group and
the vertical bars are used to indicated that the patterns to either side
of them are alternatives.  The dollar sign is used to indicate the end
of a line and both the two spaces and the tab are each inserted as is to
indicate what they are.

@item [@key{RET}]*
Finally, the last part of the pattern indicates that the end of the line
or the whitespace following the period, question mark or exclamation
mark may, but need not, be followed by one or more carriage returns.  In
the pattern, the carriage return is inserted as an actual carriage
return between square brackets but here it is shown as @key{RET}.
@end table
@end ignore

@node re-search-forward
@section The @code{re-search-forward} Function
@findex re-search-forward

The @code{re-search-forward} function is very like the
@code{search-forward} function.  (@xref{search-forward, , The
@code{search-forward} Function}.)

@code{re-search-forward} searches for a regular expression.  If the
search is successful, it leaves point immediately after the last
character in the target.  If the search is backwards, it leaves point
just before the first character in the target.  You may tell
@code{re-search-forward} to return @code{t} for true.  (Moving point
is therefore a side effect.)

Like @code{search-forward}, the @code{re-search-forward} function takes
four arguments:

@enumerate
@item
The first argument is the regular expression that the function searches
for.  The regular expression will be a string between quotation marks.

@item
The optional second argument limits how far the function will search; it is a
bound, which is specified as a position in the buffer.

@item
The optional third argument specifies how the function responds to
failure: @code{nil} as the third argument causes the function to
signal an error (and print a message) when the search fails; any other
value causes it to return @code{nil} if the search fails and @code{t}
if the search succeeds.

@item
The optional fourth argument is the repeat count.  A negative repeat
count causes @code{re-search-forward} to search backwards.
@end enumerate

@need 800
The template for @code{re-search-forward} looks like this:

@smallexample
@group
(re-search-forward "@var{regular-expression}"
                @var{limit-of-search}
                @var{what-to-do-if-search-fails}
                @var{repeat-count})
@end group
@end smallexample

The second, third, and fourth arguments are optional.  However, if you
want to pass a value to either or both of the last two arguments, you
must also pass a value to all the preceding arguments.  Otherwise, the
Lisp interpreter will mistake which argument you are passing the value
to.

@need 1200
In the @code{forward-sentence} function, the regular expression will be
the value of the variable @code{sentence-end}.  In simple form, that is:

@smallexample
@group
"[.?!][]\"')@}]*\\($\\|  \\|  \\)[
]*"
@end group
@end smallexample

@noindent
The limit of the search will be the end of the paragraph (since a
sentence cannot go beyond a paragraph).  If the search fails, the
function will return @code{nil}; and the repeat count will be provided
by the argument to the @code{forward-sentence} function.

@node forward-sentence
@section @code{forward-sentence}
@findex forward-sentence

The command to move the cursor forward a sentence is a straightforward
illustration of how to use regular expression searches in Emacs Lisp.
Indeed, the function looks longer and more complicated than it is; this
is because the function is designed to go backwards as well as forwards;
and, optionally, over more than one sentence.  The function is usually
bound to the key command @kbd{M-e}.

@menu
* Complete forward-sentence::
* fwd-sentence while loops::    Two @code{while} loops.
* fwd-sentence re-search::      A regular expression search.
@end menu

@ifnottex
@node Complete forward-sentence
@unnumberedsubsec Complete @code{forward-sentence} function definition
@end ifnottex

@need 1250
Here is the code for @code{forward-sentence}:

@c in GNU Emacs 22
@smallexample
@group
(defun forward-sentence (&optional arg)
  "Move forward to next end of sentence.  With argument, repeat.
With negative argument, move backward repeatedly to start of sentence.

The variable `sentence-end' is a regular expression that matches ends of
sentences.  Also, every paragraph boundary terminates sentences as well."
@end group
@group
  (interactive "p")
  (or arg (setq arg 1))
  (let ((opoint (point))
        (sentence-end (sentence-end)))
    (while (< arg 0)
      (let ((pos (point))
            (par-beg (save-excursion (start-of-paragraph-text) (point))))
       (if (and (re-search-backward sentence-end par-beg t)
                (or (< (match-end 0) pos)
                    (re-search-backward sentence-end par-beg t)))
           (goto-char (match-end 0))
         (goto-char par-beg)))
      (setq arg (1+ arg)))
@end group
@group
    (while (> arg 0)
      (let ((par-end (save-excursion (end-of-paragraph-text) (point))))
       (if (re-search-forward sentence-end par-end t)
           (skip-chars-backward " \t\n")
         (goto-char par-end)))
      (setq arg (1- arg)))
    (constrain-to-field nil opoint t)))
@end group
@end smallexample

@ignore
GNU Emacs 21
@smallexample
@group
(defun forward-sentence (&optional arg)
  "Move forward to next sentence-end.  With argument, repeat.
With negative argument, move backward repeatedly to sentence-beginning.
Sentence ends are identified by the value of sentence-end
treated as a regular expression.  Also, every paragraph boundary
terminates sentences as well."
@end group
@group
  (interactive "p")
  (or arg (setq arg 1))
  (while (< arg 0)
    (let ((par-beg
           (save-excursion (start-of-paragraph-text) (point))))
      (if (re-search-backward
           (concat sentence-end "[^ \t\n]") par-beg t)
          (goto-char (1- (match-end 0)))
        (goto-char par-beg)))
    (setq arg (1+ arg)))
  (while (> arg 0)
    (let ((par-end
           (save-excursion (end-of-paragraph-text) (point))))
      (if (re-search-forward sentence-end par-end t)
          (skip-chars-backward " \t\n")
        (goto-char par-end)))
    (setq arg (1- arg))))
@end group
@end smallexample
@end ignore

The function looks long at first sight and it is best to look at its
skeleton first, and then its muscle.  The way to see the skeleton is to
look at the expressions that start in the left-most columns:

@smallexample
@group
(defun forward-sentence (&optional arg)
  "@var{documentation}@dots{}"
  (interactive "p")
  (or arg (setq arg 1))
  (let ((opoint (point)) (sentence-end (sentence-end)))
    (while (< arg 0)
      (let ((pos (point))
            (par-beg (save-excursion (start-of-paragraph-text) (point))))
       @var{rest-of-body-of-while-loop-when-going-backwards}
    (while (> arg 0)
      (let ((par-end (save-excursion (end-of-paragraph-text) (point))))
       @var{rest-of-body-of-while-loop-when-going-forwards}
    @var{handle-forms-and-equivalent}
@end group
@end smallexample

This looks much simpler!  The function definition consists of
documentation, an @code{interactive} expression, an @code{or}
expression, a @code{let} expression, and @code{while} loops.

Let's look at each of these parts in turn.

We note that the documentation is thorough and understandable.

The function has an @code{interactive "p"} declaration.  This means
that the processed prefix argument, if any, is passed to the
function as its argument.  (This will be a number.)  If the function
is not passed an argument (it is optional) then the argument
@code{arg} will be bound to 1.

When @code{forward-sentence} is called non-interactively without an
argument, @code{arg} is bound to @code{nil}.  The @code{or} expression
handles this.  What it does is either leave the value of @code{arg} as
it is, but only if @code{arg} is bound to a value; or it sets the
value of @code{arg} to 1, in the case when @code{arg} is bound to
@code{nil}.

Next is a @code{let}.  That specifies the values of two local
variables, @code{opoint} and @code{sentence-end}.  The local value of
point, from before the search, is used in the
@code{constrain-to-field} function which handles forms and
equivalents.  The @code{sentence-end} variable is set by the
@code{sentence-end} function.

@node fwd-sentence while loops
@unnumberedsubsec The @code{while} loops

Two @code{while} loops follow.  The first @code{while} has a
true-or-false-test that tests true if the prefix argument for
@code{forward-sentence} is a negative number.  This is for going
backwards.  The body of this loop is similar to the body of the second
@code{while} clause, but it is not exactly the same.  We will skip
this @code{while} loop and concentrate on the second @code{while}
loop.

@need 1500
The second @code{while} loop is for moving point forward.  Its skeleton
looks like this:

@smallexample
@group
(while (> arg 0)            ; @r{true-or-false-test}
  (let @var{varlist}
    (if (@var{true-or-false-test})
        @var{then-part}
      @var{else-part}
  (setq arg (1- arg))))     ; @code{while} @r{loop decrementer}
@end group
@end smallexample

The @code{while} loop is of the decrementing kind.
(@xref{Decrementing Loop, , A Loop with a Decrementing Counter}.)  It
has a true-or-false-test that tests true so long as the counter (in
this case, the variable @code{arg}) is greater than zero; and it has a
decrementer that subtracts 1 from the value of the counter every time
the loop repeats.

If no prefix argument is given to @code{forward-sentence}, which is
the most common way the command is used, this @code{while} loop will
run once, since the value of @code{arg} will be 1.

The body of the @code{while} loop consists of a @code{let} expression,
which creates and binds a local variable, and has, as its body, an
@code{if} expression.

@need 1250
The body of the @code{while} loop looks like this:

@smallexample
@group
(let ((par-end
       (save-excursion (end-of-paragraph-text) (point))))
  (if (re-search-forward sentence-end par-end t)
      (skip-chars-backward " \t\n")
    (goto-char par-end)))
@end group
@end smallexample

The @code{let} expression creates and binds the local variable
@code{par-end}.  As we shall see, this local variable is designed to
provide a bound or limit to the regular expression search.  If the
search fails to find a proper sentence ending in the paragraph, it will
stop on reaching the end of the paragraph.

But first, let us examine how @code{par-end} is bound to the value of
the end of the paragraph.  What happens is that the @code{let} sets the
value of @code{par-end} to the value returned when the Lisp interpreter
evaluates the expression

@smallexample
@group
(save-excursion (end-of-paragraph-text) (point))
@end group
@end smallexample

@noindent
In this expression, @code{(end-of-paragraph-text)} moves point to the
end of the paragraph, @code{(point)} returns the value of point, and then
@code{save-excursion} restores point to its original position.  Thus,
the @code{let} binds @code{par-end} to the value returned by the
@code{save-excursion} expression, which is the position of the end of
the paragraph.  (The @code{end-of-paragraph-text} function uses
@code{forward-paragraph}, which we will discuss shortly.)

@need 1200
Emacs next evaluates the body of the @code{let}, which is an @code{if}
expression that looks like this:

@smallexample
@group
(if (re-search-forward sentence-end par-end t) ; @r{if-part}
    (skip-chars-backward " \t\n")              ; @r{then-part}
  (goto-char par-end)))                        ; @r{else-part}
@end group
@end smallexample

The @code{if} tests whether its first argument is true and if so,
evaluates its then-part; otherwise, the Emacs Lisp interpreter
evaluates the else-part.  The true-or-false-test of the @code{if}
expression is the regular expression search.

It may seem odd to have what looks like the real work of
the @code{forward-sentence} function buried here, but this is a common
way this kind of operation is carried out in Lisp.

@node fwd-sentence re-search
@unnumberedsubsec The regular expression search

The @code{re-search-forward} function searches for the end of the
sentence, that is, for the pattern defined by the @code{sentence-end}
regular expression.  If the pattern is found---if the end of the sentence is
found---then the @code{re-search-forward} function does two things:

@enumerate
@item
The @code{re-search-forward} function carries out a side effect, which
is to move point to the end of the occurrence found.

@item
The @code{re-search-forward} function returns a value of true.  This is
the value received by the @code{if}, and means that the search was
successful.
@end enumerate

@noindent
The side effect, the movement of point, is completed before the
@code{if} function is handed the value returned by the successful
conclusion of the search.

When the @code{if} function receives the value of true from a successful
call to @code{re-search-forward}, the @code{if} evaluates the then-part,
which is the expression @code{(skip-chars-backward " \t\n")}.  This
expression moves backwards over any blank spaces, tabs or carriage
returns until a printed character is found and then leaves point after
the character.  Since point has already been moved to the end of the
pattern that marks the end of the sentence, this action leaves point
right after the closing printed character of the sentence, which is
usually a period.

On the other hand, if the @code{re-search-forward} function fails to
find a pattern marking the end of the sentence, the function returns
false.  The false then causes the @code{if} to evaluate its third
argument, which is @code{(goto-char par-end)}:  it moves point to the
end of the paragraph.

(And if the text is in a form or equivalent, and point may not move
fully, then the @code{constrain-to-field} function comes into play.)

Regular expression searches are exceptionally useful and the pattern
illustrated by @code{re-search-forward}, in which the search is the
test of an @code{if} expression, is handy.  You will see or write code
incorporating this pattern often.

@node forward-paragraph
@section @code{forward-paragraph}: a Goldmine of Functions
@findex forward-paragraph

@ignore
@c in GNU Emacs 22
(defun forward-paragraph (&optional arg)
  "Move forward to end of paragraph.
With argument ARG, do it ARG times;
a negative argument ARG = -N means move backward N paragraphs.

A line which `paragraph-start' matches either separates paragraphs
\(if `paragraph-separate' matches it also) or is the first line of a paragraph.
A paragraph end is the beginning of a line which is not part of the paragraph
to which the end of the previous line belongs, or the end of the buffer.
Returns the count of paragraphs left to move."
  (interactive "p")
  (or arg (setq arg 1))
  (let* ((opoint (point))
         (fill-prefix-regexp
          (and fill-prefix (not (equal fill-prefix ""))
               (not paragraph-ignore-fill-prefix)
               (regexp-quote fill-prefix)))
         ;; Remove ^ from paragraph-start and paragraph-sep if they are there.
         ;; These regexps shouldn't be anchored, because we look for them
         ;; starting at the left-margin.  This allows paragraph commands to
         ;; work normally with indented text.
         ;; This hack will not find problem cases like "whatever\\|^something".
         (parstart (if (and (not (equal "" paragraph-start))
                            (equal ?^ (aref paragraph-start 0)))
                       (substring paragraph-start 1)
                     paragraph-start))
         (parsep (if (and (not (equal "" paragraph-separate))
                          (equal ?^ (aref paragraph-separate 0)))
                     (substring paragraph-separate 1)
                   paragraph-separate))
         (parsep
          (if fill-prefix-regexp
              (concat parsep "\\|"
                      fill-prefix-regexp "[ \t]*$")
            parsep))
         ;; This is used for searching.
         (sp-parstart (concat "^[ \t]*\\(?:" parstart "\\|" parsep "\\)"))
         start found-start)
    (while (and (< arg 0) (not (bobp)))
      (if (and (not (looking-at parsep))
               (re-search-backward "^\n" (max (1- (point)) (point-min)) t)
               (looking-at parsep))
          (setq arg (1+ arg))
        (setq start (point))
        ;; Move back over paragraph-separating lines.
        (forward-char -1) (beginning-of-line)
        (while (and (not (bobp))
                    (progn (move-to-left-margin)
                           (looking-at parsep)))
          (forward-line -1))
        (if (bobp)
            nil
          (setq arg (1+ arg))
          ;; Go to end of the previous (non-separating) line.
          (end-of-line)
          ;; Search back for line that starts or separates paragraphs.
          (if (if fill-prefix-regexp
                  ;; There is a fill prefix; it overrides parstart.
                  (let (multiple-lines)
                    (while (and (progn (beginning-of-line) (not (bobp)))
                                (progn (move-to-left-margin)
                                       (not (looking-at parsep)))
                                (looking-at fill-prefix-regexp))
                      (unless (= (point) start)
                        (setq multiple-lines t))
                      (forward-line -1))
                    (move-to-left-margin)
                    ;; This deleted code caused a long hanging-indent line
                    ;; not to be filled together with the following lines.
                    ;; ;; Don't move back over a line before the paragraph
                    ;; ;; which doesn't start with fill-prefix
                    ;; ;; unless that is the only line we've moved over.
                    ;; (and (not (looking-at fill-prefix-regexp))
                    ;;      multiple-lines
                    ;;      (forward-line 1))
                    (not (bobp)))
                (while (and (re-search-backward sp-parstart nil 1)
                            (setq found-start t)
                            ;; Found a candidate, but need to check if it is a
                            ;; REAL parstart.
                            (progn (setq start (point))
                                   (move-to-left-margin)
                                   (not (looking-at parsep)))
                            (not (and (looking-at parstart)
                                      (or (not use-hard-newlines)
                                          (bobp)
                                          (get-text-property
                                           (1- start) 'hard)))))
                  (setq found-start nil)
                  (goto-char start))
                found-start)
              ;; Found one.
              (progn
                ;; Move forward over paragraph separators.
                ;; We know this cannot reach the place we started
                ;; because we know we moved back over a non-separator.
                (while (and (not (eobp))
                            (progn (move-to-left-margin)
                                   (looking-at parsep)))
                  (forward-line 1))
                ;; If line before paragraph is just margin, back up to there.
                (end-of-line 0)
                (if (> (current-column) (current-left-margin))
                    (forward-char 1)
                  (skip-chars-backward " \t")
                  (if (not (bolp))
                      (forward-line 1))))
            ;; No starter or separator line => use buffer beg.
            (goto-char (point-min))))))

    (while (and (> arg 0) (not (eobp)))
      ;; Move forward over separator lines...
      (while (and (not (eobp))
                  (progn (move-to-left-margin) (not (eobp)))
                  (looking-at parsep))
        (forward-line 1))
      (unless (eobp) (setq arg (1- arg)))
      ;; ... and one more line.
      (forward-line 1)
      (if fill-prefix-regexp
          ;; There is a fill prefix; it overrides parstart.
          (while (and (not (eobp))
                      (progn (move-to-left-margin) (not (eobp)))
                      (not (looking-at parsep))
                      (looking-at fill-prefix-regexp))
            (forward-line 1))
        (while (and (re-search-forward sp-parstart nil 1)
                    (progn (setq start (match-beginning 0))
                           (goto-char start)
                           (not (eobp)))
                    (progn (move-to-left-margin)
                           (not (looking-at parsep)))
                    (or (not (looking-at parstart))
                        (and use-hard-newlines
                             (not (get-text-property (1- start) 'hard)))))
          (forward-char 1))
        (if (< (point) (point-max))
            (goto-char start))))
    (constrain-to-field nil opoint t)
    ;; Return the number of steps that could not be done.
    arg))
@end ignore

The @code{forward-paragraph} function moves point forward to the end
of the paragraph.  It is usually bound to @kbd{M-@}} and makes use of a
number of functions that are important in themselves, including
@code{let*}, @code{match-beginning}, and @code{looking-at}.

The function definition for @code{forward-paragraph} is considerably
longer than the function definition for @code{forward-sentence}
because it works with a paragraph, each line of which may begin with a
fill prefix.

A fill prefix consists of a string of characters that are repeated at
the beginning of each line.  For example, in Lisp code, it is a
convention to start each line of a paragraph-long comment with
@samp{;;; }.  In Text mode, four blank spaces make up another common
fill prefix, creating an indented paragraph.  (@xref{Fill Prefix, , ,
emacs, The GNU Emacs Manual}, for more information about fill
prefixes.)

The existence of a fill prefix means that in addition to being able to
find the end of a paragraph whose lines begin on the left-most
column, the @code{forward-paragraph} function must be able to find the
end of a paragraph when all or many of the lines in the buffer begin
with the fill prefix.

Moreover, it is sometimes practical to ignore a fill prefix that
exists, especially when blank lines separate paragraphs.
This is an added complication.

@menu
* forward-paragraph in brief::  Key parts of the function definition.
* fwd-para let::                The @code{let*} expression.
* fwd-para while::              The forward motion @code{while} loop.
@end menu

@ifnottex
@node forward-paragraph in brief
@unnumberedsubsec Shortened @code{forward-paragraph} function definition
@end ifnottex

Rather than print all of the @code{forward-paragraph} function, we
will only print parts of it.  Read without preparation, the function
can be daunting!

@need 800
In outline, the function looks like this:

@smallexample
@group
(defun forward-paragraph (&optional arg)
  "@var{documentation}@dots{}"
  (interactive "p")
  (or arg (setq arg 1))
  (let*
      @var{varlist}
    (while (and (< arg 0) (not (bobp)))     ; @r{backward-moving-code}
      @dots{}
    (while (and (> arg 0) (not (eobp)))     ; @r{forward-moving-code}
      @dots{}
@end group
@end smallexample

The first parts of the function are routine: the function's argument
list consists of one optional argument.  Documentation follows.

The lower case @samp{p} in the @code{interactive} declaration means
that the processed prefix argument, if any, is passed to the function.
This will be a number, and is the repeat count of how many paragraphs
point will move.  The @code{or} expression in the next line handles
the common case when no argument is passed to the function, which occurs
if the function is called from other code rather than interactively.
This case was described earlier.  (@xref{forward-sentence, The
@code{forward-sentence} function}.)  Now we reach the end of the
familiar part of this function.

@node fwd-para let
@unnumberedsubsec The @code{let*} expression

@findex let*
The next line of the @code{forward-paragraph} function begins a
@code{let*} expression (@pxref{let* introduced,,@code{let*}
introduced}), in which Emacs binds a total of seven variables:
@code{opoint}, @code{fill-prefix-regexp}, @code{parstart},
@code{parsep}, @code{sp-parstart}, @code{start}, and
@code{found-start}.

The variable @code{parsep} appears twice, first, to remove instances
of @samp{^}, and second, to handle fill prefixes.

The variable @code{opoint} is just the value of @code{point}.  As you
can guess, it is used in a @code{constrain-to-field} expression, just
as in @code{forward-sentence}.

The variable @code{fill-prefix-regexp} is set to the value returned by
evaluating the following list:

@smallexample
@group
(and fill-prefix
     (not (equal fill-prefix ""))
     (not paragraph-ignore-fill-prefix)
     (regexp-quote fill-prefix))
@end group
@end smallexample

@noindent
This is an expression whose first element is the @code{and} special form.

As we learned earlier (@pxref{kill-new 函数, , @code{kill-new} 函数}), the @code{and} special form evaluates each of its
arguments until one of the arguments returns a value of @code{nil}, in
which case the @code{and} expression returns @code{nil}; however, if
none of the arguments returns a value of @code{nil}, the value
resulting from evaluating the last argument is returned.  (Since such
a value is not @code{nil}, it is considered true in Lisp.)  In other
words, an @code{and} expression returns a true value only if all its
arguments are true.
@findex and

In this case, the variable @code{fill-prefix-regexp} is bound to a
non-@code{nil} value only if the following four expressions produce a
true (i.e., a non-@code{nil}) value when they are evaluated; otherwise,
@code{fill-prefix-regexp} is bound to @code{nil}.

@table @code
@item fill-prefix
When this variable is evaluated, the value of the fill prefix, if any,
is returned.  If there is no fill prefix, this variable returns
@code{nil}.

@item (not (equal fill-prefix "")
This expression checks whether an existing fill prefix is an empty
string, that is, a string with no characters in it.  An empty string is
not a useful fill prefix.

@item (not paragraph-ignore-fill-prefix)
This expression returns @code{nil} if the variable
@code{paragraph-ignore-fill-prefix} has been turned on by being set to a
true value such as @code{t}.

@item (regexp-quote fill-prefix)
This is the last argument to the @code{and} special form.  If all the
arguments to the @code{and} are true, the value resulting from
evaluating this expression will be returned by the @code{and} expression
and bound to the variable @code{fill-prefix-regexp},
@end table

@findex regexp-quote
@noindent
The result of evaluating this @code{and} expression successfully is that
@code{fill-prefix-regexp} will be bound to the value of
@code{fill-prefix} as modified by the @code{regexp-quote} function.
What @code{regexp-quote} does is read a string and return a regular
expression that will exactly match the string and match nothing else.
This means that @code{fill-prefix-regexp} will be set to a value that
will exactly match the fill prefix if the fill prefix exists.
Otherwise, the variable will be set to @code{nil}.

The next two local variables in the @code{let*} expression are
designed to remove instances of @samp{^} from @code{parstart} and
@code{parsep}, the local variables which indicate the paragraph start
and the paragraph separator.  The next expression sets @code{parsep}
again.  That is to handle fill prefixes.

This is the setting that requires the definition call @code{let*}
rather than @code{let}.  The true-or-false-test for the @code{if}
depends on whether the variable @code{fill-prefix-regexp} evaluates to
@code{nil} or some other value.

If @code{fill-prefix-regexp} does not have a value, Emacs evaluates
the else-part of the @code{if} expression and binds @code{parsep} to
its local value.  (@code{parsep} is a regular expression that matches
what separates paragraphs.)

But if @code{fill-prefix-regexp} does have a value, Emacs evaluates
the then-part of the @code{if} expression and binds @code{parsep} to a
regular expression that includes the @code{fill-prefix-regexp} as part
of the pattern.

Specifically, @code{parsep} is set to the original value of the
paragraph separate regular expression concatenated with an alternative
expression that consists of the @code{fill-prefix-regexp} followed by
optional whitespace to the end of the line.  The whitespace is defined
by @w{@code{"[ \t]*$"}}.)  The @samp{\\|} defines this portion of the
regexp as an alternative to @code{parsep}.

According to a comment in the code, the next local variable,
@code{sp-parstart}, is used for searching, and then the final two,
@code{start} and @code{found-start}, are set to @code{nil}.

Now we get into the body of the @code{let*}.  The first part of the body
of the @code{let*} deals with the case when the function is given a
negative argument and is therefore moving backwards.  We will skip this
section.

@node fwd-para while
@unnumberedsubsec The forward motion @code{while} loop

The second part of the body of the @code{let*} deals with forward
motion.  It is a @code{while} loop that repeats itself so long as the
value of @code{arg} is greater than zero.  In the most common use of
the function, the value of the argument is 1, so the body of the
@code{while} loop is evaluated exactly once, and the cursor moves
forward one paragraph.

@ignore
(while (and (> arg 0) (not (eobp)))

  ;; Move forward over separator lines...
  (while (and (not (eobp))
              (progn (move-to-left-margin) (not (eobp)))
              (looking-at parsep))
    (forward-line 1))
  (unless (eobp) (setq arg (1- arg)))
  ;; ... and one more line.
  (forward-line 1)

  (if fill-prefix-regexp
      ;; There is a fill prefix; it overrides parstart.
      (while (and (not (eobp))
                  (progn (move-to-left-margin) (not (eobp)))
                  (not (looking-at parsep))
                  (looking-at fill-prefix-regexp))
        (forward-line 1))

    (while (and (re-search-forward sp-parstart nil 1)
                (progn (setq start (match-beginning 0))
                       (goto-char start)
                       (not (eobp)))
                (progn (move-to-left-margin)
                       (not (looking-at parsep)))
                (or (not (looking-at parstart))
                    (and use-hard-newlines
                         (not (get-text-property (1- start) 'hard)))))
      (forward-char 1))

    (if (< (point) (point-max))
        (goto-char start))))
@end ignore

This part handles three situations: when point is between paragraphs,
when there is a fill prefix and when there is no fill prefix.

@need 800
The @code{while} loop looks like this:

@smallexample
@group
;; @r{going forwards and not at the end of the buffer}
(while (and (> arg 0) (not (eobp)))

  ;; @r{between paragraphs}
  ;; Move forward over separator lines...
  (while (and (not (eobp))
              (progn (move-to-left-margin) (not (eobp)))
              (looking-at parsep))
    (forward-line 1))
  ;;  @r{This decrements the loop}
  (unless (eobp) (setq arg (1- arg)))
  ;; ... and one more line.
  (forward-line 1)
@end group

@group
  (if fill-prefix-regexp
      ;; There is a fill prefix; it overrides parstart;
      ;; we go forward line by line
      (while (and (not (eobp))
                  (progn (move-to-left-margin) (not (eobp)))
                  (not (looking-at parsep))
                  (looking-at fill-prefix-regexp))
        (forward-line 1))
@end group

@group
    ;; There is no fill prefix;
    ;; we go forward character by character
    (while (and (re-search-forward sp-parstart nil 1)
                (progn (setq start (match-beginning 0))
                       (goto-char start)
                       (not (eobp)))
                (progn (move-to-left-margin)
                       (not (looking-at parsep)))
                (or (not (looking-at parstart))
                    (and use-hard-newlines
                         (not (get-text-property (1- start) 'hard)))))
      (forward-char 1))
@end group

@group
    ;; and if there is no fill prefix and if we are not at the end,
    ;;     go to whatever was found in the regular expression search
    ;;     for sp-parstart
    (if (< (point) (point-max))
        (goto-char start))))
@end group
@end smallexample

@findex eobp
We can see that this is a decrementing counter @code{while} loop,
using the expression @code{(setq arg (1- arg))} as the decrementer.
That expression is not far from the @code{while}, but is hidden in
another Lisp macro, an @code{unless} macro.  Unless we are at the end
of the buffer---that is what the @code{eobp} function determines; it
is an abbreviation of @samp{End Of Buffer P}---we decrease the value
of @code{arg} by one.

(If we are at the end of the buffer, we cannot go forward any more and
the next loop of the @code{while} expression will test false since the
test is an @code{and} with @code{(not (eobp))}.  The @code{not}
function means exactly as you expect; it is another name for
@code{null}, a function that returns true when its argument is false.)

Interestingly, the loop count is not decremented until we leave the
space between paragraphs, unless we come to the end of buffer or stop
seeing the local value of the paragraph separator.

That second @code{while} also has a @code{(move-to-left-margin)}
expression.  The function is self-explanatory.  It is inside a
@code{progn} expression and not the last element of its body, so it is
only invoked for its side effect, which is to move point to the left
margin of the current line.

@findex looking-at
The @code{looking-at} function is also self-explanatory; it returns
true if the text after point matches the regular expression given as
its argument.

The rest of the body of the loop looks difficult at first, but makes
sense as you come to understand it.

@need 800
First consider what happens if there is a fill prefix:

@smallexample
@group
  (if fill-prefix-regexp
      ;; There is a fill prefix; it overrides parstart;
      ;; we go forward line by line
      (while (and (not (eobp))
                  (progn (move-to-left-margin) (not (eobp)))
                  (not (looking-at parsep))
                  (looking-at fill-prefix-regexp))
        (forward-line 1))
@end group
@end smallexample

@noindent
This expression moves point forward line by line so long
as four conditions are true:

@enumerate
@item
Point is not at the end of the buffer.

@item
We can move to the left margin of the text and are
not at the end of the buffer.

@item
The text following point does not separate paragraphs.

@item
The pattern following point is the fill prefix regular expression.
@end enumerate

The last condition may be puzzling, until you remember that point was
moved to the beginning of the line early in the @code{forward-paragraph}
function.  This means that if the text has a fill prefix, the
@code{looking-at} function will see it.

@need 1250
Consider what happens when there is no fill prefix.

@smallexample
@group
    (while (and (re-search-forward sp-parstart nil 1)
                (progn (setq start (match-beginning 0))
                       (goto-char start)
                       (not (eobp)))
                (progn (move-to-left-margin)
                       (not (looking-at parsep)))
                (or (not (looking-at parstart))
                    (and use-hard-newlines
                         (not (get-text-property (1- start) 'hard)))))
      (forward-char 1))
@end group
@end smallexample

@noindent
This @code{while} loop has us searching forward for
@code{sp-parstart}, which is the combination of possible whitespace
with the local value of the start of a paragraph or of a paragraph
separator.  (The latter two are within an expression starting
@code{\(?:} so that they are not referenced by the
@code{match-beginning} function.)

@need 800
The two expressions,

@smallexample
@group
(setq start (match-beginning 0))
(goto-char start)
@end group
@end smallexample

@noindent
mean go to the start of the text matched by the regular expression
search.

The @code{(match-beginning 0)} expression is new.  It returns a number
specifying the location of the start of the text that was matched by
the last search.

The @code{match-beginning} function is used here because of a
characteristic of a forward search: a successful forward search,
regardless of whether it is a plain search or a regular expression
search, moves point to the end of the text that is found.  In this
case, a successful search moves point to the end of the pattern for
@code{sp-parstart}.

However, we want to put point at the end of the current paragraph, not
somewhere else.  Indeed, since the search possibly includes the
paragraph separator, point may end up at the beginning of the next one
unless we use an expression that includes @code{match-beginning}.

@findex match-beginning
When given an argument of 0, @code{match-beginning} returns the
position that is the start of the text matched by the most recent
search.  In this case, the most recent search looks for
@code{sp-parstart}.  The @code{(match-beginning 0)} expression returns
the beginning position of that pattern, rather than the end position
of that pattern.

(Incidentally, when passed a positive number as an argument, the
@code{match-beginning} function returns the location of point at that
parenthesized expression in the last search unless that parenthesized
expression begins with @code{\(?:}.  I don't know why @code{\(?:}
appears here since the argument is 0.)

@need 1250
The last expression when there is no fill prefix is

@smallexample
@group
(if (< (point) (point-max))
    (goto-char start))))
@end group
@end smallexample

@noindent
This says that if there is no fill prefix and if we are not at the
end, point should move to the beginning of whatever was found by the
regular expression search for @code{sp-parstart}.

The full definition for the @code{forward-paragraph} function not only
includes code for going forwards, but also code for going backwards.

If you are reading this inside of GNU Emacs and you want to see the
whole function, you can type @kbd{C-h f} (@code{describe-function})
and the name of the function.  This gives you the function
documentation and the name of the library containing the function's
source.  Place point over the name of the library and press the @key{RET}
key; you will be taken directly to the source.  (Be sure to install
your sources!  Without them, you are like a person who tries to drive
a car with his eyes shut!)

@node Regexp Review
@section Review

Here is a brief summary of some recently introduced functions.

@table @code
@item while
Repeatedly evaluate the body of the expression so long as the first
element of the body tests true.  Then return @code{nil}.  (The
expression is evaluated only for its side effects.)

@need 1250
For example:

@smallexample
@group
(let ((foo 2))
  (while (> foo 0)
    (insert (format "foo is %d.\n" foo))
    (setq foo (1- foo))))

     @result{}      foo is 2.
             foo is 1.
             nil
@end group
@end smallexample

@noindent
(The @code{insert} function inserts its arguments at point; the
@code{format} function returns a string formatted from its arguments
the way @code{message} formats its arguments; @code{\n} produces a new
line.)

@item re-search-forward
Search for a pattern, and if the pattern is found, move point to rest
just after it.

@noindent
Takes four arguments, like @code{search-forward}:

@enumerate
@item
A regular expression that specifies the pattern to search for.
(Remember to put quotation marks around this argument!)

@item
Optionally, the limit of the search.

@item
Optionally, what to do if the search fails, return @code{nil} or an
error message.

@item
Optionally, how many times to repeat the search; if negative, the
search goes backwards.
@end enumerate

@item let*
Bind some variables locally to particular values,
and then evaluate the remaining arguments, returning the value of the
last one.  While binding the local variables, use the local values of
variables bound earlier, if any.

@need 1250
For example:

@smallexample
@group
(let* ((foo 7)
       (bar (* 3 foo)))
  (message "`bar' is %d." bar))
     @result{} ‘bar’ is 21.
@end group
@end smallexample

@item match-beginning
Return the position of the start of the text found by the last regular
expression search.

@item looking-at
Return @code{t} for true if the text after point matches the argument,
which should be a regular expression.

@item eobp
Return @code{t} for true if point is at the end of the accessible part
of a buffer.  The end of the accessible part is the end of the buffer
if the buffer is not narrowed; it is the end of the narrowed part if
the buffer is narrowed.
@end table

@need 1500
@node re-search Exercises
@section Exercises with @code{re-search-forward}

@itemize @bullet
@item
Write a function to search for a regular expression that matches two
or more blank lines in sequence.

@item
Write a function to search for duplicated words, such as ``the the''.
@xref{Regexps, , Syntax of Regular Expressions, emacs, The GNU Emacs
Manual}, for information on how to write a regexp (a regular
expression) to match a string that is composed of two identical
halves.  You can devise several regexps; some are better than others.
The function I use is described in an appendix, along with several
regexps.  @xref{the-the, , @code{the-the} Duplicated Words Function}.
@end itemize

@node Counting Words
@chapter Counting via Repetition and Regexps
@cindex Repetition for word counting
@cindex Regular expressions for word counting

Repetition and regular expression searches are powerful tools that you
often use when you write code in Emacs Lisp.  This chapter illustrates
the use of regular expression searches through the construction of
word count commands using @code{while} loops and recursion.

@menu
* Why Count Words::
* @value{COUNT-WORDS}::          Use a regexp, but find a problem.
* recursive-count-words::       Start with case of no words in region.
* Counting Exercise::
@end menu

@ifnottex
@node Why Count Words
@unnumberedsec Counting words
@end ifnottex

The standard Emacs distribution contains functions for counting the
number of lines and words within a region.

Certain types of writing ask you to count words.  Thus, if you write
an essay, you may be limited to 800 words; if you write a novel, you
may discipline yourself to write 1000 words a day.  It seems odd, but
for a long time, Emacs lacked a word count command.  Perhaps people used
Emacs mostly for code or types of documentation that did not require
word counts; or perhaps they restricted themselves to the operating
system word count command, @code{wc}.  Alternatively, people may have
followed the publishers' convention and computed a word count by
dividing the number of characters in a document by five.

There are many ways to implement a command to count words.  Here are
some examples, which you may wish to compare with the standard Emacs
command, @code{count-words-region}.

@node @value{COUNT-WORDS}
@section The @code{@value{COUNT-WORDS}} Function
@findex @value{COUNT-WORDS}

A word count command could count words in a line, paragraph, region,
or buffer.  What should the command cover?  You could design the
command to count the number of words in a complete buffer.  However,
the Emacs tradition encourages flexibility---you may want to count
words in just a section, rather than all of a buffer.  So it makes
more sense to design the command to count the number of words in a
region.  Once you have a command to count words in a region, you can,
if you wish, count words in a whole buffer by marking it with
@w{@kbd{C-x h}} (@code{mark-whole-buffer}).

Clearly, counting words is a repetitive act: starting from the
beginning of the region, you count the first word, then the second
word, then the third word, and so on, until you reach the end of the
region.  This means that word counting is ideally suited to recursion
or to a @code{while} loop.

@menu
* Design @value{COUNT-WORDS}::  The definition using a @code{while} loop.
* Whitespace Bug::              The Whitespace Bug in @code{@value{COUNT-WORDS}}.
@end menu

@ifnottex
@node Design @value{COUNT-WORDS}
@unnumberedsubsec Designing @code{@value{COUNT-WORDS}}
@end ifnottex

First, we will implement the word count command with a @code{while}
loop, then with recursion.  The command will, of course, be
interactive.

@need 800
The template for an interactive function definition is, as always:

@smallexample
@group
(defun @var{name-of-function} (@var{argument-list})
  "@var{documentation}@dots{}"
  (@var{interactive-expression}@dots{})
  @var{body}@dots{})
@end group
@end smallexample

What we need to do is fill in the slots.

The name of the function should be self-explanatory and easy
to remember.  @code{count-words-region} is the obvious choice.  Since
that name is used for the standard Emacs command to count words, we
will name our implementation @code{@value{COUNT-WORDS}}.

The function counts words within a region.  This means that the
argument list must contain symbols that are bound to the two
positions, the beginning and end of the region.  These two positions
can be called @samp{beginning} and @samp{end} respectively.  The first
line of the documentation should be a single sentence, since that is
all that is printed as documentation by a command such as
@code{apropos}.  The interactive expression will be of the form
@samp{(interactive "r")}, since that will cause Emacs to pass the
beginning and end of the region to the function's argument list.  All
this is routine.

The body of the function needs to be written to do three tasks:
first, to set up conditions under which the @code{while} loop can
count words, second, to run the @code{while} loop, and third, to send
a message to the user.

When a user calls @code{@value{COUNT-WORDS}}, point may be at the
beginning or the end of the region.  However, the counting process
must start at the beginning of the region.  This means we will want
to put point there if it is not already there.  Executing
@code{(goto-char beginning)} ensures this.  Of course, we will want to
return point to its expected position when the function finishes its
work.  For this reason, the body must be enclosed in a
@code{save-excursion} expression.

The central part of the body of the function consists of a
@code{while} loop in which one expression jumps point forward word by
word, and another expression counts those jumps.  The true-or-false-test
of the @code{while} loop should test true so long as point should jump
forward, and false when point is at the end of the region.

We could use @code{(forward-word 1)} as the expression for moving point
forward word by word, but it is easier to see what Emacs identifies as a
``word'' if we use a regular expression search.

A regular expression search that finds the pattern for which it is
searching leaves point after the last character matched.  This means
that a succession of successful word searches will move point forward
word by word.

As a practical matter, we want the regular expression search to jump
over whitespace and punctuation between words as well as over the
words themselves.  A regexp that refuses to jump over interword
whitespace would never jump more than one word!  This means that
the regexp should include the whitespace and punctuation that follows
a word, if any, as well as the word itself.  (A word may end a buffer
and not have any following whitespace or punctuation, so that part of
the regexp must be optional.)

Thus, what we want for the regexp is a pattern defining one or more
word constituent characters followed, optionally, by one or more
characters that are not word constituents.  The regular expression for
this is:

@smallexample
\w+\W*
@end smallexample

@noindent
The buffer's syntax table determines which characters are and are not
word constituents.  For more information about syntax,
@pxref{Syntax Tables, , Syntax Tables, elisp, The GNU Emacs Lisp
Reference Manual}.

@need 800
The search expression looks like this:

@smallexample
(re-search-forward "\\w+\\W*")
@end smallexample

@noindent
(Note that paired backslashes precede the @samp{w} and @samp{W}.  A
single backslash has special meaning to the Emacs Lisp interpreter.
It indicates that the following character is interpreted differently
than usual.  For example, the two characters, @samp{\n}, stand for
@samp{newline}, rather than for a backslash followed by @samp{n}.  Two
backslashes in a row stand for an ordinary, unspecial backslash, so
Emacs Lisp interpreter ends of seeing a single backslash followed by a
letter.  So it discovers the letter is special.)

We need a counter to count how many words there are; this variable
must first be set to 0 and then incremented each time Emacs goes
around the @code{while} loop.  The incrementing expression is simply:

@smallexample
(setq count (1+ count))
@end smallexample

Finally, we want to tell the user how many words there are in the
region.  The @code{message} function is intended for presenting this
kind of information to the user.  The message has to be phrased so
that it reads properly regardless of how many words there are in the
region: we don't want to say that ``there are 1 words in the region''.
The conflict between singular and plural is ungrammatical.  We can
solve this problem by using a conditional expression that evaluates
different messages depending on the number of words in the region.
There are three possibilities: no words in the region, one word in the
region, and more than one word.  This means that the @code{cond}
special form is appropriate.

@need 1500
All this leads to the following function definition:

@smallexample
@group
;;; @r{First version; has bugs!}
(defun @value{COUNT-WORDS} (beginning end)
  "Print number of words in the region.
Words are defined as at least one word-constituent
character followed by at least one character that
is not a word-constituent.  The buffer's syntax
table determines which characters these are."
  (interactive "r")
  (message "Counting words in region ... ")
@end group

@group
;;; @r{1. Set up appropriate conditions.}
  (save-excursion
    (goto-char beginning)
    (let ((count 0))
@end group

@group
;;; @r{2. Run the} while @r{loop.}
      (while (< (point) end)
        (re-search-forward "\\w+\\W*")
        (setq count (1+ count)))
@end group

@group
;;; @r{3. Send a message to the user.}
      (cond ((zerop count)
             (message
              "The region does NOT have any words."))
            ((= 1 count)
             (message
              "The region has 1 word."))
            (t
             (message
              "The region has %d words." count))))))
@end group
@end smallexample

@noindent
As written, the function works, but not in all circumstances.

@node Whitespace Bug
@subsection The Whitespace Bug in @code{@value{COUNT-WORDS}}

The @code{@value{COUNT-WORDS}} command described in the preceding
section has two bugs, or rather, one bug with two manifestations.
First, if you mark a region containing only whitespace in the middle
of some text, the @code{@value{COUNT-WORDS}} command tells you that the
region contains one word!  Second, if you mark a region containing
only whitespace at the end of the buffer or the accessible portion of
a narrowed buffer, the command displays an error message that looks
like this:

@smallexample
Search failed: "\\w+\\W*"
@end smallexample

If you are reading this in Info in GNU Emacs, you can test for these
bugs yourself.

First, evaluate the function in the usual manner to install it.
@ifinfo
Here is a copy of the definition.  Place your cursor after the closing
parenthesis and type @kbd{C-x C-e} to install it.

@smallexample
@group
;; @r{First version; has bugs!}
(defun @value{COUNT-WORDS} (beginning end)
  "Print number of words in the region.
Words are defined as at least one word-constituent character followed
by at least one character that is not a word-constituent.  The buffer's
syntax table determines which characters these are."
@end group
@group
  (interactive "r")
  (message "Counting words in region ... ")
@end group

@group
;;; @r{1. Set up appropriate conditions.}
  (save-excursion
    (goto-char beginning)
    (let ((count 0))
@end group

@group
;;; @r{2. Run the} while @r{loop.}
      (while (< (point) end)
        (re-search-forward "\\w+\\W*")
        (setq count (1+ count)))
@end group

@group
;;; @r{3. Send a message to the user.}
      (cond ((zerop count)
             (message "The region does NOT have any words."))
            ((= 1 count) (message "The region has 1 word."))
            (t (message "The region has %d words." count))))))
@end group
@end smallexample
@end ifinfo

@need 1000
If you wish, you can also install this key binding by evaluating it:

@smallexample
(global-set-key "\C-c=" '@value{COUNT-WORDS})
@end smallexample

To conduct the first test, set mark and point to the beginning and end
of the following line and then type @kbd{C-c =} (or @kbd{M-x
@value{COUNT-WORDS}} if you have not bound @kbd{C-c =}):

@smallexample
    one   two  three
@end smallexample

@noindent
Emacs will tell you, correctly, that the region has three words.

Repeat the test, but place mark at the beginning of the line and place
point just @emph{before} the word @samp{one}.  Again type the command
@kbd{C-c =} (or @kbd{M-x @value{COUNT-WORDS}}).  Emacs should tell you
that the region has no words, since it is composed only of the
whitespace at the beginning of the line.  But instead Emacs tells you
that the region has one word!

For the third test, copy the sample line to the end of the
@file{*scratch*} buffer and then type several spaces at the end of the
line.  Place mark right after the word @samp{three} and point at the
end of line.  (The end of the line will be the end of the buffer.)
Type @kbd{C-c =} (or @kbd{M-x @value{COUNT-WORDS}}) as you did before.
Again, Emacs should tell you that the region has no words, since it is
composed only of the whitespace at the end of the line.  Instead,
Emacs displays an error message saying @samp{Search failed}.

The two bugs stem from the same problem.

Consider the first manifestation of the bug, in which the command
tells you that the whitespace at the beginning of the line contains
one word.  What happens is this: The @code{M-x @value{COUNT-WORDS}}
command moves point to the beginning of the region.  The @code{while}
tests whether the value of point is smaller than the value of
@code{end}, which it is.  Consequently, the regular expression search
looks for and finds the first word.  It leaves point after the word.
@code{count} is set to one.  The @code{while} loop repeats; but this
time the value of point is larger than the value of @code{end}, the
loop is exited; and the function displays a message saying the number
of words in the region is one.  In brief, the regular expression
search looks for and finds the word even though it is outside
the marked region.

In the second manifestation of the bug, the region is whitespace at
the end of the buffer.  Emacs says @samp{Search failed}.  What happens
is that the true-or-false-test in the @code{while} loop tests true, so
the search expression is executed.  But since there are no more words
in the buffer, the search fails.

In both manifestations of the bug, the search extends or attempts to
extend outside of the region.

The solution is to limit the search to the region---this is a fairly
simple action, but as you may have come to expect, it is not quite as
simple as you might think.

As we have seen, the @code{re-search-forward} function takes a search
pattern as its first argument.  But in addition to this first,
mandatory argument, it accepts three optional arguments.  The optional
second argument bounds the search.  The optional third argument, if
@code{t}, causes the function to return @code{nil} rather than signal
an error if the search fails.  The optional fourth argument is a
repeat count.  (In Emacs, you can see a function's documentation by
typing @kbd{C-h f}, the name of the function, and then @key{RET}.)

In the @code{@value{COUNT-WORDS}} definition, the value of the end of
the region is held by the variable @code{end} which is passed as an
argument to the function.  Thus, we can add @code{end} as an argument
to the regular expression search expression:

@smallexample
(re-search-forward "\\w+\\W*" end)
@end smallexample

However, if you make only this change to the @code{@value{COUNT-WORDS}}
definition and then test the new version of the definition on a
stretch of whitespace, you will receive an error message saying
@samp{Search failed}.

What happens is this: the search is limited to the region, and fails
as you expect because there are no word-constituent characters in the
region.  Since it fails, we receive an error message.  But we do not
want to receive an error message in this case; we want to receive the
message ``The region does NOT have any words.''

The solution to this problem is to provide @code{re-search-forward}
with a third argument of @code{t}, which causes the function to return
@code{nil} rather than signal an error if the search fails.

However, if you make this change and try it, you will see the message
``Counting words in region ... '' and @dots{} you will keep on seeing
that message @dots{}, until you type @kbd{C-g} (@code{keyboard-quit}).

Here is what happens: the search is limited to the region, as before,
and it fails because there are no word-constituent characters in the
region, as expected.  Consequently, the @code{re-search-forward}
expression returns @code{nil}.  It does nothing else.  In particular,
it does not move point, which it does as a side effect if it finds the
search target.  After the @code{re-search-forward} expression returns
@code{nil}, the next expression in the @code{while} loop is evaluated.
This expression increments the count.  Then the loop repeats.  The
true-or-false-test tests true because the value of point is still less
than the value of end, since the @code{re-search-forward} expression
did not move point. @dots{} and the cycle repeats @dots{}

The @code{@value{COUNT-WORDS}} definition requires yet another
modification, to cause the true-or-false-test of the @code{while} loop
to test false if the search fails.  Put another way, there are two
conditions that must be satisfied in the true-or-false-test before the
word count variable is incremented: point must still be within the
region and the search expression must have found a word to count.

Since both the first condition and the second condition must be true
together, the two expressions, the region test and the search
expression, can be joined with an @code{and} special form and embedded in
the @code{while} loop as the true-or-false-test, like this:

@smallexample
(and (< (point) end) (re-search-forward "\\w+\\W*" end t))
@end smallexample

@c colon in printed section title causes problem in Info cross reference
@c also trouble with an overfull hbox
@iftex
@noindent
(For information about @code{and}, see
@ref{kill-new function, , The @code{kill-new} function}.)
@end iftex
@ifinfo
@noindent
(@xref{kill-new function, , The @code{kill-new} function}, for
information about @code{and}.)
@end ifinfo

The @code{re-search-forward} expression returns @code{t} if the search
succeeds and as a side effect moves point.  Consequently, as words are
found, point is moved through the region.  When the search expression
fails to find another word, or when point reaches the end of the
region, the true-or-false-test tests false, the @code{while} loop
exits, and the @code{@value{COUNT-WORDS}} function displays one or
other of its messages.

After incorporating these final changes, the @code{@value{COUNT-WORDS}}
works without bugs (or at least, without bugs that I have found!).
Here is what it looks like:

@smallexample
@group
;;; @r{Final version:} @code{while}
(defun @value{COUNT-WORDS} (beginning end)
  "Print number of words in the region."
  (interactive "r")
  (message "Counting words in region ... ")
@end group

@group
;;; @r{1. Set up appropriate conditions.}
  (save-excursion
    (let ((count 0))
      (goto-char beginning)
@end group

@group
;;; @r{2. Run the} while @r{loop.}
      (while (and (< (point) end)
                  (re-search-forward "\\w+\\W*" end t))
        (setq count (1+ count)))
@end group

@group
;;; @r{3. Send a message to the user.}
      (cond ((zerop count)
             (message
              "The region does NOT have any words."))
            ((= 1 count)
             (message
              "The region has 1 word."))
            (t
             (message
              "The region has %d words." count))))))
@end group
@end smallexample

@node recursive-count-words
@section Count Words Recursively
@cindex Count words recursively
@cindex Recursively counting words
@cindex Words, counted recursively

You can write the function for counting words recursively as well as
with a @code{while} loop.  Let's see how this is done.

First, we need to recognize that the @code{@value{COUNT-WORDS}}
function has three jobs: it sets up the appropriate conditions for
counting to occur; it counts the words in the region; and it sends a
message to the user telling how many words there are.

If we write a single recursive function to do everything, we will
receive a message for every recursive call.  If the region contains 13
words, we will receive thirteen messages, one right after the other.
We don't want this!  Instead, we must write two functions to do the
job, one of which (the recursive function) will be used inside of the
other.  One function will set up the conditions and display the
message; the other will return the word count.

Let us start with the function that causes the message to be displayed.
We can continue to call this @code{@value{COUNT-WORDS}}.

This is the function that the user will call.  It will be interactive.
Indeed, it will be similar to our previous versions of this
function, except that it will call @code{recursive-count-words} to
determine how many words are in the region.

@need 1250
We can readily construct a template for this function, based on our
previous versions:

@smallexample
@group
;; @r{Recursive version; uses regular expression search}
(defun @value{COUNT-WORDS} (beginning end)
  "@var{documentation}@dots{}"
  (@var{interactive-expression}@dots{})
@end group
@group

;;; @r{1. Set up appropriate conditions.}
  (@var{explanatory message})
  (@var{set-up functions}@dots{}
@end group
@group

;;; @r{2. Count the words.}
    @var{recursive call}
@end group
@group

;;; @r{3. Send a message to the user.}
    @var{message providing word count}))
@end group
@end smallexample

The definition looks straightforward, except that somehow the count
returned by the recursive call must be passed to the message
displaying the word count.  A little thought suggests that this can be
done by making use of a @code{let} expression: we can bind a variable
in the varlist of a @code{let} expression to the number of words in
the region, as returned by the recursive call; and then the
@code{cond} expression, using binding, can display the value to the
user.

Often, one thinks of the binding within a @code{let} expression as
somehow secondary to the primary work of a function.  But in this
case, what you might consider the primary job of the function,
counting words, is done within the @code{let} expression.

@need 1250
Using @code{let}, the function definition looks like this:

@smallexample
@group
(defun @value{COUNT-WORDS} (beginning end)
  "Print number of words in the region."
  (interactive "r")
@end group

@group
;;; @r{1. Set up appropriate conditions.}
  (message "Counting words in region ... ")
  (save-excursion
    (goto-char beginning)
@end group

@group
;;; @r{2. Count the words.}
    (let ((count (recursive-count-words end)))
@end group

@group
;;; @r{3. Send a message to the user.}
      (cond ((zerop count)
             (message
              "The region does NOT have any words."))
            ((= 1 count)
             (message
              "The region has 1 word."))
            (t
             (message
              "The region has %d words." count))))))
@end group
@end smallexample

Next, we need to write the recursive counting function.

A recursive function has at least three parts: the do-again-test, the
next-step-expression, and the recursive call.

The do-again-test determines whether the function will or will not be
called again.  Since we are counting words in a region and can use a
function that moves point forward for every word, the do-again-test
can check whether point is still within the region.  The do-again-test
should find the value of point and determine whether point is before,
at, or after the value of the end of the region.  We can use the
@code{point} function to locate point.  Clearly, we must pass the
value of the end of the region to the recursive counting function as an
argument.

In addition, the do-again-test should also test whether the search finds a
word.  If it does not, the function should not call itself again.

The next-step-expression changes a value so that when the recursive
function is supposed to stop calling itself, it stops.  More
precisely, the next-step-expression changes a value so that at the
right time, the do-again-test stops the recursive function from
calling itself again.  In this case, the next-step-expression can be
the expression that moves point forward, word by word.

The third part of a recursive function is the recursive call.

Somewhere, we also need a part that does the work of the
function, a part that does the counting.  A vital part!

@need 1250
But already, we have an outline of the recursive counting function:

@smallexample
@group
(defun recursive-count-words (region-end)
  "@var{documentation}@dots{}"
   @var{do-again-test}
   @var{next-step-expression}
   @var{recursive call})
@end group
@end smallexample

Now we need to fill in the slots.  Let's start with the simplest cases
first:  if point is at or beyond the end of the region, there cannot
be any words in the region, so the function should return zero.
Likewise, if the search fails, there are no words to count, so the
function should return zero.

On the other hand, if point is within the region and the search
succeeds, the function should call itself again.

@need 800
Thus, the do-again-test should look like this:

@smallexample
@group
(and (< (point) region-end)
     (re-search-forward "\\w+\\W*" region-end t))
@end group
@end smallexample

Note that the search expression is part of the do-again-test---the
function returns @code{t} if its search succeeds and @code{nil} if it
fails.  (@xref{Whitespace Bug, , The Whitespace Bug in
@code{@value{COUNT-WORDS}}}, for an explanation of how
@code{re-search-forward} works.)

The do-again-test is the true-or-false test of an @code{if} clause.
Clearly, if the do-again-test succeeds, the then-part of the @code{if}
clause should call the function again; but if it fails, the else-part
should return zero since either point is outside the region or the
search failed because there were no words to find.

But before considering the recursive call, we need to consider the
next-step-expression.  What is it?  Interestingly, it is the search
part of the do-again-test.

In addition to returning @code{t} or @code{nil} for the
do-again-test, @code{re-search-forward} moves point forward as a side
effect of a successful search.  This is the action that changes the
value of point so that the recursive function stops calling itself
when point completes its movement through the region.  Consequently,
the @code{re-search-forward} expression is the next-step-expression.

@need 1200
In outline, then, the body of the @code{recursive-count-words}
function looks like this:

@smallexample
@group
(if @var{do-again-test-and-next-step-combined}
    ;; @r{then}
    @var{recursive-call-returning-count}
  ;; @r{else}
  @var{return-zero})
@end group
@end smallexample

How to incorporate the mechanism that counts?

If you are not used to writing recursive functions, a question like
this can be troublesome.  But it can and should be approached
systematically.

We know that the counting mechanism should be associated in some way
with the recursive call.  Indeed, since the next-step-expression moves
point forward by one word, and since a recursive call is made for
each word, the counting mechanism must be an expression that adds one
to the value returned by a call to @code{recursive-count-words}.

@need 800
Consider several cases:

@itemize @bullet
@item
If there are two words in the region, the function should return
a value resulting from adding one to the value returned when it counts
the first word, plus the number returned when it counts the remaining
words in the region, which in this case is one.

@item
If there is one word in the region, the function should return
a value resulting from adding one to the value returned when it counts
that word, plus the number returned when it counts the remaining
words in the region, which in this case is zero.

@item
If there are no words in the region, the function should return zero.
@end itemize

From the sketch we can see that the else-part of the @code{if} returns
zero for the case of no words.  This means that the then-part of the
@code{if} must return a value resulting from adding one to the value
returned from a count of the remaining words.

@need 1200
The expression will look like this, where @code{1+} is a function that
adds one to its argument.

@smallexample
(1+ (recursive-count-words region-end))
@end smallexample

@need 1200
The whole @code{recursive-count-words} function will then look like
this:

@smallexample
@group
(defun recursive-count-words (region-end)
  "@var{documentation}@dots{}"

;;; @r{1. do-again-test}
  (if (and (< (point) region-end)
           (re-search-forward "\\w+\\W*" region-end t))
@end group

@group
;;; @r{2. then-part: the recursive call}
      (1+ (recursive-count-words region-end))

;;; @r{3. else-part}
    0))
@end group
@end smallexample

@need 1250
Let's examine how this works:

If there are no words in the region, the else part of the @code{if}
expression is evaluated and consequently the function returns zero.

If there is one word in the region, the value of point is less than
the value of @code{region-end} and the search succeeds.  In this case,
the true-or-false-test of the @code{if} expression tests true, and the
then-part of the @code{if} expression is evaluated.  The counting
expression is evaluated.  This expression returns a value (which will
be the value returned by the whole function) that is the sum of one
added to the value returned by a recursive call.

Meanwhile, the next-step-expression has caused point to jump over the
first (and in this case only) word in the region.  This means that
when @code{(recursive-count-words region-end)} is evaluated a second
time, as a result of the recursive call, the value of point will be
equal to or greater than the value of region end.  So this time,
@code{recursive-count-words} will return zero.  The zero will be added
to one, and the original evaluation of @code{recursive-count-words}
will return one plus zero, which is one, which is the correct amount.

Clearly, if there are two words in the region, the first call to
@code{recursive-count-words} returns one added to the value returned
by calling @code{recursive-count-words} on a region containing the
remaining word---that is, it adds one to one, producing two, which is
the correct amount.

Similarly, if there are three words in the region, the first call to
@code{recursive-count-words} returns one added to the value returned
by calling @code{recursive-count-words} on a region containing the
remaining two words---and so on and so on.

@need 1250
@noindent
With full documentation the two functions look like this:

@need 1250
@noindent
The recursive function:

@findex recursive-count-words
@smallexample
@group
(defun recursive-count-words (region-end)
  "Number of words between point and REGION-END."
@end group

@group
;;; @r{1. do-again-test}
  (if (and (< (point) region-end)
           (re-search-forward "\\w+\\W*" region-end t))
@end group

@group
;;; @r{2. then-part: the recursive call}
      (1+ (recursive-count-words region-end))

;;; @r{3. else-part}
    0))
@end group
@end smallexample

@need 800
@noindent
The wrapper:

@smallexample
@group
;;; @r{Recursive version}
(defun @value{COUNT-WORDS} (beginning end)
  "Print number of words in the region.
@end group

@group
Words are defined as at least one word-constituent
character followed by at least one character that is
not a word-constituent.  The buffer's syntax table
determines which characters these are."
@end group
@group
  (interactive "r")
  (message "Counting words in region ... ")
  (save-excursion
    (goto-char beginning)
    (let ((count (recursive-count-words end)))
@end group
@group
      (cond ((zerop count)
             (message
              "The region does NOT have any words."))
@end group
@group
            ((= 1 count)
             (message "The region has 1 word."))
            (t
             (message
              "The region has %d words." count))))))
@end group
@end smallexample

@node Counting Exercise
@section Exercise: Counting Punctuation

Using a @code{while} loop, write a function to count the number of
punctuation marks in a region---period, comma, semicolon, colon,
exclamation mark, and question mark.  Do the same using recursion.

@node Words in a defun
@chapter Counting Words in a @code{defun}
@cindex Counting words in a @code{defun}
@cindex Word counting in a @code{defun}

Our next project is to count the number of words in a function
definition.  Clearly, this can be done using some variant of
@code{@value{COUNT-WORDS}}.  @xref{Counting Words, , Counting via
Repetition and Regexps}.  If we are just going to count the words in
one definition, it is easy enough to mark the definition with the
@kbd{C-M-h} (@code{mark-defun}) command, and then call
@code{@value{COUNT-WORDS}}.

However, I am more ambitious: I want to count the words and symbols in
every definition in the Emacs sources and then print a graph that
shows how many functions there are of each length: how many contain 40
to 49 words or symbols, how many contain 50 to 59 words or symbols,
and so on.  I have often been curious how long a typical function is,
and this will tell.

@menu
* Divide and Conquer::
* Words and Symbols::           What to count?
* Syntax::                      What constitutes a word or symbol?
* count-words-in-defun::        Very like @code{@value{COUNT-WORDS}}.
* Several defuns::              Counting several defuns in a file.
* Find a File::                 Do you want to look at a file?
* lengths-list-file::           A list of the lengths of many definitions.
* Several files::               Counting in definitions in different files.
* Several files recursively::   Recursively counting in different files.
* Prepare the data::            Prepare the data for display in a graph.
@end menu

@ifnottex
@node Divide and Conquer
@unnumberedsec Divide and Conquer
@end ifnottex

Described in one phrase, the histogram project is daunting; but
divided into numerous small steps, each of which we can take one at a
time, the project becomes less fearsome.  Let us consider what the
steps must be:

@itemize @bullet
@item
First, write a function to count the words in one definition.  This
includes the problem of handling symbols as well as words.

@item
Second, write a function to list the number of words in each function
in a file.  This function can use the @code{count-words-in-defun}
function.

@item
Third, write a function to list the number of words in each function
in each of several files.  This entails automatically finding the
various files, switching to them, and counting the words in the
definitions within them.

@item
Fourth, write a function to convert the list of numbers that we
created in step three to a form that will be suitable for printing as
a graph.

@item
Fifth, write a function to print the results as a graph.
@end itemize

This is quite a project!  But if we take each step slowly, it will not
be difficult.

@node Words and Symbols
@section What to Count?
@cindex Words and symbols in defun

When we first start thinking about how to count the words in a
function definition, the first question is (or ought to be) what are
we going to count?  When we speak of ``words'' with respect to a Lisp
function definition, we are actually speaking, in large part, of
symbols.  For example, the following @code{multiply-by-seven}
function contains the five symbols @code{defun},
@code{multiply-by-seven}, @code{number}, @code{*}, and @code{7}.  In
addition, in the documentation string, it contains the four words
@samp{Multiply}, @samp{NUMBER}, @samp{by}, and @samp{seven}.  The
symbol @samp{number} is repeated, so the definition contains a total
of ten words and symbols.

@smallexample
@group
(defun multiply-by-seven (number)
  "Multiply NUMBER by seven."
  (* 7 number))
@end group
@end smallexample

@noindent
However, if we mark the @code{multiply-by-seven} definition with
@kbd{C-M-h} (@code{mark-defun}), and then call
@code{@value{COUNT-WORDS}} on it, we will find that
@code{@value{COUNT-WORDS}} claims the definition has eleven words, not
ten!  Something is wrong!

The problem is twofold: @code{@value{COUNT-WORDS}} does not count the
@samp{*} as a word, and it counts the single symbol,
@code{multiply-by-seven}, as containing three words.  The hyphens are
treated as if they were interword spaces rather than intraword
connectors: @samp{multiply-by-seven} is counted as if it were written
@samp{multiply by seven}.

The cause of this confusion is the regular expression search within
the @code{@value{COUNT-WORDS}} definition that moves point forward word
by word.  In the canonical version of @code{@value{COUNT-WORDS}}, the
regexp is:

@smallexample
"\\w+\\W*"
@end smallexample

@noindent
This regular expression is a pattern defining one or more word
constituent characters possibly followed by one or more characters
that are not word constituents.  What is meant by ``word constituent
characters'' brings us to the issue of syntax, which is worth a section
of its own.

@node Syntax
@section What Constitutes a Word or Symbol?
@cindex Syntax categories and tables

Emacs treats different characters as belonging to different
@dfn{syntax categories}.  For example, the regular expression,
@samp{\\w+}, is a pattern specifying one or more @emph{word
constituent} characters.  Word constituent characters are members of
one syntax category.  Other syntax categories include the class of
punctuation characters, such as the period and the comma, and the
class of whitespace characters, such as the blank space and the tab
character.  (For more information, @pxref{Syntax Tables, , Syntax
Tables, elisp, The GNU Emacs Lisp Reference Manual}.)

Syntax tables specify which characters belong to which categories.
Usually, a hyphen is not specified as a word constituent character.
Instead, it is specified as being in the class of characters that are
part of symbol names but not words.  This means that the
@code{@value{COUNT-WORDS}} function treats it in the same way it treats
an interword white space, which is why @code{@value{COUNT-WORDS}}
counts @samp{multiply-by-seven} as three words.

There are two ways to cause Emacs to count @samp{multiply-by-seven} as
one symbol: modify the syntax table or modify the regular expression.

We could redefine a hyphen as a word constituent character by
modifying the syntax table that Emacs keeps for each mode.  This
action would serve our purpose, except that a hyphen is merely the
most common character within symbols that is not typically a word
constituent character; there are others, too.

Alternatively, we can redefine the regexp used in the
@code{@value{COUNT-WORDS}} definition so as to include symbols.  This
procedure has the merit of clarity, but the task is a little tricky.

@need 1200
The first part is simple enough: the pattern must match at least one
character that is a word or symbol constituent.  Thus:

@smallexample
"\\(\\w\\|\\s_\\)+"
@end smallexample

@noindent
The @samp{\\(} is the first part of the grouping construct that
includes the @samp{\\w} and the @samp{\\s_} as alternatives, separated
by the @samp{\\|}.  The @samp{\\w} matches any word-constituent
character and the @samp{\\s_} matches any character that is part of a
symbol name but not a word-constituent character.  The @samp{+}
following the group indicates that the word or symbol constituent
characters must be matched at least once.

However, the second part of the regexp is more difficult to design.
What we want is to follow the first part with optionally one or more
characters that are not constituents of a word or symbol.  At first,
I thought I could define this with the following:

@smallexample
"\\(\\W\\|\\S_\\)*"
@end smallexample

@noindent
The upper case @samp{W} and @samp{S} match characters that are
@emph{not} word or symbol constituents.  Unfortunately, this
expression matches any character that is either not a word constituent
or not a symbol constituent.  This matches any character!

I then noticed that every word or symbol in my test region was
followed by white space (blank space, tab, or newline).  So I tried
placing a pattern to match one or more blank spaces after the pattern
for one or more word or symbol constituents.  This failed, too.  Words
and symbols are often separated by whitespace, but in actual code
parentheses may follow symbols and punctuation may follow words.  So
finally, I designed a pattern in which the word or symbol constituents
are followed optionally by characters that are not white space and
then followed optionally by white space.

@need 800
Here is the full regular expression:

@smallexample
"\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"
@end smallexample

@node count-words-in-defun
@section The @code{count-words-in-defun} Function
@cindex Counting words in a @code{defun}

We have seen that there are several ways to write a
@code{count-words-region} function.  To write a
@code{count-words-in-defun}, we need merely adapt one of these
versions.

The version that uses a @code{while} loop is easy to understand, so I
am going to adapt that.  Because @code{count-words-in-defun} will be
part of a more complex program, it need not be interactive and it need
not display a message but just return the count.  These considerations
simplify the definition a little.

On the other hand, @code{count-words-in-defun} will be used within a
buffer that contains function definitions.  Consequently, it is
reasonable to ask that the function determine whether it is called
when point is within a function definition, and if it is, to return
the count for that definition.  This adds complexity to the
definition, but saves us from needing to pass arguments to the
function.

@need 1250
These considerations lead us to prepare the following template:

@smallexample
@group
(defun count-words-in-defun ()
  "@var{documentation}@dots{}"
  (@var{set up}@dots{}
     (@var{while loop}@dots{})
   @var{return count})
@end group
@end smallexample

@noindent
As usual, our job is to fill in the slots.

First, the set up.

We are presuming that this function will be called within a buffer
containing function definitions.  Point will either be within a
function definition or not.  For @code{count-words-in-defun} to work,
point must move to the beginning of the definition, a counter must
start at zero, and the counting loop must stop when point reaches the
end of the definition.

The @code{beginning-of-defun} function searches backwards for an
opening delimiter such as a @samp{(} at the beginning of a line, and
moves point to that position, or else to the limit of the search.  In
practice, this means that @code{beginning-of-defun} moves point to the
beginning of an enclosing or preceding function definition, or else to
the beginning of the buffer.  We can use @code{beginning-of-defun} to
place point where we wish to start.

The @code{while} loop requires a counter to keep track of the words or
symbols being counted.  A @code{let} expression can be used to create
a local variable for this purpose, and bind it to an initial value of zero.

The @code{end-of-defun} function works like @code{beginning-of-defun}
except that it moves point to the end of the definition.
@code{end-of-defun} can be used as part of an expression that
determines the position of the end of the definition.

The set up for @code{count-words-in-defun} takes shape rapidly: first
we move point to the beginning of the definition, then we create a
local variable to hold the count, and finally, we record the position
of the end of the definition so the @code{while} loop will know when to stop
looping.

@need 1250
The code looks like this:

@smallexample
@group
(beginning-of-defun)
(let ((count 0)
      (end (save-excursion (end-of-defun) (point))))
@end group
@end smallexample

@noindent
The code is simple.  The only slight complication is likely to concern
@code{end}: it is bound to the position of the end of the definition
by a @code{save-excursion} expression that returns the value of point
after @code{end-of-defun} temporarily moves it to the end of the
definition.

The second part of the @code{count-words-in-defun}, after the set up,
is the @code{while} loop.

The loop must contain an expression that jumps point forward word by
word and symbol by symbol, and another expression that counts the
jumps.  The true-or-false-test for the @code{while} loop should test
true so long as point should jump forward, and false when point is at
the end of the definition.  We have already redefined the regular
expression for this, so the loop is straightforward:

@smallexample
@group
(while (and (< (point) end)
            (re-search-forward
             "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*" end t))
  (setq count (1+ count)))
@end group
@end smallexample

The third part of the function definition returns the count of words
and symbols.  This part is the last expression within the body of the
@code{let} expression, and can be, very simply, the local variable
@code{count}, which when evaluated returns the count.

@need 1250
Put together, the @code{count-words-in-defun} definition looks like this:

@findex count-words-in-defun
@smallexample
@group
(defun count-words-in-defun ()
  "Return the number of words and symbols in a defun."
  (beginning-of-defun)
  (let ((count 0)
        (end (save-excursion (end-of-defun) (point))))
@end group
@group
    (while
        (and (< (point) end)
             (re-search-forward
              "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"
              end t))
      (setq count (1+ count)))
    count))
@end group
@end smallexample

How to test this?  The function is not interactive, but it is easy to
put a wrapper around the function to make it interactive; we can use
almost the same code as for the recursive version of
@code{@value{COUNT-WORDS}}:

@smallexample
@group
;;; @r{Interactive version.}
(defun count-words-defun ()
  "Number of words and symbols in a function definition."
  (interactive)
  (message
   "Counting words and symbols in function definition ... ")
@end group
@group
  (let ((count (count-words-in-defun)))
    (cond
     ((zerop count)
      (message
       "The definition does NOT have any words or symbols."))
@end group
@group
     ((= 1 count)
      (message
       "The definition has 1 word or symbol."))
     (t
      (message
       "The definition has %d words or symbols." count)))))
@end group
@end smallexample

@need 800
@noindent
Let's re-use @kbd{C-c =} as a convenient key binding:

@smallexample
(global-set-key "\C-c=" 'count-words-defun)
@end smallexample

Now we can try out @code{count-words-defun}: install both
@code{count-words-in-defun} and @code{count-words-defun}, and set the
key binding.  Then copy the following to an Emacs Lisp buffer (like,
for instance, @file{*scratch*}), place the cursor within the
definition, and use the @kbd{C-c =} command.

@smallexample
@group
(defun multiply-by-seven (number)
  "Multiply NUMBER by seven."
  (* 7 number))
     @result{} 10
@end group
@end smallexample

@noindent
Success!  The definition has 10 words and symbols.

The next problem is to count the numbers of words and symbols in
several definitions within a single file.

@node Several defuns
@section Count Several @code{defuns} Within a File

A file such as @file{simple.el} may have a hundred or more function
definitions within it.  Our long term goal is to collect statistics on
many files, but as a first step, our immediate goal is to collect
statistics on one file.

The information will be a series of numbers, each number being the
length of a function definition.  We can store the numbers in a list.

We know that we will want to incorporate the information regarding one
file with information about many other files; this means that the
function for counting definition lengths within one file need only
return the list of lengths.  It need not and should not display any
messages.

The word count commands contain one expression to jump point forward
word by word and another expression to count the jumps.  The function
to return the lengths of definitions can be designed to work the same
way, with one expression to jump point forward definition by
definition and another expression to construct the lengths' list.

This statement of the problem makes it elementary to write the
function definition.  Clearly, we will start the count at the
beginning of the file, so the first command will be @code{(goto-char
(point-min))}.  Next, we start the @code{while} loop; and the
true-or-false test of the loop can be a regular expression search for
the next function definition---so long as the search succeeds, point
is moved forward and then the body of the loop is evaluated.  The body
needs an expression that constructs the lengths' list.  @code{cons},
the list construction command, can be used to create the list.  That
is almost all there is to it.

@need 800
Here is what this fragment of code looks like:

@smallexample
@group
(goto-char (point-min))
(while (re-search-forward "^(defun" nil t)
  (setq lengths-list
        (cons (count-words-in-defun) lengths-list)))
@end group
@end smallexample

What we have left out is the mechanism for finding the file that
contains the function definitions.

In previous examples, we either used this, the Info file, or we
switched back and forth to some other buffer, such as the
@file{*scratch*} buffer.

Finding a file is a new process that we have not yet discussed.

@node Find a File
@section Find a File
@cindex Find a File

To find a file in Emacs, you use the @kbd{C-x C-f} (@code{find-file})
command.  This command is almost, but not quite right for the lengths
problem.

@need 1200
Let's look at the source for @code{find-file}:

@smallexample
@group
(defun find-file (filename)
  "Edit file FILENAME.
Switch to a buffer visiting file FILENAME,
creating one if none already exists."
  (interactive "FFind file: ")
  (switch-to-buffer (find-file-noselect filename)))
@end group
@end smallexample

@noindent
(The most recent version of the @code{find-file} function definition
permits you to specify optional wildcards to visit multiple files;
that makes the definition more complex and we will not discuss it
here, since it is not relevant.  You can see its source using either
@kbd{M-.} (@code{xref-find-definitions}) or @kbd{C-h f}
(@code{describe-function}).)

@ignore
In Emacs 22
(defun find-file (filename &optional wildcards)
  "Edit file FILENAME.
Switch to a buffer visiting file FILENAME,
creating one if none already exists.
Interactively, the default if you just type @key{RET} is the current directory,
but the visited file name is available through the minibuffer history:
type M-n to pull it into the minibuffer.

Interactively, or if WILDCARDS is non-nil in a call from Lisp,
expand wildcards (if any) and visit multiple files.  You can
suppress wildcard expansion by setting `find-file-wildcards' to nil.

To visit a file without any kind of conversion and without
automatically choosing a major mode, use \\[find-file-literally]."
  (interactive (find-file-read-args "Find file: " nil))
  (let ((value (find-file-noselect filename nil nil wildcards)))
    (if (listp value)
        (mapcar 'switch-to-buffer (nreverse value))
      (switch-to-buffer value))))
@end ignore

The definition I am showing possesses short but complete documentation
and an interactive specification that prompts you for a file name when
you use the command interactively.  The body of the definition
contains two functions, @code{find-file-noselect} and
@code{switch-to-buffer}.

According to its documentation as shown by @kbd{C-h f} (the
@code{describe-function} command), the @code{find-file-noselect}
function reads the named file into a buffer and returns the buffer.
(Its most recent version includes an optional @var{wildcards} argument,
too, as well as another to read a file literally and another to
suppress warning messages.  These optional arguments are irrelevant.)

However, the @code{find-file-noselect} function does not select the
buffer in which it puts the file.  Emacs does not switch its attention
(or yours if you are using @code{find-file-noselect}) to the selected
buffer.  That is what @code{switch-to-buffer} does: it switches the
buffer to which Emacs attention is directed; and it switches the
buffer displayed in the window to the new buffer.  We have discussed
buffer switching elsewhere.  (@xref{切换缓冲区}.)

In this histogram project, we do not need to display each file on the
screen as the program determines the length of each definition within
it.  Instead of employing @code{switch-to-buffer}, we can work with
@code{set-buffer}, which redirects the attention of the computer
program to a different buffer but does not redisplay it on the screen.
So instead of calling on @code{find-file} to do the job, we must write
our own expression.

The task is easy: use @code{find-file-noselect} and @code{set-buffer}.

@node lengths-list-file
@section @code{lengths-list-file} in Detail

The core of the @code{lengths-list-file} function is a @code{while}
loop containing a function to move point forward defun by defun, and
a function to count the number of words and symbols in each defun.
This core must be surrounded by functions that do various other tasks,
including finding the file, and ensuring that point starts out at the
beginning of the file.  The function definition looks like this:
@findex lengths-list-file

@smallexample
@group
(defun lengths-list-file (filename)
  "Return list of definitions' lengths within FILE.
The returned list is a list of numbers.
Each number is the number of words or
symbols in one function definition."
@end group
@group
  (message "Working on `%s' ... " filename)
  (save-excursion
    (let ((buffer (find-file-noselect filename))
          (lengths-list))
      (set-buffer buffer)
      (setq buffer-read-only t)
      (widen)
      (goto-char (point-min))
      (while (re-search-forward "^(defun" nil t)
        (setq lengths-list
              (cons (count-words-in-defun) lengths-list)))
      (kill-buffer buffer)
      lengths-list)))
@end group
@end smallexample

@noindent
The function is passed one argument, the name of the file on which it
will work.  It has four lines of documentation, but no interactive
specification.  Since people worry that a computer is broken if they
don't see anything going on, the first line of the body is a
message.

The next line contains a @code{save-excursion} that returns Emacs's
attention to the current buffer when the function completes.  This is
useful in case you embed this function in another function that
presumes point is restored to the original buffer.

In the varlist of the @code{let} expression, Emacs finds the file and
binds the local variable @code{buffer} to the buffer containing the
file.  At the same time, Emacs creates @code{lengths-list} as a local
variable.

Next, Emacs switches its attention to the buffer.

In the following line, Emacs makes the buffer read-only.  Ideally,
this line is not necessary.  None of the functions for counting words
and symbols in a function definition should change the buffer.
Besides, the buffer is not going to be saved, even if it were changed.
This line is entirely the consequence of great, perhaps excessive,
caution.  The reason for the caution is that this function and those
it calls work on the sources for Emacs and it is inconvenient if they
are inadvertently modified.  It goes without saying that I did not
realize a need for this line until an experiment went awry and started
to modify my Emacs source files @dots{}

Next comes a call to widen the buffer if it is narrowed.  This
function is usually not needed---Emacs creates a fresh buffer if none
already exists; but if a buffer visiting the file already exists Emacs
returns that one.  In this case, the buffer may be narrowed and must
be widened.  If we wanted to be fully user-friendly, we would
arrange to save the restriction and the location of point, but we
won't.

The @code{(goto-char (point-min))} expression moves point to the
beginning of the buffer.

Then comes a @code{while} loop in which the work of the function is
carried out.  In the loop, Emacs determines the length of each
definition and constructs a lengths' list containing the information.

Emacs kills the buffer after working through it.  This is to save
space inside of Emacs.  My version of GNU Emacs 19 contained over 300
source files of interest; GNU Emacs 22 contains over a thousand source
files.  Another function will apply @code{lengths-list-file} to each
of the files.

Finally, the last expression within the @code{let} expression is the
@code{lengths-list} variable; its value is returned as the value of
the whole function.

You can try this function by installing it in the usual fashion.  Then
place your cursor after the following expression and type @kbd{C-x
C-e} (@code{eval-last-sexp}).

@c !!! 22.1.1 lisp sources location here
@smallexample
(lengths-list-file
 "/usr/local/share/emacs/22.1/lisp/emacs-lisp/debug.el")
@end smallexample

@noindent
You may need to change the pathname of the file; the one here is for
GNU Emacs version 22.1.  To change the expression, copy it to
the @file{*scratch*} buffer and edit it.

@need 1200
@noindent
Also, to see the full length of the list, rather than a truncated
version, you may have to evaluate the following:
@c We do not want to insert, so do not mention the zero prefix argument.

@smallexample
(custom-set-variables '(eval-expression-print-length nil))
@end smallexample

@noindent
(@xref{defcustom, , Specifying Variables using @code{defcustom}}.
Then evaluate the @code{lengths-list-file} expression.)

@need 1200
The lengths' list for @file{debug.el} takes less than a second to
produce and looks like this in GNU Emacs 22:

@smallexample
(83 113 105 144 289 22 30 97 48 89 25 52 52 88 28 29 77 49 43 290 232 587)
@end smallexample

@need 1500
(Using my old machine, the version 19 lengths' list for @file{debug.el}
took seven seconds to produce and looked like this:

@smallexample
(75 41 80 62 20 45 44 68 45 12 34 235)
@end smallexample

@noindent
The newer version of @file{debug.el} contains more defuns than the
earlier one; and my new machine is much faster than the old one.)

Note that the length of the last definition in the file is first in
the list.

@node Several files
@section Count Words in @code{defuns} in Different Files

In the previous section, we created a function that returns a list of
the lengths of each definition in a file.  Now, we want to define a
function to return a master list of the lengths of the definitions in
a list of files.

Working on each of a list of files is a repetitious act, so we can use
either a @code{while} loop or recursion.

@menu
* lengths-list-many-files::     Return a list of the lengths of defuns.
* append::                      Attach one list to another.
@end menu

@ifnottex
@node lengths-list-many-files
@unnumberedsubsec Determine the lengths of @code{defuns}
@end ifnottex

The design using a @code{while} loop is routine.  The argument passed
to the function is a list of files.  As we saw earlier (@pxref{Loop
Example}), you can write a @code{while} loop so that the body of the
loop is evaluated if such a list contains elements, but to exit the
loop if the list is empty.  For this design to work, the body of the
loop must contain an expression that shortens the list each time the
body is evaluated, so that eventually the list is empty.  The usual
technique is to set the value of the list to the value of the @sc{cdr}
of the list each time the body is evaluated.

@need 800
The template looks like this:

@smallexample
@group
(while @var{test-whether-list-is-empty}
  @var{body}@dots{}
  @var{set-list-to-cdr-of-list})
@end group
@end smallexample

Also, we remember that a @code{while} loop returns @code{nil} (the
result of evaluating the true-or-false-test), not the result of any
evaluation within its body.  (The evaluations within the body of the
loop are done for their side effects.)  However, the expression that
sets the lengths' list is part of the body---and that is the value
that we want returned by the function as a whole.  To do this, we
enclose the @code{while} loop within a @code{let} expression, and
arrange that the last element of the @code{let} expression contains
the value of the lengths' list.  (@xref{Incrementing Example, , Loop
Example with an Incrementing Counter}.)

@findex lengths-list-many-files
@need 1250
These considerations lead us directly to the function itself:

@smallexample
@group
;;; @r{Use @code{while} loop.}
(defun lengths-list-many-files (list-of-files)
  "Return list of lengths of defuns in LIST-OF-FILES."
@end group
@group
  (let (lengths-list)

;;; @r{true-or-false-test}
    (while list-of-files
      (setq lengths-list
            (append
             lengths-list

;;; @r{Generate a lengths' list.}
             (lengths-list-file
              (expand-file-name (car list-of-files)))))
@end group

@group
;;; @r{Make files' list shorter.}
      (setq list-of-files (cdr list-of-files)))

;;; @r{Return final value of lengths' list.}
    lengths-list))
@end group
@end smallexample

@code{expand-file-name} is a built-in function that converts a file
name to the absolute, long, path name form.  The function employs the
name of the directory in which the function is called.

@c !!! 22.1.1 lisp sources location here
@need 1500
Thus, if @code{expand-file-name} is called on @code{debug.el} when
Emacs is visiting the
@file{/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/} directory,

@smallexample
debug.el
@end smallexample

@need 800
@noindent
becomes

@c !!! 22.1.1 lisp sources location here
@smallexample
/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/debug.el
@end smallexample

The only other new element of this function definition is the as yet
unstudied function @code{append}, which merits a short section for
itself.

@node append
@subsection The @code{append} Function

@need 800
The @code{append} function attaches one list to another.  Thus,

@smallexample
(append '(1 2 3 4) '(5 6 7 8))
@end smallexample

@need 800
@noindent
produces the list

@smallexample
(1 2 3 4 5 6 7 8)
@end smallexample

This is exactly how we want to attach two lengths' lists produced by
@code{lengths-list-file} to each other.  The results contrast with
@code{cons},

@smallexample
(cons '(1 2 3 4) '(5 6 7 8))
@end smallexample

@need 1250
@noindent
which constructs a new list in which the first argument to @code{cons}
becomes the first element of the new list:

@smallexample
((1 2 3 4) 5 6 7 8)
@end smallexample

@node Several files recursively
@section Recursively Count Words in Different Files

Besides a @code{while} loop, you can work on each of a list of files
with recursion.  A recursive version of @code{lengths-list-many-files}
is short and simple.

The recursive function has the usual parts: the do-again-test, the
next-step-expression, and the recursive call.  The do-again-test
determines whether the function should call itself again, which it
will do if the @code{list-of-files} contains any remaining elements;
the next-step-expression resets the @code{list-of-files} to the
@sc{cdr} of itself, so eventually the list will be empty; and the
recursive call calls itself on the shorter list.  The complete
function is shorter than this description!
@findex recursive-lengths-list-many-files

@smallexample
@group
(defun recursive-lengths-list-many-files (list-of-files)
  "Return list of lengths of each defun in LIST-OF-FILES."
  (if list-of-files                     ; @r{do-again-test}
      (append
       (lengths-list-file
        (expand-file-name (car list-of-files)))
       (recursive-lengths-list-many-files
        (cdr list-of-files)))))
@end group
@end smallexample

@noindent
In a sentence, the function returns the lengths' list for the first of
the @code{list-of-files} appended to the result of calling itself on
the rest of the @code{list-of-files}.

Here is a test of @code{recursive-lengths-list-many-files}, along with
the results of running @code{lengths-list-file} on each of the files
individually.

Install @code{recursive-lengths-list-many-files} and
@code{lengths-list-file}, if necessary, and then evaluate the
following expressions.  You may need to change the files' pathnames;
those here work when this Info file and the Emacs sources are located
in their customary places.  To change the expressions, copy them to
the @file{*scratch*} buffer, edit them, and then evaluate them.

The results are shown after the @samp{@result{}}.  (These results are
for files from Emacs version 22.1.1; files from other versions of
Emacs may produce different results.)

@c !!! 22.1.1 lisp sources location here
@smallexample
@group
(cd "/usr/local/share/emacs/22.1.1/")

(lengths-list-file "./lisp/macros.el")
     @result{} (283 263 480 90)
@end group

@group
(lengths-list-file "./lisp/mail/mailalias.el")
     @result{} (38 32 29 95 178 180 321 218 324)
@end group

@group
(lengths-list-file "./lisp/hex-util.el")
     @result{} (82 71)
@end group

@group
  (recursive-lengths-list-many-files
   '("./lisp/macros.el"
     "./lisp/mail/mailalias.el"
     "./lisp/hex-util.el"))
       @result{} (283 263 480 90 38 32 29 95 178 180 321 218 324 82 71)
@end group
@end smallexample

The @code{recursive-lengths-list-many-files} function produces the
output we want.

The next step is to prepare the data in the list for display in a graph.

@node Prepare the data
@section Prepare the Data for Display in a Graph

The @code{recursive-lengths-list-many-files} function returns a list
of numbers.  Each number records the length of a function definition.
What we need to do now is transform this data into a list of numbers
suitable for generating a graph.  The new list will tell how many
functions definitions contain less than 10 words and
symbols, how many contain between 10 and 19 words and symbols, how
many contain between 20 and 29 words and symbols, and so on.

In brief, we need to go through the lengths' list produced by the
@code{recursive-lengths-list-many-files} function and count the number
of defuns within each range of lengths, and produce a list of those
numbers.

@menu
* Data for Display in Detail::
* Sorting::                     Sorting lists.
* Files List::                  Making a list of files.
* Counting function definitions::
@end menu

@ifnottex
@node Data for Display in Detail
@unnumberedsubsec The Data for Display in Detail
@end ifnottex

Based on what we have done before, we can readily foresee that it
should not be too hard to write a function that @sc{cdr}s down the
lengths' list, looks at each element, determines which length range it
is in, and increments a counter for that range.

However, before beginning to write such a function, we should consider
the advantages of sorting the lengths' list first, so the numbers are
ordered from smallest to largest.  First, sorting will make it easier
to count the numbers in each range, since two adjacent numbers will
either be in the same length range or in adjacent ranges.  Second, by
inspecting a sorted list, we can discover the highest and lowest
number, and thereby determine the largest and smallest length range
that we will need.

@node Sorting
@subsection Sorting Lists
@findex sort

Emacs contains a function to sort lists, called (as you might guess)
@code{sort}.  The @code{sort} function takes two arguments, the list
to be sorted, and a predicate that determines whether the first of
two list elements is less than the second.

As we saw earlier (@pxref{错误类型的参数, , 使用错误类型的对象作为参数}), a predicate is a function that
determines whether some property is true or false.  The @code{sort}
function will reorder a list according to whatever property the
predicate uses; this means that @code{sort} can be used to sort
non-numeric lists by non-numeric criteria---it can, for example,
alphabetize a list.

@need 1250
The @code{<} function is used when sorting a numeric list.  For example,

@smallexample
(sort '(4 8 21 17 33 7 21 7) '<)
@end smallexample

@need 800
@noindent
produces this:

@smallexample
(4 7 7 8 17 21 21 33)
@end smallexample

@noindent
(Note that in this example, both the arguments are quoted so that the
symbols are not evaluated before being passed to @code{sort} as
arguments.)

Sorting the list returned by the
@code{recursive-lengths-list-many-files} function is straightforward;
it uses the @code{<} function:

@smallexample
@group
(sort
 (recursive-lengths-list-many-files
  '("./lisp/macros.el"
    "./lisp/mailalias.el"
    "./lisp/hex-util.el"))
 '<)
@end group
@end smallexample

@need 800
@noindent
which produces:

@smallexample
(29 32 38 71 82 90 95 178 180 218 263 283 321 324 480)
@end smallexample

@noindent
(Note that in this example, the first argument to @code{sort} is not
quoted, since the expression must be evaluated so as to produce the
list that is passed to @code{sort}.)

@node Files List
@subsection Making a List of Files

The @code{recursive-lengths-list-many-files} function requires a list
of files as its argument.  For our test examples, we constructed such
a list by hand; but the Emacs Lisp source directory is too large for
us to do for that.  Instead, we will write a function to do the job
for us.  In this function, we will use both a @code{while} loop and a
recursive call.

@findex directory-files
We did not have to write a function like this for older versions of
GNU Emacs, since they placed all the @samp{.el} files in one
directory.  Instead, we were able to use the @code{directory-files}
function, which lists the names of files that match a specified
pattern within a single directory.

However, recent versions of Emacs place Emacs Lisp files in
sub-directories of the top level @file{lisp} directory.  This
re-arrangement eases navigation.  For example, all the mail related
files are in a @file{lisp} sub-directory called @file{mail}.  But at
the same time, this arrangement forces us to create a file listing
function that descends into the sub-directories.

@findex files-in-below-directory
We can create this function, called @code{files-in-below-directory},
using familiar functions such as @code{car}, @code{nthcdr}, and
@code{substring} in conjunction with an existing function called
@code{directory-files-and-attributes}.  This latter function not only
lists all the filenames in a directory, including the names
of sub-directories, but also their attributes.

To restate our goal: to create a function that will enable us
to feed filenames to @code{recursive-lengths-list-many-files}
as a list that looks like this (but with more elements):

@smallexample
@group
("./lisp/macros.el"
 "./lisp/mail/rmail.el"
 "./lisp/hex-util.el")
@end group
@end smallexample

The @code{directory-files-and-attributes} function returns a list of
lists.  Each of the lists within the main list consists of 13
elements.  The first element is a string that contains the name of the
file---which, in GNU/Linux, may be a @dfn{directory file}, that is to
say, a file with the special attributes of a directory.  The second
element of the list is @code{t} for a directory, a string
for symbolic link (the string is the name linked to), or @code{nil}.

For example, the first @samp{.el} file in the @file{lisp/} directory
is @file{abbrev.el}.  Its name is
@file{/usr/local/share/emacs/22.1.1/lisp/abbrev.el} and it is not a
directory or a symbolic link.

@need 1000
This is how @code{directory-files-and-attributes} lists that file and
its attributes:

@smallexample
@group
("abbrev.el"
nil
1
1000
100
@end group
@group
(20615 27034 579989 697000)
(17905 55681 0 0)
(20615 26327 734791 805000)@footnote{If @code{current-time-list} is
@code{nil} the three timestamps are @code{(1351051674579989697
. 1000000000)}, @code{(1173477761000000000 . 1000000000)}, and
@code{(1351050967734791805 . 1000000000)}, respectively.}
13188
"-rw-r--r--"
@end group
@group
t
2971624
773)
@end group
@end smallexample

@need 1200
On the other hand, @file{mail/} is a directory within the @file{lisp/}
directory.  The beginning of its listing looks like this:

@smallexample
@group
("mail"
t
@dots{}
)
@end group
@end smallexample

(To learn about the different attributes, look at the documentation of
@code{file-attributes}.  Bear in mind that the @code{file-attributes}
function does not list the filename, so its first element is
@code{directory-files-and-attributes}'s second element.)

We will want our new function, @code{files-in-below-directory}, to
list the @samp{.el} files in the directory it is told to check, and in
any directories below that directory.

This gives us a hint on how to construct
@code{files-in-below-directory}:  within a directory, the function
should add @samp{.el} filenames to a list; and if, within a directory,
the function comes upon a sub-directory, it should go into that
sub-directory and repeat its actions.

However, we should note that every directory contains a name that
refers to itself, called @file{.} (``dot''), and a name that refers to
its parent directory, called @file{..} (``dot dot'').  (In
@file{/}, the root directory, @file{..} refers to itself, since
@file{/} has no parent.)  Clearly, we do not want our
@code{files-in-below-directory} function to enter those directories,
since they always lead us, directly or indirectly, to the current
directory.

Consequently, our @code{files-in-below-directory} function must do
several tasks:

@itemize @bullet
@item
Check to see whether it is looking at a filename that ends in
@samp{.el}; and if so, add its name to a list.

@item
Check to see whether it is looking at a filename that is the name of a
directory; and if so,

@itemize @minus
@item
Check to see whether it is looking at @file{.}  or @file{..}; and if
so skip it.

@item
Or else, go into that directory and repeat the process.
@end itemize
@end itemize

Let's write a function definition to do these tasks.  We will use a
@code{while} loop to move from one filename to another within a
directory, checking what needs to be done; and we will use a recursive
call to repeat the actions on each sub-directory.  The recursive
pattern is Accumulate
(@pxref{Accumulate}),
using @code{append} as the combiner.

@ignore
(directory-files "/usr/local/src/emacs/lisp/" t "\\.el$")
(shell-command "find /usr/local/src/emacs/lisp/ -name '*.el'")

(directory-files "/usr/local/share/emacs/22.1.1/lisp/" t "\\.el$")
(shell-command "find /usr/local/share/emacs/22.1.1/lisp/ -name '*.el'")
@end ignore

@c  /usr/local/share/emacs/22.1.1/lisp/

@need 800
Here is the function:

@smallexample
@group
(defun files-in-below-directory (directory)
  "List the .el files in DIRECTORY and in its sub-directories."
  ;; Although the function will be used non-interactively,
  ;; it will be easier to test if we make it interactive.
  ;; The directory will have a name such as
  ;;  "/usr/local/share/emacs/22.1.1/lisp/"
  (interactive "DDirectory name: ")
@end group
@group
  (let (el-files-list
        (current-directory-list
         (directory-files-and-attributes directory t)))
    ;; while we are in the current directory
    (while current-directory-list
@end group
@group
      (cond
       ;; check to see whether filename ends in '.el'
       ;; and if so, add its name to a list.
       ((equal ".el" (substring (car (car current-directory-list)) -3))
        (setq el-files-list
              (cons (car (car current-directory-list)) el-files-list)))
@end group
@group
       ;; check whether filename is that of a directory
       ((eq t (car (cdr (car current-directory-list))))
        ;; decide whether to skip or recurse
        (if
            (equal "."
                   (substring (car (car current-directory-list)) -1))
            ;; then do nothing since filename is that of
            ;;   current directory or parent, "." or ".."
            ()
@end group
@group
          ;; else descend into the directory and repeat the process
          (setq el-files-list
                (append
                 (files-in-below-directory
                  (car (car current-directory-list)))
                 el-files-list)))))
      ;; move to the next filename in the list; this also
      ;; shortens the list so the while loop eventually comes to an end
      (setq current-directory-list (cdr current-directory-list)))
    ;; return the filenames
    el-files-list))
@end group
@end smallexample

@c (files-in-below-directory "/usr/local/src/emacs/lisp/")
@c (files-in-below-directory "/usr/local/share/emacs/22.1.1/lisp/")

The @code{files-in-below-directory} @code{directory-files} function
takes one argument, the name of a directory.

@need 1250
Thus, on my system,

@c (length (files-in-below-directory "/usr/local/src/emacs/lisp/"))

@c !!! 22.1.1 lisp sources location here
@smallexample
@group
(length
 (files-in-below-directory "/usr/local/share/emacs/22.1.1/lisp/"))
@end group
@end smallexample

@noindent
tells me that in and below my Lisp sources directory are 1031
@samp{.el} files.

@code{files-in-below-directory} returns a list in reverse alphabetical
order.  An expression to sort the list in alphabetical order looks
like this:

@smallexample
@group
(sort
 (files-in-below-directory "/usr/local/share/emacs/22.1.1/lisp/")
 'string-lessp)
@end group
@end smallexample

@ignore
(defun test ()
  "Test how long it takes to find lengths of all sorted elisp defuns."
  (insert "\n" (current-time-string) "\n")
  (sit-for 0)
  (sort
   (recursive-lengths-list-many-files
    (files-in-below-directory "/usr/local/src/emacs/lisp/"))
   '<)
  (insert (current-time-string)))
@end ignore

@node Counting function definitions
@subsection Counting function definitions

Our immediate goal is to generate a list that tells us how many
function definitions contain fewer than 10 words and symbols, how many
contain between 10 and 19 words and symbols, how many contain between
20 and 29 words and symbols, and so on.

With a sorted list of numbers, this is easy: count how many elements
of the list are smaller than 10, then, after moving past the numbers
just counted, count how many are smaller than 20, then, after moving
past the numbers just counted, count how many are smaller than 30, and
so on.  Each of the numbers, 10, 20, 30, 40, and the like, is one
larger than the top of that range.  We can call the list of such
numbers the @code{top-of-ranges} list.

@need 1200
If we wished, we could generate this list automatically, but it is
simpler to write a list manually.  Here it is:
@vindex top-of-ranges

@smallexample
@group
(defvar top-of-ranges
 '(10  20  30  40  50
   60  70  80  90 100
  110 120 130 140 150
  160 170 180 190 200
  210 220 230 240 250
  260 270 280 290 300)
 "List specifying ranges for `defuns-per-range'.")
@end group
@end smallexample

To change the ranges, we edit this list.

Next, we need to write the function that creates the list of the
number of definitions within each range.  Clearly, this function must
take the @code{sorted-lengths} and the @code{top-of-ranges} lists
as arguments.

The @code{defuns-per-range} function must do two things again and
again: it must count the number of definitions within a range
specified by the current top-of-range value; and it must shift to the
next higher value in the @code{top-of-ranges} list after counting the
number of definitions in the current range.  Since each of these
actions is repetitive, we can use @code{while} loops for the job.
One loop counts the number of definitions in the range defined by the
current top-of-range value, and the other loop selects each of the
top-of-range values in turn.

Several entries of the @code{sorted-lengths} list are counted for each
range; this means that the loop for the @code{sorted-lengths} list
will be inside the loop for the @code{top-of-ranges} list, like a
small gear inside a big gear.

The inner loop counts the number of definitions within the range.  It
is a simple counting loop of the type we have seen before.
(@xref{Incrementing Loop, , A loop with an incrementing counter}.)
The true-or-false test of the loop tests whether the value from the
@code{sorted-lengths} list is smaller than the current value of the
top of the range.  If it is, the function increments the counter and
tests the next value from the @code{sorted-lengths} list.

@need 1250
The inner loop looks like this:

@smallexample
@group
(while @var{length-element-smaller-than-top-of-range}
  (setq number-within-range (1+ number-within-range))
  (setq sorted-lengths (cdr sorted-lengths)))
@end group
@end smallexample

The outer loop must start with the lowest value of the
@code{top-of-ranges} list, and then be set to each of the succeeding
higher values in turn.  This can be done with a loop like this:

@smallexample
@group
(while top-of-ranges
  @var{body-of-loop}@dots{}
  (setq top-of-ranges (cdr top-of-ranges)))
@end group
@end smallexample

@need 1200
Put together, the two loops look like this:

@smallexample
@group
(while top-of-ranges

  ;; @r{Count the number of elements within the current range.}
  (while @var{length-element-smaller-than-top-of-range}
    (setq number-within-range (1+ number-within-range))
    (setq sorted-lengths (cdr sorted-lengths)))

  ;; @r{Move to next range.}
  (setq top-of-ranges (cdr top-of-ranges)))
@end group
@end smallexample

In addition, in each circuit of the outer loop, Emacs should record
the number of definitions within that range (the value of
@code{number-within-range}) in a list.  We can use @code{cons} for
this purpose.  (@xref{cons, , @code{cons}}.)

The @code{cons} function works fine, except that the list it
constructs will contain the number of definitions for the highest
range at its beginning and the number of definitions for the lowest
range at its end.  This is because @code{cons} attaches new elements
of the list to the beginning of the list, and since the two loops are
working their way through the lengths' list from the lower end first,
the @code{defuns-per-range-list} will end up largest number first.
But we will want to print our graph with smallest values first and the
larger later.  The solution is to reverse the order of the
@code{defuns-per-range-list}.  We can do this using the
@code{nreverse} function, which reverses the order of a list.
@findex nreverse

@need 800
For example,

@smallexample
(nreverse '(1 2 3 4))
@end smallexample

@need 800
@noindent
produces:

@smallexample
(4 3 2 1)
@end smallexample

Note that the @code{nreverse} function is destructive---that is,
it changes the list to which it is applied; this contrasts with the
@code{car} and @code{cdr} functions, which are non-destructive.  In
this case, we do not want the original @code{defuns-per-range-list},
so it does not matter that it is destroyed.  (The @code{reverse}
function provides a reversed copy of a list, leaving the original list
as is.)
@findex reverse

@need 1250
Put all together, the @code{defuns-per-range} looks like this:

@smallexample
@group
(defun defuns-per-range (sorted-lengths top-of-ranges)
  "SORTED-LENGTHS defuns in each TOP-OF-RANGES range."
  (let ((top-of-range (car top-of-ranges))
        (number-within-range 0)
        defuns-per-range-list)
@end group

@group
    ;; @r{Outer loop.}
    (while top-of-ranges
@end group

@group
      ;; @r{Inner loop.}
      (while (and
              ;; @r{Need number for numeric test.}
              (car sorted-lengths)
              (< (car sorted-lengths) top-of-range))
@end group

@group
        ;; @r{Count number of definitions within current range.}
        (setq number-within-range (1+ number-within-range))
        (setq sorted-lengths (cdr sorted-lengths)))

      ;; @r{Exit inner loop but remain within outer loop.}
@end group

@group
      (setq defuns-per-range-list
            (cons number-within-range defuns-per-range-list))
      (setq number-within-range 0)      ; @r{Reset count to zero.}
@end group

@group
      ;; @r{Move to next range.}
      (setq top-of-ranges (cdr top-of-ranges))
      ;; @r{Specify next top of range value.}
      (setq top-of-range (car top-of-ranges)))
@end group

@group
    ;; @r{Exit outer loop and count the number of defuns larger than}
    ;; @r{  the largest top-of-range value.}
    (setq defuns-per-range-list
          (cons
           (length sorted-lengths)
           defuns-per-range-list))
@end group

@group
    ;; @r{Return a list of the number of definitions within each range,}
    ;; @r{  smallest to largest.}
    (nreverse defuns-per-range-list)))
@end group
@end smallexample

@need 1200
@noindent
The function is straightforward except for one subtle feature.  The
true-or-false test of the inner loop looks like this:

@smallexample
@group
(and (car sorted-lengths)
     (< (car sorted-lengths) top-of-range))
@end group
@end smallexample

@need 800
@noindent
instead of like this:

@smallexample
(< (car sorted-lengths) top-of-range)
@end smallexample

The purpose of the test is to determine whether the first item in the
@code{sorted-lengths} list is less than the value of the top of the
range.

The simple version of the test works fine unless the
@code{sorted-lengths} list has a @code{nil} value.  In that case, the
@code{(car sorted-lengths)} expression function returns
@code{nil}.  The @code{<} function cannot compare a number to
@code{nil}, which is an empty list, so Emacs signals an error and
stops the function from attempting to continue to execute.

The @code{sorted-lengths} list always becomes @code{nil} when the
counter reaches the end of the list.  This means that any attempt to
use the @code{defuns-per-range} function with the simple version of
the test will fail.

We solve the problem by using the @code{(car sorted-lengths)}
expression in conjunction with the @code{and} expression.  The
@code{(car sorted-lengths)} expression returns a non-@code{nil}
value so long as the list has at least one number within it, but
returns @code{nil} if the list is empty.  The @code{and} expression
first evaluates the @code{(car sorted-lengths)} expression, and
if it is @code{nil}, returns false @emph{without} evaluating the
@code{<} expression.  But if the @code{(car sorted-lengths)}
expression returns a non-@code{nil} value, the @code{and} expression
evaluates the @code{<} expression, and returns that value as the value
of the @code{and} expression.

@c colon in printed section title causes problem in Info cross reference
This way, we avoid an error.
@iftex
@noindent
(For information about @code{and}, see
@ref{kill-new function, , The @code{kill-new} function}.)
@end iftex
@ifinfo
@noindent
(@xref{kill-new function, , The @code{kill-new} function}, for
information about @code{and}.)
@end ifinfo

Here is a short test of the @code{defuns-per-range} function.  First,
evaluate the expression that binds (a shortened)
@code{top-of-ranges} list to the list of values, then evaluate the
expression for binding the @code{sorted-lengths} list, and then
evaluate the @code{defuns-per-range} function.

@smallexample
@group
;; @r{(Shorter list than we will use later.)}
(setq top-of-ranges
 '(110 120 130 140 150
   160 170 180 190 200))

(setq sorted-lengths
      '(85 86 110 116 122 129 154 176 179 200 265 300 300))

(defuns-per-range sorted-lengths top-of-ranges)
@end group
@end smallexample

@need 800
@noindent
The list returned looks like this:

@smallexample
(2 2 2 0 0 1 0 2 0 0 4)
@end smallexample

@noindent
Indeed, there are two elements of the @code{sorted-lengths} list
smaller than 110, two elements between 110 and 119, two elements
between 120 and 129, and so on.  There are four elements with a value
of 200 or larger.

@c The next step is to turn this numbers' list into a graph.
@node Readying a Graph
@chapter Readying a Graph
@cindex Readying a graph
@cindex Graph prototype
@cindex Prototype graph
@cindex Body of graph

Our goal is to construct a graph showing the numbers of function
definitions of various lengths in the Emacs lisp sources.

As a practical matter, if you were creating a graph, you would
probably use a program such as @code{gnuplot} to do the job.
(@code{gnuplot} is nicely integrated into GNU Emacs.)  In this case,
however, we create one from scratch, and in the process we will
re-acquaint ourselves with some of what we learned before and learn
more.

In this chapter, we will first write a simple graph printing function.
This first definition will be a @dfn{prototype}, a rapidly written
function that enables us to reconnoiter this unknown graph-making
territory.  We will discover dragons, or find that they are myth.
After scouting the terrain, we will feel more confident and enhance
the function to label the axes automatically.

@menu
* Columns of a graph::
* graph-body-print::            How to print the body of a graph.
* recursive-graph-body-print::
* Printed Axes::
* Line Graph Exercise::
@end menu

@ifnottex
@node Columns of a graph
@unnumberedsec Printing the Columns of a Graph
@end ifnottex

Since Emacs is designed to be flexible and work with all kinds of
terminals, including character-only terminals, the graph will need to
be made from one of the typewriter symbols.  An asterisk will do; as
we enhance the graph-printing function, we can make the choice of
symbol a user option.

We can call this function @code{graph-body-print}; it will take a
@code{numbers-list} as its only argument.  At this stage, we will not
label the graph, but only print its body.

The @code{graph-body-print} function inserts a vertical column of
asterisks for each element in the @code{numbers-list}.  The height of
each line is determined by the value of that element of the
@code{numbers-list}.

Inserting columns is a repetitive act; that means that this function can
be written either with a @code{while} loop or recursively.

Our first challenge is to discover how to print a column of asterisks.
Usually, in Emacs, we print characters onto a screen horizontally,
line by line, by typing.  We have two routes we can follow: write our
own column-insertion function or discover whether one exists in Emacs.

To see whether there is one in Emacs, we can use the @kbd{M-x apropos}
command.  This command is like the @kbd{C-h a} (@code{command-apropos})
command, except that the latter finds only those functions that are
commands.  The @kbd{M-x apropos} command lists all symbols that match
a regular expression, including functions that are not interactive.
@findex apropos

What we want to look for is some command that prints or inserts
columns.  Very likely, the name of the function will contain either
the word ``print'' or the word ``insert'' or the word ``column''.
Therefore, we can simply type @kbd{M-x apropos @key{RET}
print\|insert\|column @key{RET}} and look at the result.  On my system, this
command once took quite some time, and then produced a list of 79
functions and variables.  Now it does not take much time at all and
produces a list of 211 functions and variables.  Scanning down the
list, the only function that looks as if it might do the job is
@code{insert-rectangle}.

@need 1200
Indeed, this is the function we want; its documentation says:

@smallexample
@group
insert-rectangle:
Insert text of RECTANGLE with upper left corner at point.
RECTANGLE's first line is inserted at point,
its second line is inserted at a point vertically under point, etc.
RECTANGLE should be a list of strings.
After this command, the mark is at the upper left corner
and point is at the lower right corner.
@end group
@end smallexample

We can run a quick test, to make sure it does what we expect of it.

Here is the result of placing the cursor after the
@code{insert-rectangle} expression and typing @kbd{C-u C-x C-e}
(@code{eval-last-sexp}).  The function inserts the strings
@samp{"first"}, @samp{"second"}, and @samp{"third"} at and below
point.  Also the function returns @code{nil}.

@smallexample
@group
(insert-rectangle '("first" "second" "third"))first
                                              second
                                              thirdnil
@end group
@end smallexample

@noindent
Of course, we won't be inserting the text of the
@code{insert-rectangle} expression itself into the buffer in which we
are making the graph, but will call the function from our program.  We
shall, however, have to make sure that point is in the buffer at the
place where the @code{insert-rectangle} function will insert its
column of strings.

If you are reading this in Info, you can see how this works by
switching to another buffer, such as the @file{*scratch*} buffer,
placing point somewhere in the buffer, typing @kbd{M-:}, typing the
@code{insert-rectangle} expression into the minibuffer at the prompt,
and then typing @key{RET}.  This causes Emacs to evaluate the
expression in the minibuffer, but to use as the value of point the
position of point in the @file{*scratch*} buffer.  (@kbd{M-:}  is the
key binding for @code{eval-expression}. Also, @code{nil} does not
appear in the @file{*scratch*} buffer since the expression is
evaluated in the minibuffer.)

We find when we do this that point ends up at the end of the last
inserted line---that is to say, this function moves point as a
side-effect.  If we were to repeat the command, with point at this
position, the next insertion would be below and to the right of the
previous insertion.  We don't want this!  If we are going to make a
bar graph, the columns need to be beside each other.

So we discover that each cycle of the column-inserting @code{while}
loop must reposition point to the place we want it, and that place
will be at the top, not the bottom, of the column.  Moreover, we
remember that when we print a graph, we do not expect all the columns
to be the same height.  This means that the top of each column may be
at a different height from the previous one.  We cannot simply
reposition point to the same line each time, but moved over to the
right---or perhaps we can@dots{}

We are planning to make the columns of the bar graph out of asterisks.
The number of asterisks in the column is the number specified by the
current element of the @code{numbers-list}.  We need to construct a
list of asterisks of the right length for each call to
@code{insert-rectangle}.  If this list consists solely of the requisite
number of asterisks, then we will have to position point the right number
of lines above the base for the graph to print correctly.  This could
be difficult.

Alternatively, if we can figure out some way to pass
@code{insert-rectangle} a list of the same length each time, then we
can place point on the same line each time, but move it over one
column to the right for each new column.  If we do this, however, some
of the entries in the list passed to @code{insert-rectangle} must be
blanks rather than asterisks.  For example, if the maximum height of
the graph is 5, but the height of the column is 3, then
@code{insert-rectangle} requires an argument that looks like this:

@smallexample
(" " " " "*" "*" "*")
@end smallexample

This last proposal is not so difficult, so long as we can determine
the column height.  There are two ways for us to specify the column
height: we can arbitrarily state what it will be, which would work
fine for graphs of that height; or we can search through the list of
numbers and use the maximum height of the list as the maximum height
of the graph.  If the latter operation were difficult, then the former
procedure would be easiest, but there is a function built into Emacs
that determines the maximum of its arguments.  We can use that
function.  The function is called @code{max} and it returns the
largest of all its arguments, which must be numbers.  Thus, for
example,

@smallexample
(max  3 4 6 5 7 3)
@end smallexample

@noindent
returns 7.  (A corresponding function called @code{min} returns the
smallest of all its arguments.)
@findex max
@findex min

However, we cannot simply call @code{max} on the @code{numbers-list};
the @code{max} function expects numbers as its argument, not a list of
numbers.  Thus, the following expression,

@smallexample
(max  '(3 4 6 5 7 3))
@end smallexample

@need 800
@noindent
produces the following error message;

@smallexample
Wrong type of argument:  number-or-marker-p, (3 4 6 5 7 3)
@end smallexample

@findex apply
We need a function that passes a list of arguments to a function.
This function is @code{apply}.  This function applies its first
argument (a function) to its remaining arguments, the last of which
may be a list.

@need 1250
For example,

@smallexample
(apply 'max 3 4 7 3 '(4 8 5))
@end smallexample

@noindent
returns 8.

(Incidentally, I don't know how you would learn of this function
without a book such as this.  It is possible to discover other
functions, like @code{search-forward} or @code{insert-rectangle}, by
guessing at a part of their names and then using @code{apropos}.  Even
though its base in metaphor is clear---apply its first argument to
the rest---I doubt a novice would come up with that particular word
when using @code{apropos} or other aid.  Of course, I could be wrong;
after all, the function was first named by someone who had to invent
it.)

The second and subsequent arguments to @code{apply} are optional, so
we can use @code{apply} to call a function and pass the elements of a
list to it, like this, which also returns 8:

@smallexample
(apply 'max '(4 8 5))
@end smallexample

This latter way is how we will use @code{apply}.  The
@code{recursive-lengths-list-many-files} function returns a numbers'
list to which we can apply @code{max} (we could also apply @code{max} to
the sorted numbers' list; it does not matter whether the list is
sorted or not.)

@need 800
Hence, the operation for finding the maximum height of the graph is this:

@smallexample
(setq max-graph-height (apply 'max numbers-list))
@end smallexample

Now we can return to the question of how to create a list of strings
for a column of the graph.  Told the maximum height of the graph
and the number of asterisks that should appear in the column, the
function should return a list of strings for the
@code{insert-rectangle} command to insert.

Each column is made up of asterisks or blanks.  Since the function is
passed the value of the height of the column and the number of
asterisks in the column, the number of blanks can be found by
subtracting the number of asterisks from the height of the column.
Given the number of blanks and the number of asterisks, two
@code{while} loops can be used to construct the list:

@smallexample
@group
;;; @r{First version.}
(defun column-of-graph (max-graph-height actual-height)
  "Return list of strings that is one column of a graph."
  (let ((insert-list nil)
        (number-of-top-blanks
         (- max-graph-height actual-height)))
@end group

@group
    ;; @r{Fill in asterisks.}
    (while (> actual-height 0)
      (setq insert-list (cons "*" insert-list))
      (setq actual-height (1- actual-height)))
@end group

@group
    ;; @r{Fill in blanks.}
    (while (> number-of-top-blanks 0)
      (setq insert-list (cons " " insert-list))
      (setq number-of-top-blanks
            (1- number-of-top-blanks)))
@end group

@group
    ;; @r{Return whole list.}
    insert-list))
@end group
@end smallexample

If you install this function and then evaluate the following
expression you will see that it returns the list as desired:

@smallexample
(column-of-graph 5 3)
@end smallexample

@need 800
@noindent
returns

@smallexample
(" " " " "*" "*" "*")
@end smallexample

As written, @code{column-of-graph} contains a major flaw: the symbols
used for the blank and for the marked entries in the column are
hard-coded as a space and asterisk.  This is fine for a prototype,
but you, or another user, may wish to use other symbols.  For example,
in testing the graph function, you may want to use a period in place
of the space, to make sure the point is being repositioned properly
each time the @code{insert-rectangle} function is called; or you might
want to substitute a @samp{+} sign or other symbol for the asterisk.
You might even want to make a graph-column that is more than one
display column wide.  The program should be more flexible.  The way to
do that is to replace the blank and the asterisk with two variables
that we can call @code{graph-blank} and @code{graph-symbol} and define
those variables separately.

Also, the documentation is not well written.  These considerations
lead us to the second version of the function:

@smallexample
@group
(defvar graph-symbol "*"
  "String used as symbol in graph, usually an asterisk.")
@end group

@group
(defvar graph-blank " "
  "String used as blank in graph, usually a blank space.
graph-blank must be the same number of columns wide
as graph-symbol.")
@end group
@end smallexample

@noindent
(For an explanation of @code{defvar}, see
@ref{defvar, , Initializing a Variable with @code{defvar}}.)

@smallexample
@group
;;; @r{Second version.}
(defun column-of-graph (max-graph-height actual-height)
  "Return MAX-GRAPH-HEIGHT strings; ACTUAL-HEIGHT are graph-symbols.

@end group
@group
The graph-symbols are contiguous entries at the end
of the list.
The list will be inserted as one column of a graph.
The strings are either graph-blank or graph-symbol."
@end group

@group
  (let ((insert-list nil)
        (number-of-top-blanks
         (- max-graph-height actual-height)))
@end group

@group
    ;; @r{Fill in @code{graph-symbols}.}
    (while (> actual-height 0)
      (setq insert-list (cons graph-symbol insert-list))
      (setq actual-height (1- actual-height)))
@end group

@group
    ;; @r{Fill in @code{graph-blanks}.}
    (while (> number-of-top-blanks 0)
      (setq insert-list (cons graph-blank insert-list))
      (setq number-of-top-blanks
            (1- number-of-top-blanks)))

    ;; @r{Return whole list.}
    insert-list))
@end group
@end smallexample

If we wished, we could rewrite @code{column-of-graph} a third time to
provide optionally for a line graph as well as for a bar graph.  This
would not be hard to do.  One way to think of a line graph is that it
is no more than a bar graph in which the part of each bar that is
below the top is blank.  To construct a column for a line graph, the
function first constructs a list of blanks that is one shorter than
the value, then it uses @code{cons} to attach a graph symbol to the
list; then it uses @code{cons} again to attach the top blanks to
the list.

It is easy to see how to write such a function, but since we don't
need it, we will not do it.  But the job could be done, and if it were
done, it would be done with @code{column-of-graph}.  Even more
important, it is worth noting that few changes would have to be made
anywhere else.  The enhancement, if we ever wish to make it, is
simple.

Now, finally, we come to our first actual graph printing function.
This prints the body of a graph, not the labels for the vertical and
horizontal axes, so we can call this @code{graph-body-print}.

@node graph-body-print
@section The @code{graph-body-print} Function
@findex graph-body-print

After our preparation in the preceding section, the
@code{graph-body-print} function is straightforward.  The function
will print column after column of asterisks and blanks, using the
elements of a numbers' list to specify the number of asterisks in each
column.  This is a repetitive act, which means we can use a
decrementing @code{while} loop or recursive function for the job.  In
this section, we will write the definition using a @code{while} loop.

The @code{column-of-graph} function requires the height of the graph
as an argument, so we should determine and record that as a local variable.

This leads us to the following template for the @code{while} loop
version of this function:

@smallexample
@group
(defun graph-body-print (numbers-list)
  "@var{documentation}@dots{}"
  (let ((height  @dots{}
         @dots{}))
@end group

@group
    (while numbers-list
      @var{insert-columns-and-reposition-point}
      (setq numbers-list (cdr numbers-list)))))
@end group
@end smallexample

@noindent
We need to fill in the slots of the template.

Clearly, we can use the @code{(apply 'max numbers-list)} expression to
determine the height of the graph.

The @code{while} loop will cycle through the @code{numbers-list} one
element at a time.  As it is shortened by the @code{(setq numbers-list
(cdr numbers-list))} expression, the @sc{car} of each instance of the
list is the value of the argument for @code{column-of-graph}.

At each cycle of the @code{while} loop, the @code{insert-rectangle}
function inserts the list returned by @code{column-of-graph}.  Since
the @code{insert-rectangle} function moves point to the lower right of
the inserted rectangle, we need to save the location of point at the
time the rectangle is inserted, move back to that position after the
rectangle is inserted, and then move horizontally to the next place
from which @code{insert-rectangle} is called.

If the inserted columns are one character wide, as they will be if
single blanks and asterisks are used, the repositioning command is
simply @code{(forward-char 1)}; however, the width of a column may be
greater than one.  This means that the repositioning command should be
written @code{(forward-char symbol-width)}.  The @code{symbol-width}
itself is the length of a @code{graph-blank} and can be found using
the expression @code{(length graph-blank)}.  The best place to bind
the @code{symbol-width} variable to the value of the width of graph
column is in the varlist of the @code{let} expression.

@need 1250
These considerations lead to the following function definition:

@smallexample
@group
(defun graph-body-print (numbers-list)
  "Print a bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values."

  (let ((height (apply 'max numbers-list))
        (symbol-width (length graph-blank))
        from-position)
@end group

@group
    (while numbers-list
      (setq from-position (point))
      (insert-rectangle
       (column-of-graph height (car numbers-list)))
      (goto-char from-position)
      (forward-char symbol-width)
@end group
@group
      ;; @r{Draw graph column by column.}
      (sit-for 0)
      (setq numbers-list (cdr numbers-list)))
@end group
@group
    ;; @r{Place point for X axis labels.}
    (forward-line height)
    (insert "\n")
))
@end group
@end smallexample

@noindent
The one unexpected expression in this function is the
@w{@code{(sit-for 0)}} expression in the @code{while} loop.  This
expression makes the graph printing operation more interesting to
watch than it would be otherwise.  The expression causes Emacs to
@dfn{sit} or do nothing for a zero length of time and then redraw the
screen.  Placed here, it causes Emacs to redraw the screen column by
column.  Without it, Emacs would not redraw the screen until the
function exits.

We can test @code{graph-body-print} with a short list of numbers.

@enumerate
@item
Install @code{graph-symbol}, @code{graph-blank},
@code{column-of-graph}, which are in
@iftex
@ref{Readying a Graph, , Readying a Graph},
@end iftex
@ifnottex
@ref{Columns of a graph},
@end ifnottex
and @code{graph-body-print}.

@need 800
@item
Copy the following expression:

@smallexample
(graph-body-print '(1 2 3 4 6 4 3 5 7 6 5 2 3))
@end smallexample

@item
Switch to the @file{*scratch*} buffer and place the cursor where you
want the graph to start.

@item
Type @kbd{M-:} (@code{eval-expression}).

@item
Yank the @code{graph-body-print} expression into the minibuffer
with @kbd{C-y} (@code{yank)}.

@item
Press @key{RET} to evaluate the @code{graph-body-print} expression.
@end enumerate

@need 800
Emacs will print a graph like this:

@smallexample
@group
                    *
                *   **
                *  ****
               *** ****
              ********* *
             ************
            *************
@end group
@end smallexample

@node recursive-graph-body-print
@section The @code{recursive-graph-body-print} Function
@findex recursive-graph-body-print

The @code{graph-body-print} function may also be written recursively.
The recursive solution is divided into two parts: an outside wrapper
that uses a @code{let} expression to determine the values of several
variables that need only be found once, such as the maximum height of
the graph, and an inside function that is called recursively to print
the graph.

@need 1250
The wrapper is uncomplicated:

@smallexample
@group
(defun recursive-graph-body-print (numbers-list)
  "Print a bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values."
  (let ((height (apply 'max numbers-list))
        (symbol-width (length graph-blank))
        from-position)
    (recursive-graph-body-print-internal
     numbers-list
     height
     symbol-width)))
@end group
@end smallexample

The recursive function is a little more difficult.  It has four parts:
the do-again-test, the printing code, the recursive call, and the
next-step-expression.  The do-again-test is a @code{when}
expression that determines whether the @code{numbers-list} contains
any remaining elements; if it does, the function prints one column of
the graph using the printing code and calls itself again.  The
function calls itself again according to the value produced by the
next-step-expression which causes the call to act on a shorter
version of the @code{numbers-list}.

@smallexample
@group
(defun recursive-graph-body-print-internal
  (numbers-list height symbol-width)
  "Print a bar graph.
Used within recursive-graph-body-print function."
@end group

@group
  (when numbers-list
        (setq from-position (point))
        (insert-rectangle
         (column-of-graph height (car numbers-list)))
@end group
@group
        (goto-char from-position)
        (forward-char symbol-width)
        (sit-for 0)     ; @r{Draw graph column by column.}
        (recursive-graph-body-print-internal
         (cdr numbers-list) height symbol-width)))
@end group
@end smallexample

@need 1250
After installation, this expression can be tested; here is a sample:

@smallexample
(recursive-graph-body-print '(3 2 5 6 7 5 3 4 6 4 3 2 1))
@end smallexample

@need 800
Here is what @code{recursive-graph-body-print} produces:

@smallexample
@group
                *
               **   *
              ****  *
              **** ***
            * *********
            ************
            *************
@end group
@end smallexample

Either of these two functions, @code{graph-body-print} or
@code{recursive-graph-body-print}, create the body of a graph.

@node Printed Axes
@section Need for Printed Axes

A graph needs printed axes, so you can orient yourself.  For a do-once
project, it may be reasonable to draw the axes by hand using Emacs's
Picture mode; but a graph drawing function may be used more than once.

For this reason, I have written enhancements to the basic
@code{print-graph-body} function that automatically print labels for
the horizontal and vertical axes.  Since the label printing functions
do not contain much new material, I have placed their description in
an appendix.  @xref{Full Graph, , A Graph with Labeled Axes}.

@node Line Graph Exercise
@section Exercise

Write a line graph version of the graph printing functions.

@node Emacs Initialization
@chapter Your @file{.emacs} File
@cindex @file{.emacs} file
@cindex Customizing your @file{.emacs} file
@cindex Initialization file

``You don't have to like Emacs to like it''---this seemingly
paradoxical statement is the secret of GNU Emacs.  The plain, out-of-the-box
Emacs is a generic tool.  Most people who use it customize
it to suit themselves.

GNU Emacs is mostly written in Emacs Lisp; this means that by writing
expressions in Emacs Lisp you can change or extend Emacs.

@menu
* Default Configuration::
* Site-wide Init::              You can write site-wide init files.
* defcustom::                   Emacs will write code for you.
* Beginning init File::         How to write a @file{.emacs} init file.
* Text and Auto-fill::          Automatically wrap lines.
* Mail Aliases::                Use abbreviations for email addresses.
* Indent Tabs Mode::            Don't use tabs with @TeX{}
* Key Bindings::                Create some personal key bindings.
* Keymaps::                     More about key binding.
* Loading Files::               Load (i.e., evaluate) files automatically.
* Autoload::                    Make functions available.
* Simple Extension::            Define a function; bind it to a key.
* X11 Colors::                  Colors in X.
* Miscellaneous::
* Mode Line::                   How to customize your mode line.
@end menu

@ifnottex
@node Default Configuration
@unnumberedsec Emacs's Default Configuration
@end ifnottex

There are those who appreciate Emacs's default configuration.  After
all, Emacs starts you in C mode when you edit a C file, starts you in
Fortran mode when you edit a Fortran file, and starts you in
Fundamental mode when you edit an unadorned file.  This all makes
sense, if you do not know who is going to use Emacs.  Who knows what a
person hopes to do with an unadorned file?  Fundamental mode is the
right default for such a file, just as C mode is the right default for
editing C code.  (Enough programming languages have syntaxes
that enable them to share or nearly share features, so C mode is
now provided by CC mode, the C Collection.)

But when you do know who is going to use Emacs---you,
yourself---then it makes sense to customize Emacs.

For example, I seldom want Fundamental mode when I edit an
otherwise undistinguished file; I want Text mode.  This is why I
customize Emacs: so it suits me.

You can customize and extend Emacs by writing or adapting a
@file{~/.emacs} file.  This is your personal initialization file; its
contents, written in Emacs Lisp, tell Emacs what to do.@footnote{You
may also add @file{.el} to @file{~/.emacs} and call it a
@file{~/.emacs.el} file.  In the past, you were forbidden to type the
extra keystrokes that the name @file{~/.emacs.el} requires, but now
you may.  The new format is consistent with the Emacs Lisp file
naming conventions; the old format saves typing.}

A @file{~/.emacs} file contains Emacs Lisp code.  You can write this
code yourself; or you can use Emacs's @code{customize} feature to write
the code for you.  You can combine your own expressions and
auto-written Customize expressions in your @file{.emacs} file.

(I myself prefer to write my own expressions, except for those,
particularly fonts, that I find easier to manipulate using the
@code{customize} command.  I combine the two methods.)

Most of this chapter is about writing expressions yourself.  It
describes a simple @file{.emacs} file; for more information, see
@ref{Init File, , The Init File, emacs, The GNU Emacs Manual}, and
@ref{Init File, , The Init File, elisp, The GNU Emacs Lisp Reference
Manual}.

@node Site-wide Init
@section Site-wide Initialization Files

@cindex @file{default.el} init file
@cindex @file{site-init.el} init file
@cindex @file{site-load.el} init file
In addition to your personal initialization file, Emacs automatically
loads various site-wide initialization files, if they exist.  These
have the same form as your @file{.emacs} file, but are loaded by
everyone.

Two site-wide initialization files, @file{site-load.el} and
@file{site-init.el}, are loaded into Emacs and then dumped if a
dumped version of Emacs is created, as is most common.  (Dumped
copies of Emacs load more quickly.  However, once a file is loaded and
dumped, a change to it does not lead to a change in Emacs unless you
load it yourself or re-dump Emacs.  @xref{Building Emacs, , Building
Emacs, elisp, The GNU Emacs Lisp Reference Manual}, and the
@file{INSTALL} file.)

Three other site-wide initialization files are loaded automatically
each time you start Emacs, if they exist.  These are
@file{site-start.el}, which is loaded @emph{before} your @file{.emacs}
file, and @file{default.el}, and the terminal type file, which are both
loaded @emph{after} your @file{.emacs} file.

Settings and definitions in your @file{.emacs} file will overwrite
conflicting settings and definitions in a @file{site-start.el} file,
if it exists; but the settings and definitions in a @file{default.el}
or terminal type file will overwrite those in your @file{.emacs} file.
(You can prevent interference from a terminal type file by setting
@code{term-file-prefix} to @code{nil}.  @xref{Simple Extension, , A
Simple Extension}.)

@c Rewritten to avoid overfull hbox.
The @file{INSTALL} file that comes in the distribution contains
descriptions of the @file{site-init.el} and @file{site-load.el} files.

The @file{loadup.el}, @file{startup.el}, and @file{loaddefs.el} files
control loading.  These files are in the @file{lisp} directory of the
Emacs distribution and are worth perusing.

The @file{loaddefs.el} file contains a good many suggestions as to
what to put into your own @file{.emacs} file, or into a site-wide
initialization file.

@node defcustom
@section Specifying Variables using @code{defcustom}
@findex defcustom

You can specify variables using @code{defcustom} so that you and
others can then use Emacs's @code{customize} feature to set their
values.  (You cannot use @code{customize} to write function
definitions; but you can write @code{defuns} in your @file{.emacs}
file.  Indeed, you can write any Lisp expression in your @file{.emacs}
file.)

The @code{customize} feature depends on the @code{defcustom} macro.
Although you can use @code{defvar} or @code{setq} for variables that
users set, the @code{defcustom} macro is designed for the job.

You can use your knowledge of @code{defvar} for writing the
first three arguments for @code{defcustom}.  The first argument to
@code{defcustom} is the name of the variable.  The second argument is
the variable's initial value, if any; and this value is set only if
the value has not already been set.  The third argument is the
documentation.

The fourth and subsequent arguments to @code{defcustom} specify types
and options; these are not featured in @code{defvar}.  (These
arguments are optional.)

Each of these arguments consists of a keyword followed by a value.
Each keyword starts with the colon character @samp{:}.

@need 1250
For example, the customizable user option variable
@code{text-mode-hook} looks like this:

@smallexample
@group
(defcustom text-mode-hook nil
  "Normal hook run when entering Text mode and many related modes."
  :type 'hook
  :options '(turn-on-auto-fill flyspell-mode)
  :group 'wp)
@end group
@end smallexample

@noindent
The name of the variable is @code{text-mode-hook}; it has no default
value; and its documentation string tells you what it does.

The @code{:type} keyword tells Emacs the kind of data to which
@code{text-mode-hook} should be set and how to display the value in a
Customization buffer.

The @code{:options} keyword specifies a suggested list of values for
the variable.  Usually, @code{:options} applies to a hook.
The list is only a suggestion; it is not exclusive; a person who sets
the variable may set it to other values; the list shown following the
@code{:options} keyword is intended to offer convenient choices to a
user.

Finally, the @code{:group} keyword tells the Emacs Customization
command in which group the variable is located.  This tells where to
find it.

The @code{defcustom} macro recognizes more than a dozen keywords.
For more information, see @ref{Customization, , Writing Customization
Definitions, elisp, The GNU Emacs Lisp Reference Manual}.

Consider @code{text-mode-hook} as an example.

There are two ways to customize this variable.  You can use the
customization command or write the appropriate expressions yourself.

@need 800
Using the customization command,  you can type:

@smallexample
M-x customize
@end smallexample

@noindent
and find that the group for editing files of text is called ``Text''.
Enter that group.  Text Mode Hook is the first member.  You can click
on its various options, such as @code{turn-on-auto-fill}, to set the
values.  After you click on the button to

@smallexample
Save for Future Sessions
@end smallexample

@noindent
Emacs will write an expression into your @file{.emacs} file.
It will look like this:

@smallexample
@group
(custom-set-variables
  ;; custom-set-variables was added by Custom.
  ;; If you edit it by hand, you could mess it up, so be careful.
  ;; Your init file should contain only one such instance.
  ;; If there is more than one, they won't work right.
 '(text-mode-hook '(turn-on-auto-fill text-mode-hook-identify)))
@end group
@end smallexample

@noindent
(The @code{text-mode-hook-identify} function tells
@code{toggle-text-mode-auto-fill} which buffers are in Text mode.
It comes on automatically.)

The @code{custom-set-variables} function works somewhat differently
than a @code{setq}.  While I have never learned the differences, I
modify the @code{custom-set-variables} expressions in my @file{.emacs}
file by hand:  I make the changes in what appears to me to be a
reasonable manner and have not had any problems.  Others prefer to use
the Customization command and let Emacs do the work for them.

Another @code{custom-set-@dots{}} function is @code{custom-set-faces}.
This function sets the various font faces.  Over time, I have set a
considerable number of faces.  Some of the time, I re-set them using
@code{customize}; other times, I simply edit the
@code{custom-set-faces} expression in my @file{.emacs} file itself.

The second way to customize your @code{text-mode-hook} is to set it
yourself in your @file{.emacs} file using code that has nothing to do
with the @code{custom-set-@dots{}} functions.

@need 800
When you do this, and later use @code{customize}, you will see a
message that says

@smallexample
CHANGED outside Customize; operating on it here may be unreliable.
@end smallexample

@need 800
This message is only a warning.  If you click on the button to

@smallexample
Save for Future Sessions
@end smallexample

@noindent
Emacs will write a @code{custom-set-@dots{}} expression near the end
of your @file{.emacs} file that will be evaluated after your
hand-written expression.  It will, therefore, overrule your
hand-written expression.  No harm will be done.  When you do this,
however, be careful to remember which expression is active; if you
forget, you may confuse yourself.

So long as you remember where the values are set, you will have no
trouble.  In any event, the values are always set in your
initialization file, which is usually called @file{.emacs}.

I myself use @code{customize} for hardly anything.  Mostly, I write
expressions myself.

@findex defsubst
@findex defconst
Incidentally, to be more complete concerning defines:  @code{defsubst}
defines an inline function.  The syntax is just like that of
@code{defun}.  @code{defconst} defines a symbol as a constant.  The
intent is that neither programs nor users should ever change a value
set by @code{defconst}.  (You can change it; the value set is a
variable; but please do not.)

@node Beginning init File
@section Beginning a @file{.emacs} File
@cindex @file{.emacs} file, beginning of

When you start Emacs, it loads your @file{.emacs} file unless you tell
it not to by specifying @samp{-q} on the command line.  (The
@code{emacs -q} command gives you a plain, out-of-the-box Emacs.)

A @file{.emacs} file contains Lisp expressions.  Often, these are no
more than expressions to set values; sometimes they are function
definitions.

@xref{Init File, , The Init File @file{~/.emacs}, emacs, The GNU Emacs
Manual}, for a short description of initialization files.

This chapter goes over some of the same ground, but is a walk among
extracts from a complete, long-used @file{.emacs} file---my own.

The first part of the file consists of comments: reminders to myself.
By now, of course, I remember these things, but when I started, I did
not.

@need 1200
@smallexample
@group
;;;; Bob's .emacs file
; Robert J. Chassell
; 26 September 1985
@end group
@end smallexample

@noindent
Look at that date!  I started this file a long time ago.  I have been
adding to it ever since.

@smallexample
@group
; Each section in this file is introduced by a
; line beginning with four semicolons; and each
; entry is introduced by a line beginning with
; three semicolons.
@end group
@end smallexample

@noindent
This describes the usual conventions for comments in Emacs Lisp.
Everything on a line that follows a semicolon is a comment.  Two,
three, and four semicolons are used as subsection and section markers.
(@xref{Comments, ,, elisp, The GNU Emacs Lisp Reference Manual}, for
more about comments.)

@smallexample
@group
;;;; The Help Key
; Control-h is the help key;
; after typing control-h, type a letter to
; indicate the subject about which you want help.
; For an explanation of the help facility,
; type control-h two times in a row.
@end group
@end smallexample

@noindent
Just remember: type @kbd{C-h} two times for help.

@smallexample
@group
; To find out about any mode, type control-h m
; while in that mode.  For example, to find out
; about mail mode, enter mail mode and then type
; control-h m.
@end group
@end smallexample

@noindent
``Mode help'', as I call this, is very helpful.  Usually, it tells you
all you need to know.

Of course, you don't need to include comments like these in your
@file{.emacs} file.  I included them in mine because I kept forgetting
about Mode help or the conventions for comments---but I was able to
remember to look here to remind myself.

@node Text and Auto-fill
@section Text and Auto Fill Mode

Now we come to the part that turns on Text mode and
Auto Fill mode.

@smallexample
@group
;;; Text mode and Auto Fill mode
;; The next two lines put Emacs into Text mode
;; and Auto Fill mode, and are for writers who
;; want to start writing prose rather than code.
(setq-default major-mode 'text-mode)
(add-hook 'text-mode-hook 'turn-on-auto-fill)
@end group
@end smallexample

Here is the first part of this @file{.emacs} file that does something
besides remind a forgetful human!

The first of the two lines in parentheses tells Emacs to turn on Text
mode when you find a file, @emph{unless} that file should go into some
other mode, such as C mode.

@cindex Per-buffer, local variables list
@cindex Local variables list, per-buffer,
@cindex Automatic mode selection
@cindex Mode selection, automatic
When Emacs reads a file, it looks at the extension to the file name,
if any.  (The extension is the part that comes after a @samp{.}.)  If
the file ends with a @samp{.c} or @samp{.h} extension then Emacs turns
on C mode.  Also, Emacs looks at first nonblank line of the file; if
the line says @w{@samp{-*- C -*-}}, Emacs turns on C mode.  Emacs
possesses a list of extensions and specifications that it uses
automatically.  In addition, Emacs looks near the last page for a
per-buffer, local variables list, if any.

@ifinfo
@xref{Choosing Modes, , How Major Modes are Chosen, emacs, The GNU
Emacs Manual}.

@xref{File Variables, , Local Variables in Files, emacs, The GNU Emacs
Manual}.
@end ifinfo
@iftex
See sections ``How Major Modes are Chosen'' and ``Local Variables in
Files'' in @cite{The GNU Emacs Manual}.
@end iftex

Now, back to the @file{.emacs} file.

@need 800
Here is the line again; how does it work?

@cindex Text Mode turned on
@smallexample
(setq major-mode 'text-mode)
@end smallexample

@noindent
This line is a short, but complete Emacs Lisp expression.

We are already familiar with @code{setq}.  It sets the following variable,
@code{major-mode}, to the subsequent value, which is @code{text-mode}.
The single-quote before @code{text-mode} tells Emacs to deal directly
with the @code{text-mode} symbol, not with whatever it might stand for.
@xref{set & setq, , Setting the Value of a Variable},
for a reminder of how @code{setq} works.
The main point is that there is no difference between the procedure you
use to set a value in your @file{.emacs} file and the procedure you use
anywhere else in Emacs.

@need 800
Here is the next line:

@cindex Auto Fill mode turned on
@findex add-hook
@smallexample
(add-hook 'text-mode-hook 'turn-on-auto-fill)
@end smallexample

@noindent
In this line, the @code{add-hook} command adds
@code{turn-on-auto-fill} to the variable.

@code{turn-on-auto-fill} is the name of a program, that, you guessed
it!, turns on Auto Fill mode.

Every time Emacs turns on Text mode, Emacs runs the commands hooked
onto Text mode.  So every time Emacs turns on Text mode, Emacs also
turns on Auto Fill mode.

In brief, the first line causes Emacs to enter Text mode when you edit a
file, unless the file name extension, a first non-blank line, or local
variables to tell Emacs otherwise.

Text mode among other actions, sets the syntax table to work
conveniently for writers.  In Text mode, Emacs considers an apostrophe
as part of a word like a letter; but Emacs does not consider a period
or a space as part of a word.  Thus, @kbd{M-f} moves you over
@samp{it's}.  On the other hand, in C mode, @kbd{M-f} stops just after
the @samp{t} of @samp{it's}.

The second line causes Emacs to turn on Auto Fill mode when it turns
on Text mode.  In Auto Fill mode, Emacs automatically breaks a line
that is too wide and brings the excessively wide part of the line down
to the next line.  Emacs breaks lines between words, not within them.

When Auto Fill mode is turned off, lines continue to the right as you
type them.  Depending on how you set the value of
@code{truncate-lines}, the words you type either disappear off the
right side of the screen, or else are shown, in a rather ugly and
unreadable manner, as a continuation line on the screen.

@need 1250
In addition, in this part of my @file{.emacs} file, I tell the Emacs
fill commands to insert two spaces after a colon:

@smallexample
(setq colon-double-space t)
@end smallexample

@node Mail Aliases
@section Mail Aliases

Here is a @code{setq} that turns on mail aliases, along with more
reminders.

@smallexample
@group
;;; Message mode
; To enter message mode, type 'C-x m'
; To enter RMAIL (for reading mail),
; type 'M-x rmail'
(setq mail-aliases t)
@end group
@end smallexample

@cindex Mail aliases
@noindent
This @code{setq} sets the value of the variable
@code{mail-aliases} to @code{t}.  Since @code{t} means true, the line
says, in effect, ``Yes, use mail aliases.''

Mail aliases are convenient short names for long email addresses or
for lists of email addresses.  The file where you keep your aliases
is @file{~/.mailrc}.  You write an alias like this:

@smallexample
alias geo george@@foobar.wiz.edu
@end smallexample

@noindent
When you write a message to George, address it to @samp{geo}; the
mailer will automatically expand @samp{geo} to the full address.

@node Indent Tabs Mode
@section Indent Tabs Mode
@cindex Tabs, preventing
@findex indent-tabs-mode

By default, Emacs inserts tabs in place of multiple spaces when it
formats a region.  (For example, you might indent many lines of text
all at once with the @code{indent-region} command.)  Tabs look fine on
a terminal or with ordinary printing, but they produce badly indented
output when you use @TeX{} or Texinfo since @TeX{} ignores tabs.

@need 1250
The following turns off Indent Tabs mode:

@smallexample
@group
;;; Prevent Extraneous Tabs
(setq-default indent-tabs-mode nil)
@end group
@end smallexample

Note that this line uses @code{setq-default} rather than the
@code{setq} that we have seen before; @code{setq-default}
sets values only in buffers that do not have their own local
values for the variable.

@ifinfo
@xref{Just Spaces, , Tabs vs.@: Spaces, emacs, The GNU Emacs Manual}.

@xref{File Variables, , Local Variables in Files, emacs, The GNU Emacs
Manual}.
@end ifinfo
@iftex
See sections ``Tabs vs.@: Spaces'' and ``Local Variables in
Files'' in @cite{The GNU Emacs Manual}.
@end iftex

@need 1700
@node Key Bindings
@section Some Key Bindings

Now for some personal key bindings:

@smallexample
@group
;;; Compare windows
(global-set-key "\C-cw" 'compare-windows)
@end group
@end smallexample

@findex compare-windows
@code{compare-windows} is a nifty command that compares the text in
your current window with text in the next window.  It makes the
comparison by starting at point in each window, moving over text in
each window as far as they match.  I use this command all the time.

This also shows how to set a key globally, for all modes.

@cindex Setting a key globally
@cindex Global set key
@cindex Key setting globally
@findex global-set-key
The command is @code{global-set-key}.  It is followed by the
key binding.  In a @file{.emacs} file, the keybinding is written as
shown: @code{\C-c} stands for Control-C, which means to press the
control key and the @kbd{c} key at the same time.  The @code{w} means
to press the @kbd{w} key.  The key binding is surrounded by double
quotation marks.  In documentation, you would write this as
@w{@kbd{C-c w}}.  (If you were binding a @key{META} key, such as
@kbd{M-c}, rather than a @key{CTRL} key, you would write
@w{@code{\M-c}} in your @file{.emacs} file.  @xref{Init Rebinding, ,
Rebinding Keys in Your Init File, emacs, The GNU Emacs Manual}, for
details.)

The command invoked by the keys is @code{compare-windows}.  Note that
@code{compare-windows} is preceded by a single-quote; otherwise, Emacs
would first try to evaluate the symbol to determine its value.

These three things, the double quotation marks, the backslash before
the @samp{C}, and the single-quote are necessary parts of
key binding that I tend to forget.  Fortunately, I have come to
remember that I should look at my existing @file{.emacs} file, and
adapt what is there.

As for the key binding itself: @kbd{C-c w}.  This combines the prefix
key, @kbd{C-c}, with a single character, in this case, @kbd{w}.  This
set of keys, @kbd{C-c} followed by a single character, is strictly
reserved for individuals' own use.  (I call these @dfn{own} keys, since
these are for my own use.)  You should always be able to create such a
key binding for your own use without stomping on someone else's
key binding.  If you ever write an extension to Emacs, please avoid
taking any of these keys for public use.  Create a key like @kbd{C-c
C-w} instead.  Otherwise, we will run out of own keys.

@need 1250
Here is another key binding, with a comment:

@smallexample
@group
;;; Key binding for 'occur'
; I use occur a lot, so let's bind it to a key:
(global-set-key "\C-co" 'occur)
@end group
@end smallexample

@findex occur
The @code{occur} command shows all the lines in the current buffer
that contain a match for a regular expression.  When the region is
active, @code{occur} restricts matches to such region.  Otherwise it
uses the entire buffer.
Matching lines are shown in a buffer called @file{*Occur*}.
That buffer serves as a menu to jump to occurrences.

@findex global-unset-key
@cindex Unbinding key
@cindex Key unbinding
@need 1250
Here is how to unbind a key, so it does not
work:

@smallexample
@group
;;; Unbind 'C-x f'
(global-unset-key "\C-xf")
@end group
@end smallexample

There is a reason for this unbinding: I found I inadvertently typed
@w{@kbd{C-x f}} when I meant to type @kbd{C-x C-f}.  Rather than find a
file, as I intended, I accidentally set the width for filled text,
almost always to a width I did not want.  Since I hardly ever reset my
default width, I simply unbound the key.

@findex list-buffers@r{, rebound}
@findex buffer-menu@r{, bound to key}
@need 1250
The following rebinds an existing key:

@smallexample
@group
;;; Rebind 'C-x C-b' for 'buffer-menu'
(global-set-key "\C-x\C-b" 'buffer-menu)
@end group
@end smallexample

By default, @kbd{C-x C-b} runs the
@code{list-buffers} command.  This command lists
your buffers in @emph{another} window.  Since I
almost always want to do something in that
window, I prefer the  @code{buffer-menu}
command, which not only lists the buffers,
but moves point into that window.

@node Keymaps
@section Keymaps
@cindex Keymaps
@cindex Rebinding keys

Emacs uses @dfn{keymaps} to record which keys call which commands.
When you use @code{global-set-key} to set the key binding for a single
command in all parts of Emacs, you are specifying the key binding in
@code{current-global-map}.

Specific modes, such as C mode or Text mode, have their own keymaps;
the mode-specific keymaps override the global map that is shared by
all buffers.

The @code{global-set-key} function binds, or rebinds, the global
keymap.  For example, the following binds the key @kbd{C-x C-b} to the
function @code{buffer-menu}:

@smallexample
(global-set-key "\C-x\C-b" 'buffer-menu)
@end smallexample

Mode-specific keymaps are bound using the @code{define-key} function,
which takes a specific keymap as an argument, as well as the key and
the command.  For example, my @file{.emacs} file contains the
following expression to bind the @code{texinfo-insert-@@group} command
to @kbd{C-c C-c g}:

@smallexample
@group
(define-key texinfo-mode-map "\C-c\C-cg" 'texinfo-insert-@@group)
@end group
@end smallexample

@noindent
The @code{texinfo-insert-@@group} function itself is a little extension
to Texinfo mode that inserts @samp{@@group} into a Texinfo file.  I
use this command all the time and prefer to type the three strokes
@kbd{C-c C-c g} rather than the six strokes @kbd{@@ g r o u p}.
(@samp{@@group} and its matching @samp{@@end group} are commands that
keep all enclosed text together on one page; many multi-line examples
in this book are surrounded by @samp{@@group @dots{} @@end group}.)

@need 1250
Here is the @code{texinfo-insert-@@group} function definition:

@smallexample
@group
(defun texinfo-insert-@@group ()
  "Insert the string @@group in a Texinfo buffer."
  (interactive)
  (beginning-of-line)
  (insert "@@group\n"))
@end group
@end smallexample

(Of course, I could have used Abbrev mode to save typing, rather than
write a function to insert a word; but I prefer key strokes consistent
with other Texinfo mode key bindings.)

You will see numerous @code{define-key} expressions in
@file{loaddefs.el} as well as in the various mode libraries, such as
@file{cc-mode.el} and @file{lisp-mode.el}.

@xref{Key Bindings, , Customizing Key Bindings, emacs, The GNU Emacs
Manual}, and @ref{Keymaps, , Keymaps, elisp, The GNU Emacs Lisp
Reference Manual}, for more information about keymaps.

@node Loading Files
@section Loading Files
@cindex Loading files
@c findex load

Many people in the GNU Emacs community have written extensions to
Emacs.  As time goes by, these extensions are often included in new
releases.  For example, the Calendar and Diary packages are now part
of the standard GNU Emacs, as is Calc.

You can use a @code{load} command to evaluate a complete file and
thereby install all the functions and variables in the file into Emacs.
For example:

@c (auto-compression-mode t)

@smallexample
(load "~/emacs/slowsplit")
@end smallexample

This evaluates, i.e., loads, the @file{slowsplit.el} file or if it
exists, the faster, byte compiled @file{slowsplit.elc} file from the
@file{emacs} sub-directory of your home directory.  The file contains
the function @code{split-window-quietly}, which John Robinson wrote in
1989.

The @code{split-window-quietly} function splits a window with the
minimum of redisplay.  I installed it in 1989 because it worked well
with the slow 1200 baud terminals I was then using.  Nowadays, I only
occasionally come across such a slow connection, but I continue to use
the function because I like the way it leaves the bottom half of a
buffer in the lower of the new windows and the top half in the upper
window.

@need 1250
To replace the key binding for the default
@code{split-window-vertically}, you must also unset that key and bind
the keys to @code{split-window-quietly}, like this:

@smallexample
@group
(global-unset-key "\C-x2")
(global-set-key "\C-x2" 'split-window-quietly)
@end group
@end smallexample

@vindex load-path
If you load many extensions, as I do, then instead of specifying the
exact location of the extension file, as shown above, you can specify
that directory as part of Emacs's @code{load-path}.  Then, when Emacs
loads a file, it will search that directory as well as its default
list of directories.  (The default list is specified in @file{paths.h}
when Emacs is built.)

@need 1250
The following command adds your @file{~/emacs} directory to the
existing load path:

@smallexample
@group
;;; Emacs Load Path
(setq load-path (cons "~/emacs" load-path))
@end group
@end smallexample

Incidentally, @code{load-library} is an interactive interface to the
@code{load} function.  The complete function looks like this:

@findex load-library
@smallexample
@group
(defun load-library (library)
  "Load the Emacs Lisp library named LIBRARY.
This is an interface to the function `load'.  LIBRARY is searched
for in `load-path', both with and without `load-suffixes' (as
well as `load-file-rep-suffixes').

See Info node `(emacs)Lisp Libraries' for more details.
See `load-file' for a different interface to `load'."
  (interactive
   (list (completing-read "Load library: "
                          (apply-partially 'locate-file-completion-table
                                           load-path
                                           (get-load-suffixes)))))
  (load library))
@end group
@end smallexample

The name of the function, @code{load-library}, comes from the use of
``library'' as a conventional synonym for ``file''.  The source for the
@code{load-library} command is in the @file{files.el} library.

Another interactive command that does a slightly different job is
@code{load-file}.  @xref{Lisp Libraries, , Libraries of Lisp Code for
Emacs, emacs, The GNU Emacs Manual}, for information on the
distinction between @code{load-library} and this command.

@node Autoload
@section Autoloading
@findex autoload

Instead of installing a function by loading the file that contains it,
or by evaluating the function definition, you can make the function
available but not actually install it until it is first called.  This
is called @dfn{autoloading}.

When you execute an autoloaded function, Emacs automatically evaluates
the file that contains the definition, and then calls the function.

Emacs starts quicker with autoloaded functions, since their libraries
are not loaded right away; but you need to wait a moment when you
first use such a function, while its containing file is evaluated.

Rarely used functions are frequently autoloaded.  The
@file{loaddefs.el} library contains thousands of autoloaded functions,
from @code{5x5} to @code{zone}.  Of course, you may
come to use a rare function frequently.  When you do, you should
load that function's file with a @code{load} expression in your
@file{.emacs} file.

In my @file{.emacs} file, I load 14 libraries that contain functions
that would otherwise be autoloaded.  (Actually, it would have been
better to include these files in my dumped Emacs, but I forgot.
@xref{Building Emacs, , Building Emacs, elisp, The GNU Emacs Lisp
Reference Manual}, and the @file{INSTALL} file for more about
dumping.)

You may also want to include autoloaded expressions in your @file{.emacs}
file.  @code{autoload} is a built-in function that takes up to five
arguments, the final three of which are optional.  The first argument
is the name of the function to be autoloaded; the second is the name
of the file to be loaded.  The third argument is documentation for the
function, and the fourth tells whether the function can be called
interactively.  The fifth argument tells what type of
object---@code{autoload} can handle a keymap or macro as well as a
function (the default is a function).

@need 800
Here is a typical example:

@smallexample
@group
(autoload 'html-helper-mode
  "html-helper-mode" "Edit HTML documents" t)
@end group
@end smallexample

@noindent
(@code{html-helper-mode} is an older alternative to @code{html-mode},
which is a standard part of the distribution.)

@noindent
This expression autoloads the @code{html-helper-mode} function.  It
takes it from the @file{html-helper-mode.el} file (or from the byte
compiled version @file{html-helper-mode.elc}, if that exists.)  The
file must be located in a directory specified by @code{load-path}.
The documentation says that this is a mode to help you edit documents
written in the HyperText Markup Language.  You can call this mode
interactively by typing @kbd{M-x html-helper-mode}.  (You need to
duplicate the function's regular documentation in the autoload
expression because the regular function is not yet loaded, so its
documentation is not available.)

@xref{Autoload, , Autoload, elisp, The GNU Emacs Lisp Reference
Manual}, for more information.

@node Simple Extension
@section A Simple Extension: @code{line-to-top-of-window}
@findex line-to-top-of-window
@cindex Simple extension in @file{.emacs} file

Here is a simple extension to Emacs that moves the line that point is
on to the top of the window.  I use this all the time, to make text
easier to read.

You can put the following code into a separate file and then load it
from your @file{.emacs} file, or you can include it within your
@file{.emacs} file.

@need 1250
Here is the definition:

@smallexample
@group
;;; Line to top of window;
;;; replace three keystroke sequence  C-u 0 C-l
(defun line-to-top-of-window ()
  "Move the line that point is on to top of window."
  (interactive)
  (recenter 0))
@end group
@end smallexample

@need 1250
Now for the key binding.

Function keys as well as mouse button events and non-@sc{ascii}
characters are written within square brackets, without quotation
marks.

I bind @code{line-to-top-of-window} to my @key{F6} function key like
this:

@smallexample
(global-set-key [f6] 'line-to-top-of-window)
@end smallexample

For more information, see @ref{Init Rebinding, , Rebinding Keys in
Your Init File, emacs, The GNU Emacs Manual}.

@cindex Conditional 'twixt two versions of Emacs
@cindex Version of Emacs, choosing
@cindex Emacs version, choosing
If you run two versions of GNU Emacs, such as versions 27 and 28, and
use one @file{.emacs} file, you can select which code to evaluate with
the following conditional:

@smallexample
@group
(cond
 ((= 27 emacs-major-version)
  ;; evaluate version 27 code
  ( @dots{} ))
 ((= 28 emacs-major-version)
  ;; evaluate version 28 code
  ( @dots{} )))
@end group
@end smallexample

For example, recent versions blink
their cursors by default.  I hate such blinking, as well as other
features, so I placed the following in my @file{.emacs}
file@footnote{When I start instances of Emacs that do not load my
@file{.emacs} file or any site file, I also turn off blinking:

@smallexample
emacs -q --no-site-file -eval '(blink-cursor-mode nil)'

@exdent Or nowadays, using an even more sophisticated set of options,

emacs -Q -D
@end smallexample
}:

@smallexample
@group
(when (>= emacs-major-version 21)
  (blink-cursor-mode 0)
  ;; Insert newline when you press 'C-n' (next-line)
  ;; at the end of the buffer
  (setq next-line-add-newlines t)
@end group
@group
  ;; Turn on image viewing
  (auto-image-file-mode t)
@end group
@group
  ;; Turn on menu bar (this bar has text)
  ;; (Use numeric argument to turn on)
  (menu-bar-mode 1)
@end group
@group
  ;; Turn off tool bar (this bar has icons)
  ;; (Use numeric argument to turn on)
  (tool-bar-mode nil)
@end group
@group
  ;; Turn off tooltip mode for tool bar
  ;; (This mode causes icon explanations to pop up)
  ;; (Use numeric argument to turn on)
  (tooltip-mode nil)
  ;; If tooltips turned on, make tips appear promptly
  (setq tooltip-delay 0.1)  ; default is 0.7 second
   )
@end group
@end smallexample

@node X11 Colors
@section X11 Colors

You can specify colors when you use Emacs with the MIT X Windowing
system.

I dislike the default colors and specify my own.

@need 1250
Here are the expressions in my @file{.emacs}
file that set values:

@smallexample
@group
;; Set cursor color
(set-cursor-color "white")

;; Set mouse color
(set-mouse-color "white")

;; Set foreground and background
(set-foreground-color "white")
(set-background-color "darkblue")
@end group

@group
;;; Set highlighting colors for isearch and drag
(set-face-foreground 'highlight "white")
(set-face-background 'highlight "blue")
@end group

@group
(set-face-foreground 'region "cyan")
(set-face-background 'region "blue")
@end group

@group
(set-face-foreground 'secondary-selection "skyblue")
(set-face-background 'secondary-selection "darkblue")
@end group

@group
;; Set calendar highlighting colors
(with-eval-after-load 'calendar
  (set-face-foreground 'diary   "skyblue")
  (set-face-background 'holiday "slate blue")
  (set-face-foreground 'holiday "white"))
@end group
@end smallexample

The various shades of blue soothe my eye and prevent me from seeing
the screen flicker.

Alternatively, I could have set my specifications in various X
initialization files.  For example, I could set the foreground,
background, cursor, and pointer (i.e., mouse) colors in my
@file{~/.Xresources} file like this:

@smallexample
@group
Emacs*foreground:   white
Emacs*background:   darkblue
Emacs*cursorColor:  white
Emacs*pointerColor: white
@end group
@end smallexample

In any event, since it is not part of Emacs, I set the root color of
my X window in my @file{~/.xinitrc} file, like this@footnote{I also
run more modern window managers, such as Enlightenment, Gnome, or KDE;
in those cases, I often specify an image rather than a plain color.}:

@smallexample
xsetroot -solid Navy -fg white &
@end smallexample

@need 1700
@node Miscellaneous
@section Miscellaneous Settings for a @file{.emacs} File

@need 1250
Here are a few miscellaneous settings:
@sp 1

@itemize @minus
@item
Set the shape and color of the mouse cursor:

@smallexample
@group
; Cursor shapes are defined in
; '/usr/include/X11/cursorfont.h';
; for example, the 'target' cursor is number 128;
; the 'top_left_arrow' cursor is number 132.
@end group

@group
(let ((mpointer (x-get-resource "*mpointer"
                                "*emacs*mpointer")))
  ;; If you have not set your mouse pointer
  ;;     then set it, otherwise leave as is:
  (if (eq mpointer nil)
      (setq mpointer "132")) ; top_left_arrow
@end group
@group
  (setq x-pointer-shape (string-to-number mpointer))
  (set-mouse-color "white"))
@end group
@end smallexample

@item
Or you can set the values of a variety of features in an alist, like
this:

@smallexample
@group
(setq-default
 default-frame-alist
 '((cursor-color . "white")
   (mouse-color . "white")
   (foreground-color . "white")
   (background-color . "DodgerBlue4")
   ;; (cursor-type . bar)
   (cursor-type . box)
@end group
@group
   (tool-bar-lines . 0)
   (menu-bar-lines . 1)
   (width . 80)
   (height . 58)
   (font .
         "-Misc-Fixed-Medium-R-Normal--20-200-75-75-C-100-ISO8859-1")
   ))
@end group
@end smallexample

@item
Convert @kbd{@key{CTRL}-h} into @key{DEL} and @key{DEL}
into @kbd{@key{CTRL}-h}.@*
(Some older keyboards needed this, although I have not seen the
problem recently.)

@smallexample
@group
;; Translate 'C-h' to <DEL>.
; (keyboard-translate ?\C-h ?\C-?)

;; Translate <DEL> to 'C-h'.
(keyboard-translate ?\C-? ?\C-h)
@end group
@end smallexample

@item Turn off a blinking cursor!

@smallexample
@group
(if (fboundp 'blink-cursor-mode)
    (blink-cursor-mode -1))
@end group
@end smallexample

@noindent
or start GNU Emacs with the command @code{emacs -nbc}.

@need 1250
@item When using @command{grep}@*
@samp{-i}@w{  }   Ignore case distinctions@*
@samp{-n}@w{  }   Prefix each line of output with line number@*
@samp{-H}@w{  }   Print the filename for each match.@*
@samp{-e}@w{  }   Protect patterns beginning with a hyphen character, @samp{-}

@smallexample
(setq grep-command "grep -i -nH -e ")
@end smallexample

@item Find an existing buffer, even if it has a different name@*
This avoids problems with symbolic links.

@smallexample
(setq find-file-existing-other-name t)
@end smallexample

@item Set your language environment and default input method

@smallexample
@group
(set-language-environment "latin-1")
;; Remember you can enable or disable multilingual text input
;; with the @code{toggle-input-method'} (@kbd{C-\}) command
(setq default-input-method "latin-1-prefix")
@end group
@end smallexample

If you want to write with Chinese GB characters, set this instead:

@smallexample
@group
(set-language-environment "Chinese-GB")
(setq default-input-method "chinese-tonepy")
@end group
@end smallexample
@end itemize

@subsubheading Fixing Unpleasant Key Bindings
@cindex Key bindings, fixing
@cindex Bindings, key, fixing unpleasant

Some systems bind keys unpleasantly.  Sometimes, for example, the
@key{CTRL} key appears in an awkward spot rather than at the far left
of the home row.

Usually, when people fix these sorts of key bindings, they do not
change their @file{~/.emacs} file.  Instead, they bind the proper keys
on their consoles with the @code{loadkeys} or @code{install-keymap}
commands in their boot script and then include @code{xmodmap} commands
in their @file{.xinitrc} or @file{.Xsession} file for X Windows.

@need 1250
@noindent
For a boot script:

@smallexample
@group
loadkeys /usr/share/keymaps/i386/qwerty/emacs2.kmap.gz
@exdent or
install-keymap emacs2
@end group
@end smallexample

@need 1250
@noindent
For a @file{.xinitrc} or @file{.Xsession} file when the @key{Caps
Lock} key is at the far left of the home row:

@smallexample
@group
# Bind the key labeled 'Caps Lock' to 'Control'
# (Such a broken user interface suggests that keyboard manufacturers
# think that computers are typewriters from 1885.)

xmodmap -e "clear Lock"
xmodmap -e "add Control = Caps_Lock"
@end group
@end smallexample

@need 1250
@noindent
In a @file{.xinitrc} or @file{.Xsession} file, to convert an @key{ALT}
key to a @key{META} key:

@smallexample
@group
# Some ill designed keyboards have a key labeled ALT and no Meta
xmodmap -e "keysym Alt_L = Meta_L Alt_L"
@end group
@end smallexample

@need 1700
@node Mode Line
@section A Modified Mode Line
@vindex mode-line-format
@cindex Mode line format

Finally, a feature I really like: a modified mode line.

When I work over a network, I forget which machine I am using.  Also,
I tend to lose track of where I am, and which line point is on.

So I reset my mode line to look like this:

@smallexample
-:-- foo.texi   rattlesnake:/home/bob/  Line 1  (Texinfo Fill) Top
@end smallexample

I am visiting a file called @file{foo.texi}, on my machine
@file{rattlesnake} in my @file{/home/bob} buffer.  I am on line 1, in
Texinfo mode, and am at the top of the buffer.

@need 1200
My @file{.emacs} file has a section that looks like this:

@smallexample
@group
;; Set a Mode Line that tells me which machine, which directory,
;; and which line I am on, plus the other customary information.
(setq-default mode-line-format
 (quote
  (#("-" 0 1
     (help-echo
      "mouse-1: select window, mouse-2: delete others ..."))
   mode-line-mule-info
   mode-line-modified
   mode-line-frame-identification
   "    "
@end group
@group
   mode-line-buffer-identification
   "    "
   (:eval (substring
           (system-name) 0 (string-match "\\..+" (system-name))))
   ":"
   default-directory
   #(" " 0 1
     (help-echo
      "mouse-1: select window, mouse-2: delete others ..."))
   (line-number-mode " Line %l ")
   global-mode-string
@end group
@group
   #("   %[(" 0 6
     (help-echo
      "mouse-1: select window, mouse-2: delete others ..."))
   (:eval (format-time-string "%F"))
   mode-line-process
   minor-mode-alist
   #("%n" 0 2 (help-echo "mouse-2: widen" local-map (keymap ...)))
   ")%] "
   (-3 . "%P")
   ;;   "-%-"
   )))
@end group
@end smallexample

@noindent
Here, I redefine the default mode line.  Most of the parts are from
the original; but I make a few changes.  I set the @emph{default} mode
line format so as to permit various modes, such as Info, to override
it.

Many elements in the list are self-explanatory:
@code{mode-line-modified} is a variable that tells whether the buffer
has been modified, @code{mode-name} tells the name of the mode, and so
on.  However, the format looks complicated because of two features we
have not discussed.

@cindex Properties, in mode line example
The first string in the mode line is a dash or hyphen, @samp{-}.  In
the old days, it would have been specified simply as @code{"-"}.  But
nowadays, Emacs can add properties to a string, such as highlighting
or, as in this case, a help feature.  If you place your mouse cursor
over the hyphen, some help information appears (By default, you must
wait seven-tenths of a second before the information appears.  You can
change that timing by changing the value of @code{tooltip-delay}.)

@need 1000
The new string format has a special syntax:

@smallexample
#("-" 0 1 (help-echo "mouse-1: select window, ..."))
@end smallexample

@noindent
The @code{#(} begins a list.  The first element of the list is the
string itself, just one @samp{-}.  The second and third
elements specify the range over which the fourth element applies.  A
range starts @emph{after} a character, so a zero means the range
starts just before the first character; a 1 means that the range ends
just after the first character.  The third element is the property for
the range.  It consists of a property list,  a
property name, in this case, @samp{help-echo}, followed by a value, in this
case, a string.  The second, third, and fourth elements of this new
string format can be repeated.

@xref{Text Properties, , Text Properties, elisp, The GNU Emacs Lisp
Reference Manual}, and see @ref{Mode Line Format, , Mode Line Format,
elisp, The GNU Emacs Lisp Reference Manual}, for more information.

@code{mode-line-buffer-identification}
displays the current buffer name.  It is a list
beginning @code{(#("%12b" 0 4 @dots{}}.
The @code{#(} begins the list.

The @samp{"%12b"} displays the current buffer name, using the
@code{buffer-name} function with which we are familiar; the @samp{12}
specifies the maximum number of characters that will be displayed.
When a name has fewer characters, whitespace is added to fill out to
this number.  (Buffer names can and often should be longer than 12
characters; this length works well in a typical 80 column wide
window.)

@code{:eval} says to evaluate the following form and use the result as
a string to display.  In this case, the expression displays the first
component of the full system name.  The end of the first component is
a @samp{.} (period), so I use the @code{string-match} function to
tell me the length of the first component.  The substring from the
zeroth character to that length is the name of the machine.

@need 1250
This is the expression:

@smallexample
@group
(:eval (substring
        (system-name) 0 (string-match "\\..+" (system-name))))
@end group
@end smallexample

@samp{%[} and @samp{%]} cause a pair of square brackets
to appear for each recursive editing level.  @samp{%n} says ``Narrow''
when narrowing is in effect.  @samp{%P} tells you the percentage of
the buffer that is above the bottom of the window, or ``Top'', ``Bottom'',
or ``All''.  (A lower case @samp{p} tell you the percentage above the
@emph{top} of the window.)  @samp{%-} inserts enough dashes to fill
out the line.

Remember, you don't have to like Emacs to like it---your own
Emacs can have different colors, different commands, and different
keys than a default Emacs.

On the other hand, if you want to bring up a plain out-of-the-box
Emacs, with no customization, type:

@smallexample
emacs -q
@end smallexample

@noindent
This will start an Emacs that does @emph{not} load your
@file{~/.emacs} initialization file.  A plain, default Emacs.  Nothing
more.

@node Debugging
@chapter Debugging
@cindex debugging

GNU Emacs has two debuggers, @code{debug} and @code{edebug}.  The
first is built into the internals of Emacs and is always with you;
the second requires that you instrument a function before you can use it.

Both debuggers are described extensively in @ref{Debugging, ,
Debugging Lisp Programs, elisp, The GNU Emacs Lisp Reference Manual}.
In this chapter, I will walk through a short example of each.

@menu
* debug::                       How to use the built-in debugger.
* debug-on-entry::              Start debugging when you call a function.
* debug-on-quit::               Start debugging when you quit with @kbd{C-g}.
* edebug::                      How to use Edebug, a source level debugger.
* Debugging Exercises::
@end menu

@node debug
@section @code{debug}
@findex debug

Suppose you have written a function definition that is intended to
return the sum of the numbers 1 through a given number.  (This is the
@code{triangle} function discussed earlier.  @xref{Decrementing
Example, , Example with Decrementing Counter}, for a discussion.)
@c xref{Decrementing Loop,, Loop with a Decrementing Counter}, for a discussion.)

However, your function definition has a bug.  You have mistyped
@samp{1=} for @samp{1-}.  Here is the broken definition:

@findex triangle-bugged
@smallexample
@group
(defun triangle-bugged (number)
  "Return sum of numbers 1 through NUMBER inclusive."
  (let ((total 0))
    (while (> number 0)
      (setq total (+ total number))
      (setq number (1= number)))      ; @r{Error here.}
    total))
@end group
@end smallexample

If you are reading this in Info, you can evaluate this definition in
the normal fashion.  You will see @code{triangle-bugged} appear in the
echo area.

@need 1250
Now evaluate the @code{triangle-bugged} function with an
argument of 4:

@smallexample
(triangle-bugged 4)
@end smallexample

@noindent
This will create and enter a @file{*Backtrace*} buffer that says:

@noindent
@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function 1=)
  (1= number)
  (setq number (1= number))
  (while (> number 0) (setq total (+ total number))
        (setq number (1= number)))
  (let ((total 0)) (while (> number 0) (setq total ...)
    (setq number ...)) total)
  triangle-bugged(4)
@end group
@group
  eval((triangle-bugged 4) nil)
  eval-expression((triangle-bugged 4) nil nil 127)
  funcall-interactively(eval-expression (triangle-bugged 4) nil nil 127)
  call-interactively(eval-expression nil nil)
  command-execute(eval-expression)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@noindent
(I have reformatted this example slightly; the debugger does not fold
long lines.  As usual, you can quit the debugger by typing @kbd{q} in
the @file{*Backtrace*} buffer.)

In practice, for a bug as simple as this, the Lisp error line will
tell you what you need to know to correct the definition.  The
function @code{1=} is void.

However, suppose you are not quite certain what is going on?
You can read the complete backtrace.

Emacs automatically starts the debugger that puts you in the
@file{*Backtrace*} buffer.  You can also start the debugger manually
as described below.

Read the @file{*Backtrace*} buffer from the bottom up; it tells you
what Emacs did that led to the error.  Emacs made an interactive call
to @kbd{C-x C-e} (@code{eval-last-sexp}), which led to the evaluation
of the @code{triangle-bugged} expression.  Each line above tells you
what the Lisp interpreter evaluated next.

@need 1250
The third line from the top of the buffer is

@smallexample
(setq number (1= number))
@end smallexample

@noindent
Emacs tried to evaluate this expression; in order to do so, it tried
to evaluate the inner expression shown on the second line from the
top:

@smallexample
(1= number)
@end smallexample

@need 1250
@noindent
This is where the error occurred; as the top line says:

@smallexample
Debugger entered--Lisp error: (void-function 1=)
@end smallexample

@noindent
You can correct the mistake, re-evaluate the function definition, and
then run your test again.

@node debug-on-entry
@section @code{debug-on-entry}
@findex debug-on-entry

Emacs starts the debugger automatically when your function has an
error.

Incidentally, you can start the debugger manually for all versions of
Emacs; the advantage is that the debugger runs even if you do not have
a bug in your code.  Sometimes your code will be free of bugs!

You can enter the debugger when you call the function by calling
@code{debug-on-entry}.

@need 1250
@noindent
Type:

@smallexample
M-x debug-on-entry @key{RET} triangle-bugged @key{RET}
@end smallexample

@need 1250
@noindent
Now, evaluate the following:

@smallexample
(triangle-bugged 5)
@end smallexample

@noindent
All versions of Emacs will create a @file{*Backtrace*} buffer and tell
you that it is beginning to evaluate the @code{triangle-bugged}
function:

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--entering a function:
* triangle-bugged(5)
  eval((triangle-bugged 5) nil)
@end group
@group
  eval-expression((triangle-bugged 5) nil nil 127)
  funcall-interactively(eval-expression (triangle-bugged 5) nil nil 127)
  call-interactively(eval-expression nil nil)
  command-execute(eval-expression)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

In the @file{*Backtrace*} buffer, type @kbd{d}.  Emacs will evaluate
the first expression in @code{triangle-bugged}; the buffer will look
like this:

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--beginning evaluation of function call form:
* (let ((total 0)) (while (> number 0) (setq total ...)
        (setq number ...)) total)
* triangle-bugged(5)
  eval((triangle-bugged 5))
@end group
@group
  eval((triangle-bugged 5) nil)
  eval-expression((triangle-bugged 5) nil nil 127)
  funcall-interactively(eval-expression (triangle-bugged 5) nil nil 127)
  call-interactively(eval-expression nil nil)
  command-execute(eval-expression)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@noindent
Now, type @kbd{d} again, eight times, slowly.  Each time you type
@kbd{d}, Emacs will evaluate another expression in the function
definition.

@need 1750
Eventually, the buffer will look like this:

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--beginning evaluation of function call form:
* (setq number (1= number))
* (while (> number 0) (setq total (+ total number))
        (setq number (1= number)))
@group
@end group
* (let ((total 0)) (while (> number 0) (setq total ...)
        (setq number ...)) total)
* triangle-bugged(5)
  eval((triangle-bugged 5) nil)
@group
@end group
  eval-expression((triangle-bugged 5) nil nil 127)
  funcall-interactively(eval-expression (triangle-bugged 5) nil nil 127)
  call-interactively(eval-expression nil nil)
  command-execute(eval-expression)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@need 1500
@noindent
Finally, after you type @kbd{d} two more times, Emacs will reach the
error, and the top two lines of the @file{*Backtrace*} buffer will look
like this:

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function 1=)
* (1= number)
@dots{}
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

By typing @kbd{d}, you were able to step through the function.

You can quit a @file{*Backtrace*} buffer by typing @kbd{q} in it; this
quits the trace, but does not cancel @code{debug-on-entry}.

@findex cancel-debug-on-entry
To cancel the effect of @code{debug-on-entry}, call
@code{cancel-debug-on-entry} and the name of the function, like this:

@smallexample
M-x cancel-debug-on-entry @key{RET} triangle-bugged @key{RET}
@end smallexample

@noindent
(If you are reading this in Info, cancel @code{debug-on-entry} now.)

@node debug-on-quit
@section @code{debug-on-quit} and @code{(debug)}

In addition to setting @code{debug-on-error} or calling @code{debug-on-entry},
there are two other ways to start @code{debug}.

@findex debug-on-quit
You can start @code{debug} whenever you type @kbd{C-g}
(@code{keyboard-quit}) by setting the variable @code{debug-on-quit} to
@code{t}.  This is useful for debugging infinite loops.

@need 1500
@cindex @code{(debug)} in code
Or, you can insert a line that says @code{(debug)} into your code
where you want the debugger to start, like this:

@smallexample
@group
(defun triangle-bugged (number)
  "Return sum of numbers 1 through NUMBER inclusive."
  (let ((total 0))
    (while (> number 0)
      (setq total (+ total number))
      (debug)                         ; @r{Start debugger.}
      (setq number (1= number)))      ; @r{Error here.}
    total))
@end group
@end smallexample

The @code{debug} function is described in detail in @ref{Debugger, ,
The Lisp Debugger, elisp, The GNU Emacs Lisp Reference Manual}.

@node edebug
@section The @code{edebug} Source Level Debugger
@cindex Source level debugger
@findex edebug

Edebug is a source level debugger.  Edebug normally displays the
source of the code you are debugging, with an arrow at the left that
shows which line you are currently executing.

You can walk through the execution of a function, line by line, or run
quickly until reaching a @dfn{breakpoint} where execution stops.

Edebug is described in @ref{Edebug, , , elisp, The GNU Emacs
Lisp Reference Manual}.

@need 1250
Here is a bugged function definition for @code{triangle-recursively}.
@xref{Recursive triangle function, , Recursion in place of a counter},
for a review of it.

@smallexample
@group
(defun triangle-recursively-bugged (number)
  "Return sum of numbers 1 through NUMBER inclusive.
Uses recursion."
  (if (= number 1)
      1
    (+ number
       (triangle-recursively-bugged
        (1= number)))))               ; @r{Error here.}
@end group
@end smallexample

@noindent
Normally, you would install this definition by positioning your cursor
after the function's closing parenthesis and typing @kbd{C-x C-e}
(@code{eval-last-sexp}) or else by positioning your cursor within the
definition and typing @kbd{C-M-x} (@code{eval-defun}).  (By default,
the @code{eval-defun} command works only in Emacs Lisp mode or in Lisp
Interaction mode.)

@need 1500
However, to prepare this function definition for Edebug, you must
first @dfn{instrument} the code using a different command.  You can do
this by positioning your cursor within or just after the definition
and typing

@smallexample
M-x edebug-defun @key{RET}
@end smallexample

@noindent
This will cause Emacs to load Edebug automatically if it is not
already loaded, and properly instrument the function.

After instrumenting the function, place your cursor after the
following expression and type @kbd{C-x C-e} (@code{eval-last-sexp}):

@smallexample
(triangle-recursively-bugged 3)
@end smallexample

@noindent
You will be jumped back to the source for
@code{triangle-recursively-bugged} and the cursor positioned at the
beginning of the @code{if} line of the function.  Also, you will see
an arrowhead at the left hand side of that line.  The arrowhead marks
the line where the function is executing.  (In the following examples,
we show the arrowhead with @samp{=>}; in a windowing system, you may
see the arrowhead as a solid triangle in the window fringe.)

@smallexample
=>@point{}(if (= number 1)
@end smallexample

@noindent
@iftex
In the example, the location of point is displayed with a star,
@samp{@point{}} (in Info, it is displayed as @samp{-!-}).
@end iftex
@ifnottex
In the example, the location of point is displayed as @samp{@point{}}
(in a printed book, it is displayed with a five pointed star).
@end ifnottex

If you now press @key{SPC}, point will move to the next expression to
be executed; the line will look like this:

@smallexample
=>(if @point{}(= number 1)
@end smallexample

@noindent
As you continue to press @key{SPC}, point will move from expression to
expression.  At the same time, whenever an expression returns a value,
that value will be displayed in the echo area.  For example, after you
move point past @code{number}, you will see the following:

@smallexample
Result: 3 (#o3, #x3, ?\C-c)
@end smallexample

@noindent
This means the value of @code{number} is 3, which is octal three,
hexadecimal three, and @sc{ascii} Control-C (the third letter of the
alphabet, in case you need to know this information).

You can continue moving through the code until you reach the line with
the error.  Before evaluation, that line looks like this:

@smallexample
=>        @point{}(1= number)))))               ; @r{Error here.}
@end smallexample

@need 1250
@noindent
When you press @key{SPC} once again, you will produce an error message
that says:

@smallexample
Symbol's function definition is void:@: 1=
@end smallexample

@noindent
This is the bug.

Press @kbd{q} to quit Edebug.

To remove instrumentation from a function definition, simply
re-evaluate it with a command that does not instrument it.
For example, you could place your cursor after the definition's
closing parenthesis and type @kbd{C-x C-e}.

Edebug does a great deal more than walk with you through a function.
You can set it so it races through on its own, stopping only at an
error or at specified stopping points; you can cause it to display the
changing values of various expressions; you can find out how many
times a function is called, and more.

Edebug is described in @ref{Edebug, , , elisp, The GNU Emacs
Lisp Reference Manual}.

@need 1500
@node Debugging Exercises
@section Debugging Exercises

@itemize @bullet
@item
Install the @code{@value{COUNT-WORDS}} function and then cause it to
enter the built-in debugger when you call it.  Run the command on a
region containing two words.  You will need to press @kbd{d} a
remarkable number of times.  On your system, is a hook called after
the command finishes?  (For information on hooks, see @ref{Command
Overview, , Command Loop Overview, elisp, The GNU Emacs Lisp Reference
Manual}.)

@item
Copy @code{@value{COUNT-WORDS}} into the @file{*scratch*} buffer,
instrument the function for Edebug, and walk through its execution.
The function does not need to have a bug, although you can introduce
one if you wish.  If the function lacks a bug, the walk-through
completes without problems.

@item
While running Edebug, type @kbd{?} to see a list of all the Edebug commands.
(The @code{global-edebug-prefix} is usually @kbd{C-x X}, i.e.,
@kbd{@key{CTRL}-x} followed by an upper case @kbd{X}; use this prefix
for commands made outside of the Edebug debugging buffer.)

@item
In the Edebug debugging buffer, use the @kbd{p}
(@code{edebug-bounce-point}) command to see where in the region the
@code{@value{COUNT-WORDS}} is working.

@item
Move point to some spot further down the function and then type the
@kbd{h} (@code{edebug-goto-here}) command to jump to that location.

@item
Use the @kbd{t} (@code{edebug-trace-mode}) command to cause Edebug to
walk through the function on its own; use an upper case @kbd{T} for
@code{edebug-Trace-fast-mode}.

@item
Set a breakpoint, then run Edebug in Trace mode until it reaches the
stopping point.
@end itemize

@node Conclusion
@chapter Conclusion

We have now reached the end of this Introduction.  You have now
learned enough about programming in Emacs Lisp to set values, to write
simple @file{.emacs} files for yourself and your friends, and write
simple customizations and extensions to Emacs.

This is a place to stop.  Or, if you wish, you can now go onward, and
teach yourself.

You have learned some of the basic nuts and bolts of programming.  But
only some.  There are a great many more brackets and hinges that are
easy to use that we have not touched.

A path you can follow right now lies among the sources to GNU Emacs
and in
@ifnotinfo
@cite{The GNU Emacs Lisp Reference Manual}.
@end ifnotinfo
@ifinfo
@ref{Top, , The GNU Emacs Lisp Reference Manual, elisp, The GNU
Emacs Lisp Reference Manual}.
@end ifinfo

The Emacs Lisp sources are an adventure.  When you read the sources and
come across a function or expression that is unfamiliar, you need to
figure out or find out what it does.

Go to the Reference Manual.  It is a thorough, complete, and fairly
easy-to-read description of Emacs Lisp.  It is written not only for
experts, but for people who know what you know.  (The @cite{Reference
Manual} comes with the standard GNU Emacs distribution.  Like this
introduction, it comes as a Texinfo source file, so you can read it
on your computer and as a typeset, printed book.)

Go to the other built-in help that is part of GNU Emacs: the built-in
documentation for all functions and variables, and
@code{xref-find-definitions}, the program that takes you to sources.

Here is an example of how I explore the sources.  Because of its name,
@file{simple.el} is the file I looked at first, a long time ago.  As
it happens some of the functions in @file{simple.el} are complicated,
or at least look complicated at first sight.  The @code{open-line}
function, for example, looks complicated.

You may want to walk through this function slowly, as we did with the
@code{forward-sentence} function.  (@xref{forward-sentence, The
@code{forward-sentence} function}.)  Or you may want to skip that
function and look at another, such as @code{split-line}.  You don't
need to read all the functions.  According to
@code{count-words-in-defun}, the @code{split-line} function contains
102 words and symbols.

Even though it is short, @code{split-line} contains  expressions
we have not studied: @code{skip-chars-forward}, @code{indent-to},
@code{current-column} and @code{insert-and-inherit}.

Consider the @code{skip-chars-forward} function.
In GNU Emacs, you can find out more about @code{skip-chars-forward} by
typing @kbd{C-h f} (@code{describe-function}) and the name of the
function.  This gives you the function documentation.

You may be able to guess what is done by a well named function such as
@code{indent-to}; or you can look it up, too.  Incidentally, the
@code{describe-function} function itself is in @file{help.el}; it is
one of those long, but decipherable functions.  You can look up
@code{describe-function} using the @kbd{C-h f} command!

In this instance, since the code is Lisp, the @file{*Help*} buffer
contains the name of the library containing the function's source.
You can put point over the name of the library and press the @key{RET} key,
which in this situation is bound to @code{help-follow}, and be taken
directly to the source, in the same way as @kbd{M-.}
(@code{xref-find-definitions}).

The definition for @code{describe-function} illustrates how to
customize the @code{interactive} expression without using the standard
character codes; and it shows how to create a temporary buffer.

(The @code{indent-to} function is written in C rather than Emacs Lisp;
it is a built-in function.  @code{help-follow} takes you to its
source as does @code{xref-find-definitions}, when properly set up.)

You can look at a function's source using
@code{xref-find-definitions}, which is bound to @kbd{M-.}  Finally,
you can find out what the Reference Manual has to say by visiting the
manual in Info, and typing @kbd{i} (@code{Info-index}) and the name of
the function, or by looking up the function in the index to a printed
copy of the manual.

Similarly, you can find out what is meant by
@code{insert-and-inherit}.

Other interesting source files include @file{paragraphs.el},
@file{loaddefs.el}, and @file{loadup.el}.  The @file{paragraphs.el}
file includes short, easily understood functions as well as longer
ones.  The @file{loaddefs.el} file contains the many standard
autoloads and many keymaps.  I have never looked at it all; only at
parts.  @file{loadup.el} is the file that loads the standard parts of
Emacs; it tells you a great deal about how Emacs is built.
(@xref{Building Emacs, , Building Emacs, elisp, The GNU Emacs Lisp
Reference Manual}, for more about building.)

As I said, you have learned some nuts and bolts; however, and very
importantly, we have hardly touched major aspects of programming; I
have said nothing about how to sort information, except to use the
predefined @code{sort} function; I have said nothing about how to store
information, except to use variables and lists; I have said nothing
about how to write programs that write programs.  These are topics for
another, and different kind of book, a different kind of learning.

What you have done is learn enough for much practical work with GNU
Emacs.  What you have done is get started.  This is the end of a
beginning.

@c ================ Appendix ================

@node the-the
@appendix The @code{the-the} Function
@findex the-the
@cindex Duplicated words function
@cindex Words, duplicated

Sometimes when you you write text, you duplicate words---as with ``you
you'' near the beginning of this sentence.  I find that most
frequently, I duplicate ``the''; hence, I call the function for
detecting duplicated words, @code{the-the}.

@need 1250
As a first step, you could use the following regular expression to
search for duplicates:

@smallexample
\\(\\w+[ \t\n]+\\)\\1
@end smallexample

@noindent
This regexp matches one or more word-constituent characters followed
by one or more spaces, tabs, or newlines.  However, it does not detect
duplicated words on different lines, since the ending of the first
word, the end of the line, is different from the ending of the second
word, a space.  (For more information about regular expressions, see
@ref{Regexp Search, , Regular Expression Searches}, as well as
@ref{Regexps, , Syntax of Regular Expressions, emacs, The GNU Emacs
Manual}, and @ref{Regular Expressions, , Regular Expressions, elisp,
The GNU Emacs Lisp Reference Manual}.)

You might try searching just for duplicated word-constituent
characters but that does not work since the pattern detects doubles
such as the two occurrences of ``th'' in ``with the''.

Another possible regexp searches for word-constituent characters
followed by non-word-constituent characters, reduplicated.  Here,
@w{@samp{\\w+}} matches one or more word-constituent characters and
@w{@samp{\\W*}} matches zero or more non-word-constituent characters.

@smallexample
\\(\\(\\w+\\)\\W*\\)\\1
@end smallexample

@noindent
Again, not useful.

Here is the pattern that I use.  It is not perfect, but good enough.
@w{@samp{\\b}} matches the empty string, provided it is at the beginning
or end of a word; @w{@samp{[^@@ \n\t]+}} matches one or more occurrences of
any characters that are @emph{not} an @@-sign, space, newline, or tab.

@smallexample
\\b\\([^@@ \n\t]+\\)[ \n\t]+\\1\\b
@end smallexample

One can write more complicated expressions, but I found that this
expression is good enough, so I use it.

Here is the @code{the-the} function, as I include it in my
@file{.emacs} file, along with a handy global key binding:

@smallexample
@group
(defun the-the ()
  "Search forward for for a duplicated word."
  (interactive)
  (message "Searching for for duplicated words ...")
  (push-mark)
@end group
@group
  ;; This regexp is not perfect
  ;; but is fairly good over all:
  (if (re-search-forward
       "\\b\\([^@@ \n\t]+\\)[ \n\t]+\\1\\b" nil 'move)
      (message "Found duplicated word.")
    (message "End of buffer")))
@end group

@group
;; Bind 'the-the' to  C-c \
(global-set-key "\C-c\\" 'the-the)
@end group
@end smallexample

@sp 1
Here is test text:

@smallexample
@group
one two two three four five
five six seven
@end group
@end smallexample

You can substitute the other regular expressions shown above in the
function definition and try each of them on this list.

@node Kill Ring
@appendix Handling the Kill Ring
@cindex Kill ring handling
@cindex Handling the kill ring
@cindex Ring, making a list like a

The kill ring is a list that is transformed into a ring by the
workings of the @code{current-kill} function.  The @code{yank} and
@code{yank-pop} commands use the @code{current-kill} function.

This appendix describes the @code{current-kill} function as well as
both the @code{yank} and the @code{yank-pop} commands, but first,
consider the workings of the kill ring.

@menu
* What the Kill Ring Does::
* current-kill::
* yank::                        Paste a copy of a clipped element.
* yank-pop::                    Insert element pointed to.
* ring file::
@end menu

@ifnottex
@node What the Kill Ring Does
@unnumberedsec What the Kill Ring Does
@end ifnottex

@need 1250
The kill ring has a default maximum length of sixty items; this number
is too large for an explanation.  Instead, set it to four.  Please
evaluate the following:

@smallexample
@group
(setq old-kill-ring-max kill-ring-max)
(setq kill-ring-max 4)
@end group
@end smallexample

@noindent
Then, please copy each line of the following indented example into the
kill ring.  You may kill each line with @kbd{C-k} or mark it and copy
it with @kbd{M-w}.

@noindent
(In a read-only buffer, such as the @file{*info*} buffer, the kill
command, @kbd{C-k} (@code{kill-line}), will not remove the text,
merely copy it to the kill ring.  However, your machine may beep at
you.  Alternatively, for silence, you may copy the region of each line
with the @kbd{M-w} (@code{kill-ring-save}) command.  You must mark
each line for this command to succeed, but it does not matter at which
end you put point or mark.)

@need 1250
@noindent
Please invoke the calls in order, so that five elements attempt to
fill the kill ring:

@smallexample
@group
first some text
second piece of text
third line
fourth line of text
fifth bit of text
@end group
@end smallexample

@need 1250
@noindent
Then find the value of @code{kill-ring} by evaluating

@smallexample
kill-ring
@end smallexample

@need 800
@noindent
It is:

@smallexample
@group
("fifth bit of text" "fourth line of text"
"third line" "second piece of text")
@end group
@end smallexample

@noindent
The first element, @samp{first some text}, was dropped.

@need 1250
To return to the old value for the length of the kill ring, evaluate:

@smallexample
(setq kill-ring-max old-kill-ring-max)
@end smallexample

@node current-kill
@appendixsec The @code{current-kill} Function
@findex current-kill

The @code{current-kill} function changes the element in the kill ring
to which @code{kill-ring-yank-pointer} points.  (Also, the
@code{kill-new} function sets @code{kill-ring-yank-pointer} to point
to the latest element of the kill ring.  The @code{kill-new}
function is used directly or indirectly by @code{kill-append},
@code{copy-region-as-kill}, @code{kill-ring-save}, @code{kill-line},
and @code{kill-region}.)

@menu
* Code for current-kill::
* Understanding current-kill::
@end menu

@ifnottex
@node Code for current-kill
@unnumberedsubsec The code for @code{current-kill}
@end ifnottex


@need 1500
The @code{current-kill} function is used by @code{yank} and by
@code{yank-pop}.  Here is the code for @code{current-kill}:

@smallexample
@group
(defun current-kill (n &optional do-not-move)
  "Rotate the yanking point by N places, and then return that kill.
If N is zero and `interprogram-paste-function' is set to a
function that returns a string or a list of strings, and if that
function doesn't return nil, then that string (or list) is added
to the front of the kill ring and the string (or first string in
the list) is returned as the latest kill.
@end group
@group
If N is not zero, and if `yank-pop-change-selection' is
non-nil, use `interprogram-cut-function' to transfer the
kill at the new yank point into the window system selection.
@end group
@group
If optional arg DO-NOT-MOVE is non-nil, then don't actually
move the yanking point; just return the Nth kill forward."

  (let ((interprogram-paste (and (= n 0)
                                 interprogram-paste-function
                                 (funcall interprogram-paste-function))))
@end group
@group
    (if interprogram-paste
        (progn
          ;; Disable the interprogram cut function when we add the new
          ;; text to the kill ring, so Emacs doesn't try to own the
          ;; selection, with identical text.
          (let ((interprogram-cut-function nil))
            (if (listp interprogram-paste)
              (mapc 'kill-new (nreverse interprogram-paste))
              (kill-new interprogram-paste)))
          (car kill-ring))
@end group
@group
      (or kill-ring (error "Kill ring is empty"))
      (let ((ARGth-kill-element
             (nthcdr (mod (- n (length kill-ring-yank-pointer))
                          (length kill-ring))
                     kill-ring)))
        (unless do-not-move
          (setq kill-ring-yank-pointer ARGth-kill-element)
          (when (and yank-pop-change-selection
                     (> n 0)
                     interprogram-cut-function)
            (funcall interprogram-cut-function (car ARGth-kill-element))))
        (car ARGth-kill-element)))))
@end group
@end smallexample

Remember also that the @code{kill-new} function sets
@code{kill-ring-yank-pointer} to the latest element of the kill
ring, which means that all the functions that call it set the value
indirectly: @code{kill-append}, @code{copy-region-as-kill},
@code{kill-ring-save}, @code{kill-line}, and @code{kill-region}.

@need 1500
Here is the line in @code{kill-new}, which is explained in
@ref{kill-new 函数, , @code{kill-new} 函数}.

@smallexample
(setq kill-ring-yank-pointer kill-ring)
@end smallexample

@ifnottex
@node Understanding current-kill
@unnumberedsubsec @code{current-kill} in Outline
@end ifnottex

The @code{current-kill} function looks complex, but as usual, it can
be understood by taking it apart piece by piece.  First look at it in
skeletal form:

@smallexample
@group
(defun current-kill (n &optional do-not-move)
  "Rotate the yanking point by N places, and then return that kill."
  (let @var{varlist}
    @var{body}@dots{})
@end group
@end smallexample

This function takes two arguments, one of which is optional.  It has a
documentation string.  It is @emph{not} interactive.

@menu
* Body of current-kill::
* Digression concerning error::  How to mislead humans, but not computers.
* Determining the Element::
@end menu

@ifnottex
@node Body of current-kill
@unnumberedsubsubsec The Body of @code{current-kill}
@end ifnottex

The body of the function definition is a @code{let} expression, which
itself has a body as well as a @var{varlist}.

The @code{let} expression declares a variable that will be only usable
within the bounds of this function.  This variable is called
@code{interprogram-paste} and is for copying to another program.  It
is not for copying within this instance of GNU Emacs.  Most window
systems provide a facility for interprogram pasting.  Sadly, that
facility usually provides only for the last element.  Most windowing
systems have not adopted a ring of many possibilities, even though
Emacs has provided it for decades.

The @code{if} expression has two parts, one if there exists
@code{interprogram-paste} and one if not.

@need 2000
Let us consider the else-part of the @code{current-kill}
function.  (The then-part uses the @code{kill-new} function, which
we have already described.  @xref{kill-new 函数, , @code{kill-new} 函数}.)

@smallexample
@group
(or kill-ring (error "Kill ring is empty"))
(let ((ARGth-kill-element
       (nthcdr (mod (- n (length kill-ring-yank-pointer))
                    (length kill-ring))
               kill-ring)))
  (or do-not-move
      (setq kill-ring-yank-pointer ARGth-kill-element))
  (car ARGth-kill-element))
@end group
@end smallexample

@noindent
The code first checks whether the kill ring has content; otherwise it
signals an error.

@need 1000
Note that the @code{or} expression is very similar to testing length
with an @code{if}:

@findex zerop
@findex error
@smallexample
@group
(if (zerop (length kill-ring))          ; @r{if-part}
    (error "Kill ring is empty"))       ; @r{then-part}
  ;; No else-part
@end group
@end smallexample

@noindent
If there is not anything in the kill ring, its length must be zero and
an error message sent to the user: @samp{Kill ring is empty}.  The
@code{current-kill} function uses an @code{or} expression which is
simpler.  But an @code{if} expression reminds us what goes on.

This @code{if} expression uses the function @code{zerop} which returns
true if the value it is testing is zero.  When @code{zerop} tests
true, the then-part of the @code{if} is evaluated.  The then-part is a
list starting with the function @code{error}, which is a function that
is similar to the @code{message} function
(@pxref{message, , The @code{message} Function}) in that
it prints a one-line message in the echo area.  However, in addition
to printing a message, @code{error} also stops evaluation of the
function within which it is embedded.  This means that the rest of the
function will not be evaluated if the length of the kill ring is zero.

Then the @code{current-kill} function selects the element to return.
The selection depends on the number of places that @code{current-kill}
rotates and on where @code{kill-ring-yank-pointer} points.

Next, either the optional @code{do-not-move} argument is true or the
current value of @code{kill-ring-yank-pointer} is set to point to the
list.  Finally, another expression returns the first element of the
list even if the @code{do-not-move} argument is true.

@ifnottex
@node Digression concerning error
@unnumberedsubsubsec Digression about the word ``error''
@end ifnottex

In my opinion, it is slightly misleading, at least to humans, to use
the term ``error'' as the name of the @code{error} function.  A better
term would be ``cancel''.  Strictly speaking, of course, you cannot
point to, much less rotate a pointer to a list that has no length, so
from the point of view of the computer, the word ``error'' is correct.
But a human expects to attempt this sort of thing, if only to find out
whether the kill ring is full or empty.  This is an act of
exploration.

From the human point of view, the act of exploration and discovery is
not necessarily an error, and therefore should not be labeled as one,
even in the bowels of a computer.  As it is, the code in Emacs implies
that a human who is acting virtuously, by exploring his or her
environment, is making an error.  This is bad.  Even though the computer
takes the same steps as it does when there is an error, a term such as
``cancel'' would have a clearer connotation.

@ifnottex
@node Determining the Element
@unnumberedsubsubsec Determining the Element
@end ifnottex

Among other actions, the else-part of the @code{if} expression sets
the value of @code{kill-ring-yank-pointer} to
@code{ARGth-kill-element} when the kill ring has something in it and
the value of @code{do-not-move} is @code{nil}.

@need 800
The code looks like this:

@smallexample
@group
(nthcdr (mod (- n (length kill-ring-yank-pointer))
             (length kill-ring))
        kill-ring)))
@end group
@end smallexample

This needs some examination.  Unless it is not supposed to move the
pointer, the @code{current-kill} function changes where
@code{kill-ring-yank-pointer} points.
That is what the
@w{@code{(setq kill-ring-yank-pointer ARGth-kill-element))}}
expression does.  Also, clearly, @code{ARGth-kill-element} is being
set to be equal to some @sc{cdr} of the kill ring, using the
@code{nthcdr} function that is described in an earlier section.
(@xref{copy-region-as-kill}.)  How does it do this?

As we have seen before (@pxref{nthcdr}), the @code{nthcdr} function
works by repeatedly taking the @sc{cdr} of a list---it takes the
@sc{cdr} of the @sc{cdr} of the @sc{cdr} @dots{}

@need 800
The two following expressions produce the same result:

@smallexample
@group
(setq kill-ring-yank-pointer (cdr kill-ring))

(setq kill-ring-yank-pointer (nthcdr 1 kill-ring))
@end group
@end smallexample

However, the @code{nthcdr} expression is more complicated.  It uses
the @code{mod} function to determine which @sc{cdr} to select.

(You will remember to look at inner functions first; indeed, we will
have to go inside the @code{mod}.)

The @code{mod} function returns the value of its first argument modulo
the second; that is to say, it returns the remainder after dividing
the first argument by the second.  The value returned has the same
sign as the second argument.

@need 800
Thus,

@smallexample
@group
(mod 12 4)
  @result{} 0  ;; @r{because there is no remainder}
(mod 13 4)
  @result{} 1
@end group
@end smallexample

@need 1250
In this case, the first argument is often smaller than the second.
That is fine.

@smallexample
@group
(mod 0 4)
  @result{} 0
(mod 1 4)
  @result{} 1
@end group
@end smallexample

We can guess what the @code{-} function does.  It is like @code{+} but
subtracts instead of adds; the @code{-} function subtracts its second
argument from its first.  Also, we already know what the @code{length}
function does (@pxref{长度}).  It returns the length of a list.

And @code{n} is the name of the required argument to the
@code{current-kill} function.

@need 1250
So when the first argument to @code{nthcdr} is zero, the @code{nthcdr}
expression returns the whole list, as you can see by evaluating the
following:

@smallexample
@group
;; kill-ring-yank-pointer @r{and} kill-ring @r{have a length of four}
;; @r{and} (mod (- 0 4) 4) @result{} 0
(nthcdr (mod (- 0 4) 4)
        '("fourth line of text"
          "third line"
          "second piece of text"
          "first some text"))
@end group
@end smallexample

@need 1250
When the first argument to the @code{current-kill} function is one,
the @code{nthcdr} expression returns the list without its first
element.

@smallexample
@group
(nthcdr (mod (- 1 4) 4)
        '("fourth line of text"
          "third line"
          "second piece of text"
          "first some text"))
@end group
@end smallexample

@cindex @samp{global variable} defined
@cindex @samp{variable, global}, defined
Incidentally, both @code{kill-ring} and @code{kill-ring-yank-pointer}
are @dfn{global variables}.  That means that any expression in Emacs
Lisp can access them.  They are not like the local variables set by
@code{let} or like the symbols in an argument list.
Local variables can only be accessed
within the @code{let} that defines them or the function that specifies
them in an argument list (and within expressions called by them).

@c texi2dvi fails when the name of the section is within ifnottex ...
@ifnottex
(@xref{避免混淆, , @code{let} 避免混淆}, and
@end ifnottex
@iftex
(@xref{Permanent Installation, , @code{let} Prevents Confusion}, and
@end iftex
@ref{defun, , The @code{defun} Macro}.)

@node yank
@appendixsec @code{yank}
@findex yank

After learning about @code{current-kill}, the code for the
@code{yank} function is almost easy.

The @code{yank} function does not use the
@code{kill-ring-yank-pointer} variable directly.  It calls
@code{insert-for-yank} which calls @code{current-kill} which sets the
@code{kill-ring-yank-pointer} variable.

@need 1250
The code looks like this:

@c in GNU Emacs 22
@smallexample
@group
(defun yank (&optional arg)
  "Reinsert (\"paste\") the last stretch of killed text.
More precisely, reinsert the stretch of killed text most recently
killed OR yanked.  Put point at end, and set mark at beginning.
With just \\[universal-argument] as argument, same but put point at beginning (and mark at end).
With argument N, reinsert the Nth most recently killed stretch of killed
text.

When this command inserts killed text into the buffer, it honors
`yank-excluded-properties' and `yank-handler' as described in the
doc string for `insert-for-yank-1', which see.

See also the command `yank-pop' (\\[yank-pop])."
@end group
@group
  (interactive "*P")
  (setq yank-window-start (window-start))
  ;; If we don't get all the way thru, make last-command indicate that
  ;; for the following command.
  (setq this-command t)
  (push-mark (point))
@end group
@group
  (insert-for-yank (current-kill (cond
                                  ((listp arg) 0)
                                  ((eq arg '-) -2)
                                  (t (1- arg)))))
  (if (consp arg)
      ;; This is like exchange-point-and-mark, but doesn't activate the mark.
      ;; It is cleaner to avoid activation, even though the command
      ;; loop would deactivate the mark because we inserted text.
      (goto-char (prog1 (mark t)
                   (set-marker (mark-marker) (point) (current-buffer)))))
@end group
@group
  ;; If we do get all the way thru, make this-command indicate that.
  (if (eq this-command t)
      (setq this-command 'yank))
  nil)
@end group
@end smallexample

The key expression is @code{insert-for-yank}, which inserts the string
returned by @code{current-kill}, but removes some text properties from
it.

However, before getting to that expression, the function sets the value
of @code{yank-window-start} to the position returned by the
@code{(window-start)} expression, the position at which the display
currently starts.  The @code{yank} function also sets
@code{this-command} and pushes the mark.

After it yanks the appropriate element, if the optional argument is a
@sc{cons} rather than a number or nothing, it puts point at beginning
of the yanked text and mark at its end.

(The @code{prog1} function is like @code{progn} but returns the value
of its first argument rather than the value of its last argument.  Its
first argument is forced to return the buffer's mark as an integer.
You can see the documentation for these functions by placing point
over them in this buffer and then typing @kbd{C-h f}
(@code{describe-function}) followed by a @kbd{RET}; the default is the
function.)

The last part of the function tells what to do when it succeeds.

@node yank-pop
@appendixsec @code{yank-pop}
@findex yank-pop

After understanding @code{yank} and @code{current-kill}, you know how
to approach the @code{yank-pop} function.  Leaving out the
documentation to save space, it looks like this:

@c GNU Emacs 22
@smallexample
@group
(defun yank-pop (&optional arg)
  "@dots{}"
  (interactive "*p")
  (if (not (eq last-command 'yank))
      (error "Previous command was not a yank"))
@end group
@group
  (setq this-command 'yank)
  (unless arg (setq arg 1))
  (let ((inhibit-read-only t)
        (before (< (point) (mark t))))
@end group
@group
    (if before
        (funcall (or yank-undo-function 'delete-region) (point) (mark t))
      (funcall (or yank-undo-function 'delete-region) (mark t) (point)))
    (setq yank-undo-function nil)
@end group
@group
    (set-marker (mark-marker) (point) (current-buffer))
    (insert-for-yank (current-kill arg))
    ;; Set the window start back where it was in the yank command,
    ;; if possible.
    (set-window-start (selected-window) yank-window-start t)
@end group
@group
    (if before
        ;; This is like exchange-point-and-mark,
        ;;     but doesn't activate the mark.
        ;; It is cleaner to avoid activation, even though the command
        ;; loop would deactivate the mark because we inserted text.
        (goto-char (prog1 (mark t)
                     (set-marker (mark-marker)
                                 (point)
                                 (current-buffer))))))
  nil)
@end group
@end smallexample

The function is interactive with a small @samp{p} so the prefix
argument is processed and passed to the function.  The command can
only be used after a previous yank; otherwise an error message is
sent.  This check uses the variable @code{last-command} which is set
by @code{yank} and is discussed elsewhere.
(@xref{copy-region-as-kill}.)

The @code{let} clause sets the variable @code{before} to true or false
depending whether point is before or after mark and then the region
between point and mark is deleted.  This is the region that was just
inserted by the previous yank and it is this text that will be
replaced.

@code{funcall} calls its first argument as a function, passing
remaining arguments to it.  The first argument is whatever the
@code{or} expression returns.  The two remaining arguments are the
positions of point and mark set by the preceding @code{yank} command.

There is more, but that is the hardest part.

@node ring file
@appendixsec The @file{ring.el} File
@cindex @file{ring.el} file

Interestingly, GNU Emacs posses a file called @file{ring.el} that
provides many of the features we just discussed.  But functions such
as @code{kill-ring-yank-pointer} do not use this library, possibly
because they were written earlier.

@node Full Graph
@appendix A Graph with Labeled Axes

Printed axes help you understand a graph.  They convey scale.  In an
earlier chapter (@pxref{Readying a Graph, ,  Readying a Graph}), we
wrote the code to print the body of a graph.  Here we write the code
for printing and labeling vertical and horizontal axes, along with the
body itself.

@menu
* Labeled Example::
* print-graph Varlist::         @code{let} expression in @code{print-graph}.
* print-Y-axis::                Print a label for the vertical axis.
* print-X-axis::                Print a horizontal label.
* Print Whole Graph::           The function to print a complete graph.
@end menu

@ifnottex
@node Labeled Example
@unnumberedsec Labeled Example Graph
@end ifnottex

Since insertions fill a buffer to the right and below point, the new
graph printing function should first print the Y or vertical axis,
then the body of the graph, and finally the X or horizontal axis.
This sequence lays out for us the contents of the function:

@enumerate
@item
Set up code.

@item
Print Y axis.

@item
Print body of graph.

@item
Print X axis.
@end enumerate

@need 800
Here is an example of how a finished graph should look:

@smallexample
@group
    10 -
                  *
                  *  *
                  *  **
                  *  ***
     5 -      *   *******
            * *** *******
            *************
          ***************
     1 - ****************
         |   |    |    |
         1   5   10   15
@end group
@end smallexample

@noindent
In this graph, both the vertical and the horizontal axes are labeled
with numbers.  However, in some graphs, the horizontal axis is time
and would be better labeled with months, like this:

@smallexample
@group
     5 -      *
            * ** *
            *******
          ********** **
     1 - **************
         |    ^      |
         Jan  June   Jan
@end group
@end smallexample

Indeed, with a little thought, we can easily come up with a variety of
vertical and horizontal labeling schemes.  Our task could become
complicated.  But complications breed confusion.  Rather than permit
this, it is better choose a simple labeling scheme for our first
effort, and to modify or replace it later.

@need 1200
These considerations suggest the following outline for the
@code{print-graph} function:

@smallexample
@group
(defun print-graph (numbers-list)
  "@var{documentation}@dots{}"
  (let ((height  @dots{}
        @dots{}))
@end group
@group
    (print-Y-axis height @dots{} )
    (graph-body-print numbers-list)
    (print-X-axis @dots{} )))
@end group
@end smallexample

We can work on each part of the @code{print-graph} function definition
in turn.

@node print-graph Varlist
@appendixsec The @code{print-graph} Varlist
@cindex @code{print-graph} varlist

In writing the @code{print-graph} function, the first task is to write
the varlist in the @code{let} expression.  (We will leave aside for the
moment any thoughts about making the function interactive or about the
contents of its documentation string.)

The varlist should set several values.  Clearly, the top of the label
for the vertical axis must be at least the height of the graph, which
means that we must obtain this information here.  Note that the
@code{print-graph-body} function also requires this information.  There
is no reason to calculate the height of the graph in two different
places, so we should change @code{print-graph-body} from the way we
defined it earlier to take advantage of the calculation.

Similarly, both the function for printing the X axis labels and the
@code{print-graph-body} function need to learn the value of the width of
each symbol.  We can perform the calculation here and change the
definition for @code{print-graph-body} from the way we defined it in the
previous chapter.

The length of the label for the horizontal axis must be at least as long
as the graph.  However, this information is used only in the function
that prints the horizontal axis, so it does not need to be calculated here.

These thoughts lead us directly to the following form for the varlist
in the @code{let} for @code{print-graph}:

@smallexample
@group
(let ((height (apply 'max numbers-list)) ; @r{First version.}
      (symbol-width (length graph-blank)))
@end group
@end smallexample

@noindent
As we shall see, this expression is not quite right.

@need 2000
@node print-Y-axis
@appendixsec The @code{print-Y-axis} Function
@cindex Axis, print vertical
@cindex Y axis printing
@cindex Vertical axis printing
@cindex Print vertical axis

The job of the @code{print-Y-axis} function is to print a label for
the vertical axis that looks like this:

@smallexample
@group
    10 -




     5 -



     1 -
@end group
@end smallexample

@noindent
The function should be passed the height of the graph, and then should
construct and insert the appropriate numbers and marks.

@menu
* print-Y-axis in Detail::
* Height of label::             What height for the Y axis?
* Compute a Remainder::         How to compute the remainder of a division.
* Y Axis Element::              Construct a line for the Y axis.
* Y-axis-column::               Generate a list of Y axis labels.
* print-Y-axis Penultimate::    A not quite final version.
@end menu

@ifnottex
@node print-Y-axis in Detail
@unnumberedsubsec The @code{print-Y-axis} Function in Detail
@end ifnottex

It is easy enough to see in the figure what the Y axis label should
look like; but to say in words, and then to write a function
definition to do the job is another matter.  It is not quite true to
say that we want a number and a tic every five lines: there are only
three lines between the @samp{1} and the @samp{5} (lines 2, 3, and 4),
but four lines between the @samp{5} and the @samp{10} (lines 6, 7, 8,
and 9).  It is better to say that we want a number and a tic mark on
the base line (number 1) and then that we want a number and a tic on
the fifth line from the bottom and on every line that is a multiple of
five.

@ifnottex
@node Height of label
@unnumberedsubsec What height should the label be?
@end ifnottex

The next issue is what height the label should be?  Suppose the maximum
height of tallest column of the graph is seven.  Should the highest
label on the Y axis be @samp{5 -}, and should the graph stick up above
the label?  Or should the highest label be @samp{7 -}, and mark the peak
of the graph?  Or should the highest label be @code{10 -}, which is a
multiple of five, and be higher than the topmost value of the graph?

The latter form is preferred.  Most graphs are drawn within rectangles
whose sides are an integral number of steps long---5, 10, 15, and so
on for a step distance of five.  But as soon as we decide to use a
step height for the vertical axis, we discover that the simple
expression in the varlist for computing the height is wrong.  The
expression is @code{(apply 'max numbers-list)}.  This returns the
precise height, not the maximum height plus whatever is necessary to
round up to the nearest multiple of five.  A more complex expression
is required.

As usual in cases like this, a complex problem becomes simpler if it is
divided into several smaller problems.

First, consider the case when the highest value of the graph is an
integral multiple of five---when it is 5, 10, 15, or some higher
multiple of five.  We can use this value as the Y axis height.

A fairly simply way to determine whether a number is a multiple of
five is to divide it by five and see if the division results in a
remainder.  If there is no remainder, the number is a multiple of
five.  Thus, seven divided by five has a remainder of two, and seven
is not an integral multiple of five.  Put in slightly different
language, more reminiscent of the classroom, five goes into seven
once, with a remainder of two.  However, five goes into ten twice,
with no remainder: ten is an integral multiple of five.

@node Compute a Remainder
@appendixsubsec Side Trip: Compute a Remainder

@findex % @r{(remainder function)}
@cindex Remainder function, @code{%}
In Lisp, the function for computing a remainder is @code{%}.  The
function returns the remainder of its first argument divided by its
second argument.  As it happens, @code{%} is a function in Emacs Lisp
that you cannot discover using @code{apropos}: you find nothing if you
type @kbd{M-x apropos @key{RET} remainder @key{RET}}.  The only way to
learn of the existence of @code{%} is to read about it in a book such
as this or in the Emacs Lisp sources.

You can try the @code{%} function by evaluating the following two
expressions:

@smallexample
@group
(% 7 5)

(% 10 5)
@end group
@end smallexample

@noindent
The first expression returns 2 and the second expression returns 0.

To test whether the returned value is zero or some other number, we
can use the @code{zerop} function.  This function returns @code{t} if
its argument, which must be a number, is zero.

@smallexample
@group
(zerop (% 7 5))
     @result{} nil

(zerop (% 10 5))
     @result{} t
@end group
@end smallexample

Thus, the following expression will return @code{t} if the height
of the graph is evenly divisible by five:

@smallexample
(zerop (% height 5))
@end smallexample

@noindent
(The value of @code{height}, of course, can be found from @code{(apply
'max numbers-list)}.)

On the other hand, if the value of @code{height} is not a multiple of
five, we want to reset the value to the next higher multiple of five.
This is straightforward arithmetic using functions with which we are
already familiar.  First, we divide the value of @code{height} by five
to determine how many times five goes into the number.  Thus, five
goes into twelve twice.  If we add one to this quotient and multiply by
five, we will obtain the value of the next multiple of five that is
larger than the height.  Five goes into twelve twice.  Add one to two,
and multiply by five; the result is fifteen, which is the next multiple
of five that is higher than twelve.  The Lisp expression for this is:

@smallexample
(* (1+ (/ height 5)) 5)
@end smallexample

@noindent
For example, if you evaluate the following, the result is 15:

@smallexample
(* (1+ (/ 12 5)) 5)
@end smallexample

All through this discussion, we have been using 5 as the value
for spacing labels on the Y axis; but we may want to use some other
value.  For generality, we should replace 5 with a variable to
which we can assign a value.  The best name I can think of for this
variable is @code{Y-axis-label-spacing}.

@need 1250
Using this term, and an @code{if} expression, we produce the
following:

@smallexample
@group
(if (zerop (% height Y-axis-label-spacing))
    height
  ;; @r{else}
  (* (1+ (/ height Y-axis-label-spacing))
     Y-axis-label-spacing))
@end group
@end smallexample

@noindent
This expression returns the value of @code{height} itself if the height
is an even multiple of the value of the @code{Y-axis-label-spacing} or
else it computes and returns a value of @code{height} that is equal to
the next higher multiple of the value of the @code{Y-axis-label-spacing}.

We can now include this expression in the @code{let} expression of the
@code{print-graph} function (after first setting the value of
@code{Y-axis-label-spacing}):
@vindex Y-axis-label-spacing

@smallexample
@group
(defvar Y-axis-label-spacing 5
  "Number of lines from one Y axis label to next.")
@end group

@group
@dots{}
(let* ((height (apply 'max numbers-list))
       (height-of-top-line
        (if (zerop (% height Y-axis-label-spacing))
            height
@end group
@group
          ;; @r{else}
          (* (1+ (/ height Y-axis-label-spacing))
             Y-axis-label-spacing)))
       (symbol-width (length graph-blank))))
@dots{}
@end group
@end smallexample

@noindent
(Note use of the  @code{let*} function: the initial value of height is
computed once by the @code{(apply 'max numbers-list)} expression and
then the resulting value of  @code{height} is used to compute its
final value.  @xref{fwd-para let, , The @code{let*} expression}, for
more about @code{let*}.)

@node Y Axis Element
@appendixsubsec Construct a Y Axis Element

When we print the vertical axis, we want to insert strings such as
@w{@samp{5 -}} and @w{@samp{10 - }} every five lines.
Moreover, we want the numbers and dashes to line up, so shorter
numbers must be padded with leading spaces.  If some of the strings
use two digit numbers, the strings with single digit numbers must
include a leading blank space before the number.

@findex number-to-string
To figure out the length of the number, the @code{length} function is
used.  But the @code{length} function works only with a string, not with
a number.  So the number has to be converted from being a number to
being a string.  This is done with the @code{number-to-string} function.
For example,

@smallexample
@group
(length (number-to-string 35))
     @result{} 2

(length (number-to-string 100))
     @result{} 3
@end group
@end smallexample

@noindent
(@code{number-to-string} is also called @code{int-to-string}; you will
see this alternative name in various sources.)

In addition, in each label, each number is followed by a string such
as @w{@samp{ - }}, which we will call the @code{Y-axis-tic} marker.
This variable is defined with @code{defvar}:

@vindex Y-axis-tic
@smallexample
@group
(defvar Y-axis-tic " - "
   "String that follows number in a Y axis label.")
@end group
@end smallexample

The length of the Y label is the sum of the length of the Y axis tic
mark and the length of the number of the top of the graph.

@smallexample
(length (concat (number-to-string height) Y-axis-tic)))
@end smallexample

This value will be calculated by the @code{print-graph} function in
its varlist as @code{full-Y-label-width} and passed on.  (Note that we
did not think to include this in the varlist when we first proposed it.)

To make a complete vertical axis label, a tic mark is concatenated
with a number; and the two together may be preceded by one or more
spaces depending on how long the number is.  The label consists of
three parts: the (optional) leading spaces, the number, and the tic
mark.  The function is passed the value of the number for the specific
row, and the value of the width of the top line, which is calculated
(just once) by @code{print-graph}.

@smallexample
@group
(defun Y-axis-element (number full-Y-label-width)
  "Construct a NUMBERed label element.
A numbered element looks like this `  5 - ',
and is padded as needed so all line up with
the element for the largest number."
@end group
@group
  (let* ((leading-spaces
         (- full-Y-label-width
            (length
             (concat (number-to-string number)
                     Y-axis-tic)))))
@end group
@group
    (concat
     (make-string leading-spaces ? )
     (number-to-string number)
     Y-axis-tic)))
@end group
@end smallexample

The @code{Y-axis-element} function concatenates together the leading
spaces, if any; the number, as a string; and the tic mark.

To figure out how many leading spaces the label will need, the
function subtracts the actual length of the label---the length of the
number plus the length of the tic mark---from the desired label width.

@findex make-string
Blank spaces are inserted using the @code{make-string} function.  This
function takes two arguments: the first tells it how long the string
will be and the second is a symbol for the character to insert, in a
special format.  The format is a question mark followed by a blank
space, like this, @samp{? }.  @xref{Character Type, , Character Type,
elisp, The GNU Emacs Lisp Reference Manual}, for a description of the
syntax for characters.  (Of course, you might want to replace the
blank space by some other character @dots{}  You know what to do.)

The @code{number-to-string} function is used in the concatenation
expression, to convert the number to a string that is concatenated
with the leading spaces and the tic mark.

@node Y-axis-column
@appendixsubsec Create a Y Axis Column

The preceding functions provide all the tools needed to construct a
function that generates a list of numbered and blank strings to insert
as the label for the vertical axis:

@findex Y-axis-column
@smallexample
@group
(defun Y-axis-column (height width-of-label)
  "Construct list of Y axis labels and blank strings.
For HEIGHT of line above base and WIDTH-OF-LABEL."
  (let (Y-axis)
@group
@end group
    (while (> height 1)
      (if (zerop (% height Y-axis-label-spacing))
          ;; @r{Insert label.}
          (setq Y-axis
                (cons
                 (Y-axis-element height width-of-label)
                 Y-axis))
@group
@end group
        ;; @r{Else, insert blanks.}
        (setq Y-axis
              (cons
               (make-string width-of-label ? )
               Y-axis)))
      (setq height (1- height)))
    ;; @r{Insert base line.}
    (setq Y-axis
          (cons (Y-axis-element 1 width-of-label) Y-axis))
    (nreverse Y-axis)))
@end group
@end smallexample

In this function, we start with the value of @code{height} and
repetitively subtract one from its value.  After each subtraction, we
test to see whether the value is an integral multiple of the
@code{Y-axis-label-spacing}.  If it is, we construct a numbered label
using the @code{Y-axis-element} function; if not, we construct a
blank label using the @code{make-string} function.  The base line
consists of the number one followed by a tic mark.

@need 2000
@node print-Y-axis Penultimate
@appendixsubsec The Not Quite Final Version of @code{print-Y-axis}

The list constructed by the @code{Y-axis-column} function is passed to
the @code{print-Y-axis} function, which inserts the list as a column.

@findex print-Y-axis
@smallexample
@group
(defun print-Y-axis (height full-Y-label-width)
  "Insert Y axis using HEIGHT and FULL-Y-LABEL-WIDTH.
Height must be the maximum height of the graph.
Full width is the width of the highest label element."
;; Value of height and full-Y-label-width
;; are passed by print-graph.
@end group
@group
  (let ((start (point)))
    (insert-rectangle
     (Y-axis-column height full-Y-label-width))
    ;; @r{Place point ready for inserting graph.}
    (goto-char start)
    ;; @r{Move point forward by value of} full-Y-label-width
    (forward-char full-Y-label-width)))
@end group
@end smallexample

The @code{print-Y-axis} uses the @code{insert-rectangle} function to
insert the Y axis labels created by the @code{Y-axis-column} function.
In addition, it places point at the correct position for printing the body of
the graph.

You can test @code{print-Y-axis}:

@enumerate
@item
Install

@smallexample
@group
Y-axis-label-spacing
Y-axis-tic
Y-axis-element
Y-axis-column
print-Y-axis
@end group
@end smallexample

@item
Copy the following expression:

@smallexample
(print-Y-axis 12 5)
@end smallexample

@item
Switch to the @file{*scratch*} buffer and place the cursor where you
want the axis labels to start.

@item
Type @kbd{M-:} (@code{eval-expression}).

@item
Yank the @code{graph-body-print} expression into the minibuffer
with @kbd{C-y} (@code{yank)}.

@item
Press @key{RET} to evaluate the expression.
@end enumerate

Emacs will print labels vertically, the top one being @w{@samp{10 -@w{
}}}.  (The @code{print-graph} function will pass the value of
@code{height-of-top-line}, which in this case will end up as 15,
thereby getting rid of what might appear as a bug.)

@need 2000
@node print-X-axis
@appendixsec The @code{print-X-axis} Function
@cindex Axis, print horizontal
@cindex X axis printing
@cindex Print horizontal axis
@cindex Horizontal axis printing

X axis labels are much like Y axis labels, except that the ticks are on a
line above the numbers.  Labels should look like this:

@smallexample
@group
    |   |    |    |
    1   5   10   15
@end group
@end smallexample

The first tic is under the first column of the graph and is preceded by
several blank spaces.  These spaces provide room in rows above for the Y
axis labels.  The second, third, fourth, and subsequent ticks are all
spaced equally, according to the value of @code{X-axis-label-spacing}.

The second row of the X axis consists of numbers, preceded by several
blank spaces and also separated according to the value of the variable
@code{X-axis-label-spacing}.

The value of the variable @code{X-axis-label-spacing} should itself be
measured in units of @code{symbol-width}, since you may want to change
the width of the symbols that you are using to print the body of the
graph without changing the ways the graph is labeled.

@menu
* Similarities differences::    Much like @code{print-Y-axis}, but not exactly.
* X Axis Tic Marks::            Create tic marks for the horizontal axis.
@end menu

@ifnottex
@node Similarities differences
@unnumberedsubsec Similarities and differences
@end ifnottex

The @code{print-X-axis} function is constructed in more or less the
same fashion as the @code{print-Y-axis} function except that it has
two lines: the line of tic marks and the numbers.  We will write a
separate function to print each line and then combine them within the
@code{print-X-axis} function.

This is a three step process:

@enumerate
@item
Write a function to print the X axis tic marks, @code{print-X-axis-tic-line}.

@item
Write a function to print the X numbers, @code{print-X-axis-numbered-line}.

@item
Write a function to print both lines, the @code{print-X-axis} function,
using @code{print-X-axis-tic-line} and
@code{print-X-axis-numbered-line}.
@end enumerate

@node X Axis Tic Marks
@appendixsubsec X Axis Tic Marks

The first function should print the X axis tic marks.  We must specify
the tic marks themselves and their spacing:

@smallexample
@group
(defvar X-axis-label-spacing
  (if (boundp 'graph-blank)
      (* 5 (length graph-blank)) 5)
  "Number of units from one X axis label to next.")
@end group
@end smallexample

@noindent
(Note that the value of @code{graph-blank} is set by another
@code{defvar}.  The @code{boundp} predicate checks whether it has
already been set; @code{boundp} returns @code{nil} if it has not.  If
@code{graph-blank} were unbound and we did not use this conditional
construction, we would enter the debugger and see an error message
saying @samp{@w{Debugger entered--Lisp error:}
@w{(void-variable graph-blank)}}.)

@need 1200
Here is the @code{defvar} for @code{X-axis-tic-symbol}:

@smallexample
@group
(defvar X-axis-tic-symbol "|"
  "String to insert to point to a column in X axis.")
@end group
@end smallexample

@need 1250
The goal is to make a line that looks like this:

@smallexample
       |   |    |    |
@end smallexample

The first tic is indented so that it is under the first column, which is
indented to provide space for the Y axis labels.

A tic element consists of the blank spaces that stretch from one tic to
the next plus a tic symbol.  The number of blanks is determined by the
width of the tic symbol and the @code{X-axis-label-spacing}.

@need 1250
The code looks like this:

@smallexample
@group
;;; X-axis-tic-element
@dots{}
(concat
 (make-string
  ;; @r{Make a string of blanks.}
  (-  (* symbol-width X-axis-label-spacing)
      (length X-axis-tic-symbol))
  ? )
 ;; @r{Concatenate blanks with tic symbol.}
 X-axis-tic-symbol)
@dots{}
@end group
@end smallexample

Next, we determine how many blanks are needed to indent the first tic
mark to the first column of the graph.  This uses the value of
@code{full-Y-label-width} passed it by the @code{print-graph} function.

@need 1250
The code to make @code{X-axis-leading-spaces}
looks like this:

@smallexample
@group
;; X-axis-leading-spaces
@dots{}
(make-string full-Y-label-width ? )
@dots{}
@end group
@end smallexample

We also need to determine the length of the horizontal axis, which is
the length of the numbers list, and the number of ticks in the horizontal
axis:

@smallexample
@group
;; X-length
@dots{}
(length numbers-list)
@end group

@group
;; tic-width
@dots{}
(* symbol-width X-axis-label-spacing)
@end group

@group
;; number-of-X-ticks
(if (zerop (% (X-length tic-width)))
    (/ (X-length tic-width))
  (1+ (/ (X-length tic-width))))
@end group
@end smallexample

@need 1250
All this leads us directly to the function for printing the X axis tic line:

@findex print-X-axis-tic-line
@smallexample
@group
(defun print-X-axis-tic-line
  (number-of-X-tics X-axis-leading-spaces X-axis-tic-element)
  "Print ticks for X axis."
    (insert X-axis-leading-spaces)
    (insert X-axis-tic-symbol)  ; @r{Under first column.}
@end group
@group
    ;; @r{Insert second tic in the right spot.}
    (insert (concat
             (make-string
              (-  (* symbol-width X-axis-label-spacing)
                  ;; @r{Insert white space up to second tic symbol.}
                  (* 2 (length X-axis-tic-symbol)))
              ? )
             X-axis-tic-symbol))
@end group
@group
    ;; @r{Insert remaining ticks.}
    (while (> number-of-X-tics 1)
      (insert X-axis-tic-element)
      (setq number-of-X-tics (1- number-of-X-tics))))
@end group
@end smallexample

The line of numbers is equally straightforward:

@need 1250
First, we create a numbered element with blank spaces before each number:

@findex X-axis-element
@smallexample
@group
(defun X-axis-element (number)
  "Construct a numbered X axis element."
  (let ((leading-spaces
         (-  (* symbol-width X-axis-label-spacing)
             (length (number-to-string number)))))
    (concat (make-string leading-spaces ? )
            (number-to-string number))))
@end group
@end smallexample

Next, we create the function to print the numbered line, starting with
the number 1 under the first column:

@findex print-X-axis-numbered-line
@smallexample
@group
(defun print-X-axis-numbered-line
  (number-of-X-tics X-axis-leading-spaces)
  "Print line of X-axis numbers"
  (let ((number X-axis-label-spacing))
    (insert X-axis-leading-spaces)
    (insert "1")
@end group
@group
    (insert (concat
             (make-string
              ;; @r{Insert white space up to next number.}
              (-  (* symbol-width X-axis-label-spacing) 2)
              ? )
             (number-to-string number)))
@end group
@group
    ;; @r{Insert remaining numbers.}
    (setq number (+ number X-axis-label-spacing))
    (while (> number-of-X-tics 1)
      (insert (X-axis-element number))
      (setq number (+ number X-axis-label-spacing))
      (setq number-of-X-tics (1- number-of-X-tics)))))
@end group
@end smallexample

Finally, we need to write the @code{print-X-axis} that uses
@code{print-X-axis-tic-line} and
@code{print-X-axis-numbered-line}.

The function must determine the local values of the variables used by both
@code{print-X-axis-tic-line} and @code{print-X-axis-numbered-line}, and
then it must call them.  Also, it must print the carriage return that
separates the two lines.

The function consists of a varlist that specifies five local variables,
and calls to each of the two line printing functions:

@findex print-X-axis
@smallexample
@group
(defun print-X-axis (numbers-list)
  "Print X axis labels to length of NUMBERS-LIST."
  (let* ((leading-spaces
          (make-string full-Y-label-width ? ))
@end group
@group
       ;; symbol-width @r{is provided by} graph-body-print
       (tic-width (* symbol-width X-axis-label-spacing))
       (X-length (length numbers-list))
@end group
@group
       (X-tic
        (concat
         (make-string
@end group
@group
          ;; @r{Make a string of blanks.}
          (-  (* symbol-width X-axis-label-spacing)
              (length X-axis-tic-symbol))
          ? )
@end group
@group
         ;; @r{Concatenate blanks with tic symbol.}
         X-axis-tic-symbol))
@end group
@group
       (tic-number
        (if (zerop (% X-length tic-width))
            (/ X-length tic-width)
          (1+ (/ X-length tic-width)))))
@end group
@group
    (print-X-axis-tic-line tic-number leading-spaces X-tic)
    (insert "\n")
    (print-X-axis-numbered-line tic-number leading-spaces)))
@end group
@end smallexample

@need 1250
You can test @code{print-X-axis}:

@enumerate
@item
Install @code{X-axis-tic-symbol}, @code{X-axis-label-spacing},
@code{print-X-axis-tic-line}, as well as @code{X-axis-element},
@code{print-X-axis-numbered-line}, and @code{print-X-axis}.

@item
Copy the following expression:

@smallexample
@group
(progn
 (let ((full-Y-label-width 5)
       (symbol-width 1))
   (print-X-axis
    '(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16))))
@end group
@end smallexample

@item
Switch to the @file{*scratch*} buffer and place the cursor where you
want the axis labels to start.

@item
Type @kbd{M-:} (@code{eval-expression}).

@item
Yank the test expression into the minibuffer
with @kbd{C-y} (@code{yank)}.

@item
Press @key{RET} to evaluate the expression.
@end enumerate

@need 1250
Emacs will print the horizontal axis like this:
@sp 1

@smallexample
@group
     |   |    |    |    |
     1   5   10   15   20
@end group
@end smallexample

@node Print Whole Graph
@appendixsec Printing the Whole Graph
@cindex Printing the whole graph
@cindex Whole graph printing
@cindex Graph, printing all

Now we are nearly ready to print the whole graph.

The function to print the graph with the proper labels follows the
outline we created earlier (@pxref{Full Graph, , A Graph with Labeled
Axes}), but with additions.

@need 1250
Here is the outline:

@smallexample
@group
(defun print-graph (numbers-list)
  "@var{documentation}@dots{}"
  (let ((height  @dots{}
        @dots{}))
@end group
@group
    (print-Y-axis height @dots{} )
    (graph-body-print numbers-list)
    (print-X-axis @dots{} )))
@end group
@end smallexample

@menu
* The final version::           A few changes.
* Test print-graph::            Run a short test.
* Graphing words in defuns::    Executing the final code.
* lambda::                      How to write an anonymous function.
* mapcar::                      Apply a function to elements of a list.
* Another Bug::                 Yet another bug @dots{} most insidious.
* Final printed graph::         The graph itself!
@end menu

@ifnottex
@node The final version
@unnumberedsubsec Changes for the Final Version
@end ifnottex

The final version is different from what we planned in two ways:
first, it contains additional values calculated once in the varlist;
second, it carries an option to specify the labels' increment per row.
This latter feature turns out to be essential; otherwise, a graph may
have more rows than fit on a display or on a sheet of paper.

@need 1500
This new feature requires a change to the @code{Y-axis-column}
function, to add @code{vertical-step} to it.  The function looks like
this:

@findex Y-axis-column @r{Final version.}
@smallexample
@group
;;; @r{Final version.}
(defun Y-axis-column
  (height width-of-label &optional vertical-step)
  "Construct list of labels for Y axis.
HEIGHT is maximum height of graph.
WIDTH-OF-LABEL is maximum width of label.
VERTICAL-STEP, an option, is a positive integer
that specifies how much a Y axis label increments
for each line.  For example, a step of 5 means
that each line is five units of the graph."
@end group
@group
  (let (Y-axis
        (number-per-line (or vertical-step 1)))
    (while (> height 1)
      (if (zerop (% height Y-axis-label-spacing))
@end group
@group
          ;; @r{Insert label.}
          (setq Y-axis
                (cons
                 (Y-axis-element
                  (* height number-per-line)
                  width-of-label)
                 Y-axis))
@end group
@group
        ;; @r{Else, insert blanks.}
        (setq Y-axis
              (cons
               (make-string width-of-label ? )
               Y-axis)))
      (setq height (1- height)))
@end group
@group
    ;; @r{Insert base line.}
    (setq Y-axis (cons (Y-axis-element
                        (or vertical-step 1)
                        width-of-label)
                       Y-axis))
    (nreverse Y-axis)))
@end group
@end smallexample

The values for the maximum height of graph and the width of a symbol
are computed by @code{print-graph} in its @code{let} expression; so
@code{graph-body-print} must be changed to accept them.

@findex graph-body-print @r{Final version.}
@smallexample
@group
;;; @r{Final version.}
(defun graph-body-print (numbers-list height symbol-width)
  "Print a bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values.
HEIGHT is maximum height of graph.
SYMBOL-WIDTH is number of each column."
@end group
@group
  (let (from-position)
    (while numbers-list
      (setq from-position (point))
      (insert-rectangle
       (column-of-graph height (car numbers-list)))
      (goto-char from-position)
      (forward-char symbol-width)
@end group
@group
      ;; @r{Draw graph column by column.}
      (sit-for 0)
      (setq numbers-list (cdr numbers-list)))
    ;; @r{Place point for X axis labels.}
    (forward-line height)
    (insert "\n")))
@end group
@end smallexample

@need 1250
Finally, the code for the @code{print-graph} function:

@findex print-graph @r{Final version.}
@smallexample
@group
;;; @r{Final version.}
(defun print-graph
  (numbers-list &optional vertical-step)
  "Print labeled bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values.
@end group

@group
Optionally, VERTICAL-STEP, a positive integer,
specifies how much a Y axis label increments for
each line.  For example, a step of 5 means that
each row is five units."
@end group
@group
  (let* ((symbol-width (length graph-blank))
         ;; @code{height} @r{is both the largest number}
         ;; @r{and the number with the most digits.}
         (height (apply 'max numbers-list))
@end group
@group
         (height-of-top-line
          (if (zerop (% height Y-axis-label-spacing))
              height
            ;; @r{else}
            (* (1+ (/ height Y-axis-label-spacing))
               Y-axis-label-spacing)))
@end group
@group
         (vertical-step (or vertical-step 1))
         (full-Y-label-width
          (length
@end group
@group
           (concat
            (number-to-string
             (* height-of-top-line vertical-step))
            Y-axis-tic))))
@end group

@group
    (print-Y-axis
     height-of-top-line full-Y-label-width vertical-step)
@end group
@group
    (graph-body-print
     numbers-list height-of-top-line symbol-width)
    (print-X-axis numbers-list)))
@end group
@end smallexample

@node Test print-graph
@appendixsubsec Testing @code{print-graph}

@need 1250
We can test the @code{print-graph} function with a short list of numbers:

@enumerate
@item
Install the final versions of @code{Y-axis-column},
@code{graph-body-print}, and @code{print-graph} (in addition to the
rest of the code.)

@item
Copy the following expression:

@smallexample
(print-graph '(3 2 5 6 7 5 3 4 6 4 3 2 1))
@end smallexample

@item
Switch to the @file{*scratch*} buffer and place the cursor where you
want the axis labels to start.

@item
Type @kbd{M-:} (@code{eval-expression}).

@item
Yank the test expression into the minibuffer
with @kbd{C-y} (@code{yank)}.

@item
Press @key{RET} to evaluate the expression.
@end enumerate

@need 1250
Emacs will print a graph that looks like this:

@smallexample
@group
10 -


         *
        **   *
 5 -   ****  *
       **** ***
     * *********
     ************
 1 - *************

     |   |    |    |
     1   5   10   15
@end group
@end smallexample

@need 1200
On the other hand, if you pass @code{print-graph} a
@code{vertical-step} value of 2, by evaluating this expression:

@smallexample
(print-graph '(3 2 5 6 7 5 3 4 6 4 3 2 1) 2)
@end smallexample

@need 1250
@noindent
The graph looks like this:

@smallexample
@group
20 -


         *
        **   *
10 -   ****  *
       **** ***
     * *********
     ************
 2 - *************

     |   |    |    |
     1   5   10   15
@end group
@end smallexample

@noindent
(A question: is the @samp{2} on the bottom of the vertical axis a bug or a
feature?  If you think it is a bug, and should be a @samp{1} instead, (or
even a @samp{0}), you can modify the sources.)

@node Graphing words in defuns
@appendixsubsec Graphing Numbers of Words and Symbols

Now for the graph for which all this code was written: a graph that
shows how many function definitions contain fewer than 10 words and
symbols, how many contain between 10 and 19 words and symbols, how
many contain between 20 and 29 words and symbols, and so on.

This is a multi-step process.  First make sure you have loaded all the
requisite code.

@need 1500
It is a good idea to reset the value of @code{top-of-ranges} in case
you have set it to some different value.  You can evaluate the
following:

@smallexample
@group
(setq top-of-ranges
 '(10  20  30  40  50
   60  70  80  90 100
  110 120 130 140 150
  160 170 180 190 200
  210 220 230 240 250
  260 270 280 290 300)
@end group
@end smallexample

@noindent
Next create a list of the number of words and symbols in each range.

@need 1500
@noindent
Evaluate the following:

@smallexample
@group
(setq list-for-graph
       (defuns-per-range
         (sort
          (recursive-lengths-list-many-files
           (directory-files "/usr/local/emacs/lisp"
                            t ".+el$"))
          '<)
         top-of-ranges))
@end group
@end smallexample

@noindent
On my old machine, this took about an hour.  It looked though 303 Lisp
files in my copy of Emacs version 19.23.  After all that computing,
the @code{list-for-graph} had this value:

@smallexample
@group
(537 1027 955 785 594 483 349 292 224 199 166 120 116 99
90 80 67 48 52 45 41 33 28 26 25 20 12 28 11 13 220)
@end group
@end smallexample

@noindent
This means that my copy of Emacs had 537 function definitions with
fewer than 10 words or symbols in them, 1,027 function definitions
with 10 to 19 words or symbols in them, 955 function definitions with
20 to 29 words or symbols in them, and so on.

Clearly, just by looking at this list we can see that most function
definitions contain ten to thirty words and symbols.

Now for printing.  We do @emph{not} want to print a graph that is
1,030 lines high @dots{}  Instead, we should print a graph that is
fewer than twenty-five lines high.  A graph that height can be
displayed on almost any monitor, and easily printed on a sheet of paper.

This means that each value in @code{list-for-graph} must be reduced to
one-fiftieth its present value.

Here is a short function to do just that, using two functions we have
not yet seen, @code{mapcar} and @code{lambda}.

@smallexample
@group
(defun one-fiftieth (full-range)
  "Return list, each number one-fiftieth of previous."
 (mapcar (lambda (arg) (/ arg 50)) full-range))
@end group
@end smallexample

@node lambda
@appendixsubsec A @code{lambda} Expression: Useful Anonymity
@cindex Anonymous function
@findex lambda

@code{lambda} is the symbol for an anonymous function, a function
without a name.  Every time you use an anonymous function, you need to
include its whole body.

@need 1250
@noindent
Thus,

@smallexample
(lambda (arg) (/ arg 50))
@end smallexample

@noindent
is a function that returns the value resulting from
dividing whatever is passed to it as @code{arg} by 50.

@need 1200
Earlier, for example, we had a function @code{multiply-by-seven}; it
multiplied its argument by 7.  This function is similar, except it
divides its argument by 50; and, it has no name.  The anonymous
equivalent of @code{multiply-by-seven} is:

@smallexample
(lambda (number) (* 7 number))
@end smallexample

@noindent
(@xref{defun, ,  The @code{defun} Macro}.)

@need 1250
@noindent
If we want to multiply 3 by 7, we can write:

@c clear print-postscript-figures
@c lambda example diagram #1
@ifnottex
@smallexample
@group
(multiply-by-seven 3)
 \_______________/ ^
         |         |
      function  argument
@end group
@end smallexample
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{lambda-1}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
(multiply-by-seven 3)
 \_______________/ ^
         |         |
      function  argument
@end group
@end smallexample
@end iftex
@end ifclear

@noindent
This expression returns 21.

@need 1250
@noindent
Similarly, we can write:

@c lambda example diagram #2
@ifnottex
@smallexample
@group
((lambda (number) (* 7 number)) 3)
 \____________________________/ ^
               |                |
      anonymous function     argument
@end group
@end smallexample
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{lambda-2}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
((lambda (number) (* 7 number)) 3)
 \____________________________/ ^
               |                |
      anonymous function     argument
@end group
@end smallexample
@end iftex
@end ifclear

@need 1250
@noindent
If we want to divide 100 by 50, we can write:

@c lambda example diagram #3
@ifnottex
@smallexample
@group
((lambda (arg) (/ arg 50)) 100)
 \______________________/  \_/
             |              |
    anonymous function   argument
@end group
@end smallexample
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{lambda-3}
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
((lambda (arg) (/ arg 50)) 100)
 \______________________/  \_/
             |              |
    anonymous function   argument
@end group
@end smallexample
@end iftex
@end ifclear

@noindent
This expression returns 2.  The 100 is passed to the function, which
divides that number by 50.

@xref{Lambda Expressions, , Lambda Expressions, elisp, The GNU Emacs
Lisp Reference Manual}, for more about @code{lambda}.  Lisp and lambda
expressions derive from the Lambda Calculus.

@node mapcar
@appendixsubsec The @code{mapcar} Function
@findex mapcar

@code{mapcar} is a function that calls its first argument with each
element of its second argument, in turn.  The second argument must be
a sequence.

The @samp{map} part of the name comes from the mathematical phrase,
``mapping over a domain'', meaning to apply a function to each of the
elements in a domain.  The mathematical phrase is based on the
metaphor of a surveyor walking, one step at a time, over an area he is
mapping.  And @samp{car}, of course, comes from the Lisp notion of the
first of a list.

@need 1250
@noindent
For example,

@smallexample
@group
(mapcar '1+ '(2 4 6))
     @result{} (3 5 7)
@end group
@end smallexample

@noindent
The function @code{1+} which adds one to its argument, is executed on
@emph{each} element of the list, and a new list is returned.

Contrast this with @code{apply}, which applies its first argument to
all the remaining.
(@xref{Readying a Graph, , Readying a Graph}, for an explanation of
@code{apply}.)

@need 1250
In the definition of @code{one-fiftieth}, the first argument is the
anonymous function:

@smallexample
(lambda (arg) (/ arg 50))
@end smallexample

@noindent
and the second argument is @code{full-range}, which will be bound to
@code{list-for-graph}.

@need 1250
The whole expression looks like this:

@smallexample
(mapcar (lambda (arg) (/ arg 50)) full-range))
@end smallexample

@xref{Mapping Functions, , Mapping Functions, elisp, The GNU Emacs
Lisp Reference Manual}, for more about @code{mapcar}.

Using the @code{one-fiftieth} function, we can generate a list in
which each element is one-fiftieth the size of the corresponding
element in @code{list-for-graph}.

@smallexample
@group
(setq fiftieth-list-for-graph
      (one-fiftieth list-for-graph))
@end group
@end smallexample

@need 1250
The resulting list looks like this:

@smallexample
@group
(10 20 19 15 11 9 6 5 4 3 3 2 2
1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 4)
@end group
@end smallexample

@noindent
This, we are almost ready to print!  (We also notice the loss of
information: many of the higher ranges are 0, meaning that fewer than
50 defuns had that many words or symbols---but not necessarily meaning
that none had that many words or symbols.)

@node Another Bug
@appendixsubsec Another Bug @dots{} Most Insidious
@cindex Bug, most insidious type
@cindex Insidious type of bug

I said ``almost ready to print''!  Of course, there is a bug in the
@code{print-graph} function @dots{}  It has a @code{vertical-step}
option, but not a @code{horizontal-step} option.  The
@code{top-of-range} scale goes from 10 to 300 by tens.  But the
@code{print-graph} function will print only by ones.

This is a classic example of what some consider the most insidious
type of bug, the bug of omission.  This is not the kind of bug you can
find by studying the code, for it is not in the code; it is an omitted
feature.  Your best actions are to try your program early and often;
and try to arrange, as much as you can, to write code that is easy to
understand and easy to change.  Try to be aware, whenever you can,
that whatever you have written, @emph{will} be rewritten, if not soon,
eventually.  A hard maxim to follow.

It is the @code{print-X-axis-numbered-line} function that needs the
work; and then the @code{print-X-axis} and the @code{print-graph}
functions need to be adapted.  Not much needs to be done; there is one
nicety: the numbers ought to line up under the tic marks.  This takes
a little thought.

@need 1250
Here is the corrected @code{print-X-axis-numbered-line}:

@smallexample
@group
(defun print-X-axis-numbered-line
  (number-of-X-tics X-axis-leading-spaces
   &optional horizontal-step)
  "Print line of X-axis numbers"
  (let ((number X-axis-label-spacing)
        (horizontal-step (or horizontal-step 1)))
@end group
@group
    (insert X-axis-leading-spaces)
    ;; @r{Delete extra leading spaces.}
    (delete-char
     (- (1-
         (length (number-to-string horizontal-step)))))
    (insert (concat
             (make-string
@end group
@group
              ;; @r{Insert white space.}
              (-  (* symbol-width
                     X-axis-label-spacing)
                  (1-
                   (length
                    (number-to-string horizontal-step)))
                  2)
              ? )
             (number-to-string
              (* number horizontal-step))))
@end group
@group
    ;; @r{Insert remaining numbers.}
    (setq number (+ number X-axis-label-spacing))
    (while (> number-of-X-tics 1)
      (insert (X-axis-element
               (* number horizontal-step)))
      (setq number (+ number X-axis-label-spacing))
      (setq number-of-X-tics (1- number-of-X-tics)))))
@end group
@end smallexample

@need 1500
If you are reading this in Info, you can see the new versions of
@code{print-X-axis} @code{print-graph} and evaluate them.  If you are
reading this in a printed book, you can see the changed lines here
(the full text is too much to print).

@iftex
@smallexample
@group
(defun print-X-axis (numbers-list horizontal-step)
  @dots{}
    (print-X-axis-numbered-line
     tic-number leading-spaces horizontal-step))
@end group
@end smallexample

@smallexample
@group
(defun print-graph
  (numbers-list
   &optional vertical-step horizontal-step)
  @dots{}
    (print-X-axis numbers-list horizontal-step))
@end group
@end smallexample
@end iftex

@ifnottex
@smallexample
@group
(defun print-X-axis (numbers-list horizontal-step)
  "Print X axis labels to length of NUMBERS-LIST.
Optionally, HORIZONTAL-STEP, a positive integer,
specifies how much an X  axis label increments for
each column."
@end group
@group
;; Value of symbol-width and full-Y-label-width
;; are passed by print-graph.
  (let* ((leading-spaces
          (make-string full-Y-label-width ? ))
       ;; symbol-width @r{is provided by} graph-body-print
       (tic-width (* symbol-width X-axis-label-spacing))
       (X-length (length numbers-list))
@end group
@group
       (X-tic
        (concat
         (make-string
          ;; @r{Make a string of blanks.}
          (-  (* symbol-width X-axis-label-spacing)
              (length X-axis-tic-symbol))
          ? )
@end group
@group
         ;; @r{Concatenate blanks with tic symbol.}
         X-axis-tic-symbol))
       (tic-number
        (if (zerop (% X-length tic-width))
            (/ X-length tic-width)
          (1+ (/ X-length tic-width)))))
@end group

@group
    (print-X-axis-tic-line
     tic-number leading-spaces X-tic)
    (insert "\n")
    (print-X-axis-numbered-line
     tic-number leading-spaces horizontal-step)))
@end group
@end smallexample

@smallexample
@group
(defun print-graph
  (numbers-list &optional vertical-step horizontal-step)
  "Print labeled bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values.
@end group

@group
Optionally, VERTICAL-STEP, a positive integer,
specifies how much a Y axis label increments for
each line.  For example, a step of 5 means that
each row is five units.
@end group

@group
Optionally, HORIZONTAL-STEP, a positive integer,
specifies how much an X  axis label increments for
each column."
  (let* ((symbol-width (length graph-blank))
         ;; @code{height} @r{is both the largest number}
         ;; @r{and the number with the most digits.}
         (height (apply 'max numbers-list))
@end group
@group
         (height-of-top-line
          (if (zerop (% height Y-axis-label-spacing))
              height
            ;; @r{else}
            (* (1+ (/ height Y-axis-label-spacing))
               Y-axis-label-spacing)))
@end group
@group
         (vertical-step (or vertical-step 1))
         (full-Y-label-width
          (length
           (concat
            (number-to-string
             (* height-of-top-line vertical-step))
            Y-axis-tic))))
@end group
@group
    (print-Y-axis
     height-of-top-line full-Y-label-width vertical-step)
    (graph-body-print
        numbers-list height-of-top-line symbol-width)
    (print-X-axis numbers-list horizontal-step)))
@end group
@end smallexample
@end ifnottex

@c qqq
@ignore
Graphing Definitions Re-listed

@need 1250
Here are all the graphing definitions in their final form:

@smallexample
@group
(defvar top-of-ranges
 '(10  20  30  40  50
   60  70  80  90 100
  110 120 130 140 150
  160 170 180 190 200
  210 220 230 240 250)
 "List specifying ranges for `defuns-per-range'.")
@end group

@group
(defvar graph-symbol "*"
  "String used as symbol in graph, usually an asterisk.")
@end group

@group
(defvar graph-blank " "
  "String used as blank in graph, usually a blank space.
graph-blank must be the same number of columns wide
as graph-symbol.")
@end group

@group
(defvar Y-axis-tic " - "
   "String that follows number in a Y axis label.")
@end group

@group
(defvar Y-axis-label-spacing 5
  "Number of lines from one Y axis label to next.")
@end group

@group
(defvar X-axis-tic-symbol "|"
  "String to insert to point to a column in X axis.")
@end group

@group
(defvar X-axis-label-spacing
  (if (boundp 'graph-blank)
      (* 5 (length graph-blank)) 5)
  "Number of units from one X axis label to next.")
@end group
@end smallexample

@smallexample
@group
(defun count-words-in-defun ()
  "Return the number of words and symbols in a defun."
  (beginning-of-defun)
  (let ((count 0)
        (end (save-excursion (end-of-defun) (point))))
@end group

@group
    (while
        (and (< (point) end)
             (re-search-forward
              "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"
              end t))
      (setq count (1+ count)))
    count))
@end group
@end smallexample

@smallexample
@group
(defun lengths-list-file (filename)
  "Return list of definitions' lengths within FILE.
The returned list is a list of numbers.
Each number is the number of words or
symbols in one function definition."
@end group

@group
  (message "Working on `%s' ... " filename)
  (save-excursion
    (let ((buffer (find-file-noselect filename))
          (lengths-list))
      (set-buffer buffer)
      (setq buffer-read-only t)
      (widen)
      (goto-char (point-min))
@end group

@group
      (while (re-search-forward "^(defun" nil t)
        (setq lengths-list
              (cons (count-words-in-defun) lengths-list)))
      (kill-buffer buffer)
      lengths-list)))
@end group
@end smallexample

@smallexample
@group
(defun lengths-list-many-files (list-of-files)
  "Return list of lengths of defuns in LIST-OF-FILES."
  (let (lengths-list)
;;; @r{true-or-false-test}
    (while list-of-files
      (setq lengths-list
            (append
             lengths-list
@end group
@group
;;; @r{Generate a lengths' list.}
             (lengths-list-file
              (expand-file-name (car list-of-files)))))
;;; @r{Make files' list shorter.}
      (setq list-of-files (cdr list-of-files)))
;;; @r{Return final value of lengths' list.}
    lengths-list))
@end group
@end smallexample

@smallexample
@group
(defun defuns-per-range (sorted-lengths top-of-ranges)
  "SORTED-LENGTHS defuns in each TOP-OF-RANGES range."
  (let ((top-of-range (car top-of-ranges))
        (number-within-range 0)
        defuns-per-range-list)
@end group

@group
    ;; @r{Outer loop.}
    (while top-of-ranges

      ;; @r{Inner loop.}
      (while (and
              ;; @r{Need number for numeric test.}
              (car sorted-lengths)
              (< (car sorted-lengths) top-of-range))

        ;; @r{Count number of definitions within current range.}
        (setq number-within-range (1+ number-within-range))
        (setq sorted-lengths (cdr sorted-lengths)))
@end group

@group
      ;; @r{Exit inner loop but remain within outer loop.}

      (setq defuns-per-range-list
            (cons number-within-range defuns-per-range-list))
      (setq number-within-range 0)      ; @r{Reset count to zero.}

      ;; @r{Move to next range.}
      (setq top-of-ranges (cdr top-of-ranges))
      ;; @r{Specify next top of range value.}
      (setq top-of-range (car top-of-ranges)))
@end group

@group
    ;; @r{Exit outer loop and count the number of defuns larger than}
    ;; @r{  the largest top-of-range value.}
    (setq defuns-per-range-list
          (cons
           (length sorted-lengths)
           defuns-per-range-list))

    ;; @r{Return a list of the number of definitions within each range,}
    ;; @r{  smallest to largest.}
    (nreverse defuns-per-range-list)))
@end group
@end smallexample

@smallexample
@group
(defun column-of-graph (max-graph-height actual-height)
  "Return list of MAX-GRAPH-HEIGHT strings;
ACTUAL-HEIGHT are graph-symbols.
The graph-symbols are contiguous entries at the end
of the list.
The list will be inserted as one column of a graph.
The strings are either graph-blank or graph-symbol."
@end group

@group
  (let ((insert-list nil)
        (number-of-top-blanks
         (- max-graph-height actual-height)))

    ;; @r{Fill in @code{graph-symbols}.}
    (while (> actual-height 0)
      (setq insert-list (cons graph-symbol insert-list))
      (setq actual-height (1- actual-height)))
@end group

@group
    ;; @r{Fill in @code{graph-blanks}.}
    (while (> number-of-top-blanks 0)
      (setq insert-list (cons graph-blank insert-list))
      (setq number-of-top-blanks
            (1- number-of-top-blanks)))

    ;; @r{Return whole list.}
    insert-list))
@end group
@end smallexample

@smallexample
@group
(defun Y-axis-element (number full-Y-label-width)
  "Construct a NUMBERed label element.
A numbered element looks like this `  5 - ',
and is padded as needed so all line up with
the element for the largest number."
@end group
@group
  (let* ((leading-spaces
         (- full-Y-label-width
            (length
             (concat (number-to-string number)
                     Y-axis-tic)))))
@end group
@group
    (concat
     (make-string leading-spaces ? )
     (number-to-string number)
     Y-axis-tic)))
@end group
@end smallexample

@smallexample
@group
(defun print-Y-axis
  (height full-Y-label-width &optional vertical-step)
  "Insert Y axis by HEIGHT and FULL-Y-LABEL-WIDTH.
Height must be the  maximum height of the graph.
Full width is the width of the highest label element.
Optionally, print according to VERTICAL-STEP."
@end group
@group
;; Value of height and full-Y-label-width
;; are passed by 'print-graph'.
  (let ((start (point)))
    (insert-rectangle
     (Y-axis-column height full-Y-label-width vertical-step))
@end group
@group
    ;; @r{Place point ready for inserting graph.}
    (goto-char start)
    ;; @r{Move point forward by value of} full-Y-label-width
    (forward-char full-Y-label-width)))
@end group
@end smallexample

@smallexample
@group
(defun print-X-axis-tic-line
  (number-of-X-tics X-axis-leading-spaces X-axis-tic-element)
  "Print ticks for X axis."
    (insert X-axis-leading-spaces)
    (insert X-axis-tic-symbol)  ; @r{Under first column.}
@end group
@group
    ;; @r{Insert second tic in the right spot.}
    (insert (concat
             (make-string
              (-  (* symbol-width X-axis-label-spacing)
                  ;; @r{Insert white space up to second tic symbol.}
                  (* 2 (length X-axis-tic-symbol)))
              ? )
             X-axis-tic-symbol))
@end group
@group
    ;; @r{Insert remaining ticks.}
    (while (> number-of-X-tics 1)
      (insert X-axis-tic-element)
      (setq number-of-X-tics (1- number-of-X-tics))))
@end group
@end smallexample

@smallexample
@group
(defun X-axis-element (number)
  "Construct a numbered X axis element."
  (let ((leading-spaces
         (-  (* symbol-width X-axis-label-spacing)
             (length (number-to-string number)))))
    (concat (make-string leading-spaces ? )
            (number-to-string number))))
@end group
@end smallexample

@smallexample
@group
(defun graph-body-print (numbers-list height symbol-width)
  "Print a bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values.
HEIGHT is maximum height of graph.
SYMBOL-WIDTH is number of each column."
@end group
@group
  (let (from-position)
    (while numbers-list
      (setq from-position (point))
      (insert-rectangle
       (column-of-graph height (car numbers-list)))
      (goto-char from-position)
      (forward-char symbol-width)
@end group
@group
      ;; @r{Draw graph column by column.}
      (sit-for 0)
      (setq numbers-list (cdr numbers-list)))
    ;; @r{Place point for X axis labels.}
    (forward-line height)
    (insert "\n")))
@end group
@end smallexample

@smallexample
@group
(defun Y-axis-column
  (height width-of-label &optional vertical-step)
  "Construct list of labels for Y axis.
HEIGHT is maximum height of graph.
WIDTH-OF-LABEL is maximum width of label.
@end group
@group
VERTICAL-STEP, an option, is a positive integer
that specifies how much a Y axis label increments
for each line.  For example, a step of 5 means
that each line is five units of the graph."
  (let (Y-axis
        (number-per-line (or vertical-step 1)))
@end group
@group
    (while (> height 1)
      (if (zerop (% height Y-axis-label-spacing))
          ;; @r{Insert label.}
          (setq Y-axis
                (cons
                 (Y-axis-element
                  (* height number-per-line)
                  width-of-label)
                 Y-axis))
@end group
@group
        ;; @r{Else, insert blanks.}
        (setq Y-axis
              (cons
               (make-string width-of-label ? )
               Y-axis)))
      (setq height (1- height)))
@end group
@group
    ;; @r{Insert base line.}
    (setq Y-axis (cons (Y-axis-element
                        (or vertical-step 1)
                        width-of-label)
                       Y-axis))
    (nreverse Y-axis)))
@end group
@end smallexample

@smallexample
@group
(defun print-X-axis-numbered-line
  (number-of-X-tics X-axis-leading-spaces
   &optional horizontal-step)
  "Print line of X-axis numbers"
  (let ((number X-axis-label-spacing)
        (horizontal-step (or horizontal-step 1)))
@end group
@group
    (insert X-axis-leading-spaces)
    ;; line up number
    (delete-char (- (1- (length (number-to-string horizontal-step)))))
    (insert (concat
             (make-string
              ;; @r{Insert white space up to next number.}
              (-  (* symbol-width X-axis-label-spacing)
                  (1- (length (number-to-string horizontal-step)))
                  2)
              ? )
             (number-to-string (* number horizontal-step))))
@end group
@group
    ;; @r{Insert remaining numbers.}
    (setq number (+ number X-axis-label-spacing))
    (while (> number-of-X-tics 1)
      (insert (X-axis-element (* number horizontal-step)))
      (setq number (+ number X-axis-label-spacing))
      (setq number-of-X-tics (1- number-of-X-tics)))))
@end group
@end smallexample

@smallexample
@group
(defun print-X-axis (numbers-list horizontal-step)
  "Print X axis labels to length of NUMBERS-LIST.
Optionally, HORIZONTAL-STEP, a positive integer,
specifies how much an X  axis label increments for
each column."
@end group
@group
;; Value of symbol-width and full-Y-label-width
;; are passed by 'print-graph'.
  (let* ((leading-spaces
          (make-string full-Y-label-width ? ))
       ;; symbol-width @r{is provided by} graph-body-print
       (tic-width (* symbol-width X-axis-label-spacing))
       (X-length (length numbers-list))
@end group
@group
       (X-tic
        (concat
         (make-string
          ;; @r{Make a string of blanks.}
          (-  (* symbol-width X-axis-label-spacing)
              (length X-axis-tic-symbol))
          ? )
@end group
@group
         ;; @r{Concatenate blanks with tic symbol.}
         X-axis-tic-symbol))
       (tic-number
        (if (zerop (% X-length tic-width))
            (/ X-length tic-width)
          (1+ (/ X-length tic-width)))))
@end group

@group
    (print-X-axis-tic-line
     tic-number leading-spaces X-tic)
    (insert "\n")
    (print-X-axis-numbered-line
     tic-number leading-spaces horizontal-step)))
@end group
@end smallexample

@smallexample
@group
(defun one-fiftieth (full-range)
  "Return list, each number of which is 1/50th previous."
 (mapcar (lambda (arg) (/ arg 50)) full-range))
@end group
@end smallexample

@smallexample
@group
(defun print-graph
  (numbers-list &optional vertical-step horizontal-step)
  "Print labeled bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values.
@end group

@group
Optionally, VERTICAL-STEP, a positive integer,
specifies how much a Y axis label increments for
each line.  For example, a step of 5 means that
each row is five units.
@end group

@group
Optionally, HORIZONTAL-STEP, a positive integer,
specifies how much an X  axis label increments for
each column."
  (let* ((symbol-width (length graph-blank))
         ;; @code{height} @r{is both the largest number}
         ;; @r{and the number with the most digits.}
         (height (apply 'max numbers-list))
@end group
@group
         (height-of-top-line
          (if (zerop (% height Y-axis-label-spacing))
              height
            ;; @r{else}
            (* (1+ (/ height Y-axis-label-spacing))
               Y-axis-label-spacing)))
@end group
@group
         (vertical-step (or vertical-step 1))
         (full-Y-label-width
          (length
           (concat
            (number-to-string
             (* height-of-top-line vertical-step))
            Y-axis-tic))))
@end group
@group

    (print-Y-axis
     height-of-top-line full-Y-label-width vertical-step)
    (graph-body-print
        numbers-list height-of-top-line symbol-width)
    (print-X-axis numbers-list horizontal-step)))
@end group
@end smallexample
@c qqq
@end ignore

@page
@node Final printed graph
@appendixsubsec The Printed Graph

When made and installed, you can call the @code{print-graph} command
like this:
@sp 1

@smallexample
@group
(print-graph fiftieth-list-for-graph 50 10)
@end group
@end smallexample
@sp 1

@noindent
Here is the graph:
@sp 2

@smallexample
@group
1000 -  *
        **
        **
        **
        **
 750 -  ***
        ***
        ***
        ***
        ****
 500 - *****
       ******
       ******
       ******
       *******
 250 - ********
       *********                     *
       ***********                   *
       *************                 *
  50 - ***************** *           *
       |   |    |    |    |    |    |    |
      10  50  100  150  200  250  300  350
@end group
@end smallexample

@sp 2

@noindent
The largest group of functions contain 10--19 words and symbols each.

@node 自由软件和自由手册
@appendix 自由软件和自由手册

@strong{作者：理查德·斯托曼}
@sp 1

自由操作系统中最大的不足之处不在于软件本身，而在于我们无法在这些系统中包含好的自由手册。许多我们最重要的程序都没有附带完整的手册。文档是任何软件包的基本组成部分；当一个重要的自由软件包没有附带自由手册时，这是一个重大的缺陷。我们今天有许多这样的缺口。

很多年前的一天，我想学习Perl。我找到了一本免费的手册副本，但我发现它很难阅读。当我询问Perl用户是否有其他选择时，他们告诉我有更好的入门手册---但那些手册并不是免费的。

为什么会这样呢？好的手册作者为O'Reilly Associates编写了手册，该出版社以限制性条款发布它们---禁止复制、禁止修改、源文件不可用---这些条件使它们无法进入自由软件社区。

这并不是这种情况发生的第一次，而且（令我们的社区丧失很多）远非最后一次。自从那时以来，专有手册出版商引诱了许多作者限制他们的手册。许多次我听到GNU用户热切地告诉我，他正在撰写一本手册，他希望能够帮助GNU项目---然后我的希望落空，因为他继续解释说他已经签署了一份与出版商的合同，该合同将限制使用，以至于我们无法使用它。

鉴于写好英语是程序员中一种罕见的技能，我们不能承受以这种方式失去手册的代价。

自由文档，就像自由软件一样，是关乎自由而非价格的问题。这些手册的问题并不在于O'Reilly Associates对印刷品收费---这本身是可以接受的。自由软件基金会在@uref{https://shop.fsf.org, 官方商店}出售免费@uref{https://www.gnu.org/doc/doc.html, GNU手册}的印刷本。但GNU手册以源代码形式提供，而这些手册只能以纸质形式获得。GNU手册附带有复制和修改的权限；Perl手册则没有。这些限制是问题所在。

对于一个自由手册，标准几乎与自由软件相同：它涉及给予所有用户特定的自由。必须允许重新分发（包括商业重新分发），以便手册可以随程序的每个副本一起提供，无论是在线还是纸质的。修改的许可也是至关重要的。

总的来说，我不认为人们有必要获得修改各种文章和书籍的权限。对于文学作品，问题不一定与软件相同。例如，我认为你和我没有义务允许修改像这篇文章这样描述我们行动和观点的文章。

但是，为自由软件提供文档的关键原因之一是修改的自由至关重要。当人们行使他们修改软件的权利，添加或更改其功能时，如果他们是尽责的，他们将同时更改手册---以便他们可以为修改后的程序提供准确可用的文档。一份手册，禁止程序员尽责并完成工作，或者更确切地说，如果他们更改程序，则要求他们从头开始编写新手册，这将无法满足我们社区的需求。

虽然对修改的全面禁令是不可接受的，但对修改方式的某些限制并不构成问题。例如，要求保留原作者的版权声明、分发条款或作者列表是可以接受的。还要求修改版本包含修改通知，甚至包含整个部分不得删除或更改，只要这些部分涉及非技术主题，也没有问题（一些GNU手册有这些限制）。

这些种类的限制不是问题，因为从实际角度来看，它们并不阻止认真的程序员调整手册以适应修改后的程序。换句话说，它们并不阻止自由软件社区充分利用手册。

然而，必须有可能修改手册的所有技术内容，然后通过所有通常的媒体、通过所有通常的渠道分发结果；否则，这些限制将阻碍社区，手册就不是自由的，因此我们需要另一份手册。

不幸的是，当存在专有手册时，很难找到愿意写另一份手册的人。阻碍在于许多用户认为专有手册已经足够好---因此他们认为没有必要写一份自由手册。他们没有意识到自由操作系统存在需要填补的空白。

为什么用户认为专有手册已经足够好呢？有些人还没有考虑这个问题。我希望这篇文章能够改变这种看法。

其他用户认为专有手册是可以接受的，原因与许多人认为专有软件是可以接受的原因相同：他们纯粹以实际的角度进行判断，而不使用自由作为标准。这些人有权发表他们的观点，但由于这些观点源于不包括自由的价值观，对于那些重视自由的人来说，它们并不是指导。

请传播关于这个问题的信息。我们继续失去手册，因为它们受到专有出版的限制。如果我们传播这样的信息，即专有手册是不够的，也许下一个想通过撰写文档来帮助GNU的人在为时已晚之前会意识到，他首先必须使其自由。

我们还可以鼓励商业出版商销售自由的、遵循版权的手册，而不是专有的手册。你可以帮助实现这一点的一种方式是在购买手册之前检查其分发条款，并更喜欢遵循版权的手册而不是非遵循版权的手册。

@sp 2
@noindent
注：自由软件基金会在其网站上维护了一个页面，列出了其他出版商提供的免费图书：@*
@uref{https://www.gnu.org/doc/other-free-books.html}

@node GNU Free Documentation License
@appendix GNU Free Documentation License

@cindex FDL, GNU Free Documentation License
@include doclicense.texi

@node Index
@unnumbered Index

@ignore
MENU ENTRY: NODE NAME.
@end ignore

@printindex cp

@iftex
@c Place biographical information on right-hand (verso) page

@tex
\par\vfill\supereject
\ifodd\pageno
    \global\evenheadline={\hfil} \global\evenfootline={\hfil}
    \global\oddheadline={\hfil} \global\oddfootline={\hfil}
    %\page\hbox{}\page
\else
%    \par\vfill\supereject
    \global\evenheadline={\hfil} \global\evenfootline={\hfil}
    \global\oddheadline={\hfil} \global\oddfootline={\hfil}
    %\page\hbox{}%\page
    %\page\hbox{}%\page
\fi
@end tex

@c page
@w{ }

@c ================ Biographical information ================

@w{ }
@sp 8
@center About the Author
@sp 1
@end iftex

@ifnottex
@node 作者简介
@unnumbered 作者简介
@end ifnottex

@quotation
罗伯特·J·查瑟尔（1946--2017）于1985年开始使用GNU Emacs。他撰写和编辑了Emacs和Emacs Lisp的教材，并在世界各地演讲，倡导软件自由。查瑟尔是自由软件基金会（Free Software Foundation, Inc.）的创始董事兼财务主管。他是《Texinfo》手册的合著者，还编辑了十多本其他书籍。他毕业于英格兰剑桥大学，对社会和经济历史有浓厚兴趣，同时还是一名私人飞行爱好者。

@uref{https://www.fsf.org/blogs/community/goodbye-to-bob-chassell,
"向鲍勃·查瑟尔告别"}
@end quotation

@c @page
@c @w{ }
@c
@c @c Prevent page number on blank verso, so eject it first.
@c @tex
@c \par\vfill\supereject
@c @end tex

@c @iftex
@c @headings off
@c @evenheading @thispage @| @| @thistitle
@c @oddheading            @| @| @thispage
@c @end iftex

@bye
